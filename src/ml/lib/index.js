var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i4 = decorators.length - 1, decorator; i4 >= 0; i4--)
    if (decorator = decorators[i4])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value2) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet = (obj, member, value2, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// node_modules/@lit-labs/ssr-dom-shim/lib/element-internals.js
var ElementInternalsShim = class ElementInternals {
  get shadowRoot() {
    return this.__host.__shadowRoot;
  }
  constructor(_host) {
    this.ariaAtomic = "";
    this.ariaAutoComplete = "";
    this.ariaBrailleLabel = "";
    this.ariaBrailleRoleDescription = "";
    this.ariaBusy = "";
    this.ariaChecked = "";
    this.ariaColCount = "";
    this.ariaColIndex = "";
    this.ariaColSpan = "";
    this.ariaCurrent = "";
    this.ariaDescription = "";
    this.ariaDisabled = "";
    this.ariaExpanded = "";
    this.ariaHasPopup = "";
    this.ariaHidden = "";
    this.ariaInvalid = "";
    this.ariaKeyShortcuts = "";
    this.ariaLabel = "";
    this.ariaLevel = "";
    this.ariaLive = "";
    this.ariaModal = "";
    this.ariaMultiLine = "";
    this.ariaMultiSelectable = "";
    this.ariaOrientation = "";
    this.ariaPlaceholder = "";
    this.ariaPosInSet = "";
    this.ariaPressed = "";
    this.ariaReadOnly = "";
    this.ariaRequired = "";
    this.ariaRoleDescription = "";
    this.ariaRowCount = "";
    this.ariaRowIndex = "";
    this.ariaRowSpan = "";
    this.ariaSelected = "";
    this.ariaSetSize = "";
    this.ariaSort = "";
    this.ariaValueMax = "";
    this.ariaValueMin = "";
    this.ariaValueNow = "";
    this.ariaValueText = "";
    this.role = "";
    this.form = null;
    this.labels = [];
    this.states = /* @__PURE__ */ new Set();
    this.validationMessage = "";
    this.validity = {};
    this.willValidate = true;
    this.__host = _host;
  }
  checkValidity() {
    console.warn("`ElementInternals.checkValidity()` was called on the server.This method always returns true.");
    return true;
  }
  reportValidity() {
    return true;
  }
  setFormValue() {
  }
  setValidity() {
  }
};

// node_modules/@lit-labs/ssr-dom-shim/index.js
var attributes = /* @__PURE__ */ new WeakMap();
var attributesForElement = (element) => {
  let attrs = attributes.get(element);
  if (attrs === void 0) {
    attributes.set(element, attrs = /* @__PURE__ */ new Map());
  }
  return attrs;
};
var ElementShim = class Element {
  constructor() {
    this.__shadowRootMode = null;
    this.__shadowRoot = null;
    this.__internals = null;
  }
  get attributes() {
    return Array.from(attributesForElement(this)).map(([name, value2]) => ({
      name,
      value: value2
    }));
  }
  get shadowRoot() {
    if (this.__shadowRootMode === "closed") {
      return null;
    }
    return this.__shadowRoot;
  }
  get localName() {
    return this.constructor.__localName;
  }
  get tagName() {
    return this.localName?.toUpperCase();
  }
  setAttribute(name, value2) {
    attributesForElement(this).set(name, String(value2));
  }
  removeAttribute(name) {
    attributesForElement(this).delete(name);
  }
  toggleAttribute(name, force) {
    if (this.hasAttribute(name)) {
      if (force === void 0 || !force) {
        this.removeAttribute(name);
        return false;
      }
    } else {
      if (force === void 0 || force) {
        this.setAttribute(name, "");
        return true;
      } else {
        return false;
      }
    }
    return true;
  }
  hasAttribute(name) {
    return attributesForElement(this).has(name);
  }
  attachShadow(init5) {
    const shadowRoot = { host: this };
    this.__shadowRootMode = init5.mode;
    if (init5 && init5.mode === "open") {
      this.__shadowRoot = shadowRoot;
    }
    return shadowRoot;
  }
  attachInternals() {
    if (this.__internals !== null) {
      throw new Error(`Failed to execute 'attachInternals' on 'HTMLElement': ElementInternals for the specified element was already attached.`);
    }
    const internals = new ElementInternalsShim(this);
    this.__internals = internals;
    return internals;
  }
  getAttribute(name) {
    const value2 = attributesForElement(this).get(name);
    return value2 ?? null;
  }
};
var HTMLElementShim = class HTMLElement extends ElementShim {
};
var HTMLElementShimWithRealType = HTMLElementShim;
var CustomElementRegistryShim = class CustomElementRegistry {
  constructor() {
    this.__definitions = /* @__PURE__ */ new Map();
  }
  define(name, ctor) {
    if (this.__definitions.has(name)) {
      if (process.env.NODE_ENV === "development") {
        console.warn(`'CustomElementRegistry' already has "${name}" defined. This may have been caused by live reload or hot module replacement in which case it can be safely ignored.
Make sure to test your application with a production build as repeat registrations will throw in production.`);
      } else {
        throw new Error(`Failed to execute 'define' on 'CustomElementRegistry': the name "${name}" has already been used with this registry`);
      }
    }
    ctor.__localName = name;
    this.__definitions.set(name, {
      ctor,
      // Note it's important we read `observedAttributes` in case it is a getter
      // with side-effects, as is the case in Lit, where it triggers class
      // finalization.
      //
      // TODO(aomarks) To be spec compliant, we should also capture the
      // registration-time lifecycle methods like `connectedCallback`. For them
      // to be actually accessible to e.g. the Lit SSR element renderer, though,
      // we'd need to introduce a new API for accessing them (since `get` only
      // returns the constructor).
      observedAttributes: ctor.observedAttributes ?? []
    });
  }
  get(name) {
    const definition = this.__definitions.get(name);
    return definition?.ctor;
  }
};
var CustomElementRegistryShimWithRealType = CustomElementRegistryShim;
var customElements2 = new CustomElementRegistryShimWithRealType();

// node_modules/@lit/reactive-element/node/css-tag.js
var t2 = globalThis;
var e = t2.ShadowRoot && (void 0 === t2.ShadyCSS || t2.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s = Symbol();
var o = /* @__PURE__ */ new WeakMap();
var n = class {
  constructor(t6, e5, o5) {
    if (this._$cssResult$ = true, o5 !== s) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t6, this.t = e5;
  }
  get styleSheet() {
    let t6 = this.o;
    const s3 = this.t;
    if (e && void 0 === t6) {
      const e5 = void 0 !== s3 && 1 === s3.length;
      e5 && (t6 = o.get(s3)), void 0 === t6 && ((this.o = t6 = new CSSStyleSheet()).replaceSync(this.cssText), e5 && o.set(s3, t6));
    }
    return t6;
  }
  toString() {
    return this.cssText;
  }
};
var r = (t6) => new n("string" == typeof t6 ? t6 : t6 + "", void 0, s);
var i = (t6, ...e5) => {
  const o5 = 1 === t6.length ? t6[0] : e5.reduce((e6, s3, o6) => e6 + ((t7) => {
    if (true === t7._$cssResult$) return t7.cssText;
    if ("number" == typeof t7) return t7;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t7 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s3) + t6[o6 + 1], t6[0]);
  return new n(o5, t6, s);
};
var S = (s3, o5) => {
  if (e) s3.adoptedStyleSheets = o5.map((t6) => t6 instanceof CSSStyleSheet ? t6 : t6.styleSheet);
  else for (const e5 of o5) {
    const o6 = document.createElement("style"), n7 = t2.litNonce;
    void 0 !== n7 && o6.setAttribute("nonce", n7), o6.textContent = e5.cssText, s3.appendChild(o6);
  }
};
var c = e || void 0 === t2.CSSStyleSheet ? (t6) => t6 : (t6) => t6 instanceof CSSStyleSheet ? ((t7) => {
  let e5 = "";
  for (const s3 of t7.cssRules) e5 += s3.cssText;
  return r(e5);
})(t6) : t6;

// node_modules/@lit/reactive-element/node/reactive-element.js
var { is: r2, defineProperty: h, getOwnPropertyDescriptor: o2, getOwnPropertyNames: n2, getOwnPropertySymbols: a, getPrototypeOf: c2 } = Object;
var l = globalThis;
l.customElements ??= customElements2;
var p = l.trustedTypes;
var d = p ? p.emptyScript : "";
var u = l.reactiveElementPolyfillSupport;
var f = (t6, s3) => t6;
var b = { toAttribute(t6, s3) {
  switch (s3) {
    case Boolean:
      t6 = t6 ? d : null;
      break;
    case Object:
    case Array:
      t6 = null == t6 ? t6 : JSON.stringify(t6);
  }
  return t6;
}, fromAttribute(t6, s3) {
  let i4 = t6;
  switch (s3) {
    case Boolean:
      i4 = null !== t6;
      break;
    case Number:
      i4 = null === t6 ? null : Number(t6);
      break;
    case Object:
    case Array:
      try {
        i4 = JSON.parse(t6);
      } catch (t7) {
        i4 = null;
      }
  }
  return i4;
} };
var y = (t6, s3) => !r2(t6, s3);
var m = { attribute: true, type: String, converter: b, reflect: false, hasChanged: y };
Symbol.metadata ??= Symbol("metadata"), l.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var g = class extends (globalThis.HTMLElement ?? HTMLElementShimWithRealType) {
  static addInitializer(t6) {
    this._$Ei(), (this.l ??= []).push(t6);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t6, s3 = m) {
    if (s3.state && (s3.attribute = false), this._$Ei(), this.elementProperties.set(t6, s3), !s3.noAccessor) {
      const i4 = Symbol(), e5 = this.getPropertyDescriptor(t6, i4, s3);
      void 0 !== e5 && h(this.prototype, t6, e5);
    }
  }
  static getPropertyDescriptor(t6, s3, i4) {
    const { get: e5, set: r5 } = o2(this.prototype, t6) ?? { get() {
      return this[s3];
    }, set(t7) {
      this[s3] = t7;
    } };
    return { get() {
      return e5?.call(this);
    }, set(s4) {
      const h5 = e5?.call(this);
      r5.call(this, s4), this.requestUpdate(t6, h5, i4);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t6) {
    return this.elementProperties.get(t6) ?? m;
  }
  static _$Ei() {
    if (this.hasOwnProperty(f("elementProperties"))) return;
    const t6 = c2(this);
    t6.finalize(), void 0 !== t6.l && (this.l = [...t6.l]), this.elementProperties = new Map(t6.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(f("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(f("properties"))) {
      const t7 = this.properties, s3 = [...n2(t7), ...a(t7)];
      for (const i4 of s3) this.createProperty(i4, t7[i4]);
    }
    const t6 = this[Symbol.metadata];
    if (null !== t6) {
      const s3 = litPropertyMetadata.get(t6);
      if (void 0 !== s3) for (const [t7, i4] of s3) this.elementProperties.set(t7, i4);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t7, s3] of this.elementProperties) {
      const i4 = this._$Eu(t7, s3);
      void 0 !== i4 && this._$Eh.set(i4, t7);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t6) {
    const s3 = [];
    if (Array.isArray(t6)) {
      const e5 = new Set(t6.flat(1 / 0).reverse());
      for (const t7 of e5) s3.unshift(c(t7));
    } else void 0 !== t6 && s3.push(c(t6));
    return s3;
  }
  static _$Eu(t6, s3) {
    const i4 = s3.attribute;
    return false === i4 ? void 0 : "string" == typeof i4 ? i4 : "string" == typeof t6 ? t6.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t6) => this.enableUpdating = t6), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t6) => t6(this));
  }
  addController(t6) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t6), void 0 !== this.renderRoot && this.isConnected && t6.hostConnected?.();
  }
  removeController(t6) {
    this._$EO?.delete(t6);
  }
  _$E_() {
    const t6 = /* @__PURE__ */ new Map(), s3 = this.constructor.elementProperties;
    for (const i4 of s3.keys()) this.hasOwnProperty(i4) && (t6.set(i4, this[i4]), delete this[i4]);
    t6.size > 0 && (this._$Ep = t6);
  }
  createRenderRoot() {
    const t6 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S(t6, this.constructor.elementStyles), t6;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t6) => t6.hostConnected?.());
  }
  enableUpdating(t6) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t6) => t6.hostDisconnected?.());
  }
  attributeChangedCallback(t6, s3, i4) {
    this._$AK(t6, i4);
  }
  _$EC(t6, s3) {
    const i4 = this.constructor.elementProperties.get(t6), e5 = this.constructor._$Eu(t6, i4);
    if (void 0 !== e5 && true === i4.reflect) {
      const r5 = (void 0 !== i4.converter?.toAttribute ? i4.converter : b).toAttribute(s3, i4.type);
      this._$Em = t6, null == r5 ? this.removeAttribute(e5) : this.setAttribute(e5, r5), this._$Em = null;
    }
  }
  _$AK(t6, s3) {
    const i4 = this.constructor, e5 = i4._$Eh.get(t6);
    if (void 0 !== e5 && this._$Em !== e5) {
      const t7 = i4.getPropertyOptions(e5), r5 = "function" == typeof t7.converter ? { fromAttribute: t7.converter } : void 0 !== t7.converter?.fromAttribute ? t7.converter : b;
      this._$Em = e5, this[e5] = r5.fromAttribute(s3, t7.type), this._$Em = null;
    }
  }
  requestUpdate(t6, s3, i4) {
    if (void 0 !== t6) {
      if (i4 ??= this.constructor.getPropertyOptions(t6), !(i4.hasChanged ?? y)(this[t6], s3)) return;
      this.P(t6, s3, i4);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t6, s3, i4) {
    this._$AL.has(t6) || this._$AL.set(t6, s3), true === i4.reflect && this._$Em !== t6 && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t6);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t7) {
      Promise.reject(t7);
    }
    const t6 = this.scheduleUpdate();
    return null != t6 && await t6, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t8, s4] of this._$Ep) this[t8] = s4;
        this._$Ep = void 0;
      }
      const t7 = this.constructor.elementProperties;
      if (t7.size > 0) for (const [s4, i4] of t7) true !== i4.wrapped || this._$AL.has(s4) || void 0 === this[s4] || this.P(s4, this[s4], i4);
    }
    let t6 = false;
    const s3 = this._$AL;
    try {
      t6 = this.shouldUpdate(s3), t6 ? (this.willUpdate(s3), this._$EO?.forEach((t7) => t7.hostUpdate?.()), this.update(s3)) : this._$EU();
    } catch (s4) {
      throw t6 = false, this._$EU(), s4;
    }
    t6 && this._$AE(s3);
  }
  willUpdate(t6) {
  }
  _$AE(t6) {
    this._$EO?.forEach((t7) => t7.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t6)), this.updated(t6);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t6) {
    return true;
  }
  update(t6) {
    this._$Ej &&= this._$Ej.forEach((t7) => this._$EC(t7, this[t7])), this._$EU();
  }
  updated(t6) {
  }
  firstUpdated(t6) {
  }
};
g.elementStyles = [], g.shadowRootOptions = { mode: "open" }, g[f("elementProperties")] = /* @__PURE__ */ new Map(), g[f("finalized")] = /* @__PURE__ */ new Map(), u?.({ ReactiveElement: g }), (l.reactiveElementVersions ??= []).push("2.0.4");

// node_modules/lit-html/node/lit-html.js
var n3 = globalThis;
var c3 = n3.trustedTypes;
var h2 = c3 ? c3.createPolicy("lit-html", { createHTML: (t6) => t6 }) : void 0;
var f2 = "$lit$";
var v = `lit$${Math.random().toFixed(9).slice(2)}$`;
var m2 = "?" + v;
var _ = `<${m2}>`;
var w = void 0 === n3.document ? { createTreeWalker: () => ({}) } : document;
var lt = () => w.createComment("");
var st = (t6) => null === t6 || "object" != typeof t6 && "function" != typeof t6;
var g2 = Array.isArray;
var $ = (t6) => g2(t6) || "function" == typeof t6?.[Symbol.iterator];
var x = "[ 	\n\f\r]";
var T = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var E = /-->/g;
var k = />/g;
var O = RegExp(`>|${x}(?:([^\\s"'>=/]+)(${x}*=${x}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var S2 = /'/g;
var j = /"/g;
var M = /^(?:script|style|textarea|title)$/i;
var P = (t6) => (i4, ...s3) => ({ _$litType$: t6, strings: i4, values: s3 });
var ke = P(1);
var Oe = P(2);
var Se = P(3);
var R = Symbol.for("lit-noChange");
var D = Symbol.for("lit-nothing");
var V = /* @__PURE__ */ new WeakMap();
var I = w.createTreeWalker(w, 129);
function N(t6, i4) {
  if (!g2(t6) || !t6.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== h2 ? h2.createHTML(i4) : i4;
}
var U = (t6, i4) => {
  const s3 = t6.length - 1, e5 = [];
  let h5, o5 = 2 === i4 ? "<svg>" : 3 === i4 ? "<math>" : "", n7 = T;
  for (let i5 = 0; i5 < s3; i5++) {
    const s4 = t6[i5];
    let r5, l3, c6 = -1, a4 = 0;
    for (; a4 < s4.length && (n7.lastIndex = a4, l3 = n7.exec(s4), null !== l3); ) a4 = n7.lastIndex, n7 === T ? "!--" === l3[1] ? n7 = E : void 0 !== l3[1] ? n7 = k : void 0 !== l3[2] ? (M.test(l3[2]) && (h5 = RegExp("</" + l3[2], "g")), n7 = O) : void 0 !== l3[3] && (n7 = O) : n7 === O ? ">" === l3[0] ? (n7 = h5 ?? T, c6 = -1) : void 0 === l3[1] ? c6 = -2 : (c6 = n7.lastIndex - l3[2].length, r5 = l3[1], n7 = void 0 === l3[3] ? O : '"' === l3[3] ? j : S2) : n7 === j || n7 === S2 ? n7 = O : n7 === E || n7 === k ? n7 = T : (n7 = O, h5 = void 0);
    const u3 = n7 === O && t6[i5 + 1].startsWith("/>") ? " " : "";
    o5 += n7 === T ? s4 + _ : c6 >= 0 ? (e5.push(r5), s4.slice(0, c6) + f2 + s4.slice(c6) + v + u3) : s4 + v + (-2 === c6 ? i5 : u3);
  }
  return [N(t6, o5 + (t6[s3] || "<?>") + (2 === i4 ? "</svg>" : 3 === i4 ? "</math>" : "")), e5];
};
var B = class _B {
  constructor({ strings: t6, _$litType$: i4 }, s3) {
    let e5;
    this.parts = [];
    let h5 = 0, o5 = 0;
    const n7 = t6.length - 1, r5 = this.parts, [l3, a4] = U(t6, i4);
    if (this.el = _B.createElement(l3, s3), I.currentNode = this.el.content, 2 === i4 || 3 === i4) {
      const t7 = this.el.content.firstChild;
      t7.replaceWith(...t7.childNodes);
    }
    for (; null !== (e5 = I.nextNode()) && r5.length < n7; ) {
      if (1 === e5.nodeType) {
        if (e5.hasAttributes()) for (const t7 of e5.getAttributeNames()) if (t7.endsWith(f2)) {
          const i5 = a4[o5++], s4 = e5.getAttribute(t7).split(v), n8 = /([.?@])?(.*)/.exec(i5);
          r5.push({ type: 1, index: h5, name: n8[2], strings: s4, ctor: "." === n8[1] ? Y : "?" === n8[1] ? Z : "@" === n8[1] ? q : G }), e5.removeAttribute(t7);
        } else t7.startsWith(v) && (r5.push({ type: 6, index: h5 }), e5.removeAttribute(t7));
        if (M.test(e5.tagName)) {
          const t7 = e5.textContent.split(v), i5 = t7.length - 1;
          if (i5 > 0) {
            e5.textContent = c3 ? c3.emptyScript : "";
            for (let s4 = 0; s4 < i5; s4++) e5.append(t7[s4], lt()), I.nextNode(), r5.push({ type: 2, index: ++h5 });
            e5.append(t7[i5], lt());
          }
        }
      } else if (8 === e5.nodeType) if (e5.data === m2) r5.push({ type: 2, index: h5 });
      else {
        let t7 = -1;
        for (; -1 !== (t7 = e5.data.indexOf(v, t7 + 1)); ) r5.push({ type: 7, index: h5 }), t7 += v.length - 1;
      }
      h5++;
    }
  }
  static createElement(t6, i4) {
    const s3 = w.createElement("template");
    return s3.innerHTML = t6, s3;
  }
};
function z(t6, i4, s3 = t6, e5) {
  if (i4 === R) return i4;
  let h5 = void 0 !== e5 ? s3.o?.[e5] : s3.l;
  const o5 = st(i4) ? void 0 : i4._$litDirective$;
  return h5?.constructor !== o5 && (h5?._$AO?.(false), void 0 === o5 ? h5 = void 0 : (h5 = new o5(t6), h5._$AT(t6, s3, e5)), void 0 !== e5 ? (s3.o ??= [])[e5] = h5 : s3.l = h5), void 0 !== h5 && (i4 = z(t6, h5._$AS(t6, i4.values), h5, e5)), i4;
}
var F = class {
  constructor(t6, i4) {
    this._$AV = [], this._$AN = void 0, this._$AD = t6, this._$AM = i4;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t6) {
    const { el: { content: i4 }, parts: s3 } = this._$AD, e5 = (t6?.creationScope ?? w).importNode(i4, true);
    I.currentNode = e5;
    let h5 = I.nextNode(), o5 = 0, n7 = 0, r5 = s3[0];
    for (; void 0 !== r5; ) {
      if (o5 === r5.index) {
        let i5;
        2 === r5.type ? i5 = new et(h5, h5.nextSibling, this, t6) : 1 === r5.type ? i5 = new r5.ctor(h5, r5.name, r5.strings, this, t6) : 6 === r5.type && (i5 = new K(h5, this, t6)), this._$AV.push(i5), r5 = s3[++n7];
      }
      o5 !== r5?.index && (h5 = I.nextNode(), o5++);
    }
    return I.currentNode = w, e5;
  }
  p(t6) {
    let i4 = 0;
    for (const s3 of this._$AV) void 0 !== s3 && (void 0 !== s3.strings ? (s3._$AI(t6, s3, i4), i4 += s3.strings.length - 2) : s3._$AI(t6[i4])), i4++;
  }
};
var et = class _et {
  get _$AU() {
    return this._$AM?._$AU ?? this.v;
  }
  constructor(t6, i4, s3, e5) {
    this.type = 2, this._$AH = D, this._$AN = void 0, this._$AA = t6, this._$AB = i4, this._$AM = s3, this.options = e5, this.v = e5?.isConnected ?? true;
  }
  get parentNode() {
    let t6 = this._$AA.parentNode;
    const i4 = this._$AM;
    return void 0 !== i4 && 11 === t6?.nodeType && (t6 = i4.parentNode), t6;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t6, i4 = this) {
    t6 = z(this, t6, i4), st(t6) ? t6 === D || null == t6 || "" === t6 ? (this._$AH !== D && this._$AR(), this._$AH = D) : t6 !== this._$AH && t6 !== R && this._(t6) : void 0 !== t6._$litType$ ? this.$(t6) : void 0 !== t6.nodeType ? this.T(t6) : $(t6) ? this.k(t6) : this._(t6);
  }
  O(t6) {
    return this._$AA.parentNode.insertBefore(t6, this._$AB);
  }
  T(t6) {
    this._$AH !== t6 && (this._$AR(), this._$AH = this.O(t6));
  }
  _(t6) {
    this._$AH !== D && st(this._$AH) ? this._$AA.nextSibling.data = t6 : this.T(w.createTextNode(t6)), this._$AH = t6;
  }
  $(t6) {
    const { values: i4, _$litType$: s3 } = t6, e5 = "number" == typeof s3 ? this._$AC(t6) : (void 0 === s3.el && (s3.el = B.createElement(N(s3.h, s3.h[0]), this.options)), s3);
    if (this._$AH?._$AD === e5) this._$AH.p(i4);
    else {
      const t7 = new F(e5, this), s4 = t7.u(this.options);
      t7.p(i4), this.T(s4), this._$AH = t7;
    }
  }
  _$AC(t6) {
    let i4 = V.get(t6.strings);
    return void 0 === i4 && V.set(t6.strings, i4 = new B(t6)), i4;
  }
  k(t6) {
    g2(this._$AH) || (this._$AH = [], this._$AR());
    const i4 = this._$AH;
    let s3, e5 = 0;
    for (const h5 of t6) e5 === i4.length ? i4.push(s3 = new _et(this.O(lt()), this.O(lt()), this, this.options)) : s3 = i4[e5], s3._$AI(h5), e5++;
    e5 < i4.length && (this._$AR(s3 && s3._$AB.nextSibling, e5), i4.length = e5);
  }
  _$AR(t6 = this._$AA.nextSibling, i4) {
    for (this._$AP?.(false, true, i4); t6 && t6 !== this._$AB; ) {
      const i5 = t6.nextSibling;
      t6.remove(), t6 = i5;
    }
  }
  setConnected(t6) {
    void 0 === this._$AM && (this.v = t6, this._$AP?.(t6));
  }
};
var G = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t6, i4, s3, e5, h5) {
    this.type = 1, this._$AH = D, this._$AN = void 0, this.element = t6, this.name = i4, this._$AM = e5, this.options = h5, s3.length > 2 || "" !== s3[0] || "" !== s3[1] ? (this._$AH = Array(s3.length - 1).fill(new String()), this.strings = s3) : this._$AH = D;
  }
  _$AI(t6, i4 = this, s3, e5) {
    const h5 = this.strings;
    let o5 = false;
    if (void 0 === h5) t6 = z(this, t6, i4, 0), o5 = !st(t6) || t6 !== this._$AH && t6 !== R, o5 && (this._$AH = t6);
    else {
      const e6 = t6;
      let n7, r5;
      for (t6 = h5[0], n7 = 0; n7 < h5.length - 1; n7++) r5 = z(this, e6[s3 + n7], i4, n7), r5 === R && (r5 = this._$AH[n7]), o5 ||= !st(r5) || r5 !== this._$AH[n7], r5 === D ? t6 = D : t6 !== D && (t6 += (r5 ?? "") + h5[n7 + 1]), this._$AH[n7] = r5;
    }
    o5 && !e5 && this.j(t6);
  }
  j(t6) {
    t6 === D ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t6 ?? "");
  }
};
var Y = class extends G {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t6) {
    this.element[this.name] = t6 === D ? void 0 : t6;
  }
};
var Z = class extends G {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t6) {
    this.element.toggleAttribute(this.name, !!t6 && t6 !== D);
  }
};
var q = class extends G {
  constructor(t6, i4, s3, e5, h5) {
    super(t6, i4, s3, e5, h5), this.type = 5;
  }
  _$AI(t6, i4 = this) {
    if ((t6 = z(this, t6, i4, 0) ?? D) === R) return;
    const s3 = this._$AH, e5 = t6 === D && s3 !== D || t6.capture !== s3.capture || t6.once !== s3.once || t6.passive !== s3.passive, h5 = t6 !== D && (s3 === D || e5);
    e5 && this.element.removeEventListener(this.name, this, s3), h5 && this.element.addEventListener(this.name, this, t6), this._$AH = t6;
  }
  handleEvent(t6) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t6) : this._$AH.handleEvent(t6);
  }
};
var K = class {
  constructor(t6, i4, s3) {
    this.element = t6, this.type = 6, this._$AN = void 0, this._$AM = i4, this.options = s3;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t6) {
    z(this, t6);
  }
};
var si = { M: f2, P: v, A: m2, C: 1, L: U, R: F, D: $, V: z, I: et, H: G, N: Z, U: q, B: Y, F: K };
var Re = n3.litHtmlPolyfillSupport;
Re?.(B, et), (n3.litHtmlVersions ??= []).push("3.2.0");
var Q = (t6, i4, s3) => {
  const e5 = s3?.renderBefore ?? i4;
  let h5 = e5._$litPart$;
  if (void 0 === h5) {
    const t7 = s3?.renderBefore ?? null;
    e5._$litPart$ = h5 = new et(i4.insertBefore(lt(), t7), t7, void 0, s3 ?? {});
  }
  return h5._$AI(t6), h5;
};

// node_modules/lit-element/lit-element.js
var h3 = class extends g {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    const t6 = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t6.firstChild, t6;
  }
  update(t6) {
    const e5 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t6), this.o = Q(e5, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this.o?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.o?.setConnected(false);
  }
  render() {
    return R;
  }
};
h3._$litElement$ = true, h3["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: h3 });
var f3 = globalThis.litElementPolyfillSupport;
f3?.({ LitElement: h3 });
(globalThis.litElementVersions ??= []).push("4.1.0");

// node_modules/@lit/reactive-element/node/decorators/custom-element.js
var t3 = (t6) => (e5, o5) => {
  void 0 !== o5 ? o5.addInitializer(() => {
    customElements.define(t6, e5);
  }) : customElements.define(t6, e5);
};

// node_modules/@lit/reactive-element/node/decorators/property.js
var o3 = { attribute: true, type: String, converter: b, reflect: false, hasChanged: y };
var r3 = (t6 = o3, e5, r5) => {
  const { kind: n7, metadata: i4 } = r5;
  let s3 = globalThis.litPropertyMetadata.get(i4);
  if (void 0 === s3 && globalThis.litPropertyMetadata.set(i4, s3 = /* @__PURE__ */ new Map()), s3.set(r5.name, t6), "accessor" === n7) {
    const { name: o5 } = r5;
    return { set(r6) {
      const n8 = e5.get.call(this);
      e5.set.call(this, r6), this.requestUpdate(o5, n8, t6);
    }, init(e6) {
      return void 0 !== e6 && this.P(o5, void 0, t6), e6;
    } };
  }
  if ("setter" === n7) {
    const { name: o5 } = r5;
    return function(r6) {
      const n8 = this[o5];
      e5.call(this, r6), this.requestUpdate(o5, n8, t6);
    };
  }
  throw Error("Unsupported decorator location: " + n7);
};
function n4(t6) {
  return (e5, o5) => "object" == typeof o5 ? r3(t6, e5, o5) : ((t7, e6, o6) => {
    const r5 = e6.hasOwnProperty(o6);
    return e6.constructor.createProperty(o6, r5 ? { ...t7, wrapped: true } : t7), r5 ? Object.getOwnPropertyDescriptor(e6, o6) : void 0;
  })(t6, e5, o5);
}

// node_modules/lit-html/node/directive-helpers.js
var { I: et2 } = si;
var rt = (o5) => void 0 === o5.strings;

// node_modules/lit-html/node/directive.js
var t4 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
var e3 = (t6) => (...e5) => ({ _$litDirective$: t6, values: e5 });
var i2 = class {
  constructor(t6) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t6, e5, i4) {
    this.t = t6, this._$AM = e5, this.i = i4;
  }
  _$AS(t6, e5) {
    return this.update(t6, e5);
  }
  update(t6, e5) {
    return this.render(...e5);
  }
};

// node_modules/lit-html/node/async-directive.js
var mt = (i4, t6) => {
  const e5 = i4._$AN;
  if (void 0 === e5) return false;
  for (const i5 of e5) i5._$AO?.(t6, false), mt(i5, t6);
  return true;
};
var _t = (i4) => {
  let t6, e5;
  do {
    if (void 0 === (t6 = i4._$AM)) break;
    e5 = t6._$AN, e5.delete(i4), i4 = t6;
  } while (0 === e5?.size);
};
var wt = (i4) => {
  for (let t6; t6 = i4._$AM; i4 = t6) {
    let e5 = t6._$AN;
    if (void 0 === e5) t6._$AN = e5 = /* @__PURE__ */ new Set();
    else if (e5.has(i4)) break;
    e5.add(i4), gt(t6);
  }
};
function bt(i4) {
  void 0 !== this._$AN ? (_t(this), this._$AM = i4, wt(this)) : this._$AM = i4;
}
function yt(i4, t6 = false, e5 = 0) {
  const s3 = this._$AH, o5 = this._$AN;
  if (void 0 !== o5 && 0 !== o5.size) if (t6) if (Array.isArray(s3)) for (let i5 = e5; i5 < s3.length; i5++) mt(s3[i5], false), _t(s3[i5]);
  else null != s3 && (mt(s3, false), _t(s3));
  else mt(this, i4);
}
var gt = (i4) => {
  i4.type == t4.CHILD && (i4._$AP ??= yt, i4._$AQ ??= bt);
};
var $t = class extends i2 {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(i4, t6, e5) {
    super._$AT(i4, t6, e5), wt(this), this.isConnected = i4._$AU;
  }
  _$AO(i4, t6 = true) {
    i4 !== this.isConnected && (this.isConnected = i4, i4 ? this.reconnected?.() : this.disconnected?.()), t6 && (mt(this, i4), _t(this));
  }
  setValue(i4) {
    if (rt(this.t)) this.t._$AI(i4, this);
    else {
      const t6 = [...this.t._$AH];
      t6[this.i] = i4, this.t._$AI(t6, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};

// node_modules/lit-html/node/directives/ref.js
var ii = () => new Zt();
var Zt = class {
};
var qt = /* @__PURE__ */ new WeakMap();
var Kt = e3(class extends $t {
  render(t6) {
    return D;
  }
  update(t6, [i4]) {
    const s3 = i4 !== this.Y;
    return s3 && void 0 !== this.Y && this.rt(void 0), (s3 || this.lt !== this.ct) && (this.Y = i4, this.ht = t6.options?.host, this.rt(this.ct = t6.element)), D;
  }
  rt(t6) {
    if (this.isConnected || (t6 = void 0), "function" == typeof this.Y) {
      const i4 = this.ht ?? globalThis;
      let s3 = qt.get(i4);
      void 0 === s3 && (s3 = /* @__PURE__ */ new WeakMap(), qt.set(i4, s3)), void 0 !== s3.get(this.Y) && this.Y.call(this.ht, void 0), s3.set(this.Y, t6), void 0 !== t6 && this.Y.call(this.ht, t6);
    } else this.Y.value = t6;
  }
  get lt() {
    return "function" == typeof this.Y ? qt.get(this.ht ?? globalThis)?.get(this.Y) : this.Y?.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});

// src/components/video-selector.ts
var _fileInputEl, _selectEl;
var VideoSelector = class extends h3 {
  constructor() {
    super(...arguments);
    this.playing = false;
    this.cameras = [];
    __privateAdd(this, _fileInputEl, ii());
    __privateAdd(this, _selectEl, ii());
  }
  render() {
    const source = this.source;
    let sel = ``;
    if (source) {
      if (source.kind === `camera`) {
        const first2 = this.cameras[0];
        if (source.id === `` && first2) {
          sel = first2.id;
        } else {
          sel = source.id;
        }
      }
    }
    const cameras = this.cameras.length === 0 ? ke`` : ke`
          ${this.cameras.map((d4) => ke`<option .source=${d4} ?selected=${d4.id === sel} value=${d4.id}>${d4.label}</option>`)}`;
    return ke`
    <div id="contents">
      <div id="toolbar"><button @click=${this.onStartStopClick}>${this.playing ? `Stop` : `Start`}</button></div>
      <select ${Kt(__privateGet(this, _selectEl))} @change=${this.onCameraSelectChange}>
        ${cameras}
      </select>
      <input @change=${this.onFileChange} ${Kt(__privateGet(this, _fileInputEl))} id="fileInput" type="file" accept="video/*" />
      <button @click=${this.onFileSelect}>File</button>
    </div>
    `;
  }
  getSelected() {
    const el = __privateGet(this, _selectEl).value;
    if (!el) return;
    const item = el.item(el.selectedIndex);
    if (!item) return;
    return item.source;
  }
  /**
  * Start stop source & processing
  */
  onStartStopClick() {
    this.dispatchEvent(new CustomEvent(`startstop`, { detail: this.getSelected() }));
  }
  onFileSelect() {
    __privateGet(this, _fileInputEl).value?.click();
  }
  notifySourceState(state) {
    this.playing = state === `started`;
  }
  onFileChange(event2) {
    const target = event2.target;
    if (!target) return;
    if (!target.files) return;
    const files = target.files;
    if (files.length === 0) return;
    const url = URL.createObjectURL(files[0]);
    const s3 = {
      id: url,
      label: `file`,
      kind: `file`
    };
    this.dispatchEvent(new CustomEvent(`change`, {
      detail: s3
    }));
  }
  /**
   * User has selected a camera
   * @param event
   * @returns 
   */
  onCameraSelectChange(event2) {
    const t6 = event2.target;
    const opt = t6.item(t6.selectedIndex);
    if (!opt) return;
    const value2 = opt.value;
    this.source = {
      kind: `camera`,
      label: opt.innerText,
      id: value2
    };
    this.dispatchEvent(new CustomEvent(`change`, { detail: this.source }));
  }
};
_fileInputEl = new WeakMap();
_selectEl = new WeakMap();
VideoSelector.styles = i`
    :host {
      display:block;
      background-color: hsla(0,0%,30%,0.5);
    }
    #contents {
      padding: 0.5rem;
    }
    input {
      display: none;
    }
    #toolbar {
      margin-bottom: 0.5rem;
    }
  `;
__decorateClass([
  n4()
], VideoSelector.prototype, "source", 2);
__decorateClass([
  n4()
], VideoSelector.prototype, "playing", 2);
__decorateClass([
  n4()
], VideoSelector.prototype, "cameras", 2);
VideoSelector = __decorateClass([
  t3("video-selector")
], VideoSelector);

// src/util/drawing.ts
var PiPi = Math.PI * 2;
var traceLine = (ctx, ...points) => {
  if (points.length < 2) return;
  ctx.moveTo(points[0].x, points[0].y);
  for (let i4 = 1; i4 < points.length; i4++) {
    if (points[i4] === void 0) continue;
    ctx.lineTo(points[i4].x, points[i4].y);
  }
};
var drawDot = (ctx, point2, radius, fillStyle, label, labelFillStyle) => {
  ctx.beginPath();
  ctx.arc(point2.x, point2.y, radius, 0, PiPi, false);
  if (fillStyle) {
    ctx.fillStyle = fillStyle;
  }
  ctx.fill();
  if (label) {
    if (labelFillStyle) ctx.fillStyle = labelFillStyle;
    ctx.fillText(label, point2.x + radius, point2.y - radius);
  }
};
var toAbsolute = (el) => (pt2) => {
  return { x: pt2.x * el.width, y: pt2.y * el.height };
};
var vpScale = (el) => {
  const s3 = Math.min(el.width, el.height);
  return (v3) => {
    return v3 * s3;
  };
};
var wrap = (el) => {
  const ctx = el.getContext(`2d`);
  if (!ctx) throw new Error(`Context unavailable`);
  const abs4 = toAbsolute(el);
  const dot2 = (point2, radius, fillStyle, label, labelFillStyle) => {
    drawDot(ctx, abs4(point2), scale4(radius), fillStyle, label, labelFillStyle);
  };
  const clear2 = () => {
    ctx.clearRect(0, 0, el.width, el.height);
  };
  const fill3 = (style) => {
    if (style) ctx.fillStyle = style;
    ctx.fillRect(0, 0, el.width, el.height);
  };
  const line3 = (a4, b4, width) => {
    a4 = abs4(a4);
    b4 = abs4(b4);
    width = scale4(width);
    ctx.beginPath();
    ctx.moveTo(a4.x, a4.y);
    ctx.lineTo(b4.x, b4.y);
    ctx.lineWidth = width;
    ctx.stroke();
    ctx.closePath();
  };
  const joinPoints = (width, ...points) => {
    width = scale4(width);
    ctx.beginPath();
    for (let i4 = 0; i4 < points.length; i4++) {
      const pt2 = abs4(points[i4]);
      if (i4 === 0) {
        ctx.moveTo(pt2.x, pt2.y);
      } else {
        ctx.lineTo(pt2.x, pt2.y);
      }
    }
    ctx.lineWidth = width;
    ctx.stroke();
    ctx.closePath();
  };
  const scale4 = vpScale(el);
  const testPattern = () => {
    ctx.beginPath();
    ctx.strokeStyle = `red`;
    ctx.lineWidth = 2;
    traceLine(ctx, { x: 0, y: 0 }, { x: el.width, y: el.height });
    traceLine(ctx, { x: 0, y: el.height }, { x: el.width, y: 0 });
    ctx.stroke();
  };
  const text2 = (text3, point2, style) => {
    point2 = abs4(point2);
    if (style) ctx.fillStyle = style;
    ctx.fillText(text3, point2.x, point2.y);
  };
  return { dot: dot2, abs: abs4, clear: clear2, testPattern, scale: scale4, line: line3, joinPoints, fill: fill3, text: text2, ctx };
};
var typewriter = (ctx, x3 = 0, y3 = 0) => {
  const measure = (msg) => {
    const m5 = ctx.measureText(msg);
    return {
      width: m5.width,
      height: m5.fontBoundingBoxAscent + m5.fontBoundingBoxDescent
    };
  };
  const move = (toX, toY) => {
    x3 = toX;
    y3 = toY;
  };
  const line3 = (msg, colour2) => {
    const r5 = measure(msg);
    if (colour2) ctx.fillStyle = colour2;
    ctx.fillText(msg, x3, y3);
    y3 += r5.height;
  };
  const word = (msg, colour2) => {
    const r5 = measure(msg);
    if (colour2) ctx.fillStyle = colour2;
    ctx.fillText(msg, x3, y3);
    x3 += r5.width;
  };
  return { line: line3, word, move };
};

// node_modules/@mediapipe/tasks-vision/vision_bundle.mjs
var t5 = "undefined" != typeof self ? self : {};
function e4(e5) {
  t: {
    for (var n7 = ["CLOSURE_FLAGS"], r5 = t5, i4 = 0; i4 < n7.length; i4++) if (null == (r5 = r5[n7[i4]])) {
      n7 = null;
      break t;
    }
    n7 = r5;
  }
  return null != (e5 = n7 && n7[e5]) && e5;
}
function n5() {
  throw Error("Invalid UTF8");
}
function r4(t6, e5) {
  return e5 = String.fromCharCode.apply(null, e5), null == t6 ? e5 : t6 + e5;
}
var i3;
var s2;
var o4 = "undefined" != typeof TextDecoder;
var a2;
var h4 = "undefined" != typeof TextEncoder;
function c4(t6) {
  if (h4) t6 = (a2 ||= new TextEncoder()).encode(t6);
  else {
    let n7 = 0;
    const r5 = new Uint8Array(3 * t6.length);
    for (let i4 = 0; i4 < t6.length; i4++) {
      var e5 = t6.charCodeAt(i4);
      if (128 > e5) r5[n7++] = e5;
      else {
        if (2048 > e5) r5[n7++] = e5 >> 6 | 192;
        else {
          if (55296 <= e5 && 57343 >= e5) {
            if (56319 >= e5 && i4 < t6.length) {
              const s3 = t6.charCodeAt(++i4);
              if (56320 <= s3 && 57343 >= s3) {
                e5 = 1024 * (e5 - 55296) + s3 - 56320 + 65536, r5[n7++] = e5 >> 18 | 240, r5[n7++] = e5 >> 12 & 63 | 128, r5[n7++] = e5 >> 6 & 63 | 128, r5[n7++] = 63 & e5 | 128;
                continue;
              }
              i4--;
            }
            e5 = 65533;
          }
          r5[n7++] = e5 >> 12 | 224, r5[n7++] = e5 >> 6 & 63 | 128;
        }
        r5[n7++] = 63 & e5 | 128;
      }
    }
    t6 = n7 === r5.length ? r5 : r5.subarray(0, n7);
  }
  return t6;
}
var u2;
var l2 = e4(610401301);
var d2 = e4(188588736);
var f4 = t5.navigator;
function p2(t6) {
  return !!l2 && (!!u2 && u2.brands.some(({ brand: e5 }) => e5 && -1 != e5.indexOf(t6)));
}
function g3(e5) {
  var n7;
  return (n7 = t5.navigator) && (n7 = n7.userAgent) || (n7 = ""), -1 != n7.indexOf(e5);
}
function m3() {
  return !!l2 && (!!u2 && 0 < u2.brands.length);
}
function y2() {
  return m3() ? p2("Chromium") : (g3("Chrome") || g3("CriOS")) && !(!m3() && g3("Edge")) || g3("Silk");
}
function _2(t6) {
  return _2[" "](t6), t6;
}
u2 = f4 && f4.userAgentData || null, _2[" "] = function() {
};
var v2 = !m3() && (g3("Trident") || g3("MSIE"));
!g3("Android") || y2(), y2(), g3("Safari") && (y2() || !m3() && g3("Coast") || !m3() && g3("Opera") || !m3() && g3("Edge") || (m3() ? p2("Microsoft Edge") : g3("Edg/")) || m3() && p2("Opera"));
var E2 = {};
var w2 = null;
function T2(t6) {
  var e5 = t6.length, n7 = 3 * e5 / 4;
  n7 % 3 ? n7 = Math.floor(n7) : -1 != "=.".indexOf(t6[e5 - 1]) && (n7 = -1 != "=.".indexOf(t6[e5 - 2]) ? n7 - 2 : n7 - 1);
  var r5 = new Uint8Array(n7), i4 = 0;
  return function(t7, e6) {
    function n8(e7) {
      for (; r6 < t7.length; ) {
        var n9 = t7.charAt(r6++), i6 = w2[n9];
        if (null != i6) return i6;
        if (!/^[\s\xa0]*$/.test(n9)) throw Error("Unknown base64 encoding at char: " + n9);
      }
      return e7;
    }
    A();
    for (var r6 = 0; ; ) {
      var i5 = n8(-1), s3 = n8(0), o5 = n8(64), a4 = n8(64);
      if (64 === a4 && -1 === i5) break;
      e6(i5 << 2 | s3 >> 4), 64 != o5 && (e6(s3 << 4 & 240 | o5 >> 2), 64 != a4 && e6(o5 << 6 & 192 | a4));
    }
  }(t6, function(t7) {
    r5[i4++] = t7;
  }), i4 !== n7 ? r5.subarray(0, i4) : r5;
}
function A() {
  if (!w2) {
    w2 = {};
    for (var t6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), e5 = ["+/=", "+/", "-_=", "-_.", "-_"], n7 = 0; 5 > n7; n7++) {
      var r5 = t6.concat(e5[n7].split(""));
      E2[n7] = r5;
      for (var i4 = 0; i4 < r5.length; i4++) {
        var s3 = r5[i4];
        void 0 === w2[s3] && (w2[s3] = i4);
      }
    }
  }
}
var b2 = "undefined" != typeof Uint8Array;
var k2 = !v2 && "function" == typeof btoa;
function x2(t6) {
  if (!k2) {
    var e5;
    void 0 === e5 && (e5 = 0), A(), e5 = E2[e5];
    var n7 = Array(Math.floor(t6.length / 3)), r5 = e5[64] || "";
    let h5 = 0, c6 = 0;
    for (; h5 < t6.length - 2; h5 += 3) {
      var i4 = t6[h5], s3 = t6[h5 + 1], o5 = t6[h5 + 2], a4 = e5[i4 >> 2];
      i4 = e5[(3 & i4) << 4 | s3 >> 4], s3 = e5[(15 & s3) << 2 | o5 >> 6], o5 = e5[63 & o5], n7[c6++] = a4 + i4 + s3 + o5;
    }
    switch (a4 = 0, o5 = r5, t6.length - h5) {
      case 2:
        o5 = e5[(15 & (a4 = t6[h5 + 1])) << 2] || r5;
      case 1:
        t6 = t6[h5], n7[c6] = e5[t6 >> 2] + e5[(3 & t6) << 4 | a4 >> 4] + o5 + r5;
    }
    return n7.join("");
  }
  for (e5 = "", n7 = 0, r5 = t6.length - 10240; n7 < r5; ) e5 += String.fromCharCode.apply(null, t6.subarray(n7, n7 += 10240));
  return e5 += String.fromCharCode.apply(null, n7 ? t6.subarray(n7) : t6), btoa(e5);
}
var S3 = /[-_.]/g;
var L = { "-": "+", _: "/", ".": "=" };
function F2(t6) {
  return L[t6] || "";
}
function R2(t6) {
  if (!k2) return T2(t6);
  S3.test(t6) && (t6 = t6.replace(S3, F2)), t6 = atob(t6);
  const e5 = new Uint8Array(t6.length);
  for (let n7 = 0; n7 < t6.length; n7++) e5[n7] = t6.charCodeAt(n7);
  return e5;
}
function M2(t6) {
  return b2 && null != t6 && t6 instanceof Uint8Array;
}
var P2;
function C() {
  return P2 ||= new Uint8Array(0);
}
var O2 = {};
var I2;
function U2(t6) {
  if (t6 !== O2) throw Error("illegal external caller");
}
function D2() {
  return I2 ||= new B2(null, O2);
}
function N2(t6) {
  U2(O2);
  var e5 = t6.g;
  return null == (e5 = null == e5 || M2(e5) ? e5 : "string" == typeof e5 ? R2(e5) : null) ? e5 : t6.g = e5;
}
var B2 = class {
  constructor(t6, e5) {
    if (U2(e5), this.g = t6, null != t6 && 0 === t6.length) throw Error("ByteString should be constructed with non-empty values");
  }
  h() {
    const t6 = N2(this);
    return t6 ? new Uint8Array(t6) : C();
  }
};
function G2(t6, e5) {
  return Error(`Invalid wire type: ${t6} (at position ${e5})`);
}
function j2() {
  return Error("Failed to read varint, encoding is invalid.");
}
function V2(t6, e5) {
  return Error(`Tried to read past the end of the data ${e5} > ${t6}`);
}
function X(t6) {
  if ("string" == typeof t6) return { buffer: R2(t6), P: false };
  if (Array.isArray(t6)) return { buffer: new Uint8Array(t6), P: false };
  if (t6.constructor === Uint8Array) return { buffer: t6, P: false };
  if (t6.constructor === ArrayBuffer) return { buffer: new Uint8Array(t6), P: false };
  if (t6.constructor === B2) return { buffer: N2(t6) || C(), P: true };
  if (t6 instanceof Uint8Array) return { buffer: new Uint8Array(t6.buffer, t6.byteOffset, t6.byteLength), P: false };
  throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers");
}
function H() {
  return "function" == typeof BigInt;
}
var W = "function" == typeof Uint8Array.prototype.slice;
var z2;
var K2 = 0;
var Y2 = 0;
function $2(t6) {
  const e5 = 0 > t6;
  let n7 = (t6 = Math.abs(t6)) >>> 0;
  if (t6 = Math.floor((t6 - n7) / 4294967296), e5) {
    const [e6, r5] = rt2(n7, t6);
    t6 = r5, n7 = e6;
  }
  K2 = n7 >>> 0, Y2 = t6 >>> 0;
}
function q2(t6) {
  const e5 = z2 ||= new DataView(new ArrayBuffer(8));
  e5.setFloat32(0, +t6, true), Y2 = 0, K2 = e5.getUint32(0, true);
}
function J(t6, e5) {
  return 4294967296 * e5 + (t6 >>> 0);
}
function Z2(t6, e5) {
  const n7 = 2147483648 & e5;
  return n7 && (e5 = ~e5 >>> 0, 0 == (t6 = 1 + ~t6 >>> 0) && (e5 = e5 + 1 >>> 0)), t6 = J(t6, e5), n7 ? -t6 : t6;
}
function Q2(t6, e5) {
  if (t6 >>>= 0, 2097151 >= (e5 >>>= 0)) var n7 = "" + (4294967296 * e5 + t6);
  else H() ? n7 = "" + (BigInt(e5) << BigInt(32) | BigInt(t6)) : (t6 = (16777215 & t6) + 6777216 * (n7 = 16777215 & (t6 >>> 24 | e5 << 8)) + 6710656 * (e5 = e5 >> 16 & 65535), n7 += 8147497 * e5, e5 *= 2, 1e7 <= t6 && (n7 += Math.floor(t6 / 1e7), t6 %= 1e7), 1e7 <= n7 && (e5 += Math.floor(n7 / 1e7), n7 %= 1e7), n7 = e5 + tt(n7) + tt(t6));
  return n7;
}
function tt(t6) {
  return t6 = String(t6), "0000000".slice(t6.length) + t6;
}
function et3() {
  var t6 = K2, e5 = Y2;
  if (2147483648 & e5) if (H()) t6 = "" + (BigInt(0 | e5) << BigInt(32) | BigInt(t6 >>> 0));
  else {
    const [n7, r5] = rt2(t6, e5);
    t6 = "-" + Q2(n7, r5);
  }
  else t6 = Q2(t6, e5);
  return t6;
}
function nt(t6) {
  if (16 > t6.length) $2(Number(t6));
  else if (H()) t6 = BigInt(t6), K2 = Number(t6 & BigInt(4294967295)) >>> 0, Y2 = Number(t6 >> BigInt(32) & BigInt(4294967295));
  else {
    const e5 = +("-" === t6[0]);
    Y2 = K2 = 0;
    const n7 = t6.length;
    for (let r5 = e5, i4 = (n7 - e5) % 6 + e5; i4 <= n7; r5 = i4, i4 += 6) {
      const e6 = Number(t6.slice(r5, i4));
      Y2 *= 1e6, K2 = 1e6 * K2 + e6, 4294967296 <= K2 && (Y2 += Math.trunc(K2 / 4294967296), Y2 >>>= 0, K2 >>>= 0);
    }
    if (e5) {
      const [t7, e6] = rt2(K2, Y2);
      K2 = t7, Y2 = e6;
    }
  }
}
function rt2(t6, e5) {
  return e5 = ~e5, t6 ? t6 = 1 + ~t6 : e5 += 1, [t6, e5];
}
function it(t6, e5) {
  let n7, r5 = 0, i4 = 0, s3 = 0;
  const o5 = t6.h;
  let a4 = t6.g;
  do {
    n7 = o5[a4++], r5 |= (127 & n7) << s3, s3 += 7;
  } while (32 > s3 && 128 & n7);
  for (32 < s3 && (i4 |= (127 & n7) >> 4), s3 = 3; 32 > s3 && 128 & n7; s3 += 7) n7 = o5[a4++], i4 |= (127 & n7) << s3;
  if (dt(t6, a4), 128 > n7) return e5(r5 >>> 0, i4 >>> 0);
  throw j2();
}
function st2(t6) {
  let e5 = 0, n7 = t6.g;
  const r5 = n7 + 10, i4 = t6.h;
  for (; n7 < r5; ) {
    const r6 = i4[n7++];
    if (e5 |= r6, 0 == (128 & r6)) return dt(t6, n7), !!(127 & e5);
  }
  throw j2();
}
function ot(t6) {
  const e5 = t6.h;
  let n7 = t6.g, r5 = e5[n7++], i4 = 127 & r5;
  if (128 & r5 && (r5 = e5[n7++], i4 |= (127 & r5) << 7, 128 & r5 && (r5 = e5[n7++], i4 |= (127 & r5) << 14, 128 & r5 && (r5 = e5[n7++], i4 |= (127 & r5) << 21, 128 & r5 && (r5 = e5[n7++], i4 |= r5 << 28, 128 & r5 && 128 & e5[n7++] && 128 & e5[n7++] && 128 & e5[n7++] && 128 & e5[n7++] && 128 & e5[n7++]))))) throw j2();
  return dt(t6, n7), i4;
}
function at(t6) {
  return ot(t6) >>> 0;
}
function ht(t6) {
  var e5 = t6.h;
  const n7 = t6.g, r5 = e5[n7], i4 = e5[n7 + 1], s3 = e5[n7 + 2];
  return e5 = e5[n7 + 3], dt(t6, t6.g + 4), (r5 << 0 | i4 << 8 | s3 << 16 | e5 << 24) >>> 0;
}
function ct(t6) {
  var e5 = ht(t6);
  t6 = 2 * (e5 >> 31) + 1;
  const n7 = e5 >>> 23 & 255;
  return e5 &= 8388607, 255 == n7 ? e5 ? NaN : 1 / 0 * t6 : 0 == n7 ? t6 * Math.pow(2, -149) * e5 : t6 * Math.pow(2, n7 - 150) * (e5 + Math.pow(2, 23));
}
function ut(t6) {
  return ot(t6);
}
function lt2(t6, e5, { ca: n7 = false } = {}) {
  t6.ca = n7, e5 && (e5 = X(e5), t6.h = e5.buffer, t6.m = e5.P, t6.j = 0, t6.l = t6.h.length, t6.g = t6.j);
}
function dt(t6, e5) {
  if (t6.g = e5, e5 > t6.l) throw V2(t6.l, e5);
}
function ft(t6, e5) {
  if (0 > e5) throw Error(`Tried to read a negative byte length: ${e5}`);
  const n7 = t6.g, r5 = n7 + e5;
  if (r5 > t6.l) throw V2(e5, t6.l - n7);
  return t6.g = r5, n7;
}
function pt(t6, e5) {
  if (0 == e5) return D2();
  var n7 = ft(t6, e5);
  return t6.ca && t6.m ? n7 = t6.h.subarray(n7, n7 + e5) : (t6 = t6.h, n7 = n7 === (e5 = n7 + e5) ? C() : W ? t6.slice(n7, e5) : new Uint8Array(t6.subarray(n7, e5))), 0 == n7.length ? D2() : new B2(n7, O2);
}
var gt2 = [];
function mt2(t6) {
  var e5 = t6.g;
  if (e5.g == e5.l) return false;
  t6.l = t6.g.g;
  var n7 = at(t6.g);
  if (e5 = n7 >>> 3, !(0 <= (n7 &= 7) && 5 >= n7)) throw G2(n7, t6.l);
  if (1 > e5) throw Error(`Invalid field number: ${e5} (at position ${t6.l})`);
  return t6.m = e5, t6.h = n7, true;
}
function yt2(t6) {
  switch (t6.h) {
    case 0:
      0 != t6.h ? yt2(t6) : st2(t6.g);
      break;
    case 1:
      dt(t6 = t6.g, t6.g + 8);
      break;
    case 2:
      if (2 != t6.h) yt2(t6);
      else {
        var e5 = at(t6.g);
        dt(t6 = t6.g, t6.g + e5);
      }
      break;
    case 5:
      dt(t6 = t6.g, t6.g + 4);
      break;
    case 3:
      for (e5 = t6.m; ; ) {
        if (!mt2(t6)) throw Error("Unmatched start-group tag: stream EOF");
        if (4 == t6.h) {
          if (t6.m != e5) throw Error("Unmatched end-group tag");
          break;
        }
        yt2(t6);
      }
      break;
    default:
      throw G2(t6.h, t6.l);
  }
}
function _t2(t6, e5, n7) {
  const r5 = t6.g.l, i4 = at(t6.g), s3 = t6.g.g + i4;
  let o5 = s3 - r5;
  if (0 >= o5 && (t6.g.l = s3, n7(e5, t6, void 0, void 0, void 0), o5 = s3 - t6.g.g), o5) throw Error(`Message parsing ended unexpectedly. Expected to read ${i4} bytes, instead read ${i4 - o5} bytes, either the data ended unexpectedly or the message misreported its own length`);
  return t6.g.g = s3, t6.g.l = r5, e5;
}
function vt(t6) {
  var e5 = at(t6.g), a4 = ft(t6 = t6.g, e5);
  if (t6 = t6.h, o4) {
    var h5, c6 = t6;
    (h5 = s2) || (h5 = s2 = new TextDecoder("utf-8", { fatal: true })), e5 = a4 + e5, c6 = 0 === a4 && e5 === c6.length ? c6 : c6.subarray(a4, e5);
    try {
      var u3 = h5.decode(c6);
    } catch (t7) {
      if (void 0 === i3) {
        try {
          h5.decode(new Uint8Array([128]));
        } catch (t8) {
        }
        try {
          h5.decode(new Uint8Array([97])), i3 = true;
        } catch (t8) {
          i3 = false;
        }
      }
      throw !i3 && (s2 = void 0), t7;
    }
  } else {
    e5 = (u3 = a4) + e5, a4 = [];
    let i4, s3 = null;
    for (; u3 < e5; ) {
      var l3 = t6[u3++];
      128 > l3 ? a4.push(l3) : 224 > l3 ? u3 >= e5 ? n5() : (i4 = t6[u3++], 194 > l3 || 128 != (192 & i4) ? (u3--, n5()) : a4.push((31 & l3) << 6 | 63 & i4)) : 240 > l3 ? u3 >= e5 - 1 ? n5() : (i4 = t6[u3++], 128 != (192 & i4) || 224 === l3 && 160 > i4 || 237 === l3 && 160 <= i4 || 128 != (192 & (h5 = t6[u3++])) ? (u3--, n5()) : a4.push((15 & l3) << 12 | (63 & i4) << 6 | 63 & h5)) : 244 >= l3 ? u3 >= e5 - 2 ? n5() : (i4 = t6[u3++], 128 != (192 & i4) || 0 != i4 - 144 + (l3 << 28) >> 30 || 128 != (192 & (h5 = t6[u3++])) || 128 != (192 & (c6 = t6[u3++])) ? (u3--, n5()) : (l3 = (7 & l3) << 18 | (63 & i4) << 12 | (63 & h5) << 6 | 63 & c6, l3 -= 65536, a4.push(55296 + (l3 >> 10 & 1023), 56320 + (1023 & l3)))) : n5(), 8192 <= a4.length && (s3 = r4(s3, a4), a4.length = 0);
    }
    u3 = r4(s3, a4);
  }
  return u3;
}
function Et(t6) {
  const e5 = at(t6.g);
  return pt(t6.g, e5);
}
function wt2(t6, e5, n7) {
  var r5 = at(t6.g);
  for (r5 = t6.g.g + r5; t6.g.g < r5; ) n7.push(e5(t6.g));
}
var Tt = [];
function At(t6) {
  return t6 ? /^\d+$/.test(t6) ? (nt(t6), new bt2(K2, Y2)) : null : kt ||= new bt2(0, 0);
}
var bt2 = class {
  constructor(t6, e5) {
    this.h = t6 >>> 0, this.g = e5 >>> 0;
  }
};
var kt;
function xt(t6) {
  return t6 ? /^-?\d+$/.test(t6) ? (nt(t6), new St(K2, Y2)) : null : Lt ||= new St(0, 0);
}
var St = class {
  constructor(t6, e5) {
    this.h = t6 >>> 0, this.g = e5 >>> 0;
  }
};
var Lt;
function Ft(t6, e5, n7) {
  for (; 0 < n7 || 127 < e5; ) t6.g.push(127 & e5 | 128), e5 = (e5 >>> 7 | n7 << 25) >>> 0, n7 >>>= 7;
  t6.g.push(e5);
}
function Rt(t6, e5) {
  for (; 127 < e5; ) t6.g.push(127 & e5 | 128), e5 >>>= 7;
  t6.g.push(e5);
}
function Mt(t6, e5) {
  if (0 <= e5) Rt(t6, e5);
  else {
    for (let n7 = 0; 9 > n7; n7++) t6.g.push(127 & e5 | 128), e5 >>= 7;
    t6.g.push(1);
  }
}
function Pt(t6, e5) {
  t6.g.push(e5 >>> 0 & 255), t6.g.push(e5 >>> 8 & 255), t6.g.push(e5 >>> 16 & 255), t6.g.push(e5 >>> 24 & 255);
}
function Ct(t6, e5) {
  0 !== e5.length && (t6.l.push(e5), t6.h += e5.length);
}
function Ot(t6, e5, n7) {
  Rt(t6.g, 8 * e5 + n7);
}
function It(t6, e5) {
  return Ot(t6, e5, 2), e5 = t6.g.end(), Ct(t6, e5), e5.push(t6.h), e5;
}
function Ut(t6, e5) {
  var n7 = e5.pop();
  for (n7 = t6.h + t6.g.length() - n7; 127 < n7; ) e5.push(127 & n7 | 128), n7 >>>= 7, t6.h++;
  e5.push(n7), t6.h++;
}
function Dt(t6, e5, n7) {
  Ot(t6, e5, 2), Rt(t6.g, n7.length), Ct(t6, t6.g.end()), Ct(t6, n7);
}
function Nt(t6, e5, n7, r5) {
  null != n7 && (e5 = It(t6, e5), r5(n7, t6), Ut(t6, e5));
}
var Bt = class {
  constructor(t6, e5, n7, r5) {
    this.g = t6, this.h = e5, this.l = n7, this.pa = r5;
  }
};
function Gt(t6) {
  return Array.prototype.slice.call(t6);
}
function jt(t6) {
  return "function" == typeof Symbol && "symbol" == typeof Symbol() ? Symbol() : t6;
}
var Vt = jt();
var Xt = jt("0di");
var Ht = jt("2ex");
var Wt = jt("0dg");
var zt = Vt ? (t6, e5) => {
  t6[Vt] |= e5;
} : (t6, e5) => {
  void 0 !== t6.g ? t6.g |= e5 : Object.defineProperties(t6, { g: { value: e5, configurable: true, writable: true, enumerable: false } });
};
var Kt2 = Vt ? (t6, e5) => {
  t6[Vt] &= ~e5;
} : (t6, e5) => {
  void 0 !== t6.g && (t6.g &= ~e5);
};
function Yt(t6, e5, n7) {
  return n7 ? t6 | e5 : t6 & ~e5;
}
var $t2 = Vt ? (t6) => 0 | t6[Vt] : (t6) => 0 | t6.g;
var qt2 = Vt ? (t6) => t6[Vt] : (t6) => t6.g;
var Jt = Vt ? (t6, e5) => (t6[Vt] = e5, t6) : (t6, e5) => (void 0 !== t6.g ? t6.g = e5 : Object.defineProperties(t6, { g: { value: e5, configurable: true, writable: true, enumerable: false } }), t6);
function Zt2(t6) {
  return zt(t6, 34), t6;
}
function Qt(t6, e5) {
  Jt(e5, -14591 & (0 | t6));
}
function te(t6, e5) {
  Jt(e5, -14557 & (34 | t6));
}
function ee(t6) {
  return 0 === (t6 = t6 >> 14 & 1023) ? 536870912 : t6;
}
var ne;
var re = {};
var ie = {};
function se(t6) {
  return !(!t6 || "object" != typeof t6 || t6.Ja !== ie);
}
function oe(t6) {
  return null !== t6 && "object" == typeof t6 && !Array.isArray(t6) && t6.constructor === Object;
}
function ae(t6, e5, n7) {
  if (null != t6) {
    if ("string" == typeof t6) t6 = t6 ? new B2(t6, O2) : D2();
    else if (t6.constructor !== B2) if (M2(t6)) t6 = t6.length ? new B2(n7 ? t6 : new Uint8Array(t6), O2) : D2();
    else {
      if (!e5) throw Error();
      t6 = void 0;
    }
  }
  return t6;
}
function he(t6, e5, n7) {
  if (!Array.isArray(t6) || t6.length) return false;
  const r5 = $t2(t6);
  return !!(1 & r5) || !(!e5 || !(Array.isArray(e5) ? e5.includes(n7) : e5.has(n7))) && (Jt(t6, 1 | r5), true);
}
var ce = [];
function ue(t6) {
  if (2 & t6) throw Error();
}
Jt(ce, 55), ne = Object.freeze(ce);
var le = class _le {
  constructor(t6, e5, n7) {
    this.l = 0, this.g = t6, this.h = e5, this.m = n7;
  }
  next() {
    if (this.l < this.g.length) {
      const t6 = this.g[this.l++];
      return { done: false, value: this.h ? this.h.call(this.m, t6) : t6 };
    }
    return { done: true, value: void 0 };
  }
  [Symbol.iterator]() {
    return new _le(this.g, this.h, this.m);
  }
};
var de;
var fe;
var pe;
function ge(t6, e5) {
  (e5 = de ? e5[de] : void 0) && (t6[de] = Gt(e5));
}
function me(t6, e5) {
  t6.__closure__error__context__984382 || (t6.__closure__error__context__984382 = {}), t6.__closure__error__context__984382.severity = e5;
}
function ye() {
  const e5 = Error();
  me(e5, "incident"), function(e6) {
    t5.setTimeout(() => {
      throw e6;
    }, 0);
  }(e5);
}
function _e(t6) {
  return me(t6 = Error(t6), "warning"), t6;
}
function ve(t6) {
  return null == t6 || "number" == typeof t6 ? t6 : "NaN" === t6 || "Infinity" === t6 || "-Infinity" === t6 ? Number(t6) : void 0;
}
function Ee(t6) {
  return null == t6 || "boolean" == typeof t6 ? t6 : "number" == typeof t6 ? !!t6 : void 0;
}
Object.freeze(new class {
}()), Object.freeze(new class {
}());
var we = /^-?([1-9][0-9]*|0)(\.[0-9]+)?$/;
function Te(t6) {
  const e5 = typeof t6;
  return "number" === e5 ? Number.isFinite(t6) : "string" === e5 && we.test(t6);
}
function Ae(t6) {
  if (null == t6) return t6;
  if ("string" == typeof t6) {
    if (!t6) return;
    t6 = +t6;
  }
  return "number" == typeof t6 && Number.isFinite(t6) ? 0 | t6 : void 0;
}
function be(t6) {
  if (null == t6) return t6;
  if ("string" == typeof t6) {
    if (!t6) return;
    t6 = +t6;
  }
  return "number" == typeof t6 && Number.isFinite(t6) ? t6 >>> 0 : void 0;
}
function ke2(t6) {
  return "-" !== t6[0] && (20 > t6.length || 20 === t6.length && 184467 > Number(t6.substring(0, 6)));
}
function xe(t6) {
  return "-" === t6[0] ? 20 > t6.length || 20 === t6.length && -922337 < Number(t6.substring(0, 7)) : 19 > t6.length || 19 === t6.length && 922337 > Number(t6.substring(0, 6));
}
function Se2(t6) {
  return t6 = Math.trunc(t6), Number.isSafeInteger(t6) || ($2(t6), t6 = Z2(K2, Y2)), t6;
}
function Le(t6) {
  var e5 = Math.trunc(Number(t6));
  return Number.isSafeInteger(e5) ? String(e5) : (-1 !== (e5 = t6.indexOf(".")) && (t6 = t6.substring(0, e5)), xe(t6) || (nt(t6), t6 = et3()), t6);
}
function Fe(t6) {
  return null == t6 ? t6 : Te(t6) ? "number" == typeof t6 ? Se2(t6) : Le(t6) : void 0;
}
function Re2(t6) {
  if ("string" != typeof t6) throw Error();
  return t6;
}
function Me(t6) {
  if (null != t6 && "string" != typeof t6) throw Error();
  return t6;
}
function Pe(t6) {
  return null == t6 || "string" == typeof t6 ? t6 : void 0;
}
function Ce(t6, e5, n7, r5) {
  if (null != t6 && "object" == typeof t6 && t6.X === re) return t6;
  if (!Array.isArray(t6)) return n7 ? 2 & r5 ? (t6 = e5[Xt]) ? e5 = t6 : (Zt2((t6 = new e5()).s), e5 = e5[Xt] = t6) : e5 = new e5() : e5 = void 0, e5;
  let i4 = n7 = $t2(t6);
  return 0 === i4 && (i4 |= 32 & r5), i4 |= 2 & r5, i4 !== n7 && Jt(t6, i4), new e5(t6);
}
function Oe2(t6, e5, n7) {
  if (e5) {
    var r5 = !!r5;
    if (!Te(e5 = t6)) throw _e("int64");
    "string" == typeof e5 ? r5 = Le(e5) : r5 ? (r5 = Math.trunc(e5), Number.isSafeInteger(r5) ? r5 = String(r5) : xe(e5 = String(r5)) ? r5 = e5 : ($2(r5), r5 = et3())) : r5 = Se2(e5);
  } else r5 = Fe(t6);
  return "string" == typeof (n7 = null == (t6 = r5) ? n7 ? 0 : void 0 : t6) && (r5 = +n7, Number.isSafeInteger(r5)) ? r5 : n7;
}
var Ie;
var Ue;
var De;
function Ne(t6) {
  switch (typeof t6) {
    case "boolean":
      return Ue ||= [0, void 0, true];
    case "number":
      return 0 < t6 ? void 0 : 0 === t6 ? De ||= [0, void 0] : [-t6, void 0];
    case "string":
      return [0, t6];
    case "object":
      return t6;
  }
}
function Be(t6, e5) {
  return Ge(t6, e5[0], e5[1]);
}
function Ge(t6, e5, n7) {
  if (null == t6 && (t6 = Ie), Ie = void 0, null == t6) {
    var r5 = 96;
    n7 ? (t6 = [n7], r5 |= 512) : t6 = [], e5 && (r5 = -16760833 & r5 | (1023 & e5) << 14);
  } else {
    if (!Array.isArray(t6)) throw Error("narr");
    if (2048 & (r5 = $t2(t6))) throw Error("farr");
    if (64 & r5) return t6;
    if (r5 |= 64, n7 && (r5 |= 512, n7 !== t6[0])) throw Error("mid");
    t: {
      const i4 = (n7 = t6).length;
      if (i4) {
        const t7 = i4 - 1;
        if (oe(n7[t7])) {
          if (1024 <= (e5 = t7 - (+!!(512 & (r5 |= 256)) - 1))) throw Error("pvtlmt");
          r5 = -16760833 & r5 | (1023 & e5) << 14;
          break t;
        }
      }
      if (e5) {
        if (1024 < (e5 = Math.max(e5, i4 - (+!!(512 & r5) - 1)))) throw Error("spvt");
        r5 = -16760833 & r5 | (1023 & e5) << 14;
      }
    }
  }
  return Jt(t6, r5), t6;
}
var je = {};
var Ve = function() {
  try {
    return _2(new class extends Map {
      constructor() {
        super();
      }
    }()), false;
  } catch {
    return true;
  }
}();
var Xe = class {
  constructor() {
    this.g = /* @__PURE__ */ new Map();
  }
  get(t6) {
    return this.g.get(t6);
  }
  set(t6, e5) {
    return this.g.set(t6, e5), this.size = this.g.size, this;
  }
  delete(t6) {
    return t6 = this.g.delete(t6), this.size = this.g.size, t6;
  }
  clear() {
    this.g.clear(), this.size = this.g.size;
  }
  has(t6) {
    return this.g.has(t6);
  }
  entries() {
    return this.g.entries();
  }
  keys() {
    return this.g.keys();
  }
  values() {
    return this.g.values();
  }
  forEach(t6, e5) {
    return this.g.forEach(t6, e5);
  }
  [Symbol.iterator]() {
    return this.entries();
  }
};
var He = Ve ? (Object.setPrototypeOf(Xe.prototype, Map.prototype), Object.defineProperties(Xe.prototype, { size: { value: 0, configurable: true, enumerable: true, writable: true } }), Xe) : class extends Map {
  constructor() {
    super();
  }
};
function We(t6) {
  return t6;
}
function ze(t6) {
  if (2 & t6.N) throw Error("Cannot mutate an immutable Map");
}
var Ke = class extends He {
  constructor(t6, e5, n7 = We, r5 = We) {
    super();
    let i4 = $t2(t6);
    i4 |= 64, Jt(t6, i4), this.N = i4, this.U = e5, this.S = n7, this.Z = this.U ? Ye : r5;
    for (let s3 = 0; s3 < t6.length; s3++) {
      const o5 = t6[s3], a4 = n7(o5[0], false, true);
      let h5 = o5[1];
      e5 ? void 0 === h5 && (h5 = null) : h5 = r5(o5[1], false, true, void 0, void 0, i4), super.set(a4, h5);
    }
  }
  oa(t6 = $e) {
    if (0 !== this.size) return this.Y(t6);
  }
  Y(t6 = $e) {
    const e5 = [], n7 = super.entries();
    for (var r5; !(r5 = n7.next()).done; ) (r5 = r5.value)[0] = t6(r5[0]), r5[1] = t6(r5[1]), e5.push(r5);
    return e5;
  }
  clear() {
    ze(this), super.clear();
  }
  delete(t6) {
    return ze(this), super.delete(this.S(t6, true, false));
  }
  entries() {
    var t6 = this.na();
    return new le(t6, qe, this);
  }
  keys() {
    return this.Ia();
  }
  values() {
    var t6 = this.na();
    return new le(t6, Ke.prototype.get, this);
  }
  forEach(t6, e5) {
    super.forEach((n7, r5) => {
      t6.call(e5, this.get(r5), r5, this);
    });
  }
  set(t6, e5) {
    return ze(this), null == (t6 = this.S(t6, true, false)) ? this : null == e5 ? (super.delete(t6), this) : super.set(t6, this.Z(e5, true, true, this.U, false, this.N));
  }
  Oa(t6) {
    const e5 = this.S(t6[0], false, true);
    t6 = t6[1], t6 = this.U ? void 0 === t6 ? null : t6 : this.Z(t6, false, true, void 0, false, this.N), super.set(e5, t6);
  }
  has(t6) {
    return super.has(this.S(t6, false, false));
  }
  get(t6) {
    t6 = this.S(t6, false, false);
    const e5 = super.get(t6);
    if (void 0 !== e5) {
      var n7 = this.U;
      return n7 ? ((n7 = this.Z(e5, false, true, n7, this.ta, this.N)) !== e5 && super.set(t6, n7), n7) : e5;
    }
  }
  na() {
    return Array.from(super.keys());
  }
  Ia() {
    return super.keys();
  }
  [Symbol.iterator]() {
    return this.entries();
  }
};
function Ye(t6, e5, n7, r5, i4, s3) {
  return t6 = Ce(t6, r5, n7, s3), i4 && (t6 = an(t6)), t6;
}
function $e(t6) {
  return t6;
}
function qe(t6) {
  return [t6, this.get(t6)];
}
var Je;
function Ze() {
  return Je ||= new Ke(Zt2([]), void 0, void 0, void 0, je);
}
function Qe(t6, e5, n7, r5, i4) {
  if (null != t6) {
    if (Array.isArray(t6)) t6 = he(t6, void 0, 0) ? void 0 : i4 && 2 & $t2(t6) ? t6 : tn(t6, e5, n7, void 0 !== r5, i4);
    else if (oe(t6)) {
      const s3 = {};
      for (let o5 in t6) s3[o5] = Qe(t6[o5], e5, n7, r5, i4);
      t6 = s3;
    } else t6 = e5(t6, r5);
    return t6;
  }
}
function tn(t6, e5, n7, r5, i4) {
  const s3 = r5 || n7 ? $t2(t6) : 0;
  r5 = r5 ? !!(32 & s3) : void 0;
  const o5 = Gt(t6);
  for (let t7 = 0; t7 < o5.length; t7++) o5[t7] = Qe(o5[t7], e5, n7, r5, i4);
  return n7 && (ge(o5, t6), n7(s3, o5)), o5;
}
function en(t6) {
  return Qe(t6, nn, void 0, void 0, false);
}
function nn(t6) {
  return t6.X === re ? t6.toJSON() : t6 instanceof Ke ? t6.oa(en) : function(t7) {
    switch (typeof t7) {
      case "number":
        return isFinite(t7) ? t7 : String(t7);
      case "boolean":
        return t7 ? 1 : 0;
      case "object":
        if (t7) if (Array.isArray(t7)) {
          if (he(t7, void 0, 0)) return;
        } else {
          if (M2(t7)) return x2(t7);
          if (t7 instanceof B2) {
            const e5 = t7.g;
            return null == e5 ? "" : "string" == typeof e5 ? e5 : t7.g = x2(e5);
          }
          if (t7 instanceof Ke) return t7.oa();
        }
    }
    return t7;
  }(t6);
}
function rn(t6, e5, n7 = te) {
  if (null != t6) {
    if (b2 && t6 instanceof Uint8Array) return e5 ? t6 : new Uint8Array(t6);
    if (Array.isArray(t6)) {
      var r5 = $t2(t6);
      return 2 & r5 || (e5 &&= 0 === r5 || !!(32 & r5) && !(64 & r5 || !(16 & r5)), t6 = e5 ? Jt(t6, -12293 & (34 | r5)) : tn(t6, rn, 4 & r5 ? te : n7, true, true)), t6;
    }
    return t6.X === re ? (n7 = t6.s, t6 = 2 & (r5 = qt2(n7)) ? t6 : sn(t6, n7, r5, true)) : t6 instanceof Ke && !(2 & t6.N) && (n7 = Zt2(t6.Y(rn)), t6 = new Ke(n7, t6.U, t6.S, t6.Z)), t6;
  }
}
function sn(t6, e5, n7, r5) {
  return t6 = t6.constructor, Ie = e5 = on(e5, n7, r5), e5 = new t6(e5), Ie = void 0, e5;
}
function on(t6, e5, n7) {
  const r5 = n7 || 2 & e5 ? te : Qt, i4 = !!(32 & e5);
  return t6 = function(t7, e6, n8) {
    const r6 = Gt(t7);
    var i5 = r6.length;
    const s3 = 256 & e6 ? r6[i5 - 1] : void 0;
    for (i5 += s3 ? -1 : 0, e6 = 512 & e6 ? 1 : 0; e6 < i5; e6++) r6[e6] = n8(r6[e6]);
    if (s3) {
      e6 = r6[e6] = {};
      for (const t8 in s3) e6[t8] = n8(s3[t8]);
    }
    return ge(r6, t7), r6;
  }(t6, e5, (t7) => rn(t7, i4, r5)), zt(t6, 32 | (n7 ? 2 : 0)), t6;
}
function an(t6) {
  const e5 = t6.s, n7 = qt2(e5);
  return 2 & n7 ? sn(t6, e5, n7, false) : t6;
}
function hn(t6, e5, n7, r5) {
  return !(4 & e5) || null != n7 && (!r5 && 0 === n7 && (4096 & e5 || 8192 & e5) && 5 > (t6.constructor[Wt] = 1 + (0 | t6.constructor[Wt])) && ye(), 0 !== n7 && !(n7 & e5));
}
function cn(t6, e5) {
  return ln(t6 = t6.s, qt2(t6), e5);
}
function un(t6, e5, n7, r5) {
  if (!(0 > (e5 = r5 + (+!!(512 & e5) - 1)) || e5 >= t6.length || e5 >= n7)) return t6[e5];
}
function ln(t6, e5, n7, r5) {
  if (-1 === n7) return null;
  const i4 = ee(e5);
  if (!(n7 >= i4)) {
    var s3 = t6.length;
    return r5 && 256 & e5 && null != (r5 = t6[s3 - 1][n7]) ? (un(t6, e5, i4, n7) && null != Ht && (4 <= (e5 = (t6 = pe ??= {})[Ht] || 0) || (t6[Ht] = e5 + 1, ye())), r5) : un(t6, e5, i4, n7);
  }
  return 256 & e5 ? t6[t6.length - 1][n7] : void 0;
}
function dn(t6, e5, n7, r5) {
  const i4 = t6.s;
  let s3 = qt2(i4);
  return ue(s3), fn(i4, s3, e5, n7, r5), t6;
}
function fn(t6, e5, n7, r5, i4) {
  const s3 = ee(e5);
  if (n7 >= s3 || i4) {
    let o5 = e5;
    if (256 & e5) i4 = t6[t6.length - 1];
    else {
      if (null == r5) return o5;
      i4 = t6[s3 + (+!!(512 & e5) - 1)] = {}, o5 |= 256;
    }
    return i4[n7] = r5, n7 < s3 && (t6[n7 + (+!!(512 & e5) - 1)] = void 0), o5 !== e5 && Jt(t6, o5), o5;
  }
  return t6[n7 + (+!!(512 & e5) - 1)] = r5, 256 & e5 && (n7 in (t6 = t6[t6.length - 1]) && delete t6[n7]), e5;
}
function pn(t6, e5, n7, r5, i4) {
  var s3 = 2 & e5;
  let o5 = ln(t6, e5, n7, i4);
  Array.isArray(o5) || (o5 = ne);
  const a4 = !(2 & r5);
  r5 = !(1 & r5);
  const h5 = !!(32 & e5);
  let c6 = $t2(o5);
  return 0 !== c6 || !h5 || s3 || a4 ? 1 & c6 || (c6 |= 1, Jt(o5, c6)) : (c6 |= 33, Jt(o5, c6)), s3 ? (t6 = false, 2 & c6 || (Zt2(o5), t6 = !!(4 & c6)), (r5 || t6) && Object.freeze(o5)) : (s3 = !!(2 & c6) || !!(2048 & c6), r5 && s3 ? (o5 = Gt(o5), r5 = 1, h5 && !a4 && (r5 |= 32), Jt(o5, r5), fn(t6, e5, n7, o5, i4)) : a4 && 32 & c6 && !s3 && Kt2(o5, 32)), o5;
}
function gn(t6, e5) {
  t6 = t6.s;
  let n7 = qt2(t6);
  const r5 = ln(t6, n7, e5), i4 = ve(r5);
  return null != i4 && i4 !== r5 && fn(t6, n7, e5, i4), i4;
}
function mn(t6) {
  t6 = t6.s;
  let e5 = qt2(t6);
  const n7 = ln(t6, e5, 1), r5 = ae(n7, true, !!(34 & e5));
  return null != r5 && r5 !== n7 && fn(t6, e5, 1, r5), r5;
}
function yn(t6, e5, n7) {
  const r5 = t6.s;
  let i4 = qt2(r5);
  const s3 = 2 & i4 ? 1 : 2;
  let o5 = _n(r5, i4, e5);
  var a4 = $t2(o5);
  if (hn(t6, a4, void 0, false)) {
    (4 & a4 || Object.isFrozen(o5)) && (o5 = Gt(o5), a4 = In(a4, i4), i4 = fn(r5, i4, e5, o5));
    let s4 = t6 = 0;
    for (; t6 < o5.length; t6++) {
      const e6 = n7(o5[t6]);
      null != e6 && (o5[s4++] = e6);
    }
    s4 < t6 && (o5.length = s4), a4 = Yt(a4 = vn(a4, i4), 20, true), a4 = Yt(a4, 4096, false), a4 = Yt(a4, 8192, false), Jt(o5, a4), 2 & a4 && Object.freeze(o5);
  }
  return En(a4) || (n7 = a4, (a4 = (t6 = 1 === s3 || 4 === s3 && !!(32 & a4)) ? Yt(a4, 2, true) : Un(a4, i4, false)) !== n7 && Jt(o5, a4), t6 && Object.freeze(o5)), 2 === s3 && En(a4) && (o5 = Gt(o5), a4 = Un(a4 = In(a4, i4), i4, false), Jt(o5, a4), fn(r5, i4, e5, o5)), o5;
}
function _n(t6, e5, n7) {
  return t6 = ln(t6, e5, n7), Array.isArray(t6) ? t6 : ne;
}
function vn(t6, e5) {
  return 0 === t6 && (t6 = In(t6, e5)), Yt(t6, 1, true);
}
function En(t6) {
  return !!(2 & t6) && !!(4 & t6) || !!(2048 & t6);
}
function wn(t6) {
  t6 = Gt(t6);
  for (let e5 = 0; e5 < t6.length; e5++) {
    const n7 = t6[e5] = Gt(t6[e5]);
    Array.isArray(n7[1]) && (n7[1] = Zt2(n7[1]));
  }
  return t6;
}
function Tn(t6, e5, n7) {
  {
    const a4 = t6.s;
    let h5 = qt2(a4);
    if (ue(h5), null == n7) fn(a4, h5, e5);
    else {
      var r5, i4 = $t2(n7), s3 = i4, o5 = !!(2 & i4) || Object.isFrozen(n7);
      if ((r5 = !o5) && (r5 = false), hn(t6, i4)) for (i4 = 21, o5 && (n7 = Gt(n7), s3 = 0, i4 = Un(i4 = In(i4, h5), h5, true)), t6 = 0; t6 < n7.length; t6++) n7[t6] = Re2(n7[t6]);
      r5 && (n7 = Gt(n7), s3 = 0, i4 = Un(i4 = In(i4, h5), h5, true)), i4 !== s3 && Jt(n7, i4), fn(a4, h5, e5, n7);
    }
  }
}
function An(t6, e5, n7, r5) {
  t6 = t6.s;
  let i4 = qt2(t6);
  ue(i4), fn(t6, i4, e5, ("0" === r5 ? 0 === Number(n7) : n7 === r5) ? void 0 : n7);
}
function bn(t6, e5, n7, r5) {
  const i4 = qt2(t6);
  ue(i4), t6 = pn(t6, i4, e5, 2), r5 = n7(r5, !!(4 & (e5 = $t2(t6))) && !!(4096 & e5)), t6.push(r5);
}
function kn(t6) {
  return t6;
}
function xn(t6, e5) {
  return Sn(t6 = t6.s, qt2(t6), ws) === e5 ? e5 : -1;
}
function Sn(t6, e5, n7) {
  let r5 = 0;
  for (let i4 = 0; i4 < n7.length; i4++) {
    const s3 = n7[i4];
    null != ln(t6, e5, s3) && (0 !== r5 && (e5 = fn(t6, e5, r5)), r5 = s3);
  }
  return r5;
}
function Ln(t6, e5, n7, r5) {
  let i4 = qt2(t6);
  ue(i4);
  const s3 = ln(t6, i4, n7, r5);
  let o5;
  if (null != s3 && s3.X === re) return (e5 = an(s3)) !== s3 && fn(t6, i4, n7, e5, r5), e5.s;
  if (Array.isArray(s3)) {
    const t7 = $t2(s3);
    o5 = 2 & t7 ? on(s3, t7, false) : s3, o5 = Be(o5, e5);
  } else o5 = Be(void 0, e5);
  return o5 !== s3 && fn(t6, i4, n7, o5, r5), o5;
}
function Fn(t6, e5, n7, r5) {
  t6 = t6.s;
  let i4 = qt2(t6);
  const s3 = ln(t6, i4, n7, r5);
  return (e5 = Ce(s3, e5, false, i4)) !== s3 && null != e5 && fn(t6, i4, n7, e5, r5), e5;
}
function Rn(t6, e5, n7, r5 = false) {
  if (null == (e5 = Fn(t6, e5, n7, r5))) return e5;
  t6 = t6.s;
  let i4 = qt2(t6);
  if (!(2 & i4)) {
    const s3 = an(e5);
    s3 !== e5 && fn(t6, i4, n7, e5 = s3, r5);
  }
  return e5;
}
function Mn(t6, e5, n7, r5, i4, s3) {
  var o5 = 2, a4 = !!(2 & e5);
  o5 = a4 ? 1 : o5, i4 = !!i4, s3 &&= !a4, a4 = _n(t6, e5, r5);
  var h5 = $t2(a4);
  const c6 = !!(4 & h5);
  if (!c6) {
    var u3 = a4, l3 = e5;
    const t7 = !!(2 & (h5 = vn(h5, e5)));
    t7 && (l3 = Yt(l3, 2, true));
    let r6 = !t7, i5 = true, s4 = 0, o6 = 0;
    for (; s4 < u3.length; s4++) {
      const e6 = Ce(u3[s4], n7, false, l3);
      if (e6 instanceof n7) {
        if (!t7) {
          const t8 = !!(2 & $t2(e6.s));
          r6 &&= !t8, i5 &&= t8;
        }
        u3[o6++] = e6;
      }
    }
    o6 < s4 && (u3.length = o6), h5 = Yt(h5, 4, true), h5 = Yt(h5, 16, i5), h5 = Yt(h5, 8, r6), Jt(u3, h5), t7 && Object.freeze(u3);
  }
  if (s3 && !(8 & h5 || !a4.length && (1 === o5 || 4 === o5 && 32 & h5))) {
    for (En(h5) && (a4 = Gt(a4), h5 = In(h5, e5), e5 = fn(t6, e5, r5, a4)), n7 = a4, s3 = h5, u3 = 0; u3 < n7.length; u3++) (h5 = n7[u3]) !== (l3 = an(h5)) && (n7[u3] = l3);
    s3 = Yt(s3, 8, true), s3 = Yt(s3, 16, !n7.length), Jt(n7, s3), h5 = s3;
  }
  return En(h5) || (n7 = h5, (h5 = (s3 = 1 === o5 || 4 === o5 && !!(32 & h5)) ? Yt(h5, !a4.length || 16 & h5 && (!c6 || 32 & h5) ? 2 : 2048, true) : Un(h5, e5, i4)) !== n7 && Jt(a4, h5), s3 && Object.freeze(a4)), 2 === o5 && En(h5) && (a4 = Gt(a4), h5 = Un(h5 = In(h5, e5), e5, i4), Jt(a4, h5), fn(t6, e5, r5, a4)), a4;
}
function Pn(t6, e5, n7) {
  t6 = t6.s;
  const r5 = qt2(t6);
  return Mn(t6, r5, e5, n7, false, !(2 & r5));
}
function Cn(t6, e5, n7, r5, i4) {
  return null == r5 && (r5 = void 0), dn(t6, n7, r5, i4);
}
function On(t6, e5, n7, r5) {
  null == r5 && (r5 = void 0), t6 = t6.s;
  let i4 = qt2(t6);
  ue(i4), (n7 = Sn(t6, i4, n7)) && n7 !== e5 && null != r5 && (i4 = fn(t6, i4, n7)), fn(t6, i4, e5, r5);
}
function In(t6, e5) {
  return t6 = Yt(t6, 2, !!(2 & e5)), t6 = Yt(t6, 32, true), Yt(t6, 2048, false);
}
function Un(t6, e5, n7) {
  return 32 & e5 && n7 || (t6 = Yt(t6, 32, false)), t6;
}
function Dn(t6, e5, n7, r5) {
  t6 = t6.s;
  const i4 = qt2(t6);
  ue(i4), e5 = Mn(t6, i4, n7, e5, true), n7 = null != r5 ? r5 : new n7(), e5.push(n7), 2 & $t2(n7.s) ? Kt2(e5, 8) : Kt2(e5, 16);
}
function Nn(t6, e5) {
  return Ae(cn(t6, e5));
}
function Bn(t6, e5) {
  return t6 ?? e5;
}
function Gn(t6, e5) {
  return Bn(gn(t6, e5), 0);
}
function jn(t6, e5) {
  return Bn(Pe(cn(t6, e5)), "");
}
function Vn(t6, e5, n7) {
  if (null != n7 && "boolean" != typeof n7) throw t6 = typeof n7, Error(`Expected boolean but got ${"object" != t6 ? t6 : n7 ? Array.isArray(n7) ? "array" : t6 : "null"}: ${n7}`);
  dn(t6, e5, n7);
}
function Xn(t6, e5, n7) {
  if (null != n7) {
    if ("number" != typeof n7) throw _e("int32");
    if (!Number.isFinite(n7)) throw _e("int32");
    n7 |= 0;
  }
  dn(t6, e5, n7);
}
function Hn(t6, e5, n7) {
  if (null != n7 && "number" != typeof n7) throw Error(`Value of float/double field must be a number, found ${typeof n7}: ${n7}`);
  dn(t6, e5, n7);
}
function Wn(t6, e5, n7) {
  e5.g ? e5.m(t6, e5.g, e5.h, n7, true) : e5.m(t6, e5.h, n7, true);
}
Ke.prototype.toJSON = void 0, Ke.prototype.Ja = ie;
var zn = class {
  constructor(t6, e5) {
    this.s = Ge(t6, e5);
  }
  toJSON() {
    return Kn(this, tn(this.s, nn, void 0, void 0, false), true);
  }
  l() {
    var t6 = ko;
    return t6.g ? t6.l(this, t6.g, t6.h, true) : t6.l(this, t6.h, t6.defaultValue, true);
  }
  clone() {
    const t6 = this.s;
    return sn(this, t6, qt2(t6), false);
  }
  P() {
    return !!(2 & $t2(this.s));
  }
};
function Kn(t6, e5, n7) {
  var r5 = d2 ? void 0 : t6.constructor.B;
  const i4 = qt2(n7 ? t6.s : e5);
  if (!(t6 = e5.length)) return e5;
  let s3, o5;
  if (oe(n7 = e5[t6 - 1])) {
    t: {
      var a4 = n7;
      let t7 = {}, e6 = false;
      for (var h5 in a4) {
        let n8 = a4[h5];
        if (Array.isArray(n8)) {
          let t8 = n8;
          (he(n8, r5, +h5) || se(n8) && 0 === n8.size) && (n8 = null), n8 != t8 && (e6 = true);
        }
        null != n8 ? t7[h5] = n8 : e6 = true;
      }
      if (e6) {
        for (var c6 in t7) {
          a4 = t7;
          break t;
        }
        a4 = null;
      }
    }
    a4 != n7 && (s3 = true), t6--;
  }
  for (h5 = +!!(512 & i4) - 1; 0 < t6 && (n7 = e5[c6 = t6 - 1], c6 -= h5, null == n7 || he(n7, r5, c6) || se(n7) && 0 === n7.size); t6--) o5 = true;
  return s3 || o5 ? (e5 = Array.prototype.slice.call(e5, 0, t6), a4 && e5.push(a4), e5) : e5;
}
function Yn(t6) {
  return Array.isArray(t6) ? t6[0] instanceof Bt ? t6 : [$r, t6] : [t6, void 0];
}
function $n(t6, e5) {
  if (Array.isArray(e5)) {
    var n7 = $t2(e5);
    if (4 & n7) return e5;
    for (var r5 = 0, i4 = 0; r5 < e5.length; r5++) {
      const n8 = t6(e5[r5]);
      null != n8 && (e5[i4++] = n8);
    }
    return i4 < r5 && (e5.length = i4), Jt(e5, -12289 & (5 | n7)), 2 & n7 && Object.freeze(e5), e5;
  }
}
zn.prototype.X = re, zn.prototype.toString = function() {
  return Kn(this, this.s, false).toString();
};
var qn = Symbol();
function Jn(t6) {
  let e5 = t6[qn];
  if (!e5) {
    const n7 = sr(t6), r5 = yr(t6), i4 = r5.l;
    e5 = i4 ? (t7, e6) => i4(t7, e6, r5) : (t7, e6) => {
      for (; mt2(e6) && 4 != e6.h; ) {
        var i5 = e6.m, s3 = r5[i5];
        if (!s3) {
          var o5 = r5.ea;
          o5 && (o5 = o5[i5]) && (s3 = r5[i5] = Zn(o5));
        }
        s3 && s3(e6, t7, i5) || (i5 = (s3 = e6).l, yt2(s3), s3.ia ? s3 = void 0 : (o5 = s3.g.g - i5, s3.g.g = i5, s3 = pt(s3.g, o5)), i5 = t7, s3 && (de ||= Symbol(), (o5 = i5[de]) ? o5.push(s3) : i5[de] = [s3]));
      }
      n7 === tr || n7 === er || n7.j || (t7[fe ||= Symbol()] = n7);
    }, t6[qn] = e5;
  }
  return e5;
}
function Zn(t6) {
  const e5 = (t6 = Yn(t6))[0].g;
  if (t6 = t6[1]) {
    const n7 = Jn(t6), r5 = yr(t6).T;
    return (t7, i4, s3) => e5(t7, i4, s3, r5, n7);
  }
  return e5;
}
var Qn = class {
};
var tr;
var er;
var nr = Symbol();
function rr(t6, e5, n7) {
  const r5 = n7[1];
  let i4;
  if (r5) {
    const n8 = r5[nr];
    i4 = n8 ? n8.T : Ne(r5[0]), t6[e5] = n8 ?? r5;
  }
  i4 && i4 === Ue ? (t6.g || (t6.g = /* @__PURE__ */ new Set())).add(e5) : n7[0] && (t6.h || (t6.h = /* @__PURE__ */ new Set())).add(e5);
}
function ir(t6, e5) {
  return [t6.l, !e5 || 0 < e5[0] ? void 0 : e5];
}
function sr(t6) {
  var e5 = t6[nr];
  if (e5) return e5;
  if (!(e5 = ar(t6, t6[nr] = new Qn(), ir, ir, rr)).ea && !e5.h && !e5.g) {
    let n7 = true;
    for (let t7 in e5) isNaN(t7) || (n7 = false);
    n7 ? (Ne(t6[0]) === Ue ? er ? e5 = er : ((e5 = new Qn()).T = Ne(true), e5 = er = e5) : e5 = tr ||= new Qn(), e5 = t6[nr] = e5) : e5.j = true;
  }
  return e5;
}
function or(t6, e5, n7) {
  t6[e5] = n7;
}
function ar(t6, e5, n7, r5, i4 = or) {
  e5.T = Ne(t6[0]);
  let s3 = 0;
  var o5 = t6[++s3];
  o5 && o5.constructor === Object && (e5.ea = o5, "function" == typeof (o5 = t6[++s3]) && (e5.l = o5, e5.m = t6[++s3], o5 = t6[++s3]));
  const a4 = {};
  for (; Array.isArray(o5) && "number" == typeof o5[0] && 0 < o5[0]; ) {
    for (var h5 = 0; h5 < o5.length; h5++) a4[o5[h5]] = o5;
    o5 = t6[++s3];
  }
  for (h5 = 1; void 0 !== o5; ) {
    let l3;
    "number" == typeof o5 && (h5 += o5, o5 = t6[++s3]);
    var c6 = void 0;
    if (o5 instanceof Bt ? l3 = o5 : (l3 = qr, s3--), l3.pa) {
      o5 = t6[++s3], c6 = t6;
      var u3 = s3;
      "function" == typeof o5 && (o5 = o5(), c6[u3] = o5), c6 = o5;
    }
    for (u3 = h5 + 1, "number" == typeof (o5 = t6[++s3]) && 0 > o5 && (u3 -= o5, o5 = t6[++s3]); h5 < u3; h5++) {
      const t7 = a4[h5];
      i4(e5, h5, c6 ? r5(l3, c6, t7) : n7(l3, t7));
    }
  }
  return e5;
}
var hr = Symbol();
function cr(t6) {
  let e5 = t6[hr];
  if (!e5) {
    const n7 = fr(t6);
    e5 = (t7, e6) => Er(t7, e6, n7), t6[hr] = e5;
  }
  return e5;
}
var ur = Symbol();
function lr(t6) {
  return t6.h;
}
function dr(t6, e5) {
  let n7, r5;
  const i4 = t6.h;
  return (t7, s3, o5) => i4(t7, s3, o5, r5 ||= fr(e5).T, n7 ||= cr(e5));
}
function fr(t6) {
  let e5 = t6[ur];
  return e5 || (e5 = ar(t6, t6[ur] = {}, lr, dr), _r(t6), e5);
}
var pr = Symbol();
function gr(t6, e5) {
  const n7 = t6.g;
  return e5 ? (t7, r5, i4) => n7(t7, r5, i4, e5) : n7;
}
function mr(t6, e5, n7) {
  const r5 = t6.g;
  let i4, s3;
  return (t7, o5, a4) => r5(t7, o5, a4, s3 ||= yr(e5).T, i4 ||= Jn(e5), n7);
}
function yr(t6) {
  let e5 = t6[pr];
  return e5 || (sr(t6), e5 = ar(t6, t6[pr] = {}, gr, mr), _r(t6), e5);
}
function _r(t6) {
  pr in t6 && nr in t6 && ur in t6 && (t6.length = 0);
}
function vr(t6, e5) {
  var n7 = t6[e5];
  if (n7) return n7;
  if ((n7 = t6.ea) && (n7 = n7[e5])) {
    var r5 = (n7 = Yn(n7))[0].h;
    if (n7 = n7[1]) {
      const e6 = cr(n7), i4 = fr(n7).T;
      n7 = (n7 = t6.m) ? n7(i4, e6) : (t7, n8, s3) => r5(t7, n8, s3, i4, e6);
    } else n7 = r5;
    return t6[e5] = n7;
  }
}
function Er(t6, e5, n7) {
  for (var r5 = qt2(t6), i4 = +!!(512 & r5) - 1, s3 = t6.length, o5 = 512 & r5 ? 1 : 0, a4 = s3 + (256 & r5 ? -1 : 0); o5 < a4; o5++) {
    const r6 = t6[o5];
    if (null == r6) continue;
    const s4 = o5 - i4, a5 = vr(n7, s4);
    a5 && a5(e5, r6, s4);
  }
  if (256 & r5) {
    r5 = t6[s3 - 1];
    for (let t7 in r5) i4 = +t7, Number.isNaN(i4) || null != (s3 = r5[t7]) && (a4 = vr(n7, i4)) && a4(e5, s3, i4);
  }
  if (t6 = de ? t6[de] : void 0) for (Ct(e5, e5.g.end()), n7 = 0; n7 < t6.length; n7++) Ct(e5, N2(t6[n7]) || C());
}
function wr(t6, e5) {
  return new Bt(t6, e5, false, false);
}
function Tr(t6, e5) {
  return new Bt(t6, e5, true, false);
}
function Ar(t6, e5) {
  return new Bt(t6, e5, false, true);
}
function br(t6, e5, n7) {
  fn(t6, qt2(t6), e5, n7);
}
var kr = Ar(function(t6, e5, n7, r5, i4) {
  return 2 === t6.h && (t6 = _t2(t6, Be([void 0, void 0], r5), i4), ue(r5 = qt2(e5)), (i4 = ln(e5, r5, n7)) instanceof Ke ? 0 != (2 & i4.N) ? ((i4 = i4.Y()).push(t6), fn(e5, r5, n7, i4)) : i4.Oa(t6) : Array.isArray(i4) ? (2 & $t2(i4) && fn(e5, r5, n7, i4 = wn(i4)), i4.push(t6)) : fn(e5, r5, n7, [t6]), true);
}, function(t6, e5, n7, r5, i4) {
  if (e5 instanceof Ke) e5.forEach((e6, s3) => {
    Nt(t6, n7, Be([s3, e6], r5), i4);
  });
  else if (Array.isArray(e5)) for (let s3 = 0; s3 < e5.length; s3++) {
    const o5 = e5[s3];
    Array.isArray(o5) && Nt(t6, n7, Be(o5, r5), i4);
  }
});
function xr(t6, e5, n7) {
  t: if (null != e5) {
    if (Te(e5)) {
      if ("string" == typeof e5) {
        e5 = Le(e5);
        break t;
      }
      if ("number" == typeof e5) {
        e5 = Se2(e5);
        break t;
      }
    }
    e5 = void 0;
  }
  null != e5 && ("string" == typeof e5 && xt(e5), null != e5 && (Ot(t6, n7, 0), "number" == typeof e5 ? (t6 = t6.g, $2(e5), Ft(t6, K2, Y2)) : (n7 = xt(e5), Ft(t6.g, n7.h, n7.g))));
}
function Sr(t6, e5, n7) {
  null != (e5 = Ae(e5)) && null != e5 && (Ot(t6, n7, 0), Mt(t6.g, e5));
}
function Lr(t6, e5, n7) {
  null != (e5 = Ee(e5)) && (Ot(t6, n7, 0), t6.g.g.push(e5 ? 1 : 0));
}
function Fr(t6, e5, n7) {
  null != (e5 = Pe(e5)) && Dt(t6, n7, c4(e5));
}
function Rr(t6, e5, n7, r5, i4) {
  Nt(t6, n7, e5 instanceof zn ? e5.s : Array.isArray(e5) ? Be(e5, r5) : void 0, i4);
}
function Mr(t6, e5, n7) {
  null != (e5 = null == e5 || "string" == typeof e5 || M2(e5) || e5 instanceof B2 ? e5 : void 0) && Dt(t6, n7, X(e5).buffer);
}
function Pr(t6, e5, n7) {
  return (5 === t6.h || 2 === t6.h) && (e5 = pn(e5, qt2(e5), n7, 2, false), 2 == t6.h ? wt2(t6, ct, e5) : e5.push(ct(t6.g)), true);
}
var Cr;
var Or = wr(function(t6, e5, n7) {
  if (1 !== t6.h) return false;
  var r5 = t6.g;
  t6 = ht(r5);
  const i4 = ht(r5);
  r5 = 2 * (i4 >> 31) + 1;
  const s3 = i4 >>> 20 & 2047;
  return t6 = 4294967296 * (1048575 & i4) + t6, br(e5, n7, 2047 == s3 ? t6 ? NaN : 1 / 0 * r5 : 0 == s3 ? r5 * Math.pow(2, -1074) * t6 : r5 * Math.pow(2, s3 - 1075) * (t6 + 4503599627370496)), true;
}, function(t6, e5, n7) {
  null != (e5 = ve(e5)) && (Ot(t6, n7, 1), t6 = t6.g, (n7 = z2 ||= new DataView(new ArrayBuffer(8))).setFloat64(0, +e5, true), K2 = n7.getUint32(0, true), Y2 = n7.getUint32(4, true), Pt(t6, K2), Pt(t6, Y2));
});
var Ir = wr(function(t6, e5, n7) {
  return 5 === t6.h && (br(e5, n7, ct(t6.g)), true);
}, function(t6, e5, n7) {
  null != (e5 = ve(e5)) && (Ot(t6, n7, 5), t6 = t6.g, q2(e5), Pt(t6, K2));
});
var Ur = Tr(Pr, function(t6, e5, n7) {
  if (null != (e5 = $n(ve, e5))) for (let o5 = 0; o5 < e5.length; o5++) {
    var r5 = t6, i4 = n7, s3 = e5[o5];
    null != s3 && (Ot(r5, i4, 5), r5 = r5.g, q2(s3), Pt(r5, K2));
  }
});
var Dr = Tr(Pr, function(t6, e5, n7) {
  if (null != (e5 = $n(ve, e5)) && e5.length) {
    Ot(t6, n7, 2), Rt(t6.g, 4 * e5.length);
    for (let r5 = 0; r5 < e5.length; r5++) n7 = t6.g, q2(e5[r5]), Pt(n7, K2);
  }
});
var Nr = wr(function(t6, e5, n7) {
  return 0 === t6.h && (br(e5, n7, it(t6.g, Z2)), true);
}, xr);
var Br = wr(function(t6, e5, n7) {
  return 0 === t6.h && (br(e5, n7, 0 === (t6 = it(t6.g, Z2)) ? void 0 : t6), true);
}, xr);
var Gr = wr(function(t6, e5, n7) {
  return 0 === t6.h && (br(e5, n7, it(t6.g, J)), true);
}, function(t6, e5, n7) {
  t: if (null != e5) {
    if (Te(e5)) {
      if ("string" == typeof e5) {
        var r5 = Math.trunc(Number(e5));
        Number.isSafeInteger(r5) && 0 <= r5 ? e5 = String(r5) : (-1 !== (r5 = e5.indexOf(".")) && (e5 = e5.substring(0, r5)), ke2(e5) || (nt(e5), e5 = Q2(K2, Y2)));
        break t;
      }
      if ("number" == typeof e5) {
        e5 = 0 <= (e5 = Math.trunc(e5)) && Number.isSafeInteger(e5) ? e5 : function(t7) {
          if (0 > t7) {
            $2(t7);
            const e6 = Q2(K2, Y2);
            return t7 = Number(e6), Number.isSafeInteger(t7) ? t7 : e6;
          }
          return ke2(String(t7)) ? t7 : ($2(t7), J(K2, Y2));
        }(e5);
        break t;
      }
    }
    e5 = void 0;
  }
  null != e5 && ("string" == typeof e5 && At(e5), null != e5 && (Ot(t6, n7, 0), "number" == typeof e5 ? (t6 = t6.g, $2(e5), Ft(t6, K2, Y2)) : (n7 = At(e5), Ft(t6.g, n7.h, n7.g))));
});
var jr = wr(function(t6, e5, n7) {
  return 0 === t6.h && (br(e5, n7, ot(t6.g)), true);
}, Sr);
var Vr = Tr(function(t6, e5, n7) {
  return (0 === t6.h || 2 === t6.h) && (e5 = pn(e5, qt2(e5), n7, 2, false), 2 == t6.h ? wt2(t6, ot, e5) : e5.push(ot(t6.g)), true);
}, function(t6, e5, n7) {
  if (null != (e5 = $n(Ae, e5)) && e5.length) {
    n7 = It(t6, n7);
    for (let n8 = 0; n8 < e5.length; n8++) Mt(t6.g, e5[n8]);
    Ut(t6, n7);
  }
});
var Xr = wr(function(t6, e5, n7) {
  return 0 === t6.h && (br(e5, n7, 0 === (t6 = ot(t6.g)) ? void 0 : t6), true);
}, Sr);
var Hr = wr(function(t6, e5, n7) {
  return 0 === t6.h && (br(e5, n7, st2(t6.g)), true);
}, Lr);
var Wr = wr(function(t6, e5, n7) {
  return 0 === t6.h && (br(e5, n7, false === (t6 = st2(t6.g)) ? void 0 : t6), true);
}, Lr);
var zr = Tr(function(t6, e5, n7) {
  return 2 === t6.h && (bn(e5, n7, kn, t6 = vt(t6)), true);
}, function(t6, e5, n7) {
  if (null != (e5 = $n(Pe, e5))) for (let o5 = 0; o5 < e5.length; o5++) {
    var r5 = t6, i4 = n7, s3 = e5[o5];
    null != s3 && Dt(r5, i4, c4(s3));
  }
});
var Kr = wr(function(t6, e5, n7) {
  return 2 === t6.h && (br(e5, n7, "" === (t6 = vt(t6)) ? void 0 : t6), true);
}, Fr);
var Yr = wr(function(t6, e5, n7) {
  return 2 === t6.h && (br(e5, n7, vt(t6)), true);
}, Fr);
var $r = Ar(function(t6, e5, n7, r5, i4) {
  return 2 === t6.h && (_t2(t6, Ln(e5, r5, n7, true), i4), true);
}, Rr);
var qr = Ar(function(t6, e5, n7, r5, i4) {
  return 2 === t6.h && (_t2(t6, Ln(e5, r5, n7), i4), true);
}, Rr);
Cr = new Bt(function(t6, e5, n7, r5, i4) {
  if (2 !== t6.h) return false;
  r5 = Be(void 0, r5);
  let s3 = qt2(e5);
  ue(s3);
  let o5 = pn(e5, s3, n7, 3);
  return s3 = qt2(e5), 4 & $t2(o5) && (o5 = Gt(o5), Jt(o5, -2079 & (1 | $t2(o5))), fn(e5, s3, n7, o5)), o5.push(r5), _t2(t6, r5, i4), true;
}, function(t6, e5, n7, r5, i4) {
  if (Array.isArray(e5)) for (let s3 = 0; s3 < e5.length; s3++) Rr(t6, e5[s3], n7, r5, i4);
}, true, true);
var Jr = Ar(function(t6, e5, n7, r5, i4, s3) {
  if (2 !== t6.h) return false;
  let o5 = qt2(e5);
  return ue(o5), (s3 = Sn(e5, o5, s3)) && n7 !== s3 && fn(e5, o5, s3), _t2(t6, e5 = Ln(e5, r5, n7), i4), true;
}, Rr);
var Zr = wr(function(t6, e5, n7) {
  return 2 === t6.h && (br(e5, n7, Et(t6)), true);
}, Mr);
var Qr = Tr(function(t6, e5, n7) {
  return (0 === t6.h || 2 === t6.h) && (e5 = pn(e5, qt2(e5), n7, 2, false), 2 == t6.h ? wt2(t6, at, e5) : e5.push(at(t6.g)), true);
}, function(t6, e5, n7) {
  if (null != (e5 = $n(be, e5))) for (let o5 = 0; o5 < e5.length; o5++) {
    var r5 = t6, i4 = n7, s3 = e5[o5];
    null != s3 && (Ot(r5, i4, 0), Rt(r5.g, s3));
  }
});
var ti = wr(function(t6, e5, n7) {
  return 0 === t6.h && (br(e5, n7, ot(t6.g)), true);
}, function(t6, e5, n7) {
  null != (e5 = Ae(e5)) && (e5 = parseInt(e5, 10), Ot(t6, n7, 0), Mt(t6.g, e5));
});
var ei = Tr(function(t6, e5, n7) {
  return (0 === t6.h || 2 === t6.h) && (e5 = pn(e5, qt2(e5), n7, 2, false), 2 == t6.h ? wt2(t6, ut, e5) : e5.push(ot(t6.g)), true);
}, function(t6, e5, n7) {
  if (null != (e5 = $n(Ae, e5)) && e5.length) {
    n7 = It(t6, n7);
    for (let n8 = 0; n8 < e5.length; n8++) Mt(t6.g, e5[n8]);
    Ut(t6, n7);
  }
});
var ni = class {
  constructor(t6, e5) {
    this.h = t6, this.g = e5, this.l = Rn, this.m = Cn, this.defaultValue = void 0;
  }
};
function ri(t6, e5) {
  return new ni(t6, e5);
}
function ii2(t6, e5) {
  return (n7, r5) => {
    if (Tt.length) {
      const t7 = Tt.pop();
      t7.o(r5), lt2(t7.g, n7, r5), n7 = t7;
    } else n7 = new class {
      constructor(t7, e6) {
        if (gt2.length) {
          const n8 = gt2.pop();
          lt2(n8, t7, e6), t7 = n8;
        } else t7 = new class {
          constructor(t8, e7) {
            this.h = null, this.m = false, this.g = this.l = this.j = 0, lt2(this, t8, e7);
          }
          clear() {
            this.h = null, this.m = false, this.g = this.l = this.j = 0, this.ca = false;
          }
        }(t7, e6);
        this.g = t7, this.l = this.g.g, this.h = this.m = -1, this.o(e6);
      }
      o({ ia: t7 = false } = {}) {
        this.ia = t7;
      }
    }(n7, r5);
    try {
      const r6 = new t6(), s3 = r6.s;
      Jn(e5)(s3, n7);
      var i4 = r6;
    } finally {
      n7.g.clear(), n7.m = -1, n7.h = -1, 100 > Tt.length && Tt.push(n7);
    }
    return i4;
  };
}
function si2(t6) {
  return function() {
    const e5 = new class {
      constructor() {
        this.l = [], this.h = 0, this.g = new class {
          constructor() {
            this.g = [];
          }
          length() {
            return this.g.length;
          }
          end() {
            const t7 = this.g;
            return this.g = [], t7;
          }
        }();
      }
    }();
    Er(this.s, e5, fr(t6)), Ct(e5, e5.g.end());
    const n7 = new Uint8Array(e5.h), r5 = e5.l, i4 = r5.length;
    let s3 = 0;
    for (let t7 = 0; t7 < i4; t7++) {
      const e6 = r5[t7];
      n7.set(e6, s3), s3 += e6.length;
    }
    return e5.l = [n7], n7;
  };
}
var oi = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var ai = [0, Kr, wr(function(t6, e5, n7) {
  return 2 === t6.h && (br(e5, n7, (t6 = Et(t6)) === D2() ? void 0 : t6), true);
}, function(t6, e5, n7) {
  if (null != e5) {
    if (e5 instanceof zn) {
      const r5 = e5.Qa;
      return void (r5 && (e5 = r5(e5), null != e5 && Dt(t6, n7, X(e5).buffer)));
    }
    if (Array.isArray(e5)) return;
  }
  Mr(t6, e5, n7);
})];
var hi = [0, Yr];
var ci = [0, jr, ti, Hr, -1, Vr, ti, -1];
var ui = [0, Hr, -1];
var li = class extends zn {
  constructor() {
    super();
  }
};
li.B = [6];
var di = [0, Hr, Yr, Hr, ti, -1, ei, Yr, -1, ui, ti];
var fi = [0, Yr, -2];
var pi = class extends zn {
  constructor() {
    super();
  }
};
var gi = [0];
var mi = [0, jr, Hr, -4];
var yi = class extends zn {
  constructor(t6) {
    super(t6, 2);
  }
};
var _i = {};
var vi = [-2, _i, Hr];
_i[336783863] = [0, Yr, Hr, -1, jr, [0, [1, 2, 3, 4, 5, 6], Jr, gi, Jr, di, Jr, fi, Jr, mi, Jr, ci, Jr, [0, Yr]], hi, Hr, [0, [1, 3], [2, 4], Jr, [0, Vr], -1, Jr, [0, zr], -1, Cr, [0, Yr, -1]], Yr];
var Ei = [0, Kr, Wr];
var wi = [0, Br, -1, Wr, -3, Br, Vr, Kr, Xr, Br, -1, Wr, Xr, Wr, -2, Kr];
var Ti = [-1, {}];
var Ai = [0, Yr, 1, Ti];
var bi = [0, Yr, zr, Ti];
function ki(t6, e5) {
  An(t6, 2, Me(e5), "");
}
function xi(t6, e5) {
  bn(t6.s, 3, Re2, e5);
}
function Si(t6, e5) {
  bn(t6.s, 4, Re2, e5);
}
var Li = class extends zn {
  constructor(t6) {
    super(t6, 500);
  }
  o(t6) {
    return Cn(this, 0, 7, t6);
  }
};
Li.B = [3, 4, 5, 6, 8, 13, 17, 1005];
var Fi = [-500, Kr, -1, zr, -3, vi, Cr, ai, Xr, -1, Ai, bi, Cr, Ei, Kr, wi, Xr, zr, 987, zr];
var Ri = [0, Kr, -1, Ti];
var Mi = [-500, Yr, -1, [-1, {}], 998, Yr];
var Pi = [-500, Yr, zr, -1, [-2, {}, Hr], 997, zr, -1];
var Ci = [-500, Yr, zr, Ti, 998, zr];
function Oi(t6, e5) {
  Dn(t6, 1, Li, e5);
}
function Ii(t6, e5) {
  bn(t6.s, 10, Re2, e5);
}
function Ui(t6, e5) {
  bn(t6.s, 15, Re2, e5);
}
var Di = class extends zn {
  constructor(t6) {
    super(t6, 500);
  }
  o(t6) {
    return Cn(this, 0, 1001, t6);
  }
};
Di.B = [1, 6, 7, 9, 10, 15, 16, 17, 14, 1002];
var Ni = [-500, Cr, Fi, 4, Cr, Mi, Cr, Pi, Xr, Cr, Ci, zr, Xr, Ai, bi, Cr, Ri, zr, -2, wi, Kr, -1, Wr, 979, Ti, Cr, ai];
var Bi = ii2(Di, Ni);
Di.prototype.g = si2(Ni);
var Gi = [0, Cr, [0, jr, -2]];
var ji = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Vi = [0, jr, Ir, Yr, -1];
var Xi = class extends zn {
  constructor(t6) {
    super(t6);
  }
  g() {
    return Pn(this, ji, 1);
  }
};
Xi.B = [1];
var Hi = [0, Cr, Vi];
var Wi = ii2(Xi, Hi);
var zi = [0, jr, Ir];
var Ki = [0, jr, -1, Gi];
var Yi = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var $i = [0, jr, -3];
var qi = [0, Ir, -3];
var Ji = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Zi = [0, Ir, -1, Yr, Ir];
var Qi = class extends zn {
  constructor(t6) {
    super(t6);
  }
  h() {
    return Rn(this, Yi, 2);
  }
  g() {
    return Pn(this, Ji, 5);
  }
};
Qi.B = [5];
var ts = [0, ti, $i, qi, Ki, Cr, Zi];
var es = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
es.B = [1, 2, 3, 8, 9];
var ns = ii2(es, [0, zr, Vr, Dr, ts, Yr, -1, Nr, Cr, zi, zr, Nr]);
var rs = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var is = [0, Ir, -4];
var ss = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
ss.B = [1];
var os = ii2(ss, [0, Cr, is]);
var as = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var hs = [0, Ir, -4];
var cs = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
cs.B = [1];
var us = ii2(cs, [0, Cr, hs]);
var ls = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
ls.B = [3];
var ds = [0, jr, -1, Dr, ti];
var fs = class extends zn {
  constructor() {
    super();
  }
};
fs.prototype.g = si2([0, Ir, -4, Nr]);
var ps = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var gs = [0, 1, jr, Yr, Hi];
var ms = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
ms.B = [1];
var ys = ii2(ms, [0, Cr, gs, Nr]);
var _s = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
_s.B = [1];
var vs = class extends zn {
  constructor(t6) {
    super(t6);
  }
  qa() {
    const t6 = mn(this);
    return null == t6 ? D2() : t6;
  }
};
var Es = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var ws = [1, 2];
var Ts = [0, ws, Jr, [0, Dr], Jr, [0, Zr], jr, Yr];
var As = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
As.B = [1];
var bs = ii2(As, [0, Cr, Ts, Nr]);
var ks = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
ks.B = [4, 5];
var xs = [0, Yr, jr, Ir, zr, -1];
var Ss = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Ls = [0, Hr, -1];
var Fs = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Rs = [1, 2, 3, 4, 5];
var Ms = class extends zn {
  constructor(t6) {
    super(t6);
  }
  g() {
    return null != mn(this);
  }
  h() {
    return null != Pe(cn(this, 2));
  }
};
var Ps = [0, Zr, Yr, [0, jr, Nr, -1], [0, Gr, Nr]];
var Cs = class extends zn {
  constructor(t6) {
    super(t6);
  }
  g() {
    return Ee(cn(this, 2)) ?? false;
  }
};
var Os = [0, Ps, Hr, [0, Rs, Jr, mi, Jr, di, Jr, ci, Jr, gi, Jr, fi], ti];
var Is = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Us = [0, Os, Ir, -1, jr];
var Ds = ri(502141897, Is);
_i[502141897] = Us;
var Ns = [0, Ps];
_i[512499200] = Ns;
var Bs = [0, Ns];
_i[515723506] = Bs;
var Gs = ii2(class extends zn {
  constructor(t6) {
    super(t6);
  }
}, [0, [0, ti, -1, Ur, Qr], ds]);
var js = [0, Os];
_i[508981768] = js;
var Vs = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Xs = [0, Os, Ir, js, Hr];
var Hs = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Ws = [0, Os, Us, Xs, Ir, Bs];
_i[508968149] = Xs;
var zs = ri(508968150, Hs);
_i[508968150] = Ws;
var Ks = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Ys = ri(513916220, Ks);
_i[513916220] = [0, Os, Ws, jr];
var $s = class extends zn {
  constructor(t6) {
    super(t6);
  }
  h() {
    return Rn(this, ks, 2);
  }
  g() {
    dn(this, 2);
  }
};
var qs = [0, Os, xs];
_i[478825465] = qs;
var Js = [0, Os];
_i[478825422] = Js;
var Zs = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Qs = [0, Os, Js, qs, -1];
var to = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var eo = [0, Os, Ir, jr];
var no = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var ro = [0, Os, Ir];
var io = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var so = [0, Os, eo, ro, Ir];
var oo = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var ao = [0, Os, so, Qs];
_i[463370452] = Qs, _i[464864288] = eo, _i[474472470] = ro;
var ho = ri(462713202, io);
_i[462713202] = so;
var co = ri(479097054, oo);
_i[479097054] = ao;
var uo = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var lo = [0, Os];
var fo = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var po = [0, Os, Ir, -1, jr];
_i[514774813] = po;
var go = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var mo = [0, Os, Ir, Hr];
_i[518928384] = mo;
var yo = class extends zn {
  constructor() {
    super();
  }
};
yo.prototype.g = si2([0, Os, ro, lo, Us, Xs, po, mo]);
var _o = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var vo = ri(456383383, _o);
_i[456383383] = [0, Os, xs];
var Eo = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var wo = ri(476348187, Eo);
_i[476348187] = [0, Os, Ls];
var To = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Ao = [0, ti, -1];
var bo = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
bo.B = [3];
var ko = ri(458105876, class extends zn {
  constructor(t6) {
    super(t6);
  }
  g() {
    var t6 = this.s;
    const e5 = qt2(t6);
    var n7 = 2 & e5;
    return t6 = function(t7, e6, n8) {
      var r5 = bo;
      const i4 = 2 & e6;
      let s3 = false;
      if (null == n8) {
        if (i4) return Ze();
        n8 = [];
      } else if (n8.constructor === Ke) {
        if (0 == (2 & n8.N) || i4) return n8;
        n8 = n8.Y();
      } else Array.isArray(n8) ? s3 = !!(2 & $t2(n8)) : n8 = [];
      if (i4) {
        if (!n8.length) return Ze();
        s3 || (s3 = true, Zt2(n8));
      } else s3 && (s3 = false, n8 = wn(n8));
      return s3 || (64 & $t2(n8) ? Kt2(n8, 32) : 32 & e6 && zt(n8, 32)), fn(t7, e6, 2, r5 = new Ke(n8, r5, Oe2, void 0), false), r5;
    }(t6, e5, ln(t6, e5, 2)), null == t6 || !n7 && bo && (t6.ta = true), n7 = t6;
  }
});
_i[458105876] = [0, Ao, kr, [true, Nr, [0, Yr, -1, zr]]];
var xo = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var So = ri(458105758, xo);
_i[458105758] = [0, Os, Yr, Ao];
var Lo = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
Lo.B = [5, 6];
var Fo = ri(443442058, Lo);
_i[443442058] = [0, Os, Yr, jr, Ir, zr, -1];
var Ro = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Mo = ri(516587230, Ro);
function Po(t6, e5) {
  return e5 = e5 ? e5.clone() : new ks(), void 0 !== t6.displayNamesLocale ? dn(e5, 1, Me(t6.displayNamesLocale)) : void 0 === t6.displayNamesLocale && dn(e5, 1), void 0 !== t6.maxResults ? Xn(e5, 2, t6.maxResults) : "maxResults" in t6 && dn(e5, 2), void 0 !== t6.scoreThreshold ? Hn(e5, 3, t6.scoreThreshold) : "scoreThreshold" in t6 && dn(e5, 3), void 0 !== t6.categoryAllowlist ? Tn(e5, 4, t6.categoryAllowlist) : "categoryAllowlist" in t6 && dn(e5, 4), void 0 !== t6.categoryDenylist ? Tn(e5, 5, t6.categoryDenylist) : "categoryDenylist" in t6 && dn(e5, 5), e5;
}
function Co(t6, e5 = -1, n7 = "") {
  return { categories: t6.map((t7) => ({ index: Bn(Nn(t7, 1), 0) ?? -1, score: Gn(t7, 2) ?? 0, categoryName: jn(t7, 3) ?? "", displayName: jn(t7, 4) ?? "" })), headIndex: e5, headName: n7 };
}
function Oo(t6) {
  var e5 = yn(t6, 3, ve), n7 = yn(t6, 2, Ae), r5 = yn(t6, 1, Pe), i4 = yn(t6, 9, Pe);
  const s3 = { categories: [], keypoints: [] };
  for (let t7 = 0; t7 < e5.length; t7++) s3.categories.push({ score: e5[t7], index: n7[t7] ?? -1, categoryName: r5[t7] ?? "", displayName: i4[t7] ?? "" });
  if ((e5 = Rn(t6, Qi, 4)?.h()) && (s3.boundingBox = { originX: Nn(e5, 1) ?? 0, originY: Nn(e5, 2) ?? 0, width: Nn(e5, 3) ?? 0, height: Nn(e5, 4) ?? 0, angle: 0 }), Rn(t6, Qi, 4)?.g().length) for (const e6 of Rn(t6, Qi, 4).g()) s3.keypoints.push({ x: gn(e6, 1) ?? 0, y: gn(e6, 2) ?? 0, score: gn(e6, 4) ?? 0, label: Pe(cn(e6, 3)) ?? "" });
  return s3;
}
function Io(t6) {
  const e5 = [];
  for (const n7 of Pn(t6, as, 1)) e5.push({ x: Gn(n7, 1) ?? 0, y: Gn(n7, 2) ?? 0, z: Gn(n7, 3) ?? 0, visibility: Gn(n7, 4) ?? 0 });
  return e5;
}
function Uo(t6) {
  const e5 = [];
  for (const n7 of Pn(t6, rs, 1)) e5.push({ x: Gn(n7, 1) ?? 0, y: Gn(n7, 2) ?? 0, z: Gn(n7, 3) ?? 0, visibility: Gn(n7, 4) ?? 0 });
  return e5;
}
function Do(t6) {
  return Array.from(t6, (t7) => 127 < t7 ? t7 - 256 : t7);
}
function No(t6, e5) {
  if (t6.length !== e5.length) throw Error(`Cannot compute cosine similarity between embeddings of different sizes (${t6.length} vs. ${e5.length}).`);
  let n7 = 0, r5 = 0, i4 = 0;
  for (let s3 = 0; s3 < t6.length; s3++) n7 += t6[s3] * e5[s3], r5 += t6[s3] * t6[s3], i4 += e5[s3] * e5[s3];
  if (0 >= r5 || 0 >= i4) throw Error("Cannot compute cosine similarity on embedding with 0 norm.");
  return n7 / Math.sqrt(r5 * i4);
}
var Bo;
_i[516587230] = [0, Os, po, mo, Ir];
var Go = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]);
async function jo() {
  if (void 0 === Bo) try {
    await WebAssembly.instantiate(Go), Bo = true;
  } catch {
    Bo = false;
  }
  return Bo;
}
async function Vo(t6, e5 = "") {
  const n7 = await jo() ? "wasm_internal" : "wasm_nosimd_internal";
  return { wasmLoaderPath: `${e5}/${t6}_${n7}.js`, wasmBinaryPath: `${e5}/${t6}_${n7}.wasm` };
}
var Xo = class {
};
function Ho() {
  var t6 = navigator;
  return "undefined" != typeof OffscreenCanvas && (!function(t7 = navigator) {
    return (t7 = t7.userAgent).includes("Safari") && !t7.includes("Chrome");
  }(t6) || !!((t6 = t6.userAgent.match(/Version\/([\d]+).*Safari/)) && 1 <= t6.length && 17 <= Number(t6[1])));
}
async function Wo(t6) {
  if ("function" != typeof importScripts) {
    const e5 = document.createElement("script");
    return e5.src = t6.toString(), e5.crossOrigin = "anonymous", new Promise((t7, n7) => {
      e5.addEventListener("load", () => {
        t7();
      }, false), e5.addEventListener("error", (t8) => {
        n7(t8);
      }, false), document.body.appendChild(e5);
    });
  }
  importScripts(t6.toString());
}
function zo(t6) {
  return void 0 !== t6.videoWidth ? [t6.videoWidth, t6.videoHeight] : void 0 !== t6.naturalWidth ? [t6.naturalWidth, t6.naturalHeight] : void 0 !== t6.displayWidth ? [t6.displayWidth, t6.displayHeight] : [t6.width, t6.height];
}
function Ko(t6, e5, n7) {
  t6.m || console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target"), n7(e5 = t6.i.stringToNewUTF8(e5)), t6.i._free(e5);
}
function Yo(t6, e5, n7) {
  if (!t6.i.canvas) throw Error("No OpenGL canvas configured.");
  if (n7 ? t6.i._bindTextureToStream(n7) : t6.i._bindTextureToCanvas(), !(n7 = t6.i.canvas.getContext("webgl2") || t6.i.canvas.getContext("webgl"))) throw Error("Failed to obtain WebGL context from the provided canvas. `getContext()` should only be invoked with `webgl` or `webgl2`.");
  t6.i.gpuOriginForWebTexturesIsBottomLeft && n7.pixelStorei(n7.UNPACK_FLIP_Y_WEBGL, true), n7.texImage2D(n7.TEXTURE_2D, 0, n7.RGBA, n7.RGBA, n7.UNSIGNED_BYTE, e5), t6.i.gpuOriginForWebTexturesIsBottomLeft && n7.pixelStorei(n7.UNPACK_FLIP_Y_WEBGL, false);
  const [r5, i4] = zo(e5);
  return !t6.l || r5 === t6.i.canvas.width && i4 === t6.i.canvas.height || (t6.i.canvas.width = r5, t6.i.canvas.height = i4), [r5, i4];
}
function $o(t6, e5, n7) {
  t6.m || console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target");
  const r5 = new Uint32Array(e5.length);
  for (let n8 = 0; n8 < e5.length; n8++) r5[n8] = t6.i.stringToNewUTF8(e5[n8]);
  e5 = t6.i._malloc(4 * r5.length), t6.i.HEAPU32.set(r5, e5 >> 2), n7(e5);
  for (const e6 of r5) t6.i._free(e6);
  t6.i._free(e5);
}
function qo(t6, e5, n7) {
  t6.i.simpleListeners = t6.i.simpleListeners || {}, t6.i.simpleListeners[e5] = n7;
}
function Jo(t6, e5, n7) {
  let r5 = [];
  t6.i.simpleListeners = t6.i.simpleListeners || {}, t6.i.simpleListeners[e5] = (t7, e6, i4) => {
    e6 ? (n7(r5, i4), r5 = []) : r5.push(t7);
  };
}
Xo.forVisionTasks = function(t6) {
  return Vo("vision", t6);
}, Xo.forTextTasks = function(t6) {
  return Vo("text", t6);
}, Xo.forGenAiExperimentalTasks = function(t6) {
  return Vo("genai_experimental", t6);
}, Xo.forGenAiTasks = function(t6) {
  return Vo("genai", t6);
}, Xo.forAudioTasks = function(t6) {
  return Vo("audio", t6);
}, Xo.isSimdSupported = function() {
  return jo();
};
async function Zo(t6, e5, n7, r5) {
  return t6 = await (async (t7, e6, n8, r6, i4) => {
    if (e6 && await Wo(e6), !self.ModuleFactory) throw Error("ModuleFactory not set.");
    if (n8 && (await Wo(n8), !self.ModuleFactory)) throw Error("ModuleFactory not set.");
    return self.Module && i4 && ((e6 = self.Module).locateFile = i4.locateFile, i4.mainScriptUrlOrBlob && (e6.mainScriptUrlOrBlob = i4.mainScriptUrlOrBlob)), i4 = await self.ModuleFactory(self.Module || i4), self.ModuleFactory = self.Module = void 0, new t7(i4, r6);
  })(t6, n7.wasmLoaderPath, n7.assetLoaderPath, e5, { locateFile: (t7) => t7.endsWith(".wasm") ? n7.wasmBinaryPath.toString() : n7.assetBinaryPath && t7.endsWith(".data") ? n7.assetBinaryPath.toString() : t7 }), await t6.o(r5), t6;
}
function Qo(t6, e5) {
  const n7 = Rn(t6.baseOptions, Ms, 1) || new Ms();
  "string" == typeof e5 ? (dn(n7, 2, Me(e5)), dn(n7, 1)) : e5 instanceof Uint8Array && (dn(n7, 1, ae(e5, false, false)), dn(n7, 2)), Cn(t6.baseOptions, 0, 1, n7);
}
function ta(t6) {
  try {
    const e5 = t6.K.length;
    if (1 === e5) throw Error(t6.K[0].message);
    if (1 < e5) throw Error("Encountered multiple errors: " + t6.K.map((t7) => t7.message).join(", "));
  } finally {
    t6.K = [];
  }
}
function ea(t6, e5) {
  t6.J = Math.max(t6.J, e5);
}
function na(t6, e5) {
  t6.C = new Li(), ki(t6.C, "PassThroughCalculator"), xi(t6.C, "free_memory"), Si(t6.C, "free_memory_unused_out"), Ii(e5, "free_memory"), Oi(e5, t6.C);
}
function ra(t6, e5) {
  xi(t6.C, e5), Si(t6.C, e5 + "_unused_out");
}
function ia(t6) {
  t6.g.addBoolToStream(true, "free_memory", t6.J);
}
var sa = class {
  constructor(t6) {
    this.g = t6, this.K = [], this.J = 0, this.g.setAutoRenderToScreen(false);
  }
  l(t6, e5 = true) {
    if (e5) {
      const e6 = t6.baseOptions || {};
      if (t6.baseOptions?.modelAssetBuffer && t6.baseOptions?.modelAssetPath) throw Error("Cannot set both baseOptions.modelAssetPath and baseOptions.modelAssetBuffer");
      if (!(Rn(this.baseOptions, Ms, 1)?.g() || Rn(this.baseOptions, Ms, 1)?.h() || t6.baseOptions?.modelAssetBuffer || t6.baseOptions?.modelAssetPath)) throw Error("Either baseOptions.modelAssetPath or baseOptions.modelAssetBuffer must be set");
      if (function(t7, e7) {
        let n7 = Rn(t7.baseOptions, Fs, 3);
        if (!n7) {
          var r5 = n7 = new Fs(), i4 = new pi();
          On(r5, 4, Rs, i4);
        }
        "delegate" in e7 && ("GPU" === e7.delegate ? (e7 = n7, r5 = new li(), On(e7, 2, Rs, r5)) : (e7 = n7, r5 = new pi(), On(e7, 4, Rs, r5))), Cn(t7.baseOptions, 0, 3, n7);
      }(this, e6), e6.modelAssetPath) return fetch(e6.modelAssetPath.toString()).then((t7) => {
        if (t7.ok) return t7.arrayBuffer();
        throw Error(`Failed to fetch model: ${e6.modelAssetPath} (${t7.status})`);
      }).then((t7) => {
        try {
          this.g.i.FS_unlink("/model.dat");
        } catch {
        }
        this.g.i.FS_createDataFile("/", "model.dat", new Uint8Array(t7), true, false, false), Qo(this, "/model.dat"), this.m(), this.L();
      });
      if (e6.modelAssetBuffer instanceof Uint8Array) Qo(this, e6.modelAssetBuffer);
      else if (e6.modelAssetBuffer) return async function(t7) {
        const e7 = [];
        for (var n7 = 0; ; ) {
          const { done: r5, value: i4 } = await t7.read();
          if (r5) break;
          e7.push(i4), n7 += i4.length;
        }
        if (0 === e7.length) return new Uint8Array(0);
        if (1 === e7.length) return e7[0];
        t7 = new Uint8Array(n7), n7 = 0;
        for (const r5 of e7) t7.set(r5, n7), n7 += r5.length;
        return t7;
      }(e6.modelAssetBuffer).then((t7) => {
        Qo(this, t7), this.m(), this.L();
      });
    }
    return this.m(), this.L(), Promise.resolve();
  }
  L() {
  }
  fa() {
    let t6;
    if (this.g.fa((e5) => {
      t6 = Bi(e5);
    }), !t6) throw Error("Failed to retrieve CalculatorGraphConfig");
    return t6;
  }
  setGraph(t6, e5) {
    this.g.attachErrorListener((t7, e6) => {
      this.K.push(Error(e6));
    }), this.g.Ma(), this.g.setGraph(t6, e5), this.C = void 0, ta(this);
  }
  finishProcessing() {
    this.g.finishProcessing(), ta(this);
  }
  close() {
    this.C = void 0, this.g.closeGraph();
  }
};
function oa(t6, e5) {
  if (!t6) throw Error(`Unable to obtain required WebGL resource: ${e5}`);
  return t6;
}
sa.prototype.close = sa.prototype.close, function(e5, n7) {
  e5 = e5.split(".");
  var r5, i4 = t5;
  e5[0] in i4 || void 0 === i4.execScript || i4.execScript("var " + e5[0]);
  for (; e5.length && (r5 = e5.shift()); ) e5.length || void 0 === n7 ? i4 = i4[r5] && i4[r5] !== Object.prototype[r5] ? i4[r5] : i4[r5] = {} : i4[r5] = n7;
}("TaskRunner", sa);
var aa = class {
  constructor(t6, e5, n7, r5) {
    this.g = t6, this.h = e5, this.m = n7, this.l = r5;
  }
  bind() {
    this.g.bindVertexArray(this.h);
  }
  close() {
    this.g.deleteVertexArray(this.h), this.g.deleteBuffer(this.m), this.g.deleteBuffer(this.l);
  }
};
function ha(t6, e5, n7) {
  const r5 = t6.g;
  if (n7 = oa(r5.createShader(n7), "Failed to create WebGL shader"), r5.shaderSource(n7, e5), r5.compileShader(n7), !r5.getShaderParameter(n7, r5.COMPILE_STATUS)) throw Error(`Could not compile WebGL shader: ${r5.getShaderInfoLog(n7)}`);
  return r5.attachShader(t6.h, n7), n7;
}
function ca(t6, e5) {
  const n7 = t6.g, r5 = oa(n7.createVertexArray(), "Failed to create vertex array");
  n7.bindVertexArray(r5);
  const i4 = oa(n7.createBuffer(), "Failed to create buffer");
  n7.bindBuffer(n7.ARRAY_BUFFER, i4), n7.enableVertexAttribArray(t6.K), n7.vertexAttribPointer(t6.K, 2, n7.FLOAT, false, 0, 0), n7.bufferData(n7.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), n7.STATIC_DRAW);
  const s3 = oa(n7.createBuffer(), "Failed to create buffer");
  return n7.bindBuffer(n7.ARRAY_BUFFER, s3), n7.enableVertexAttribArray(t6.J), n7.vertexAttribPointer(t6.J, 2, n7.FLOAT, false, 0, 0), n7.bufferData(n7.ARRAY_BUFFER, new Float32Array(e5 ? [0, 1, 0, 0, 1, 0, 1, 1] : [0, 0, 0, 1, 1, 1, 1, 0]), n7.STATIC_DRAW), n7.bindBuffer(n7.ARRAY_BUFFER, null), n7.bindVertexArray(null), new aa(n7, r5, i4, s3);
}
function ua(t6, e5) {
  if (t6.g) {
    if (e5 !== t6.g) throw Error("Cannot change GL context once initialized");
  } else t6.g = e5;
}
function la(t6, e5, n7, r5) {
  return ua(t6, e5), t6.h || (t6.m(), t6.D()), n7 ? (t6.v || (t6.v = ca(t6, true)), n7 = t6.v) : (t6.A || (t6.A = ca(t6, false)), n7 = t6.A), e5.useProgram(t6.h), n7.bind(), t6.l(), t6 = r5(), n7.g.bindVertexArray(null), t6;
}
function da(t6, e5, n7) {
  return ua(t6, e5), t6 = oa(e5.createTexture(), "Failed to create texture"), e5.bindTexture(e5.TEXTURE_2D, t6), e5.texParameteri(e5.TEXTURE_2D, e5.TEXTURE_WRAP_S, e5.CLAMP_TO_EDGE), e5.texParameteri(e5.TEXTURE_2D, e5.TEXTURE_WRAP_T, e5.CLAMP_TO_EDGE), e5.texParameteri(e5.TEXTURE_2D, e5.TEXTURE_MIN_FILTER, n7 ?? e5.LINEAR), e5.texParameteri(e5.TEXTURE_2D, e5.TEXTURE_MAG_FILTER, n7 ?? e5.LINEAR), e5.bindTexture(e5.TEXTURE_2D, null), t6;
}
function fa(t6, e5, n7) {
  ua(t6, e5), t6.u || (t6.u = oa(e5.createFramebuffer(), "Failed to create framebuffe.")), e5.bindFramebuffer(e5.FRAMEBUFFER, t6.u), e5.framebufferTexture2D(e5.FRAMEBUFFER, e5.COLOR_ATTACHMENT0, e5.TEXTURE_2D, n7, 0);
}
function pa(t6) {
  t6.g?.bindFramebuffer(t6.g.FRAMEBUFFER, null);
}
var ga = class {
  H() {
    return "\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D inputTexture;\n  void main() {\n    gl_FragColor = texture2D(inputTexture, vTex);\n  }\n ";
  }
  m() {
    const t6 = this.g;
    if (this.h = oa(t6.createProgram(), "Failed to create WebGL program"), this.ba = ha(this, "\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }", t6.VERTEX_SHADER), this.aa = ha(this, this.H(), t6.FRAGMENT_SHADER), t6.linkProgram(this.h), !t6.getProgramParameter(this.h, t6.LINK_STATUS)) throw Error(`Error during program linking: ${t6.getProgramInfoLog(this.h)}`);
    this.K = t6.getAttribLocation(this.h, "aVertex"), this.J = t6.getAttribLocation(this.h, "aTex");
  }
  D() {
  }
  l() {
  }
  close() {
    if (this.h) {
      const t6 = this.g;
      t6.deleteProgram(this.h), t6.deleteShader(this.ba), t6.deleteShader(this.aa);
    }
    this.u && this.g.deleteFramebuffer(this.u), this.A && this.A.close(), this.v && this.v.close();
  }
};
var ma = class extends ga {
  H() {
    return "\n  precision mediump float;\n  uniform sampler2D backgroundTexture;\n  uniform sampler2D maskTexture;\n  uniform sampler2D colorMappingTexture;\n  varying vec2 vTex;\n  void main() {\n    vec4 backgroundColor = texture2D(backgroundTexture, vTex);\n    float category = texture2D(maskTexture, vTex).r;\n    vec4 categoryColor = texture2D(colorMappingTexture, vec2(category, 0.0));\n    gl_FragColor = mix(backgroundColor, categoryColor, categoryColor.a);\n  }\n ";
  }
  D() {
    const t6 = this.g;
    t6.activeTexture(t6.TEXTURE1), this.C = da(this, t6, t6.LINEAR), t6.activeTexture(t6.TEXTURE2), this.j = da(this, t6, t6.NEAREST);
  }
  m() {
    super.m();
    const t6 = this.g;
    this.M = oa(t6.getUniformLocation(this.h, "backgroundTexture"), "Uniform location"), this.V = oa(t6.getUniformLocation(this.h, "colorMappingTexture"), "Uniform location"), this.L = oa(t6.getUniformLocation(this.h, "maskTexture"), "Uniform location");
  }
  l() {
    super.l();
    const t6 = this.g;
    t6.uniform1i(this.L, 0), t6.uniform1i(this.M, 1), t6.uniform1i(this.V, 2);
  }
  close() {
    this.C && this.g.deleteTexture(this.C), this.j && this.g.deleteTexture(this.j), super.close();
  }
};
var ya = class extends ga {
  H() {
    return "\n  precision mediump float;\n  uniform sampler2D maskTexture;\n  uniform sampler2D defaultTexture;\n  uniform sampler2D overlayTexture;\n  varying vec2 vTex;\n  void main() {\n    float confidence = texture2D(maskTexture, vTex).r;\n    vec4 defaultColor = texture2D(defaultTexture, vTex);\n    vec4 overlayColor = texture2D(overlayTexture, vTex);\n    // Apply the alpha from the overlay and merge in the default color\n    overlayColor = mix(defaultColor, overlayColor, overlayColor.a);\n    gl_FragColor = mix(defaultColor, overlayColor, confidence);\n  }\n ";
  }
  D() {
    const t6 = this.g;
    t6.activeTexture(t6.TEXTURE1), this.j = da(this, t6), t6.activeTexture(t6.TEXTURE2), this.C = da(this, t6);
  }
  m() {
    super.m();
    const t6 = this.g;
    this.L = oa(t6.getUniformLocation(this.h, "defaultTexture"), "Uniform location"), this.M = oa(t6.getUniformLocation(this.h, "overlayTexture"), "Uniform location"), this.I = oa(t6.getUniformLocation(this.h, "maskTexture"), "Uniform location");
  }
  l() {
    super.l();
    const t6 = this.g;
    t6.uniform1i(this.I, 0), t6.uniform1i(this.L, 1), t6.uniform1i(this.M, 2);
  }
  close() {
    this.j && this.g.deleteTexture(this.j), this.C && this.g.deleteTexture(this.C), super.close();
  }
};
function _a(t6, e5) {
  switch (e5) {
    case 0:
      return t6.g.find((t7) => t7 instanceof Uint8Array);
    case 1:
      return t6.g.find((t7) => t7 instanceof Float32Array);
    case 2:
      return t6.g.find((t7) => "undefined" != typeof WebGLTexture && t7 instanceof WebGLTexture);
    default:
      throw Error(`Type is not supported: ${e5}`);
  }
}
function va(t6) {
  var e5 = _a(t6, 1);
  if (!e5) {
    if (e5 = _a(t6, 0)) e5 = new Float32Array(e5).map((t7) => t7 / 255);
    else {
      e5 = new Float32Array(t6.width * t6.height);
      const r5 = wa(t6);
      var n7 = Aa(t6);
      if (fa(n7, r5, Ea(t6)), "iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in self.document) {
        n7 = new Float32Array(t6.width * t6.height * 4), r5.readPixels(0, 0, t6.width, t6.height, r5.RGBA, r5.FLOAT, n7);
        for (let t7 = 0, r6 = 0; t7 < e5.length; ++t7, r6 += 4) e5[t7] = n7[r6];
      } else r5.readPixels(0, 0, t6.width, t6.height, r5.RED, r5.FLOAT, e5);
    }
    t6.g.push(e5);
  }
  return e5;
}
function Ea(t6) {
  let e5 = _a(t6, 2);
  if (!e5) {
    const n7 = wa(t6);
    e5 = ba(t6);
    const r5 = va(t6), i4 = Ta(t6);
    n7.texImage2D(n7.TEXTURE_2D, 0, i4, t6.width, t6.height, 0, n7.RED, n7.FLOAT, r5), ka(t6);
  }
  return e5;
}
function wa(t6) {
  if (!t6.canvas) throw Error("Conversion to different image formats require that a canvas is passed when initializing the image.");
  return t6.h || (t6.h = oa(t6.canvas.getContext("webgl2"), "You cannot use a canvas that is already bound to a different type of rendering context.")), t6.h;
}
function Ta(t6) {
  if (t6 = wa(t6), !xa) if (t6.getExtension("EXT_color_buffer_float") && t6.getExtension("OES_texture_float_linear") && t6.getExtension("EXT_float_blend")) xa = t6.R32F;
  else {
    if (!t6.getExtension("EXT_color_buffer_half_float")) throw Error("GPU does not fully support 4-channel float32 or float16 formats");
    xa = t6.R16F;
  }
  return xa;
}
function Aa(t6) {
  return t6.l || (t6.l = new ga()), t6.l;
}
function ba(t6) {
  const e5 = wa(t6);
  e5.viewport(0, 0, t6.width, t6.height), e5.activeTexture(e5.TEXTURE0);
  let n7 = _a(t6, 2);
  return n7 || (n7 = da(Aa(t6), e5, t6.m ? e5.LINEAR : e5.NEAREST), t6.g.push(n7), t6.j = true), e5.bindTexture(e5.TEXTURE_2D, n7), n7;
}
function ka(t6) {
  t6.h.bindTexture(t6.h.TEXTURE_2D, null);
}
var xa;
var Sa = class {
  constructor(t6, e5, n7, r5, i4, s3, o5) {
    this.g = t6, this.m = e5, this.j = n7, this.canvas = r5, this.l = i4, this.width = s3, this.height = o5, this.j && (0 === --La && console.error("You seem to be creating MPMask instances without invoking .close(). This leaks resources."));
  }
  Ha() {
    return !!_a(this, 0);
  }
  la() {
    return !!_a(this, 1);
  }
  R() {
    return !!_a(this, 2);
  }
  ka() {
    return (e5 = _a(t6 = this, 0)) || (e5 = va(t6), e5 = new Uint8Array(e5.map((t7) => 255 * t7)), t6.g.push(e5)), e5;
    var t6, e5;
  }
  ja() {
    return va(this);
  }
  O() {
    return Ea(this);
  }
  clone() {
    const t6 = [];
    for (const e5 of this.g) {
      let n7;
      if (e5 instanceof Uint8Array) n7 = new Uint8Array(e5);
      else if (e5 instanceof Float32Array) n7 = new Float32Array(e5);
      else {
        if (!(e5 instanceof WebGLTexture)) throw Error(`Type is not supported: ${e5}`);
        {
          const t7 = wa(this), e6 = Aa(this);
          t7.activeTexture(t7.TEXTURE1), n7 = da(e6, t7, this.m ? t7.LINEAR : t7.NEAREST), t7.bindTexture(t7.TEXTURE_2D, n7);
          const r5 = Ta(this);
          t7.texImage2D(t7.TEXTURE_2D, 0, r5, this.width, this.height, 0, t7.RED, t7.FLOAT, null), t7.bindTexture(t7.TEXTURE_2D, null), fa(e6, t7, n7), la(e6, t7, false, () => {
            ba(this), t7.clearColor(0, 0, 0, 0), t7.clear(t7.COLOR_BUFFER_BIT), t7.drawArrays(t7.TRIANGLE_FAN, 0, 4), ka(this);
          }), pa(e6), ka(this);
        }
      }
      t6.push(n7);
    }
    return new Sa(t6, this.m, this.R(), this.canvas, this.l, this.width, this.height);
  }
  close() {
    this.j && wa(this).deleteTexture(_a(this, 2)), La = -1;
  }
};
Sa.prototype.close = Sa.prototype.close, Sa.prototype.clone = Sa.prototype.clone, Sa.prototype.getAsWebGLTexture = Sa.prototype.O, Sa.prototype.getAsFloat32Array = Sa.prototype.ja, Sa.prototype.getAsUint8Array = Sa.prototype.ka, Sa.prototype.hasWebGLTexture = Sa.prototype.R, Sa.prototype.hasFloat32Array = Sa.prototype.la, Sa.prototype.hasUint8Array = Sa.prototype.Ha;
var La = 250;
var Fa = { color: "white", lineWidth: 4, radius: 6 };
function Ra(t6) {
  return { ...Fa, fillColor: (t6 = t6 || {}).color, ...t6 };
}
function Ma(t6, e5) {
  return t6 instanceof Function ? t6(e5) : t6;
}
function Pa(t6, e5, n7) {
  return Math.max(Math.min(e5, n7), Math.min(Math.max(e5, n7), t6));
}
function Ca(t6) {
  if (!t6.l) throw Error("CPU rendering requested but CanvasRenderingContext2D not provided.");
  return t6.l;
}
function Oa(t6) {
  if (!t6.j) throw Error("GPU rendering requested but WebGL2RenderingContext not provided.");
  return t6.j;
}
function Ia(t6, e5, n7) {
  if (e5.R()) n7(e5.O());
  else {
    const r5 = e5.la() ? e5.ja() : e5.ka();
    t6.m = t6.m ?? new ga();
    const i4 = Oa(t6);
    n7((t6 = new Sa([r5], e5.m, false, i4.canvas, t6.m, e5.width, e5.height)).O()), t6.close();
  }
}
function Ua(t6, e5, n7, r5) {
  const i4 = function(t7) {
    return t7.g || (t7.g = new ma()), t7.g;
  }(t6), s3 = Oa(t6), o5 = Array.isArray(n7) ? new ImageData(new Uint8ClampedArray(n7), 1, 1) : n7;
  la(i4, s3, true, () => {
    !function(t8, e6, n8, r6) {
      const i5 = t8.g;
      if (i5.activeTexture(i5.TEXTURE0), i5.bindTexture(i5.TEXTURE_2D, e6), i5.activeTexture(i5.TEXTURE1), i5.bindTexture(i5.TEXTURE_2D, t8.C), i5.texImage2D(i5.TEXTURE_2D, 0, i5.RGBA, i5.RGBA, i5.UNSIGNED_BYTE, n8), t8.I && function(t9, e7) {
        if (t9 !== e7) return false;
        t9 = t9.entries(), e7 = e7.entries();
        for (const [r7, i6] of t9) {
          t9 = r7;
          const s4 = i6;
          var n9 = e7.next();
          if (n9.done) return false;
          const [o6, a4] = n9.value;
          if (n9 = a4, t9 !== o6 || s4[0] !== n9[0] || s4[1] !== n9[1] || s4[2] !== n9[2] || s4[3] !== n9[3]) return false;
        }
        return !!e7.next().done;
      }(t8.I, r6)) i5.activeTexture(i5.TEXTURE2), i5.bindTexture(i5.TEXTURE_2D, t8.j);
      else {
        t8.I = r6;
        const e7 = Array(1024).fill(0);
        r6.forEach((t9, n9) => {
          if (4 !== t9.length) throw Error(`Color at index ${n9} is not a four-channel value.`);
          e7[4 * n9] = t9[0], e7[4 * n9 + 1] = t9[1], e7[4 * n9 + 2] = t9[2], e7[4 * n9 + 3] = t9[3];
        }), i5.activeTexture(i5.TEXTURE2), i5.bindTexture(i5.TEXTURE_2D, t8.j), i5.texImage2D(i5.TEXTURE_2D, 0, i5.RGBA, 256, 1, 0, i5.RGBA, i5.UNSIGNED_BYTE, new Uint8Array(e7));
      }
    }(i4, e5, o5, r5), s3.clearColor(0, 0, 0, 0), s3.clear(s3.COLOR_BUFFER_BIT), s3.drawArrays(s3.TRIANGLE_FAN, 0, 4);
    const t7 = i4.g;
    t7.activeTexture(t7.TEXTURE0), t7.bindTexture(t7.TEXTURE_2D, null), t7.activeTexture(t7.TEXTURE1), t7.bindTexture(t7.TEXTURE_2D, null), t7.activeTexture(t7.TEXTURE2), t7.bindTexture(t7.TEXTURE_2D, null);
  });
}
function Da(t6, e5, n7, r5) {
  const i4 = Oa(t6), s3 = function(t7) {
    return t7.h || (t7.h = new ya()), t7.h;
  }(t6), o5 = Array.isArray(n7) ? new ImageData(new Uint8ClampedArray(n7), 1, 1) : n7, a4 = Array.isArray(r5) ? new ImageData(new Uint8ClampedArray(r5), 1, 1) : r5;
  la(s3, i4, true, () => {
    var t7 = s3.g;
    t7.activeTexture(t7.TEXTURE0), t7.bindTexture(t7.TEXTURE_2D, e5), t7.activeTexture(t7.TEXTURE1), t7.bindTexture(t7.TEXTURE_2D, s3.j), t7.texImage2D(t7.TEXTURE_2D, 0, t7.RGBA, t7.RGBA, t7.UNSIGNED_BYTE, o5), t7.activeTexture(t7.TEXTURE2), t7.bindTexture(t7.TEXTURE_2D, s3.C), t7.texImage2D(t7.TEXTURE_2D, 0, t7.RGBA, t7.RGBA, t7.UNSIGNED_BYTE, a4), i4.clearColor(0, 0, 0, 0), i4.clear(i4.COLOR_BUFFER_BIT), i4.drawArrays(i4.TRIANGLE_FAN, 0, 4), i4.bindTexture(i4.TEXTURE_2D, null), (t7 = s3.g).activeTexture(t7.TEXTURE0), t7.bindTexture(t7.TEXTURE_2D, null), t7.activeTexture(t7.TEXTURE1), t7.bindTexture(t7.TEXTURE_2D, null), t7.activeTexture(t7.TEXTURE2), t7.bindTexture(t7.TEXTURE_2D, null);
  });
}
var Na = class {
  constructor(t6, e5) {
    t6 instanceof CanvasRenderingContext2D || t6 instanceof OffscreenCanvasRenderingContext2D ? (this.l = t6, this.j = e5) : this.j = t6;
  }
  Aa(t6, e5) {
    if (t6) {
      var n7 = Ca(this);
      e5 = Ra(e5), n7.save();
      var r5 = n7.canvas, i4 = 0;
      for (const s3 of t6) n7.fillStyle = Ma(e5.fillColor, { index: i4, from: s3 }), n7.strokeStyle = Ma(e5.color, { index: i4, from: s3 }), n7.lineWidth = Ma(e5.lineWidth, { index: i4, from: s3 }), (t6 = new Path2D()).arc(s3.x * r5.width, s3.y * r5.height, Ma(e5.radius, { index: i4, from: s3 }), 0, 2 * Math.PI), n7.fill(t6), n7.stroke(t6), ++i4;
      n7.restore();
    }
  }
  za(t6, e5, n7) {
    if (t6 && e5) {
      var r5 = Ca(this);
      n7 = Ra(n7), r5.save();
      var i4 = r5.canvas, s3 = 0;
      for (const o5 of e5) {
        r5.beginPath(), e5 = t6[o5.start];
        const a4 = t6[o5.end];
        e5 && a4 && (r5.strokeStyle = Ma(n7.color, { index: s3, from: e5, to: a4 }), r5.lineWidth = Ma(n7.lineWidth, { index: s3, from: e5, to: a4 }), r5.moveTo(e5.x * i4.width, e5.y * i4.height), r5.lineTo(a4.x * i4.width, a4.y * i4.height)), ++s3, r5.stroke();
      }
      r5.restore();
    }
  }
  wa(t6, e5) {
    const n7 = Ca(this);
    e5 = Ra(e5), n7.save(), n7.beginPath(), n7.lineWidth = Ma(e5.lineWidth, {}), n7.strokeStyle = Ma(e5.color, {}), n7.fillStyle = Ma(e5.fillColor, {}), n7.moveTo(t6.originX, t6.originY), n7.lineTo(t6.originX + t6.width, t6.originY), n7.lineTo(t6.originX + t6.width, t6.originY + t6.height), n7.lineTo(t6.originX, t6.originY + t6.height), n7.lineTo(t6.originX, t6.originY), n7.stroke(), n7.fill(), n7.restore();
  }
  xa(t6, e5, n7 = [0, 0, 0, 255]) {
    this.l ? function(t7, e6, n8, r5) {
      const i4 = Oa(t7);
      Ia(t7, e6, (e7) => {
        Ua(t7, e7, n8, r5), (e7 = Ca(t7)).drawImage(i4.canvas, 0, 0, e7.canvas.width, e7.canvas.height);
      });
    }(this, t6, n7, e5) : Ua(this, t6.O(), n7, e5);
  }
  ya(t6, e5, n7) {
    this.l ? function(t7, e6, n8, r5) {
      const i4 = Oa(t7);
      Ia(t7, e6, (e7) => {
        Da(t7, e7, n8, r5), (e7 = Ca(t7)).drawImage(i4.canvas, 0, 0, e7.canvas.width, e7.canvas.height);
      });
    }(this, t6, e5, n7) : Da(this, t6.O(), e5, n7);
  }
  close() {
    this.g?.close(), this.g = void 0, this.h?.close(), this.h = void 0, this.m?.close(), this.m = void 0;
  }
};
function Ba(t6, e5) {
  switch (e5) {
    case 0:
      return t6.g.find((t7) => t7 instanceof ImageData);
    case 1:
      return t6.g.find((t7) => "undefined" != typeof ImageBitmap && t7 instanceof ImageBitmap);
    case 2:
      return t6.g.find((t7) => "undefined" != typeof WebGLTexture && t7 instanceof WebGLTexture);
    default:
      throw Error(`Type is not supported: ${e5}`);
  }
}
function Ga(t6) {
  var e5 = Ba(t6, 0);
  if (!e5) {
    e5 = Va(t6);
    const n7 = Xa(t6), r5 = new Uint8Array(t6.width * t6.height * 4);
    fa(n7, e5, ja(t6)), e5.readPixels(0, 0, t6.width, t6.height, e5.RGBA, e5.UNSIGNED_BYTE, r5), pa(n7), e5 = new ImageData(new Uint8ClampedArray(r5.buffer), t6.width, t6.height), t6.g.push(e5);
  }
  return e5;
}
function ja(t6) {
  let e5 = Ba(t6, 2);
  if (!e5) {
    const n7 = Va(t6);
    e5 = Ha(t6);
    const r5 = Ba(t6, 1) || Ga(t6);
    n7.texImage2D(n7.TEXTURE_2D, 0, n7.RGBA, n7.RGBA, n7.UNSIGNED_BYTE, r5), Wa(t6);
  }
  return e5;
}
function Va(t6) {
  if (!t6.canvas) throw Error("Conversion to different image formats require that a canvas is passed when iniitializing the image.");
  return t6.h || (t6.h = oa(t6.canvas.getContext("webgl2"), "You cannot use a canvas that is already bound to a different type of rendering context.")), t6.h;
}
function Xa(t6) {
  return t6.l || (t6.l = new ga()), t6.l;
}
function Ha(t6) {
  const e5 = Va(t6);
  e5.viewport(0, 0, t6.width, t6.height), e5.activeTexture(e5.TEXTURE0);
  let n7 = Ba(t6, 2);
  return n7 || (n7 = da(Xa(t6), e5), t6.g.push(n7), t6.m = true), e5.bindTexture(e5.TEXTURE_2D, n7), n7;
}
function Wa(t6) {
  t6.h.bindTexture(t6.h.TEXTURE_2D, null);
}
function za(t6) {
  const e5 = Va(t6);
  return la(Xa(t6), e5, true, () => function(t7, e6) {
    const n7 = t7.canvas;
    if (n7.width === t7.width && n7.height === t7.height) return e6();
    const r5 = n7.width, i4 = n7.height;
    return n7.width = t7.width, n7.height = t7.height, t7 = e6(), n7.width = r5, n7.height = i4, t7;
  }(t6, () => {
    if (e5.bindFramebuffer(e5.FRAMEBUFFER, null), e5.clearColor(0, 0, 0, 0), e5.clear(e5.COLOR_BUFFER_BIT), e5.drawArrays(e5.TRIANGLE_FAN, 0, 4), !(t6.canvas instanceof OffscreenCanvas)) throw Error("Conversion to ImageBitmap requires that the MediaPipe Tasks is initialized with an OffscreenCanvas");
    return t6.canvas.transferToImageBitmap();
  }));
}
Na.prototype.close = Na.prototype.close, Na.prototype.drawConfidenceMask = Na.prototype.ya, Na.prototype.drawCategoryMask = Na.prototype.xa, Na.prototype.drawBoundingBox = Na.prototype.wa, Na.prototype.drawConnectors = Na.prototype.za, Na.prototype.drawLandmarks = Na.prototype.Aa, Na.lerp = function(t6, e5, n7, r5, i4) {
  return Pa(r5 * (1 - (t6 - e5) / (n7 - e5)) + i4 * (1 - (n7 - t6) / (n7 - e5)), r5, i4);
}, Na.clamp = Pa;
var Ka = class {
  constructor(t6, e5, n7, r5, i4, s3, o5) {
    this.g = t6, this.j = e5, this.m = n7, this.canvas = r5, this.l = i4, this.width = s3, this.height = o5, (this.j || this.m) && (0 === --Ya && console.error("You seem to be creating MPImage instances without invoking .close(). This leaks resources."));
  }
  Ga() {
    return !!Ba(this, 0);
  }
  ma() {
    return !!Ba(this, 1);
  }
  R() {
    return !!Ba(this, 2);
  }
  Ea() {
    return Ga(this);
  }
  Da() {
    var t6 = Ba(this, 1);
    return t6 || (ja(this), Ha(this), t6 = za(this), Wa(this), this.g.push(t6), this.j = true), t6;
  }
  O() {
    return ja(this);
  }
  clone() {
    const t6 = [];
    for (const e5 of this.g) {
      let n7;
      if (e5 instanceof ImageData) n7 = new ImageData(e5.data, this.width, this.height);
      else if (e5 instanceof WebGLTexture) {
        const t7 = Va(this), e6 = Xa(this);
        t7.activeTexture(t7.TEXTURE1), n7 = da(e6, t7), t7.bindTexture(t7.TEXTURE_2D, n7), t7.texImage2D(t7.TEXTURE_2D, 0, t7.RGBA, this.width, this.height, 0, t7.RGBA, t7.UNSIGNED_BYTE, null), t7.bindTexture(t7.TEXTURE_2D, null), fa(e6, t7, n7), la(e6, t7, false, () => {
          Ha(this), t7.clearColor(0, 0, 0, 0), t7.clear(t7.COLOR_BUFFER_BIT), t7.drawArrays(t7.TRIANGLE_FAN, 0, 4), Wa(this);
        }), pa(e6), Wa(this);
      } else {
        if (!(e5 instanceof ImageBitmap)) throw Error(`Type is not supported: ${e5}`);
        ja(this), Ha(this), n7 = za(this), Wa(this);
      }
      t6.push(n7);
    }
    return new Ka(t6, this.ma(), this.R(), this.canvas, this.l, this.width, this.height);
  }
  close() {
    this.j && Ba(this, 1).close(), this.m && Va(this).deleteTexture(Ba(this, 2)), Ya = -1;
  }
};
Ka.prototype.close = Ka.prototype.close, Ka.prototype.clone = Ka.prototype.clone, Ka.prototype.getAsWebGLTexture = Ka.prototype.O, Ka.prototype.getAsImageBitmap = Ka.prototype.Da, Ka.prototype.getAsImageData = Ka.prototype.Ea, Ka.prototype.hasWebGLTexture = Ka.prototype.R, Ka.prototype.hasImageBitmap = Ka.prototype.ma, Ka.prototype.hasImageData = Ka.prototype.Ga;
var Ya = 250;
function $a(...t6) {
  return t6.map(([t7, e5]) => ({ start: t7, end: e5 }));
}
var qa = /* @__PURE__ */ function(t6) {
  return class extends t6 {
    Ma() {
      this.i._registerModelResourcesGraphService();
    }
  };
}((Ja = class {
  constructor(t6, e5) {
    this.l = true, this.i = t6, this.g = null, this.h = 0, this.m = "function" == typeof this.i._addIntToInputStream, void 0 !== e5 ? this.i.canvas = e5 : Ho() ? this.i.canvas = new OffscreenCanvas(1, 1) : (console.warn("OffscreenCanvas not supported and GraphRunner constructor glCanvas parameter is undefined. Creating backup canvas."), this.i.canvas = document.createElement("canvas"));
  }
  async initializeGraph(t6) {
    const e5 = await (await fetch(t6)).arrayBuffer();
    t6 = !(t6.endsWith(".pbtxt") || t6.endsWith(".textproto")), this.setGraph(new Uint8Array(e5), t6);
  }
  setGraphFromString(t6) {
    this.setGraph(new TextEncoder().encode(t6), false);
  }
  setGraph(t6, e5) {
    const n7 = t6.length, r5 = this.i._malloc(n7);
    this.i.HEAPU8.set(t6, r5), e5 ? this.i._changeBinaryGraph(n7, r5) : this.i._changeTextGraph(n7, r5), this.i._free(r5);
  }
  configureAudio(t6, e5, n7, r5, i4) {
    this.i._configureAudio || console.warn('Attempting to use configureAudio without support for input audio. Is build dep ":gl_graph_runner_audio" missing?'), Ko(this, r5 || "input_audio", (r6) => {
      Ko(this, i4 = i4 || "audio_header", (i5) => {
        this.i._configureAudio(r6, i5, t6, e5, n7);
      });
    });
  }
  setAutoResizeCanvas(t6) {
    this.l = t6;
  }
  setAutoRenderToScreen(t6) {
    this.i._setAutoRenderToScreen(t6);
  }
  setGpuBufferVerticalFlip(t6) {
    this.i.gpuOriginForWebTexturesIsBottomLeft = t6;
  }
  fa(t6) {
    qo(this, "__graph_config__", (e5) => {
      t6(e5);
    }), Ko(this, "__graph_config__", (t7) => {
      this.i._getGraphConfig(t7, void 0);
    }), delete this.i.simpleListeners.__graph_config__;
  }
  attachErrorListener(t6) {
    this.i.errorListener = t6;
  }
  attachEmptyPacketListener(t6, e5) {
    this.i.emptyPacketListeners = this.i.emptyPacketListeners || {}, this.i.emptyPacketListeners[t6] = e5;
  }
  addAudioToStream(t6, e5, n7) {
    this.addAudioToStreamWithShape(t6, 0, 0, e5, n7);
  }
  addAudioToStreamWithShape(t6, e5, n7, r5, i4) {
    const s3 = 4 * t6.length;
    this.h !== s3 && (this.g && this.i._free(this.g), this.g = this.i._malloc(s3), this.h = s3), this.i.HEAPF32.set(t6, this.g / 4), Ko(this, r5, (t7) => {
      this.i._addAudioToInputStream(this.g, e5, n7, t7, i4);
    });
  }
  addGpuBufferToStream(t6, e5, n7) {
    Ko(this, e5, (e6) => {
      const [r5, i4] = Yo(this, t6, e6);
      this.i._addBoundTextureToStream(e6, r5, i4, n7);
    });
  }
  addBoolToStream(t6, e5, n7) {
    Ko(this, e5, (e6) => {
      this.i._addBoolToInputStream(t6, e6, n7);
    });
  }
  addDoubleToStream(t6, e5, n7) {
    Ko(this, e5, (e6) => {
      this.i._addDoubleToInputStream(t6, e6, n7);
    });
  }
  addFloatToStream(t6, e5, n7) {
    Ko(this, e5, (e6) => {
      this.i._addFloatToInputStream(t6, e6, n7);
    });
  }
  addIntToStream(t6, e5, n7) {
    Ko(this, e5, (e6) => {
      this.i._addIntToInputStream(t6, e6, n7);
    });
  }
  addUintToStream(t6, e5, n7) {
    Ko(this, e5, (e6) => {
      this.i._addUintToInputStream(t6, e6, n7);
    });
  }
  addStringToStream(t6, e5, n7) {
    Ko(this, e5, (e6) => {
      Ko(this, t6, (t7) => {
        this.i._addStringToInputStream(t7, e6, n7);
      });
    });
  }
  addStringRecordToStream(t6, e5, n7) {
    Ko(this, e5, (e6) => {
      $o(this, Object.keys(t6), (r5) => {
        $o(this, Object.values(t6), (i4) => {
          this.i._addFlatHashMapToInputStream(r5, i4, Object.keys(t6).length, e6, n7);
        });
      });
    });
  }
  addProtoToStream(t6, e5, n7, r5) {
    Ko(this, n7, (n8) => {
      Ko(this, e5, (e6) => {
        const i4 = this.i._malloc(t6.length);
        this.i.HEAPU8.set(t6, i4), this.i._addProtoToInputStream(i4, t6.length, e6, n8, r5), this.i._free(i4);
      });
    });
  }
  addEmptyPacketToStream(t6, e5) {
    Ko(this, t6, (t7) => {
      this.i._addEmptyPacketToInputStream(t7, e5);
    });
  }
  addBoolVectorToStream(t6, e5, n7) {
    Ko(this, e5, (e6) => {
      const r5 = this.i._allocateBoolVector(t6.length);
      if (!r5) throw Error("Unable to allocate new bool vector on heap.");
      for (const e7 of t6) this.i._addBoolVectorEntry(r5, e7);
      this.i._addBoolVectorToInputStream(r5, e6, n7);
    });
  }
  addDoubleVectorToStream(t6, e5, n7) {
    Ko(this, e5, (e6) => {
      const r5 = this.i._allocateDoubleVector(t6.length);
      if (!r5) throw Error("Unable to allocate new double vector on heap.");
      for (const e7 of t6) this.i._addDoubleVectorEntry(r5, e7);
      this.i._addDoubleVectorToInputStream(r5, e6, n7);
    });
  }
  addFloatVectorToStream(t6, e5, n7) {
    Ko(this, e5, (e6) => {
      const r5 = this.i._allocateFloatVector(t6.length);
      if (!r5) throw Error("Unable to allocate new float vector on heap.");
      for (const e7 of t6) this.i._addFloatVectorEntry(r5, e7);
      this.i._addFloatVectorToInputStream(r5, e6, n7);
    });
  }
  addIntVectorToStream(t6, e5, n7) {
    Ko(this, e5, (e6) => {
      const r5 = this.i._allocateIntVector(t6.length);
      if (!r5) throw Error("Unable to allocate new int vector on heap.");
      for (const e7 of t6) this.i._addIntVectorEntry(r5, e7);
      this.i._addIntVectorToInputStream(r5, e6, n7);
    });
  }
  addUintVectorToStream(t6, e5, n7) {
    Ko(this, e5, (e6) => {
      const r5 = this.i._allocateUintVector(t6.length);
      if (!r5) throw Error("Unable to allocate new unsigned int vector on heap.");
      for (const e7 of t6) this.i._addUintVectorEntry(r5, e7);
      this.i._addUintVectorToInputStream(r5, e6, n7);
    });
  }
  addStringVectorToStream(t6, e5, n7) {
    Ko(this, e5, (e6) => {
      const r5 = this.i._allocateStringVector(t6.length);
      if (!r5) throw Error("Unable to allocate new string vector on heap.");
      for (const e7 of t6) Ko(this, e7, (t7) => {
        this.i._addStringVectorEntry(r5, t7);
      });
      this.i._addStringVectorToInputStream(r5, e6, n7);
    });
  }
  addBoolToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      this.i._addBoolToInputSidePacket(t6, e6);
    });
  }
  addDoubleToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      this.i._addDoubleToInputSidePacket(t6, e6);
    });
  }
  addFloatToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      this.i._addFloatToInputSidePacket(t6, e6);
    });
  }
  addIntToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      this.i._addIntToInputSidePacket(t6, e6);
    });
  }
  addUintToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      this.i._addUintToInputSidePacket(t6, e6);
    });
  }
  addStringToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      Ko(this, t6, (t7) => {
        this.i._addStringToInputSidePacket(t7, e6);
      });
    });
  }
  addProtoToInputSidePacket(t6, e5, n7) {
    Ko(this, n7, (n8) => {
      Ko(this, e5, (e6) => {
        const r5 = this.i._malloc(t6.length);
        this.i.HEAPU8.set(t6, r5), this.i._addProtoToInputSidePacket(r5, t6.length, e6, n8), this.i._free(r5);
      });
    });
  }
  addBoolVectorToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      const n7 = this.i._allocateBoolVector(t6.length);
      if (!n7) throw Error("Unable to allocate new bool vector on heap.");
      for (const e7 of t6) this.i._addBoolVectorEntry(n7, e7);
      this.i._addBoolVectorToInputSidePacket(n7, e6);
    });
  }
  addDoubleVectorToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      const n7 = this.i._allocateDoubleVector(t6.length);
      if (!n7) throw Error("Unable to allocate new double vector on heap.");
      for (const e7 of t6) this.i._addDoubleVectorEntry(n7, e7);
      this.i._addDoubleVectorToInputSidePacket(n7, e6);
    });
  }
  addFloatVectorToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      const n7 = this.i._allocateFloatVector(t6.length);
      if (!n7) throw Error("Unable to allocate new float vector on heap.");
      for (const e7 of t6) this.i._addFloatVectorEntry(n7, e7);
      this.i._addFloatVectorToInputSidePacket(n7, e6);
    });
  }
  addIntVectorToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      const n7 = this.i._allocateIntVector(t6.length);
      if (!n7) throw Error("Unable to allocate new int vector on heap.");
      for (const e7 of t6) this.i._addIntVectorEntry(n7, e7);
      this.i._addIntVectorToInputSidePacket(n7, e6);
    });
  }
  addUintVectorToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      const n7 = this.i._allocateUintVector(t6.length);
      if (!n7) throw Error("Unable to allocate new unsigned int vector on heap.");
      for (const e7 of t6) this.i._addUintVectorEntry(n7, e7);
      this.i._addUintVectorToInputSidePacket(n7, e6);
    });
  }
  addStringVectorToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      const n7 = this.i._allocateStringVector(t6.length);
      if (!n7) throw Error("Unable to allocate new string vector on heap.");
      for (const e7 of t6) Ko(this, e7, (t7) => {
        this.i._addStringVectorEntry(n7, t7);
      });
      this.i._addStringVectorToInputSidePacket(n7, e6);
    });
  }
  attachBoolListener(t6, e5) {
    qo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachBoolListener(t7);
    });
  }
  attachBoolVectorListener(t6, e5) {
    Jo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachBoolVectorListener(t7);
    });
  }
  attachIntListener(t6, e5) {
    qo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachIntListener(t7);
    });
  }
  attachIntVectorListener(t6, e5) {
    Jo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachIntVectorListener(t7);
    });
  }
  attachUintListener(t6, e5) {
    qo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachUintListener(t7);
    });
  }
  attachUintVectorListener(t6, e5) {
    Jo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachUintVectorListener(t7);
    });
  }
  attachDoubleListener(t6, e5) {
    qo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachDoubleListener(t7);
    });
  }
  attachDoubleVectorListener(t6, e5) {
    Jo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachDoubleVectorListener(t7);
    });
  }
  attachFloatListener(t6, e5) {
    qo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachFloatListener(t7);
    });
  }
  attachFloatVectorListener(t6, e5) {
    Jo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachFloatVectorListener(t7);
    });
  }
  attachStringListener(t6, e5) {
    qo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachStringListener(t7);
    });
  }
  attachStringVectorListener(t6, e5) {
    Jo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachStringVectorListener(t7);
    });
  }
  attachProtoListener(t6, e5, n7) {
    qo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachProtoListener(t7, n7 || false);
    });
  }
  attachProtoVectorListener(t6, e5, n7) {
    Jo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachProtoVectorListener(t7, n7 || false);
    });
  }
  attachAudioListener(t6, e5, n7) {
    this.i._attachAudioListener || console.warn('Attempting to use attachAudioListener without support for output audio. Is build dep ":gl_graph_runner_audio_out" missing?'), qo(this, t6, (t7, n8) => {
      t7 = new Float32Array(t7.buffer, t7.byteOffset, t7.length / 4), e5(t7, n8);
    }), Ko(this, t6, (t7) => {
      this.i._attachAudioListener(t7, n7 || false);
    });
  }
  finishProcessing() {
    this.i._waitUntilIdle();
  }
  closeGraph() {
    this.i._closeGraph(), this.i.simpleListeners = void 0, this.i.emptyPacketListeners = void 0;
  }
}, class extends Ja {
  get ha() {
    return this.i;
  }
  sa(t6, e5, n7) {
    Ko(this, e5, (e6) => {
      const [r5, i4] = Yo(this, t6, e6);
      this.ha._addBoundTextureAsImageToStream(e6, r5, i4, n7);
    });
  }
  W(t6, e5) {
    qo(this, t6, e5), Ko(this, t6, (t7) => {
      this.ha._attachImageListener(t7);
    });
  }
  da(t6, e5) {
    Jo(this, t6, e5), Ko(this, t6, (t7) => {
      this.ha._attachImageVectorListener(t7);
    });
  }
}));
var Ja;
var Za = class extends qa {
};
async function Qa(t6, e5, n7) {
  return async function(t7, e6, n8, r5) {
    return Zo(t7, e6, n8, r5);
  }(t6, n7.canvas ?? (Ho() ? void 0 : document.createElement("canvas")), e5, n7);
}
function th(t6, e5, n7, r5) {
  if (t6.V) {
    const s3 = new fs();
    if (n7?.regionOfInterest) {
      if (!t6.ra) throw Error("This task doesn't support region-of-interest.");
      var i4 = n7.regionOfInterest;
      if (i4.left >= i4.right || i4.top >= i4.bottom) throw Error("Expected RectF with left < right and top < bottom.");
      if (0 > i4.left || 0 > i4.top || 1 < i4.right || 1 < i4.bottom) throw Error("Expected RectF values to be in [0,1].");
      Hn(s3, 1, (i4.left + i4.right) / 2), Hn(s3, 2, (i4.top + i4.bottom) / 2), Hn(s3, 4, i4.right - i4.left), Hn(s3, 3, i4.bottom - i4.top);
    } else Hn(s3, 1, 0.5), Hn(s3, 2, 0.5), Hn(s3, 4, 1), Hn(s3, 3, 1);
    if (n7?.rotationDegrees) {
      if (0 != n7?.rotationDegrees % 90) throw Error("Expected rotation to be a multiple of 90\xB0.");
      if (Hn(s3, 5, -Math.PI * n7.rotationDegrees / 180), 0 != n7?.rotationDegrees % 180) {
        const [t7, r6] = zo(e5);
        n7 = Gn(s3, 3) * r6 / t7, i4 = Gn(s3, 4) * t7 / r6, Hn(s3, 4, n7), Hn(s3, 3, i4);
      }
    }
    t6.g.addProtoToStream(s3.g(), "mediapipe.NormalizedRect", t6.V, r5);
  }
  t6.g.sa(e5, t6.ba, r5 ?? performance.now()), t6.finishProcessing();
}
function eh(t6, e5, n7) {
  if (t6.baseOptions?.g()) throw Error("Task is not initialized with image mode. 'runningMode' must be set to 'IMAGE'.");
  th(t6, e5, n7, t6.J + 1);
}
function nh(t6, e5, n7, r5) {
  if (!t6.baseOptions?.g()) throw Error("Task is not initialized with video mode. 'runningMode' must be set to 'VIDEO'.");
  th(t6, e5, n7, r5);
}
function rh(t6, e5, n7, r5) {
  var i4 = e5.data;
  const s3 = e5.width, o5 = s3 * (e5 = e5.height);
  if ((i4 instanceof Uint8Array || i4 instanceof Float32Array) && i4.length !== o5) throw Error("Unsupported channel count: " + i4.length / o5);
  return t6 = new Sa([i4], n7, false, t6.g.i.canvas, t6.M, s3, e5), r5 ? t6.clone() : t6;
}
var ih = class extends sa {
  constructor(t6, e5, n7, r5) {
    super(t6), this.g = t6, this.ba = e5, this.V = n7, this.ra = r5, this.M = new ga();
  }
  l(t6, e5 = true) {
    if ("runningMode" in t6 && Vn(this.baseOptions, 2, !!t6.runningMode && "IMAGE" !== t6.runningMode), void 0 !== t6.canvas && this.g.i.canvas !== t6.canvas) throw Error("You must create a new task to reset the canvas.");
    return super.l(t6, e5);
  }
  close() {
    this.M.close(), super.close();
  }
};
ih.prototype.close = ih.prototype.close;
var sh = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "image_in", "norm_rect_in", false), this.j = { detections: [] }, Cn(t6 = this.h = new Is(), 0, 1, e5 = new Cs()), Hn(this.h, 2, 0.5), Hn(this.h, 3, 0.3);
  }
  get baseOptions() {
    return Rn(this.h, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.h, 0, 1, t6);
  }
  o(t6) {
    return "minDetectionConfidence" in t6 && Hn(this.h, 2, t6.minDetectionConfidence ?? 0.5), "minSuppressionThreshold" in t6 && Hn(this.h, 3, t6.minSuppressionThreshold ?? 0.3), this.l(t6);
  }
  F(t6, e5) {
    return this.j = { detections: [] }, eh(this, t6, e5), this.j;
  }
  G(t6, e5, n7) {
    return this.j = { detections: [] }, nh(this, t6, n7, e5), this.j;
  }
  m() {
    var t6 = new Di();
    Ii(t6, "image_in"), Ii(t6, "norm_rect_in"), Ui(t6, "detections");
    const e5 = new yi();
    Wn(e5, Ds, this.h);
    const n7 = new Li();
    ki(n7, "mediapipe.tasks.vision.face_detector.FaceDetectorGraph"), xi(n7, "IMAGE:image_in"), xi(n7, "NORM_RECT:norm_rect_in"), Si(n7, "DETECTIONS:detections"), n7.o(e5), Oi(t6, n7), this.g.attachProtoVectorListener("detections", (t7, e6) => {
      for (const e7 of t7) t7 = ns(e7), this.j.detections.push(Oo(t7));
      ea(this, e6);
    }), this.g.attachEmptyPacketListener("detections", (t7) => {
      ea(this, t7);
    }), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
sh.prototype.detectForVideo = sh.prototype.G, sh.prototype.detect = sh.prototype.F, sh.prototype.setOptions = sh.prototype.o, sh.createFromModelPath = async function(t6, e5) {
  return Qa(sh, t6, { baseOptions: { modelAssetPath: e5 } });
}, sh.createFromModelBuffer = function(t6, e5) {
  return Qa(sh, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, sh.createFromOptions = function(t6, e5) {
  return Qa(sh, t6, e5);
};
var oh = $a([61, 146], [146, 91], [91, 181], [181, 84], [84, 17], [17, 314], [314, 405], [405, 321], [321, 375], [375, 291], [61, 185], [185, 40], [40, 39], [39, 37], [37, 0], [0, 267], [267, 269], [269, 270], [270, 409], [409, 291], [78, 95], [95, 88], [88, 178], [178, 87], [87, 14], [14, 317], [317, 402], [402, 318], [318, 324], [324, 308], [78, 191], [191, 80], [80, 81], [81, 82], [82, 13], [13, 312], [312, 311], [311, 310], [310, 415], [415, 308]);
var ah = $a([263, 249], [249, 390], [390, 373], [373, 374], [374, 380], [380, 381], [381, 382], [382, 362], [263, 466], [466, 388], [388, 387], [387, 386], [386, 385], [385, 384], [384, 398], [398, 362]);
var hh = $a([276, 283], [283, 282], [282, 295], [295, 285], [300, 293], [293, 334], [334, 296], [296, 336]);
var ch = $a([474, 475], [475, 476], [476, 477], [477, 474]);
var uh = $a([33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [33, 246], [246, 161], [161, 160], [160, 159], [159, 158], [158, 157], [157, 173], [173, 133]);
var lh = $a([46, 53], [53, 52], [52, 65], [65, 55], [70, 63], [63, 105], [105, 66], [66, 107]);
var dh = $a([469, 470], [470, 471], [471, 472], [472, 469]);
var fh = $a([10, 338], [338, 297], [297, 332], [332, 284], [284, 251], [251, 389], [389, 356], [356, 454], [454, 323], [323, 361], [361, 288], [288, 397], [397, 365], [365, 379], [379, 378], [378, 400], [400, 377], [377, 152], [152, 148], [148, 176], [176, 149], [149, 150], [150, 136], [136, 172], [172, 58], [58, 132], [132, 93], [93, 234], [234, 127], [127, 162], [162, 21], [21, 54], [54, 103], [103, 67], [67, 109], [109, 10]);
var ph = [...oh, ...ah, ...hh, ...uh, ...lh, ...fh];
var gh = $a([127, 34], [34, 139], [139, 127], [11, 0], [0, 37], [37, 11], [232, 231], [231, 120], [120, 232], [72, 37], [37, 39], [39, 72], [128, 121], [121, 47], [47, 128], [232, 121], [121, 128], [128, 232], [104, 69], [69, 67], [67, 104], [175, 171], [171, 148], [148, 175], [118, 50], [50, 101], [101, 118], [73, 39], [39, 40], [40, 73], [9, 151], [151, 108], [108, 9], [48, 115], [115, 131], [131, 48], [194, 204], [204, 211], [211, 194], [74, 40], [40, 185], [185, 74], [80, 42], [42, 183], [183, 80], [40, 92], [92, 186], [186, 40], [230, 229], [229, 118], [118, 230], [202, 212], [212, 214], [214, 202], [83, 18], [18, 17], [17, 83], [76, 61], [61, 146], [146, 76], [160, 29], [29, 30], [30, 160], [56, 157], [157, 173], [173, 56], [106, 204], [204, 194], [194, 106], [135, 214], [214, 192], [192, 135], [203, 165], [165, 98], [98, 203], [21, 71], [71, 68], [68, 21], [51, 45], [45, 4], [4, 51], [144, 24], [24, 23], [23, 144], [77, 146], [146, 91], [91, 77], [205, 50], [50, 187], [187, 205], [201, 200], [200, 18], [18, 201], [91, 106], [106, 182], [182, 91], [90, 91], [91, 181], [181, 90], [85, 84], [84, 17], [17, 85], [206, 203], [203, 36], [36, 206], [148, 171], [171, 140], [140, 148], [92, 40], [40, 39], [39, 92], [193, 189], [189, 244], [244, 193], [159, 158], [158, 28], [28, 159], [247, 246], [246, 161], [161, 247], [236, 3], [3, 196], [196, 236], [54, 68], [68, 104], [104, 54], [193, 168], [168, 8], [8, 193], [117, 228], [228, 31], [31, 117], [189, 193], [193, 55], [55, 189], [98, 97], [97, 99], [99, 98], [126, 47], [47, 100], [100, 126], [166, 79], [79, 218], [218, 166], [155, 154], [154, 26], [26, 155], [209, 49], [49, 131], [131, 209], [135, 136], [136, 150], [150, 135], [47, 126], [126, 217], [217, 47], [223, 52], [52, 53], [53, 223], [45, 51], [51, 134], [134, 45], [211, 170], [170, 140], [140, 211], [67, 69], [69, 108], [108, 67], [43, 106], [106, 91], [91, 43], [230, 119], [119, 120], [120, 230], [226, 130], [130, 247], [247, 226], [63, 53], [53, 52], [52, 63], [238, 20], [20, 242], [242, 238], [46, 70], [70, 156], [156, 46], [78, 62], [62, 96], [96, 78], [46, 53], [53, 63], [63, 46], [143, 34], [34, 227], [227, 143], [123, 117], [117, 111], [111, 123], [44, 125], [125, 19], [19, 44], [236, 134], [134, 51], [51, 236], [216, 206], [206, 205], [205, 216], [154, 153], [153, 22], [22, 154], [39, 37], [37, 167], [167, 39], [200, 201], [201, 208], [208, 200], [36, 142], [142, 100], [100, 36], [57, 212], [212, 202], [202, 57], [20, 60], [60, 99], [99, 20], [28, 158], [158, 157], [157, 28], [35, 226], [226, 113], [113, 35], [160, 159], [159, 27], [27, 160], [204, 202], [202, 210], [210, 204], [113, 225], [225, 46], [46, 113], [43, 202], [202, 204], [204, 43], [62, 76], [76, 77], [77, 62], [137, 123], [123, 116], [116, 137], [41, 38], [38, 72], [72, 41], [203, 129], [129, 142], [142, 203], [64, 98], [98, 240], [240, 64], [49, 102], [102, 64], [64, 49], [41, 73], [73, 74], [74, 41], [212, 216], [216, 207], [207, 212], [42, 74], [74, 184], [184, 42], [169, 170], [170, 211], [211, 169], [170, 149], [149, 176], [176, 170], [105, 66], [66, 69], [69, 105], [122, 6], [6, 168], [168, 122], [123, 147], [147, 187], [187, 123], [96, 77], [77, 90], [90, 96], [65, 55], [55, 107], [107, 65], [89, 90], [90, 180], [180, 89], [101, 100], [100, 120], [120, 101], [63, 105], [105, 104], [104, 63], [93, 137], [137, 227], [227, 93], [15, 86], [86, 85], [85, 15], [129, 102], [102, 49], [49, 129], [14, 87], [87, 86], [86, 14], [55, 8], [8, 9], [9, 55], [100, 47], [47, 121], [121, 100], [145, 23], [23, 22], [22, 145], [88, 89], [89, 179], [179, 88], [6, 122], [122, 196], [196, 6], [88, 95], [95, 96], [96, 88], [138, 172], [172, 136], [136, 138], [215, 58], [58, 172], [172, 215], [115, 48], [48, 219], [219, 115], [42, 80], [80, 81], [81, 42], [195, 3], [3, 51], [51, 195], [43, 146], [146, 61], [61, 43], [171, 175], [175, 199], [199, 171], [81, 82], [82, 38], [38, 81], [53, 46], [46, 225], [225, 53], [144, 163], [163, 110], [110, 144], [52, 65], [65, 66], [66, 52], [229, 228], [228, 117], [117, 229], [34, 127], [127, 234], [234, 34], [107, 108], [108, 69], [69, 107], [109, 108], [108, 151], [151, 109], [48, 64], [64, 235], [235, 48], [62, 78], [78, 191], [191, 62], [129, 209], [209, 126], [126, 129], [111, 35], [35, 143], [143, 111], [117, 123], [123, 50], [50, 117], [222, 65], [65, 52], [52, 222], [19, 125], [125, 141], [141, 19], [221, 55], [55, 65], [65, 221], [3, 195], [195, 197], [197, 3], [25, 7], [7, 33], [33, 25], [220, 237], [237, 44], [44, 220], [70, 71], [71, 139], [139, 70], [122, 193], [193, 245], [245, 122], [247, 130], [130, 33], [33, 247], [71, 21], [21, 162], [162, 71], [170, 169], [169, 150], [150, 170], [188, 174], [174, 196], [196, 188], [216, 186], [186, 92], [92, 216], [2, 97], [97, 167], [167, 2], [141, 125], [125, 241], [241, 141], [164, 167], [167, 37], [37, 164], [72, 38], [38, 12], [12, 72], [38, 82], [82, 13], [13, 38], [63, 68], [68, 71], [71, 63], [226, 35], [35, 111], [111, 226], [101, 50], [50, 205], [205, 101], [206, 92], [92, 165], [165, 206], [209, 198], [198, 217], [217, 209], [165, 167], [167, 97], [97, 165], [220, 115], [115, 218], [218, 220], [133, 112], [112, 243], [243, 133], [239, 238], [238, 241], [241, 239], [214, 135], [135, 169], [169, 214], [190, 173], [173, 133], [133, 190], [171, 208], [208, 32], [32, 171], [125, 44], [44, 237], [237, 125], [86, 87], [87, 178], [178, 86], [85, 86], [86, 179], [179, 85], [84, 85], [85, 180], [180, 84], [83, 84], [84, 181], [181, 83], [201, 83], [83, 182], [182, 201], [137, 93], [93, 132], [132, 137], [76, 62], [62, 183], [183, 76], [61, 76], [76, 184], [184, 61], [57, 61], [61, 185], [185, 57], [212, 57], [57, 186], [186, 212], [214, 207], [207, 187], [187, 214], [34, 143], [143, 156], [156, 34], [79, 239], [239, 237], [237, 79], [123, 137], [137, 177], [177, 123], [44, 1], [1, 4], [4, 44], [201, 194], [194, 32], [32, 201], [64, 102], [102, 129], [129, 64], [213, 215], [215, 138], [138, 213], [59, 166], [166, 219], [219, 59], [242, 99], [99, 97], [97, 242], [2, 94], [94, 141], [141, 2], [75, 59], [59, 235], [235, 75], [24, 110], [110, 228], [228, 24], [25, 130], [130, 226], [226, 25], [23, 24], [24, 229], [229, 23], [22, 23], [23, 230], [230, 22], [26, 22], [22, 231], [231, 26], [112, 26], [26, 232], [232, 112], [189, 190], [190, 243], [243, 189], [221, 56], [56, 190], [190, 221], [28, 56], [56, 221], [221, 28], [27, 28], [28, 222], [222, 27], [29, 27], [27, 223], [223, 29], [30, 29], [29, 224], [224, 30], [247, 30], [30, 225], [225, 247], [238, 79], [79, 20], [20, 238], [166, 59], [59, 75], [75, 166], [60, 75], [75, 240], [240, 60], [147, 177], [177, 215], [215, 147], [20, 79], [79, 166], [166, 20], [187, 147], [147, 213], [213, 187], [112, 233], [233, 244], [244, 112], [233, 128], [128, 245], [245, 233], [128, 114], [114, 188], [188, 128], [114, 217], [217, 174], [174, 114], [131, 115], [115, 220], [220, 131], [217, 198], [198, 236], [236, 217], [198, 131], [131, 134], [134, 198], [177, 132], [132, 58], [58, 177], [143, 35], [35, 124], [124, 143], [110, 163], [163, 7], [7, 110], [228, 110], [110, 25], [25, 228], [356, 389], [389, 368], [368, 356], [11, 302], [302, 267], [267, 11], [452, 350], [350, 349], [349, 452], [302, 303], [303, 269], [269, 302], [357, 343], [343, 277], [277, 357], [452, 453], [453, 357], [357, 452], [333, 332], [332, 297], [297, 333], [175, 152], [152, 377], [377, 175], [347, 348], [348, 330], [330, 347], [303, 304], [304, 270], [270, 303], [9, 336], [336, 337], [337, 9], [278, 279], [279, 360], [360, 278], [418, 262], [262, 431], [431, 418], [304, 408], [408, 409], [409, 304], [310, 415], [415, 407], [407, 310], [270, 409], [409, 410], [410, 270], [450, 348], [348, 347], [347, 450], [422, 430], [430, 434], [434, 422], [313, 314], [314, 17], [17, 313], [306, 307], [307, 375], [375, 306], [387, 388], [388, 260], [260, 387], [286, 414], [414, 398], [398, 286], [335, 406], [406, 418], [418, 335], [364, 367], [367, 416], [416, 364], [423, 358], [358, 327], [327, 423], [251, 284], [284, 298], [298, 251], [281, 5], [5, 4], [4, 281], [373, 374], [374, 253], [253, 373], [307, 320], [320, 321], [321, 307], [425, 427], [427, 411], [411, 425], [421, 313], [313, 18], [18, 421], [321, 405], [405, 406], [406, 321], [320, 404], [404, 405], [405, 320], [315, 16], [16, 17], [17, 315], [426, 425], [425, 266], [266, 426], [377, 400], [400, 369], [369, 377], [322, 391], [391, 269], [269, 322], [417, 465], [465, 464], [464, 417], [386, 257], [257, 258], [258, 386], [466, 260], [260, 388], [388, 466], [456, 399], [399, 419], [419, 456], [284, 332], [332, 333], [333, 284], [417, 285], [285, 8], [8, 417], [346, 340], [340, 261], [261, 346], [413, 441], [441, 285], [285, 413], [327, 460], [460, 328], [328, 327], [355, 371], [371, 329], [329, 355], [392, 439], [439, 438], [438, 392], [382, 341], [341, 256], [256, 382], [429, 420], [420, 360], [360, 429], [364, 394], [394, 379], [379, 364], [277, 343], [343, 437], [437, 277], [443, 444], [444, 283], [283, 443], [275, 440], [440, 363], [363, 275], [431, 262], [262, 369], [369, 431], [297, 338], [338, 337], [337, 297], [273, 375], [375, 321], [321, 273], [450, 451], [451, 349], [349, 450], [446, 342], [342, 467], [467, 446], [293, 334], [334, 282], [282, 293], [458, 461], [461, 462], [462, 458], [276, 353], [353, 383], [383, 276], [308, 324], [324, 325], [325, 308], [276, 300], [300, 293], [293, 276], [372, 345], [345, 447], [447, 372], [352, 345], [345, 340], [340, 352], [274, 1], [1, 19], [19, 274], [456, 248], [248, 281], [281, 456], [436, 427], [427, 425], [425, 436], [381, 256], [256, 252], [252, 381], [269, 391], [391, 393], [393, 269], [200, 199], [199, 428], [428, 200], [266, 330], [330, 329], [329, 266], [287, 273], [273, 422], [422, 287], [250, 462], [462, 328], [328, 250], [258, 286], [286, 384], [384, 258], [265, 353], [353, 342], [342, 265], [387, 259], [259, 257], [257, 387], [424, 431], [431, 430], [430, 424], [342, 353], [353, 276], [276, 342], [273, 335], [335, 424], [424, 273], [292, 325], [325, 307], [307, 292], [366, 447], [447, 345], [345, 366], [271, 303], [303, 302], [302, 271], [423, 266], [266, 371], [371, 423], [294, 455], [455, 460], [460, 294], [279, 278], [278, 294], [294, 279], [271, 272], [272, 304], [304, 271], [432, 434], [434, 427], [427, 432], [272, 407], [407, 408], [408, 272], [394, 430], [430, 431], [431, 394], [395, 369], [369, 400], [400, 395], [334, 333], [333, 299], [299, 334], [351, 417], [417, 168], [168, 351], [352, 280], [280, 411], [411, 352], [325, 319], [319, 320], [320, 325], [295, 296], [296, 336], [336, 295], [319, 403], [403, 404], [404, 319], [330, 348], [348, 349], [349, 330], [293, 298], [298, 333], [333, 293], [323, 454], [454, 447], [447, 323], [15, 16], [16, 315], [315, 15], [358, 429], [429, 279], [279, 358], [14, 15], [15, 316], [316, 14], [285, 336], [336, 9], [9, 285], [329, 349], [349, 350], [350, 329], [374, 380], [380, 252], [252, 374], [318, 402], [402, 403], [403, 318], [6, 197], [197, 419], [419, 6], [318, 319], [319, 325], [325, 318], [367, 364], [364, 365], [365, 367], [435, 367], [367, 397], [397, 435], [344, 438], [438, 439], [439, 344], [272, 271], [271, 311], [311, 272], [195, 5], [5, 281], [281, 195], [273, 287], [287, 291], [291, 273], [396, 428], [428, 199], [199, 396], [311, 271], [271, 268], [268, 311], [283, 444], [444, 445], [445, 283], [373, 254], [254, 339], [339, 373], [282, 334], [334, 296], [296, 282], [449, 347], [347, 346], [346, 449], [264, 447], [447, 454], [454, 264], [336, 296], [296, 299], [299, 336], [338, 10], [10, 151], [151, 338], [278, 439], [439, 455], [455, 278], [292, 407], [407, 415], [415, 292], [358, 371], [371, 355], [355, 358], [340, 345], [345, 372], [372, 340], [346, 347], [347, 280], [280, 346], [442, 443], [443, 282], [282, 442], [19, 94], [94, 370], [370, 19], [441, 442], [442, 295], [295, 441], [248, 419], [419, 197], [197, 248], [263, 255], [255, 359], [359, 263], [440, 275], [275, 274], [274, 440], [300, 383], [383, 368], [368, 300], [351, 412], [412, 465], [465, 351], [263, 467], [467, 466], [466, 263], [301, 368], [368, 389], [389, 301], [395, 378], [378, 379], [379, 395], [412, 351], [351, 419], [419, 412], [436, 426], [426, 322], [322, 436], [2, 164], [164, 393], [393, 2], [370, 462], [462, 461], [461, 370], [164, 0], [0, 267], [267, 164], [302, 11], [11, 12], [12, 302], [268, 12], [12, 13], [13, 268], [293, 300], [300, 301], [301, 293], [446, 261], [261, 340], [340, 446], [330, 266], [266, 425], [425, 330], [426, 423], [423, 391], [391, 426], [429, 355], [355, 437], [437, 429], [391, 327], [327, 326], [326, 391], [440, 457], [457, 438], [438, 440], [341, 382], [382, 362], [362, 341], [459, 457], [457, 461], [461, 459], [434, 430], [430, 394], [394, 434], [414, 463], [463, 362], [362, 414], [396, 369], [369, 262], [262, 396], [354, 461], [461, 457], [457, 354], [316, 403], [403, 402], [402, 316], [315, 404], [404, 403], [403, 315], [314, 405], [405, 404], [404, 314], [313, 406], [406, 405], [405, 313], [421, 418], [418, 406], [406, 421], [366, 401], [401, 361], [361, 366], [306, 408], [408, 407], [407, 306], [291, 409], [409, 408], [408, 291], [287, 410], [410, 409], [409, 287], [432, 436], [436, 410], [410, 432], [434, 416], [416, 411], [411, 434], [264, 368], [368, 383], [383, 264], [309, 438], [438, 457], [457, 309], [352, 376], [376, 401], [401, 352], [274, 275], [275, 4], [4, 274], [421, 428], [428, 262], [262, 421], [294, 327], [327, 358], [358, 294], [433, 416], [416, 367], [367, 433], [289, 455], [455, 439], [439, 289], [462, 370], [370, 326], [326, 462], [2, 326], [326, 370], [370, 2], [305, 460], [460, 455], [455, 305], [254, 449], [449, 448], [448, 254], [255, 261], [261, 446], [446, 255], [253, 450], [450, 449], [449, 253], [252, 451], [451, 450], [450, 252], [256, 452], [452, 451], [451, 256], [341, 453], [453, 452], [452, 341], [413, 464], [464, 463], [463, 413], [441, 413], [413, 414], [414, 441], [258, 442], [442, 441], [441, 258], [257, 443], [443, 442], [442, 257], [259, 444], [444, 443], [443, 259], [260, 445], [445, 444], [444, 260], [467, 342], [342, 445], [445, 467], [459, 458], [458, 250], [250, 459], [289, 392], [392, 290], [290, 289], [290, 328], [328, 460], [460, 290], [376, 433], [433, 435], [435, 376], [250, 290], [290, 392], [392, 250], [411, 416], [416, 433], [433, 411], [341, 463], [463, 464], [464, 341], [453, 464], [464, 465], [465, 453], [357, 465], [465, 412], [412, 357], [343, 412], [412, 399], [399, 343], [360, 363], [363, 440], [440, 360], [437, 399], [399, 456], [456, 437], [420, 456], [456, 363], [363, 420], [401, 435], [435, 288], [288, 401], [372, 383], [383, 353], [353, 372], [339, 255], [255, 249], [249, 339], [448, 261], [261, 255], [255, 448], [133, 243], [243, 190], [190, 133], [133, 155], [155, 112], [112, 133], [33, 246], [246, 247], [247, 33], [33, 130], [130, 25], [25, 33], [398, 384], [384, 286], [286, 398], [362, 398], [398, 414], [414, 362], [362, 463], [463, 341], [341, 362], [263, 359], [359, 467], [467, 263], [263, 249], [249, 255], [255, 263], [466, 467], [467, 260], [260, 466], [75, 60], [60, 166], [166, 75], [238, 239], [239, 79], [79, 238], [162, 127], [127, 139], [139, 162], [72, 11], [11, 37], [37, 72], [121, 232], [232, 120], [120, 121], [73, 72], [72, 39], [39, 73], [114, 128], [128, 47], [47, 114], [233, 232], [232, 128], [128, 233], [103, 104], [104, 67], [67, 103], [152, 175], [175, 148], [148, 152], [119, 118], [118, 101], [101, 119], [74, 73], [73, 40], [40, 74], [107, 9], [9, 108], [108, 107], [49, 48], [48, 131], [131, 49], [32, 194], [194, 211], [211, 32], [184, 74], [74, 185], [185, 184], [191, 80], [80, 183], [183, 191], [185, 40], [40, 186], [186, 185], [119, 230], [230, 118], [118, 119], [210, 202], [202, 214], [214, 210], [84, 83], [83, 17], [17, 84], [77, 76], [76, 146], [146, 77], [161, 160], [160, 30], [30, 161], [190, 56], [56, 173], [173, 190], [182, 106], [106, 194], [194, 182], [138, 135], [135, 192], [192, 138], [129, 203], [203, 98], [98, 129], [54, 21], [21, 68], [68, 54], [5, 51], [51, 4], [4, 5], [145, 144], [144, 23], [23, 145], [90, 77], [77, 91], [91, 90], [207, 205], [205, 187], [187, 207], [83, 201], [201, 18], [18, 83], [181, 91], [91, 182], [182, 181], [180, 90], [90, 181], [181, 180], [16, 85], [85, 17], [17, 16], [205, 206], [206, 36], [36, 205], [176, 148], [148, 140], [140, 176], [165, 92], [92, 39], [39, 165], [245, 193], [193, 244], [244, 245], [27, 159], [159, 28], [28, 27], [30, 247], [247, 161], [161, 30], [174, 236], [236, 196], [196, 174], [103, 54], [54, 104], [104, 103], [55, 193], [193, 8], [8, 55], [111, 117], [117, 31], [31, 111], [221, 189], [189, 55], [55, 221], [240, 98], [98, 99], [99, 240], [142, 126], [126, 100], [100, 142], [219, 166], [166, 218], [218, 219], [112, 155], [155, 26], [26, 112], [198, 209], [209, 131], [131, 198], [169, 135], [135, 150], [150, 169], [114, 47], [47, 217], [217, 114], [224, 223], [223, 53], [53, 224], [220, 45], [45, 134], [134, 220], [32, 211], [211, 140], [140, 32], [109, 67], [67, 108], [108, 109], [146, 43], [43, 91], [91, 146], [231, 230], [230, 120], [120, 231], [113, 226], [226, 247], [247, 113], [105, 63], [63, 52], [52, 105], [241, 238], [238, 242], [242, 241], [124, 46], [46, 156], [156, 124], [95, 78], [78, 96], [96, 95], [70, 46], [46, 63], [63, 70], [116, 143], [143, 227], [227, 116], [116, 123], [123, 111], [111, 116], [1, 44], [44, 19], [19, 1], [3, 236], [236, 51], [51, 3], [207, 216], [216, 205], [205, 207], [26, 154], [154, 22], [22, 26], [165, 39], [39, 167], [167, 165], [199, 200], [200, 208], [208, 199], [101, 36], [36, 100], [100, 101], [43, 57], [57, 202], [202, 43], [242, 20], [20, 99], [99, 242], [56, 28], [28, 157], [157, 56], [124, 35], [35, 113], [113, 124], [29, 160], [160, 27], [27, 29], [211, 204], [204, 210], [210, 211], [124, 113], [113, 46], [46, 124], [106, 43], [43, 204], [204, 106], [96, 62], [62, 77], [77, 96], [227, 137], [137, 116], [116, 227], [73, 41], [41, 72], [72, 73], [36, 203], [203, 142], [142, 36], [235, 64], [64, 240], [240, 235], [48, 49], [49, 64], [64, 48], [42, 41], [41, 74], [74, 42], [214, 212], [212, 207], [207, 214], [183, 42], [42, 184], [184, 183], [210, 169], [169, 211], [211, 210], [140, 170], [170, 176], [176, 140], [104, 105], [105, 69], [69, 104], [193, 122], [122, 168], [168, 193], [50, 123], [123, 187], [187, 50], [89, 96], [96, 90], [90, 89], [66, 65], [65, 107], [107, 66], [179, 89], [89, 180], [180, 179], [119, 101], [101, 120], [120, 119], [68, 63], [63, 104], [104, 68], [234, 93], [93, 227], [227, 234], [16, 15], [15, 85], [85, 16], [209, 129], [129, 49], [49, 209], [15, 14], [14, 86], [86, 15], [107, 55], [55, 9], [9, 107], [120, 100], [100, 121], [121, 120], [153, 145], [145, 22], [22, 153], [178, 88], [88, 179], [179, 178], [197, 6], [6, 196], [196, 197], [89, 88], [88, 96], [96, 89], [135, 138], [138, 136], [136, 135], [138, 215], [215, 172], [172, 138], [218, 115], [115, 219], [219, 218], [41, 42], [42, 81], [81, 41], [5, 195], [195, 51], [51, 5], [57, 43], [43, 61], [61, 57], [208, 171], [171, 199], [199, 208], [41, 81], [81, 38], [38, 41], [224, 53], [53, 225], [225, 224], [24, 144], [144, 110], [110, 24], [105, 52], [52, 66], [66, 105], [118, 229], [229, 117], [117, 118], [227, 34], [34, 234], [234, 227], [66, 107], [107, 69], [69, 66], [10, 109], [109, 151], [151, 10], [219, 48], [48, 235], [235, 219], [183, 62], [62, 191], [191, 183], [142, 129], [129, 126], [126, 142], [116, 111], [111, 143], [143, 116], [118, 117], [117, 50], [50, 118], [223, 222], [222, 52], [52, 223], [94, 19], [19, 141], [141, 94], [222, 221], [221, 65], [65, 222], [196, 3], [3, 197], [197, 196], [45, 220], [220, 44], [44, 45], [156, 70], [70, 139], [139, 156], [188, 122], [122, 245], [245, 188], [139, 71], [71, 162], [162, 139], [149, 170], [170, 150], [150, 149], [122, 188], [188, 196], [196, 122], [206, 216], [216, 92], [92, 206], [164, 2], [2, 167], [167, 164], [242, 141], [141, 241], [241, 242], [0, 164], [164, 37], [37, 0], [11, 72], [72, 12], [12, 11], [12, 38], [38, 13], [13, 12], [70, 63], [63, 71], [71, 70], [31, 226], [226, 111], [111, 31], [36, 101], [101, 205], [205, 36], [203, 206], [206, 165], [165, 203], [126, 209], [209, 217], [217, 126], [98, 165], [165, 97], [97, 98], [237, 220], [220, 218], [218, 237], [237, 239], [239, 241], [241, 237], [210, 214], [214, 169], [169, 210], [140, 171], [171, 32], [32, 140], [241, 125], [125, 237], [237, 241], [179, 86], [86, 178], [178, 179], [180, 85], [85, 179], [179, 180], [181, 84], [84, 180], [180, 181], [182, 83], [83, 181], [181, 182], [194, 201], [201, 182], [182, 194], [177, 137], [137, 132], [132, 177], [184, 76], [76, 183], [183, 184], [185, 61], [61, 184], [184, 185], [186, 57], [57, 185], [185, 186], [216, 212], [212, 186], [186, 216], [192, 214], [214, 187], [187, 192], [139, 34], [34, 156], [156, 139], [218, 79], [79, 237], [237, 218], [147, 123], [123, 177], [177, 147], [45, 44], [44, 4], [4, 45], [208, 201], [201, 32], [32, 208], [98, 64], [64, 129], [129, 98], [192, 213], [213, 138], [138, 192], [235, 59], [59, 219], [219, 235], [141, 242], [242, 97], [97, 141], [97, 2], [2, 141], [141, 97], [240, 75], [75, 235], [235, 240], [229, 24], [24, 228], [228, 229], [31, 25], [25, 226], [226, 31], [230, 23], [23, 229], [229, 230], [231, 22], [22, 230], [230, 231], [232, 26], [26, 231], [231, 232], [233, 112], [112, 232], [232, 233], [244, 189], [189, 243], [243, 244], [189, 221], [221, 190], [190, 189], [222, 28], [28, 221], [221, 222], [223, 27], [27, 222], [222, 223], [224, 29], [29, 223], [223, 224], [225, 30], [30, 224], [224, 225], [113, 247], [247, 225], [225, 113], [99, 60], [60, 240], [240, 99], [213, 147], [147, 215], [215, 213], [60, 20], [20, 166], [166, 60], [192, 187], [187, 213], [213, 192], [243, 112], [112, 244], [244, 243], [244, 233], [233, 245], [245, 244], [245, 128], [128, 188], [188, 245], [188, 114], [114, 174], [174, 188], [134, 131], [131, 220], [220, 134], [174, 217], [217, 236], [236, 174], [236, 198], [198, 134], [134, 236], [215, 177], [177, 58], [58, 215], [156, 143], [143, 124], [124, 156], [25, 110], [110, 7], [7, 25], [31, 228], [228, 25], [25, 31], [264, 356], [356, 368], [368, 264], [0, 11], [11, 267], [267, 0], [451, 452], [452, 349], [349, 451], [267, 302], [302, 269], [269, 267], [350, 357], [357, 277], [277, 350], [350, 452], [452, 357], [357, 350], [299, 333], [333, 297], [297, 299], [396, 175], [175, 377], [377, 396], [280, 347], [347, 330], [330, 280], [269, 303], [303, 270], [270, 269], [151, 9], [9, 337], [337, 151], [344, 278], [278, 360], [360, 344], [424, 418], [418, 431], [431, 424], [270, 304], [304, 409], [409, 270], [272, 310], [310, 407], [407, 272], [322, 270], [270, 410], [410, 322], [449, 450], [450, 347], [347, 449], [432, 422], [422, 434], [434, 432], [18, 313], [313, 17], [17, 18], [291, 306], [306, 375], [375, 291], [259, 387], [387, 260], [260, 259], [424, 335], [335, 418], [418, 424], [434, 364], [364, 416], [416, 434], [391, 423], [423, 327], [327, 391], [301, 251], [251, 298], [298, 301], [275, 281], [281, 4], [4, 275], [254, 373], [373, 253], [253, 254], [375, 307], [307, 321], [321, 375], [280, 425], [425, 411], [411, 280], [200, 421], [421, 18], [18, 200], [335, 321], [321, 406], [406, 335], [321, 320], [320, 405], [405, 321], [314, 315], [315, 17], [17, 314], [423, 426], [426, 266], [266, 423], [396, 377], [377, 369], [369, 396], [270, 322], [322, 269], [269, 270], [413, 417], [417, 464], [464, 413], [385, 386], [386, 258], [258, 385], [248, 456], [456, 419], [419, 248], [298, 284], [284, 333], [333, 298], [168, 417], [417, 8], [8, 168], [448, 346], [346, 261], [261, 448], [417, 413], [413, 285], [285, 417], [326, 327], [327, 328], [328, 326], [277, 355], [355, 329], [329, 277], [309, 392], [392, 438], [438, 309], [381, 382], [382, 256], [256, 381], [279, 429], [429, 360], [360, 279], [365, 364], [364, 379], [379, 365], [355, 277], [277, 437], [437, 355], [282, 443], [443, 283], [283, 282], [281, 275], [275, 363], [363, 281], [395, 431], [431, 369], [369, 395], [299, 297], [297, 337], [337, 299], [335, 273], [273, 321], [321, 335], [348, 450], [450, 349], [349, 348], [359, 446], [446, 467], [467, 359], [283, 293], [293, 282], [282, 283], [250, 458], [458, 462], [462, 250], [300, 276], [276, 383], [383, 300], [292, 308], [308, 325], [325, 292], [283, 276], [276, 293], [293, 283], [264, 372], [372, 447], [447, 264], [346, 352], [352, 340], [340, 346], [354, 274], [274, 19], [19, 354], [363, 456], [456, 281], [281, 363], [426, 436], [436, 425], [425, 426], [380, 381], [381, 252], [252, 380], [267, 269], [269, 393], [393, 267], [421, 200], [200, 428], [428, 421], [371, 266], [266, 329], [329, 371], [432, 287], [287, 422], [422, 432], [290, 250], [250, 328], [328, 290], [385, 258], [258, 384], [384, 385], [446, 265], [265, 342], [342, 446], [386, 387], [387, 257], [257, 386], [422, 424], [424, 430], [430, 422], [445, 342], [342, 276], [276, 445], [422, 273], [273, 424], [424, 422], [306, 292], [292, 307], [307, 306], [352, 366], [366, 345], [345, 352], [268, 271], [271, 302], [302, 268], [358, 423], [423, 371], [371, 358], [327, 294], [294, 460], [460, 327], [331, 279], [279, 294], [294, 331], [303, 271], [271, 304], [304, 303], [436, 432], [432, 427], [427, 436], [304, 272], [272, 408], [408, 304], [395, 394], [394, 431], [431, 395], [378, 395], [395, 400], [400, 378], [296, 334], [334, 299], [299, 296], [6, 351], [351, 168], [168, 6], [376, 352], [352, 411], [411, 376], [307, 325], [325, 320], [320, 307], [285, 295], [295, 336], [336, 285], [320, 319], [319, 404], [404, 320], [329, 330], [330, 349], [349, 329], [334, 293], [293, 333], [333, 334], [366, 323], [323, 447], [447, 366], [316, 15], [15, 315], [315, 316], [331, 358], [358, 279], [279, 331], [317, 14], [14, 316], [316, 317], [8, 285], [285, 9], [9, 8], [277, 329], [329, 350], [350, 277], [253, 374], [374, 252], [252, 253], [319, 318], [318, 403], [403, 319], [351, 6], [6, 419], [419, 351], [324, 318], [318, 325], [325, 324], [397, 367], [367, 365], [365, 397], [288, 435], [435, 397], [397, 288], [278, 344], [344, 439], [439, 278], [310, 272], [272, 311], [311, 310], [248, 195], [195, 281], [281, 248], [375, 273], [273, 291], [291, 375], [175, 396], [396, 199], [199, 175], [312, 311], [311, 268], [268, 312], [276, 283], [283, 445], [445, 276], [390, 373], [373, 339], [339, 390], [295, 282], [282, 296], [296, 295], [448, 449], [449, 346], [346, 448], [356, 264], [264, 454], [454, 356], [337, 336], [336, 299], [299, 337], [337, 338], [338, 151], [151, 337], [294, 278], [278, 455], [455, 294], [308, 292], [292, 415], [415, 308], [429, 358], [358, 355], [355, 429], [265, 340], [340, 372], [372, 265], [352, 346], [346, 280], [280, 352], [295, 442], [442, 282], [282, 295], [354, 19], [19, 370], [370, 354], [285, 441], [441, 295], [295, 285], [195, 248], [248, 197], [197, 195], [457, 440], [440, 274], [274, 457], [301, 300], [300, 368], [368, 301], [417, 351], [351, 465], [465, 417], [251, 301], [301, 389], [389, 251], [394, 395], [395, 379], [379, 394], [399, 412], [412, 419], [419, 399], [410, 436], [436, 322], [322, 410], [326, 2], [2, 393], [393, 326], [354, 370], [370, 461], [461, 354], [393, 164], [164, 267], [267, 393], [268, 302], [302, 12], [12, 268], [312, 268], [268, 13], [13, 312], [298, 293], [293, 301], [301, 298], [265, 446], [446, 340], [340, 265], [280, 330], [330, 425], [425, 280], [322, 426], [426, 391], [391, 322], [420, 429], [429, 437], [437, 420], [393, 391], [391, 326], [326, 393], [344, 440], [440, 438], [438, 344], [458, 459], [459, 461], [461, 458], [364, 434], [434, 394], [394, 364], [428, 396], [396, 262], [262, 428], [274, 354], [354, 457], [457, 274], [317, 316], [316, 402], [402, 317], [316, 315], [315, 403], [403, 316], [315, 314], [314, 404], [404, 315], [314, 313], [313, 405], [405, 314], [313, 421], [421, 406], [406, 313], [323, 366], [366, 361], [361, 323], [292, 306], [306, 407], [407, 292], [306, 291], [291, 408], [408, 306], [291, 287], [287, 409], [409, 291], [287, 432], [432, 410], [410, 287], [427, 434], [434, 411], [411, 427], [372, 264], [264, 383], [383, 372], [459, 309], [309, 457], [457, 459], [366, 352], [352, 401], [401, 366], [1, 274], [274, 4], [4, 1], [418, 421], [421, 262], [262, 418], [331, 294], [294, 358], [358, 331], [435, 433], [433, 367], [367, 435], [392, 289], [289, 439], [439, 392], [328, 462], [462, 326], [326, 328], [94, 2], [2, 370], [370, 94], [289, 305], [305, 455], [455, 289], [339, 254], [254, 448], [448, 339], [359, 255], [255, 446], [446, 359], [254, 253], [253, 449], [449, 254], [253, 252], [252, 450], [450, 253], [252, 256], [256, 451], [451, 252], [256, 341], [341, 452], [452, 256], [414, 413], [413, 463], [463, 414], [286, 441], [441, 414], [414, 286], [286, 258], [258, 441], [441, 286], [258, 257], [257, 442], [442, 258], [257, 259], [259, 443], [443, 257], [259, 260], [260, 444], [444, 259], [260, 467], [467, 445], [445, 260], [309, 459], [459, 250], [250, 309], [305, 289], [289, 290], [290, 305], [305, 290], [290, 460], [460, 305], [401, 376], [376, 435], [435, 401], [309, 250], [250, 392], [392, 309], [376, 411], [411, 433], [433, 376], [453, 341], [341, 464], [464, 453], [357, 453], [453, 465], [465, 357], [343, 357], [357, 412], [412, 343], [437, 343], [343, 399], [399, 437], [344, 360], [360, 440], [440, 344], [420, 437], [437, 456], [456, 420], [360, 420], [420, 363], [363, 360], [361, 401], [401, 288], [288, 361], [265, 372], [372, 353], [353, 265], [390, 339], [339, 249], [249, 390], [339, 448], [448, 255], [255, 339]);
function mh(t6) {
  t6.u = { faceLandmarks: [], faceBlendshapes: [], facialTransformationMatrixes: [] };
}
var yh = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "image_in", "norm_rect", false), this.u = { faceLandmarks: [], faceBlendshapes: [], facialTransformationMatrixes: [] }, this.outputFacialTransformationMatrixes = this.outputFaceBlendshapes = false, Cn(t6 = this.h = new Hs(), 0, 1, e5 = new Cs()), this.H = new Vs(), Cn(this.h, 0, 3, this.H), this.j = new Is(), Cn(this.h, 0, 2, this.j), Xn(this.j, 4, 1), Hn(this.j, 2, 0.5), Hn(this.H, 2, 0.5), Hn(this.h, 4, 0.5);
  }
  get baseOptions() {
    return Rn(this.h, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.h, 0, 1, t6);
  }
  o(t6) {
    return "numFaces" in t6 && Xn(this.j, 4, t6.numFaces ?? 1), "minFaceDetectionConfidence" in t6 && Hn(this.j, 2, t6.minFaceDetectionConfidence ?? 0.5), "minTrackingConfidence" in t6 && Hn(this.h, 4, t6.minTrackingConfidence ?? 0.5), "minFacePresenceConfidence" in t6 && Hn(this.H, 2, t6.minFacePresenceConfidence ?? 0.5), "outputFaceBlendshapes" in t6 && (this.outputFaceBlendshapes = !!t6.outputFaceBlendshapes), "outputFacialTransformationMatrixes" in t6 && (this.outputFacialTransformationMatrixes = !!t6.outputFacialTransformationMatrixes), this.l(t6);
  }
  F(t6, e5) {
    return mh(this), eh(this, t6, e5), this.u;
  }
  G(t6, e5, n7) {
    return mh(this), nh(this, t6, n7, e5), this.u;
  }
  m() {
    var t6 = new Di();
    Ii(t6, "image_in"), Ii(t6, "norm_rect"), Ui(t6, "face_landmarks");
    const e5 = new yi();
    Wn(e5, zs, this.h);
    const n7 = new Li();
    ki(n7, "mediapipe.tasks.vision.face_landmarker.FaceLandmarkerGraph"), xi(n7, "IMAGE:image_in"), xi(n7, "NORM_RECT:norm_rect"), Si(n7, "NORM_LANDMARKS:face_landmarks"), n7.o(e5), Oi(t6, n7), this.g.attachProtoVectorListener("face_landmarks", (t7, e6) => {
      for (const e7 of t7) t7 = us(e7), this.u.faceLandmarks.push(Io(t7));
      ea(this, e6);
    }), this.g.attachEmptyPacketListener("face_landmarks", (t7) => {
      ea(this, t7);
    }), this.outputFaceBlendshapes && (Ui(t6, "blendshapes"), Si(n7, "BLENDSHAPES:blendshapes"), this.g.attachProtoVectorListener("blendshapes", (t7, e6) => {
      if (this.outputFaceBlendshapes) for (const e7 of t7) t7 = Wi(e7), this.u.faceBlendshapes.push(Co(t7.g() ?? []));
      ea(this, e6);
    }), this.g.attachEmptyPacketListener("blendshapes", (t7) => {
      ea(this, t7);
    })), this.outputFacialTransformationMatrixes && (Ui(t6, "face_geometry"), Si(n7, "FACE_GEOMETRY:face_geometry"), this.g.attachProtoVectorListener("face_geometry", (t7, e6) => {
      if (this.outputFacialTransformationMatrixes) for (const e7 of t7) (t7 = Rn(Gs(e7), ls, 2)) && this.u.facialTransformationMatrixes.push({ rows: Bn(Nn(t7, 1), 0) ?? 0, columns: Bn(Nn(t7, 2), 0) ?? 0, data: yn(t7, 3, ve).slice() ?? [] });
      ea(this, e6);
    }), this.g.attachEmptyPacketListener("face_geometry", (t7) => {
      ea(this, t7);
    })), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
yh.prototype.detectForVideo = yh.prototype.G, yh.prototype.detect = yh.prototype.F, yh.prototype.setOptions = yh.prototype.o, yh.createFromModelPath = function(t6, e5) {
  return Qa(yh, t6, { baseOptions: { modelAssetPath: e5 } });
}, yh.createFromModelBuffer = function(t6, e5) {
  return Qa(yh, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, yh.createFromOptions = function(t6, e5) {
  return Qa(yh, t6, e5);
}, yh.FACE_LANDMARKS_LIPS = oh, yh.FACE_LANDMARKS_LEFT_EYE = ah, yh.FACE_LANDMARKS_LEFT_EYEBROW = hh, yh.FACE_LANDMARKS_LEFT_IRIS = ch, yh.FACE_LANDMARKS_RIGHT_EYE = uh, yh.FACE_LANDMARKS_RIGHT_EYEBROW = lh, yh.FACE_LANDMARKS_RIGHT_IRIS = dh, yh.FACE_LANDMARKS_FACE_OVAL = fh, yh.FACE_LANDMARKS_CONTOURS = ph, yh.FACE_LANDMARKS_TESSELATION = gh;
var _h = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "image_in", "norm_rect", true), Cn(t6 = this.j = new Ks(), 0, 1, e5 = new Cs());
  }
  get baseOptions() {
    return Rn(this.j, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.j, 0, 1, t6);
  }
  o(t6) {
    return super.l(t6);
  }
  Pa(t6, e5, n7) {
    const r5 = "function" != typeof e5 ? e5 : {};
    if (this.h = "function" == typeof e5 ? e5 : n7, eh(this, t6, r5 ?? {}), !this.h) return this.u;
  }
  m() {
    var t6 = new Di();
    Ii(t6, "image_in"), Ii(t6, "norm_rect"), Ui(t6, "stylized_image");
    const e5 = new yi();
    Wn(e5, Ys, this.j);
    const n7 = new Li();
    ki(n7, "mediapipe.tasks.vision.face_stylizer.FaceStylizerGraph"), xi(n7, "IMAGE:image_in"), xi(n7, "NORM_RECT:norm_rect"), Si(n7, "STYLIZED_IMAGE:stylized_image"), n7.o(e5), Oi(t6, n7), this.g.W("stylized_image", (t7, e6) => {
      var n8 = !this.h, r5 = t7.data, i4 = t7.width;
      const s3 = i4 * (t7 = t7.height);
      if (r5 instanceof Uint8Array) if (r5.length === 3 * s3) {
        const e7 = new Uint8ClampedArray(4 * s3);
        for (let t8 = 0; t8 < s3; ++t8) e7[4 * t8] = r5[3 * t8], e7[4 * t8 + 1] = r5[3 * t8 + 1], e7[4 * t8 + 2] = r5[3 * t8 + 2], e7[4 * t8 + 3] = 255;
        r5 = new ImageData(e7, i4, t7);
      } else {
        if (r5.length !== 4 * s3) throw Error("Unsupported channel count: " + r5.length / s3);
        r5 = new ImageData(new Uint8ClampedArray(r5.buffer, r5.byteOffset, r5.length), i4, t7);
      }
      else if (!(r5 instanceof WebGLTexture)) throw Error(`Unsupported format: ${r5.constructor.name}`);
      i4 = new Ka([r5], false, false, this.g.i.canvas, this.M, i4, t7), this.u = n8 = n8 ? i4.clone() : i4, this.h && this.h(n8), ea(this, e6);
    }), this.g.attachEmptyPacketListener("stylized_image", (t7) => {
      this.u = null, this.h && this.h(null), ea(this, t7);
    }), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
_h.prototype.stylize = _h.prototype.Pa, _h.prototype.setOptions = _h.prototype.o, _h.createFromModelPath = function(t6, e5) {
  return Qa(_h, t6, { baseOptions: { modelAssetPath: e5 } });
}, _h.createFromModelBuffer = function(t6, e5) {
  return Qa(_h, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, _h.createFromOptions = function(t6, e5) {
  return Qa(_h, t6, e5);
};
var vh = $a([0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7], [7, 8], [5, 9], [9, 10], [10, 11], [11, 12], [9, 13], [13, 14], [14, 15], [15, 16], [13, 17], [0, 17], [17, 18], [18, 19], [19, 20]);
function Eh(t6) {
  t6.gestures = [], t6.landmarks = [], t6.worldLandmarks = [], t6.handedness = [];
}
function wh(t6) {
  return 0 === t6.gestures.length ? { gestures: [], landmarks: [], worldLandmarks: [], handedness: [], handednesses: [] } : { gestures: t6.gestures, landmarks: t6.landmarks, worldLandmarks: t6.worldLandmarks, handedness: t6.handedness, handednesses: t6.handedness };
}
function Th(t6, e5 = true) {
  const n7 = [];
  for (const i4 of t6) {
    var r5 = Wi(i4);
    t6 = [];
    for (const n8 of r5.g()) r5 = e5 && null != Nn(n8, 1) ? Bn(Nn(n8, 1), 0) : -1, t6.push({ score: Gn(n8, 2) ?? 0, index: r5, categoryName: jn(n8, 3) ?? "", displayName: jn(n8, 4) ?? "" });
    n7.push(t6);
  }
  return n7;
}
var Ah = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "image_in", "norm_rect", false), this.gestures = [], this.landmarks = [], this.worldLandmarks = [], this.handedness = [], Cn(t6 = this.v = new oo(), 0, 1, e5 = new Cs()), this.A = new io(), Cn(this.v, 0, 2, this.A), this.u = new no(), Cn(this.A, 0, 3, this.u), this.h = new to(), Cn(this.A, 0, 2, this.h), this.j = new Zs(), Cn(this.v, 0, 3, this.j), Hn(this.h, 2, 0.5), Hn(this.A, 4, 0.5), Hn(this.u, 2, 0.5);
  }
  get baseOptions() {
    return Rn(this.v, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.v, 0, 1, t6);
  }
  o(t6) {
    if (Xn(this.h, 3, t6.numHands ?? 1), "minHandDetectionConfidence" in t6 && Hn(this.h, 2, t6.minHandDetectionConfidence ?? 0.5), "minTrackingConfidence" in t6 && Hn(this.A, 4, t6.minTrackingConfidence ?? 0.5), "minHandPresenceConfidence" in t6 && Hn(this.u, 2, t6.minHandPresenceConfidence ?? 0.5), t6.cannedGesturesClassifierOptions) {
      var e5 = new $s(), n7 = e5, r5 = Po(t6.cannedGesturesClassifierOptions, Rn(this.j, $s, 3)?.h());
      Cn(n7, 0, 2, r5), Cn(this.j, 0, 3, e5);
    } else void 0 === t6.cannedGesturesClassifierOptions && Rn(this.j, $s, 3)?.g();
    return t6.customGesturesClassifierOptions ? (Cn(n7 = e5 = new $s(), 0, 2, r5 = Po(t6.customGesturesClassifierOptions, Rn(this.j, $s, 4)?.h())), Cn(this.j, 0, 4, e5)) : void 0 === t6.customGesturesClassifierOptions && Rn(this.j, $s, 4)?.g(), this.l(t6);
  }
  Ka(t6, e5) {
    return Eh(this), eh(this, t6, e5), wh(this);
  }
  La(t6, e5, n7) {
    return Eh(this), nh(this, t6, n7, e5), wh(this);
  }
  m() {
    var t6 = new Di();
    Ii(t6, "image_in"), Ii(t6, "norm_rect"), Ui(t6, "hand_gestures"), Ui(t6, "hand_landmarks"), Ui(t6, "world_hand_landmarks"), Ui(t6, "handedness");
    const e5 = new yi();
    Wn(e5, co, this.v);
    const n7 = new Li();
    ki(n7, "mediapipe.tasks.vision.gesture_recognizer.GestureRecognizerGraph"), xi(n7, "IMAGE:image_in"), xi(n7, "NORM_RECT:norm_rect"), Si(n7, "HAND_GESTURES:hand_gestures"), Si(n7, "LANDMARKS:hand_landmarks"), Si(n7, "WORLD_LANDMARKS:world_hand_landmarks"), Si(n7, "HANDEDNESS:handedness"), n7.o(e5), Oi(t6, n7), this.g.attachProtoVectorListener("hand_landmarks", (t7, e6) => {
      for (const e7 of t7) {
        t7 = us(e7);
        const n8 = [];
        for (const e8 of Pn(t7, as, 1)) n8.push({ x: Gn(e8, 1) ?? 0, y: Gn(e8, 2) ?? 0, z: Gn(e8, 3) ?? 0, visibility: Gn(e8, 4) ?? 0 });
        this.landmarks.push(n8);
      }
      ea(this, e6);
    }), this.g.attachEmptyPacketListener("hand_landmarks", (t7) => {
      ea(this, t7);
    }), this.g.attachProtoVectorListener("world_hand_landmarks", (t7, e6) => {
      for (const e7 of t7) {
        t7 = os(e7);
        const n8 = [];
        for (const e8 of Pn(t7, rs, 1)) n8.push({ x: Gn(e8, 1) ?? 0, y: Gn(e8, 2) ?? 0, z: Gn(e8, 3) ?? 0, visibility: Gn(e8, 4) ?? 0 });
        this.worldLandmarks.push(n8);
      }
      ea(this, e6);
    }), this.g.attachEmptyPacketListener("world_hand_landmarks", (t7) => {
      ea(this, t7);
    }), this.g.attachProtoVectorListener("hand_gestures", (t7, e6) => {
      this.gestures.push(...Th(t7, false)), ea(this, e6);
    }), this.g.attachEmptyPacketListener("hand_gestures", (t7) => {
      ea(this, t7);
    }), this.g.attachProtoVectorListener("handedness", (t7, e6) => {
      this.handedness.push(...Th(t7)), ea(this, e6);
    }), this.g.attachEmptyPacketListener("handedness", (t7) => {
      ea(this, t7);
    }), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
function bh(t6) {
  return { landmarks: t6.landmarks, worldLandmarks: t6.worldLandmarks, handednesses: t6.handedness, handedness: t6.handedness };
}
Ah.prototype.recognizeForVideo = Ah.prototype.La, Ah.prototype.recognize = Ah.prototype.Ka, Ah.prototype.setOptions = Ah.prototype.o, Ah.createFromModelPath = function(t6, e5) {
  return Qa(Ah, t6, { baseOptions: { modelAssetPath: e5 } });
}, Ah.createFromModelBuffer = function(t6, e5) {
  return Qa(Ah, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, Ah.createFromOptions = function(t6, e5) {
  return Qa(Ah, t6, e5);
}, Ah.HAND_CONNECTIONS = vh;
var kh = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "image_in", "norm_rect", false), this.landmarks = [], this.worldLandmarks = [], this.handedness = [], Cn(t6 = this.j = new io(), 0, 1, e5 = new Cs()), this.u = new no(), Cn(this.j, 0, 3, this.u), this.h = new to(), Cn(this.j, 0, 2, this.h), Xn(this.h, 3, 1), Hn(this.h, 2, 0.5), Hn(this.u, 2, 0.5), Hn(this.j, 4, 0.5);
  }
  get baseOptions() {
    return Rn(this.j, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.j, 0, 1, t6);
  }
  o(t6) {
    return "numHands" in t6 && Xn(this.h, 3, t6.numHands ?? 1), "minHandDetectionConfidence" in t6 && Hn(this.h, 2, t6.minHandDetectionConfidence ?? 0.5), "minTrackingConfidence" in t6 && Hn(this.j, 4, t6.minTrackingConfidence ?? 0.5), "minHandPresenceConfidence" in t6 && Hn(this.u, 2, t6.minHandPresenceConfidence ?? 0.5), this.l(t6);
  }
  F(t6, e5) {
    return this.landmarks = [], this.worldLandmarks = [], this.handedness = [], eh(this, t6, e5), bh(this);
  }
  G(t6, e5, n7) {
    return this.landmarks = [], this.worldLandmarks = [], this.handedness = [], nh(this, t6, n7, e5), bh(this);
  }
  m() {
    var t6 = new Di();
    Ii(t6, "image_in"), Ii(t6, "norm_rect"), Ui(t6, "hand_landmarks"), Ui(t6, "world_hand_landmarks"), Ui(t6, "handedness");
    const e5 = new yi();
    Wn(e5, ho, this.j);
    const n7 = new Li();
    ki(n7, "mediapipe.tasks.vision.hand_landmarker.HandLandmarkerGraph"), xi(n7, "IMAGE:image_in"), xi(n7, "NORM_RECT:norm_rect"), Si(n7, "LANDMARKS:hand_landmarks"), Si(n7, "WORLD_LANDMARKS:world_hand_landmarks"), Si(n7, "HANDEDNESS:handedness"), n7.o(e5), Oi(t6, n7), this.g.attachProtoVectorListener("hand_landmarks", (t7, e6) => {
      for (const e7 of t7) t7 = us(e7), this.landmarks.push(Io(t7));
      ea(this, e6);
    }), this.g.attachEmptyPacketListener("hand_landmarks", (t7) => {
      ea(this, t7);
    }), this.g.attachProtoVectorListener("world_hand_landmarks", (t7, e6) => {
      for (const e7 of t7) t7 = os(e7), this.worldLandmarks.push(Uo(t7));
      ea(this, e6);
    }), this.g.attachEmptyPacketListener("world_hand_landmarks", (t7) => {
      ea(this, t7);
    }), this.g.attachProtoVectorListener("handedness", (t7, e6) => {
      var n8 = this.handedness, r5 = n8.push;
      const i4 = [];
      for (const e7 of t7) {
        t7 = Wi(e7);
        const n9 = [];
        for (const e8 of t7.g()) n9.push({ score: Gn(e8, 2) ?? 0, index: Bn(Nn(e8, 1), 0) ?? -1, categoryName: jn(e8, 3) ?? "", displayName: jn(e8, 4) ?? "" });
        i4.push(n9);
      }
      r5.call(n8, ...i4), ea(this, e6);
    }), this.g.attachEmptyPacketListener("handedness", (t7) => {
      ea(this, t7);
    }), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
kh.prototype.detectForVideo = kh.prototype.G, kh.prototype.detect = kh.prototype.F, kh.prototype.setOptions = kh.prototype.o, kh.createFromModelPath = function(t6, e5) {
  return Qa(kh, t6, { baseOptions: { modelAssetPath: e5 } });
}, kh.createFromModelBuffer = function(t6, e5) {
  return Qa(kh, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, kh.createFromOptions = function(t6, e5) {
  return Qa(kh, t6, e5);
}, kh.HAND_CONNECTIONS = vh;
var xh = $a([0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8], [9, 10], [11, 12], [11, 13], [13, 15], [15, 17], [15, 19], [15, 21], [17, 19], [12, 14], [14, 16], [16, 18], [16, 20], [16, 22], [18, 20], [11, 23], [12, 24], [23, 24], [23, 25], [24, 26], [25, 27], [26, 28], [27, 29], [28, 30], [29, 31], [30, 32], [27, 31], [28, 32]);
function Sh(t6) {
  t6.h = { faceLandmarks: [], faceBlendshapes: [], poseLandmarks: [], poseWorldLandmarks: [], poseSegmentationMasks: [], leftHandLandmarks: [], leftHandWorldLandmarks: [], rightHandLandmarks: [], rightHandWorldLandmarks: [] };
}
function Lh(t6) {
  try {
    if (!t6.I) return t6.h;
    t6.I(t6.h);
  } finally {
    ia(t6);
  }
}
function Fh(t6, e5) {
  t6 = us(t6), e5.push(Io(t6));
}
var Rh = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "input_frames_image", null, false), this.h = { faceLandmarks: [], faceBlendshapes: [], poseLandmarks: [], poseWorldLandmarks: [], poseSegmentationMasks: [], leftHandLandmarks: [], leftHandWorldLandmarks: [], rightHandLandmarks: [], rightHandWorldLandmarks: [] }, this.outputPoseSegmentationMasks = this.outputFaceBlendshapes = false, Cn(t6 = this.A = new yo(), 0, 1, e5 = new Cs()), this.u = new no(), Cn(this.A, 0, 2, this.u), this.aa = new uo(), Cn(this.A, 0, 3, this.aa), this.j = new Is(), Cn(this.A, 0, 4, this.j), this.H = new Vs(), Cn(this.A, 0, 5, this.H), this.v = new fo(), Cn(this.A, 0, 6, this.v), this.D = new go(), Cn(this.A, 0, 7, this.D), Hn(this.j, 2, 0.5), Hn(this.j, 3, 0.3), Hn(this.H, 2, 0.5), Hn(this.v, 2, 0.5), Hn(this.v, 3, 0.3), Hn(this.D, 2, 0.5), Hn(this.u, 2, 0.5);
  }
  get baseOptions() {
    return Rn(this.A, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.A, 0, 1, t6);
  }
  o(t6) {
    return "minFaceDetectionConfidence" in t6 && Hn(this.j, 2, t6.minFaceDetectionConfidence ?? 0.5), "minFaceSuppressionThreshold" in t6 && Hn(this.j, 3, t6.minFaceSuppressionThreshold ?? 0.3), "minFacePresenceConfidence" in t6 && Hn(this.H, 2, t6.minFacePresenceConfidence ?? 0.5), "outputFaceBlendshapes" in t6 && (this.outputFaceBlendshapes = !!t6.outputFaceBlendshapes), "minPoseDetectionConfidence" in t6 && Hn(this.v, 2, t6.minPoseDetectionConfidence ?? 0.5), "minPoseSuppressionThreshold" in t6 && Hn(this.v, 3, t6.minPoseSuppressionThreshold ?? 0.3), "minPosePresenceConfidence" in t6 && Hn(this.D, 2, t6.minPosePresenceConfidence ?? 0.5), "outputPoseSegmentationMasks" in t6 && (this.outputPoseSegmentationMasks = !!t6.outputPoseSegmentationMasks), "minHandLandmarksConfidence" in t6 && Hn(this.u, 2, t6.minHandLandmarksConfidence ?? 0.5), this.l(t6);
  }
  F(t6, e5, n7) {
    const r5 = "function" != typeof e5 ? e5 : {};
    return this.I = "function" == typeof e5 ? e5 : n7, Sh(this), eh(this, t6, r5), Lh(this);
  }
  G(t6, e5, n7, r5) {
    const i4 = "function" != typeof n7 ? n7 : {};
    return this.I = "function" == typeof n7 ? n7 : r5, Sh(this), nh(this, t6, i4, e5), Lh(this);
  }
  m() {
    var t6 = new Di();
    Ii(t6, "input_frames_image"), Ui(t6, "pose_landmarks"), Ui(t6, "pose_world_landmarks"), Ui(t6, "face_landmarks"), Ui(t6, "left_hand_landmarks"), Ui(t6, "left_hand_world_landmarks"), Ui(t6, "right_hand_landmarks"), Ui(t6, "right_hand_world_landmarks");
    const e5 = new yi(), n7 = new oi();
    An(n7, 1, Me("type.googleapis.com/mediapipe.tasks.vision.holistic_landmarker.proto.HolisticLandmarkerGraphOptions"), ""), function(t7, e6) {
      if (null != e6) if (Array.isArray(e6)) dn(t7, 2, tn(e6, nn, void 0, void 0, false));
      else {
        if (!("string" == typeof e6 || e6 instanceof B2 || M2(e6))) throw Error("invalid value in Any.value field: " + e6 + " expected a ByteString, a base64 encoded string, a Uint8Array or a jspb array");
        An(t7, 2, ae(e6, false, false), D2());
      }
    }(n7, this.A.g());
    const r5 = new Li();
    ki(r5, "mediapipe.tasks.vision.holistic_landmarker.HolisticLandmarkerGraph"), Dn(r5, 8, oi, n7), xi(r5, "IMAGE:input_frames_image"), Si(r5, "POSE_LANDMARKS:pose_landmarks"), Si(r5, "POSE_WORLD_LANDMARKS:pose_world_landmarks"), Si(r5, "FACE_LANDMARKS:face_landmarks"), Si(r5, "LEFT_HAND_LANDMARKS:left_hand_landmarks"), Si(r5, "LEFT_HAND_WORLD_LANDMARKS:left_hand_world_landmarks"), Si(r5, "RIGHT_HAND_LANDMARKS:right_hand_landmarks"), Si(r5, "RIGHT_HAND_WORLD_LANDMARKS:right_hand_world_landmarks"), r5.o(e5), Oi(t6, r5), na(this, t6), this.g.attachProtoListener("pose_landmarks", (t7, e6) => {
      Fh(t7, this.h.poseLandmarks), ea(this, e6);
    }), this.g.attachEmptyPacketListener("pose_landmarks", (t7) => {
      ea(this, t7);
    }), this.g.attachProtoListener("pose_world_landmarks", (t7, e6) => {
      var n8 = this.h.poseWorldLandmarks;
      t7 = os(t7), n8.push(Uo(t7)), ea(this, e6);
    }), this.g.attachEmptyPacketListener("pose_world_landmarks", (t7) => {
      ea(this, t7);
    }), this.outputPoseSegmentationMasks && (Si(r5, "POSE_SEGMENTATION_MASK:pose_segmentation_mask"), ra(this, "pose_segmentation_mask"), this.g.W("pose_segmentation_mask", (t7, e6) => {
      this.h.poseSegmentationMasks = [rh(this, t7, true, !this.I)], ea(this, e6);
    }), this.g.attachEmptyPacketListener("pose_segmentation_mask", (t7) => {
      this.h.poseSegmentationMasks = [], ea(this, t7);
    })), this.g.attachProtoListener("face_landmarks", (t7, e6) => {
      Fh(t7, this.h.faceLandmarks), ea(this, e6);
    }), this.g.attachEmptyPacketListener("face_landmarks", (t7) => {
      ea(this, t7);
    }), this.outputFaceBlendshapes && (Ui(t6, "extra_blendshapes"), Si(r5, "FACE_BLENDSHAPES:extra_blendshapes"), this.g.attachProtoListener("extra_blendshapes", (t7, e6) => {
      var n8 = this.h.faceBlendshapes;
      this.outputFaceBlendshapes && (t7 = Wi(t7), n8.push(Co(t7.g() ?? []))), ea(this, e6);
    }), this.g.attachEmptyPacketListener("extra_blendshapes", (t7) => {
      ea(this, t7);
    })), this.g.attachProtoListener("left_hand_landmarks", (t7, e6) => {
      Fh(t7, this.h.leftHandLandmarks), ea(this, e6);
    }), this.g.attachEmptyPacketListener("left_hand_landmarks", (t7) => {
      ea(this, t7);
    }), this.g.attachProtoListener("left_hand_world_landmarks", (t7, e6) => {
      var n8 = this.h.leftHandWorldLandmarks;
      t7 = os(t7), n8.push(Uo(t7)), ea(this, e6);
    }), this.g.attachEmptyPacketListener("left_hand_world_landmarks", (t7) => {
      ea(this, t7);
    }), this.g.attachProtoListener("right_hand_landmarks", (t7, e6) => {
      Fh(t7, this.h.rightHandLandmarks), ea(this, e6);
    }), this.g.attachEmptyPacketListener("right_hand_landmarks", (t7) => {
      ea(this, t7);
    }), this.g.attachProtoListener("right_hand_world_landmarks", (t7, e6) => {
      var n8 = this.h.rightHandWorldLandmarks;
      t7 = os(t7), n8.push(Uo(t7)), ea(this, e6);
    }), this.g.attachEmptyPacketListener("right_hand_world_landmarks", (t7) => {
      ea(this, t7);
    }), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
Rh.prototype.detectForVideo = Rh.prototype.G, Rh.prototype.detect = Rh.prototype.F, Rh.prototype.setOptions = Rh.prototype.o, Rh.createFromModelPath = function(t6, e5) {
  return Qa(Rh, t6, { baseOptions: { modelAssetPath: e5 } });
}, Rh.createFromModelBuffer = function(t6, e5) {
  return Qa(Rh, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, Rh.createFromOptions = function(t6, e5) {
  return Qa(Rh, t6, e5);
}, Rh.HAND_CONNECTIONS = vh, Rh.POSE_CONNECTIONS = xh, Rh.FACE_LANDMARKS_LIPS = oh, Rh.FACE_LANDMARKS_LEFT_EYE = ah, Rh.FACE_LANDMARKS_LEFT_EYEBROW = hh, Rh.FACE_LANDMARKS_LEFT_IRIS = ch, Rh.FACE_LANDMARKS_RIGHT_EYE = uh, Rh.FACE_LANDMARKS_RIGHT_EYEBROW = lh, Rh.FACE_LANDMARKS_RIGHT_IRIS = dh, Rh.FACE_LANDMARKS_FACE_OVAL = fh, Rh.FACE_LANDMARKS_CONTOURS = ph, Rh.FACE_LANDMARKS_TESSELATION = gh;
var Mh = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "input_image", "norm_rect", true), this.j = { classifications: [] }, Cn(t6 = this.h = new _o(), 0, 1, e5 = new Cs());
  }
  get baseOptions() {
    return Rn(this.h, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.h, 0, 1, t6);
  }
  o(t6) {
    return Cn(this.h, 0, 2, Po(t6, Rn(this.h, ks, 2))), this.l(t6);
  }
  ua(t6, e5) {
    return this.j = { classifications: [] }, eh(this, t6, e5), this.j;
  }
  va(t6, e5, n7) {
    return this.j = { classifications: [] }, nh(this, t6, n7, e5), this.j;
  }
  m() {
    var t6 = new Di();
    Ii(t6, "input_image"), Ii(t6, "norm_rect"), Ui(t6, "classifications");
    const e5 = new yi();
    Wn(e5, vo, this.h);
    const n7 = new Li();
    ki(n7, "mediapipe.tasks.vision.image_classifier.ImageClassifierGraph"), xi(n7, "IMAGE:input_image"), xi(n7, "NORM_RECT:norm_rect"), Si(n7, "CLASSIFICATIONS:classifications"), n7.o(e5), Oi(t6, n7), this.g.attachProtoListener("classifications", (t7, e6) => {
      this.j = function(t8) {
        const e7 = { classifications: Pn(t8, ps, 1).map((t9) => Co(Rn(t9, Xi, 4)?.g() ?? [], Bn(Nn(t9, 2), 0), jn(t9, 3))) };
        return null != Fe(cn(t8, 2)) && (e7.timestampMs = Bn(Fe(cn(t8, 2)), 0)), e7;
      }(ys(t7)), ea(this, e6);
    }), this.g.attachEmptyPacketListener("classifications", (t7) => {
      ea(this, t7);
    }), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
Mh.prototype.classifyForVideo = Mh.prototype.va, Mh.prototype.classify = Mh.prototype.ua, Mh.prototype.setOptions = Mh.prototype.o, Mh.createFromModelPath = function(t6, e5) {
  return Qa(Mh, t6, { baseOptions: { modelAssetPath: e5 } });
}, Mh.createFromModelBuffer = function(t6, e5) {
  return Qa(Mh, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, Mh.createFromOptions = function(t6, e5) {
  return Qa(Mh, t6, e5);
};
var Ph = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "image_in", "norm_rect", true), this.h = new Eo(), this.embeddings = { embeddings: [] }, Cn(t6 = this.h, 0, 1, e5 = new Cs());
  }
  get baseOptions() {
    return Rn(this.h, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.h, 0, 1, t6);
  }
  o(t6) {
    var e5 = this.h, n7 = Rn(this.h, Ss, 2);
    return n7 = n7 ? n7.clone() : new Ss(), void 0 !== t6.l2Normalize ? Vn(n7, 1, t6.l2Normalize) : "l2Normalize" in t6 && dn(n7, 1), void 0 !== t6.quantize ? Vn(n7, 2, t6.quantize) : "quantize" in t6 && dn(n7, 2), Cn(e5, 0, 2, n7), this.l(t6);
  }
  Ba(t6, e5) {
    return eh(this, t6, e5), this.embeddings;
  }
  Ca(t6, e5, n7) {
    return nh(this, t6, n7, e5), this.embeddings;
  }
  m() {
    var t6 = new Di();
    Ii(t6, "image_in"), Ii(t6, "norm_rect"), Ui(t6, "embeddings_out");
    const e5 = new yi();
    Wn(e5, wo, this.h);
    const n7 = new Li();
    ki(n7, "mediapipe.tasks.vision.image_embedder.ImageEmbedderGraph"), xi(n7, "IMAGE:image_in"), xi(n7, "NORM_RECT:norm_rect"), Si(n7, "EMBEDDINGS:embeddings_out"), n7.o(e5), Oi(t6, n7), this.g.attachProtoListener("embeddings_out", (t7, e6) => {
      t7 = bs(t7), this.embeddings = function(t8) {
        return { embeddings: Pn(t8, Es, 1).map((t9) => {
          const e7 = { headIndex: Bn(Nn(t9, 3), 0) ?? -1, headName: jn(t9, 4) ?? "" };
          if (void 0 !== Fn(t9, _s, xn(t9, 1))) t9 = yn(t9 = Rn(t9, _s, xn(t9, 1)), 1, ve), e7.floatEmbedding = t9.slice();
          else {
            const n8 = new Uint8Array(0);
            e7.quantizedEmbedding = Rn(t9, vs, xn(t9, 2))?.qa()?.h() ?? n8;
          }
          return e7;
        }), timestampMs: Bn(Fe(cn(t8, 2)), 0) };
      }(t7), ea(this, e6);
    }), this.g.attachEmptyPacketListener("embeddings_out", (t7) => {
      ea(this, t7);
    }), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
Ph.cosineSimilarity = function(t6, e5) {
  if (t6.floatEmbedding && e5.floatEmbedding) t6 = No(t6.floatEmbedding, e5.floatEmbedding);
  else {
    if (!t6.quantizedEmbedding || !e5.quantizedEmbedding) throw Error("Cannot compute cosine similarity between quantized and float embeddings.");
    t6 = No(Do(t6.quantizedEmbedding), Do(e5.quantizedEmbedding));
  }
  return t6;
}, Ph.prototype.embedForVideo = Ph.prototype.Ca, Ph.prototype.embed = Ph.prototype.Ba, Ph.prototype.setOptions = Ph.prototype.o, Ph.createFromModelPath = function(t6, e5) {
  return Qa(Ph, t6, { baseOptions: { modelAssetPath: e5 } });
}, Ph.createFromModelBuffer = function(t6, e5) {
  return Qa(Ph, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, Ph.createFromOptions = function(t6, e5) {
  return Qa(Ph, t6, e5);
};
var Ch = class {
  constructor(t6, e5, n7) {
    this.confidenceMasks = t6, this.categoryMask = e5, this.qualityScores = n7;
  }
  close() {
    this.confidenceMasks?.forEach((t6) => {
      t6.close();
    }), this.categoryMask?.close();
  }
};
function Oh(t6) {
  t6.categoryMask = void 0, t6.confidenceMasks = void 0, t6.qualityScores = void 0;
}
function Ih(t6) {
  try {
    const e5 = new Ch(t6.confidenceMasks, t6.categoryMask, t6.qualityScores);
    if (!t6.j) return e5;
    t6.j(e5);
  } finally {
    ia(t6);
  }
}
Ch.prototype.close = Ch.prototype.close;
var Uh = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "image_in", "norm_rect", false), this.u = [], this.outputCategoryMask = false, this.outputConfidenceMasks = true, this.h = new xo(), this.v = new To(), Cn(this.h, 0, 3, this.v), Cn(t6 = this.h, 0, 1, e5 = new Cs());
  }
  get baseOptions() {
    return Rn(this.h, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.h, 0, 1, t6);
  }
  o(t6) {
    return void 0 !== t6.displayNamesLocale ? dn(this.h, 2, Me(t6.displayNamesLocale)) : "displayNamesLocale" in t6 && dn(this.h, 2), "outputCategoryMask" in t6 && (this.outputCategoryMask = t6.outputCategoryMask ?? false), "outputConfidenceMasks" in t6 && (this.outputConfidenceMasks = t6.outputConfidenceMasks ?? true), super.l(t6);
  }
  L() {
    !function(t6) {
      const e5 = Pn(t6.fa(), Li, 1).filter((t7) => jn(t7, 1).includes("mediapipe.tasks.TensorsToSegmentationCalculator"));
      if (t6.u = [], 1 < e5.length) throw Error("The graph has more than one mediapipe.tasks.TensorsToSegmentationCalculator.");
      1 === e5.length && (Rn(e5[0], yi, 7)?.l()?.g() ?? /* @__PURE__ */ new Map()).forEach((e6, n7) => {
        t6.u[Number(n7)] = jn(e6, 1);
      });
    }(this);
  }
  ga(t6, e5, n7) {
    const r5 = "function" != typeof e5 ? e5 : {};
    return this.j = "function" == typeof e5 ? e5 : n7, Oh(this), eh(this, t6, r5), Ih(this);
  }
  Na(t6, e5, n7, r5) {
    const i4 = "function" != typeof n7 ? n7 : {};
    return this.j = "function" == typeof n7 ? n7 : r5, Oh(this), nh(this, t6, i4, e5), Ih(this);
  }
  Fa() {
    return this.u;
  }
  m() {
    var t6 = new Di();
    Ii(t6, "image_in"), Ii(t6, "norm_rect");
    const e5 = new yi();
    Wn(e5, So, this.h);
    const n7 = new Li();
    ki(n7, "mediapipe.tasks.vision.image_segmenter.ImageSegmenterGraph"), xi(n7, "IMAGE:image_in"), xi(n7, "NORM_RECT:norm_rect"), n7.o(e5), Oi(t6, n7), na(this, t6), this.outputConfidenceMasks && (Ui(t6, "confidence_masks"), Si(n7, "CONFIDENCE_MASKS:confidence_masks"), ra(this, "confidence_masks"), this.g.da("confidence_masks", (t7, e6) => {
      this.confidenceMasks = t7.map((t8) => rh(this, t8, true, !this.j)), ea(this, e6);
    }), this.g.attachEmptyPacketListener("confidence_masks", (t7) => {
      this.confidenceMasks = [], ea(this, t7);
    })), this.outputCategoryMask && (Ui(t6, "category_mask"), Si(n7, "CATEGORY_MASK:category_mask"), ra(this, "category_mask"), this.g.W("category_mask", (t7, e6) => {
      this.categoryMask = rh(this, t7, false, !this.j), ea(this, e6);
    }), this.g.attachEmptyPacketListener("category_mask", (t7) => {
      this.categoryMask = void 0, ea(this, t7);
    })), Ui(t6, "quality_scores"), Si(n7, "QUALITY_SCORES:quality_scores"), this.g.attachFloatVectorListener("quality_scores", (t7, e6) => {
      this.qualityScores = t7, ea(this, e6);
    }), this.g.attachEmptyPacketListener("quality_scores", (t7) => {
      this.categoryMask = void 0, ea(this, t7);
    }), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
Uh.prototype.getLabels = Uh.prototype.Fa, Uh.prototype.segmentForVideo = Uh.prototype.Na, Uh.prototype.segment = Uh.prototype.ga, Uh.prototype.setOptions = Uh.prototype.o, Uh.createFromModelPath = function(t6, e5) {
  return Qa(Uh, t6, { baseOptions: { modelAssetPath: e5 } });
}, Uh.createFromModelBuffer = function(t6, e5) {
  return Qa(Uh, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, Uh.createFromOptions = function(t6, e5) {
  return Qa(Uh, t6, e5);
};
var Dh = class {
  constructor(t6, e5, n7) {
    this.confidenceMasks = t6, this.categoryMask = e5, this.qualityScores = n7;
  }
  close() {
    this.confidenceMasks?.forEach((t6) => {
      t6.close();
    }), this.categoryMask?.close();
  }
};
Dh.prototype.close = Dh.prototype.close;
var Nh = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Bh = [0, jr, -2];
var Gh = [0, Or, -3, Hr];
var jh = [0, Or, -3, Hr, Or, -1];
var Vh = [0, jh];
var Xh = [0, Vh, Bh];
var Hh = [0, jh, Bh];
var Wh = [0, jh, jr, -1];
var zh = [0, Wh, Bh];
var Kh = [0, Or, -3, Hr, Bh, -1];
var Yh = [0, Or, -3, Hr, ti];
var $h = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var qh = [0, Or, -1, Hr];
var Jh = class extends zn {
  constructor() {
    super();
  }
};
Jh.B = [1];
var Zh = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Qh = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 15];
var tc = [0, Qh, Jr, jh, Jr, Hh, Jr, Vh, Jr, Xh, Jr, qh, Jr, Yh, Jr, Gh, Jr, [0, Yr, Or, -2, Hr, jr, Hr, -1, 2, Or, Bh], Jr, Wh, Jr, zh, Or, Bh, Yr, Jr, Kh, Jr, [0, Cr, qh]];
var ec = [0, Yr, jr, -1, Hr];
var nc = class extends zn {
  constructor() {
    super();
  }
};
nc.B = [1], nc.prototype.g = si2([0, Cr, tc, Yr, ec]);
var rc = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "image_in", "norm_rect_in", false), this.outputCategoryMask = false, this.outputConfidenceMasks = true, this.h = new xo(), this.v = new To(), Cn(this.h, 0, 3, this.v), Cn(t6 = this.h, 0, 1, e5 = new Cs());
  }
  get baseOptions() {
    return Rn(this.h, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.h, 0, 1, t6);
  }
  o(t6) {
    return "outputCategoryMask" in t6 && (this.outputCategoryMask = t6.outputCategoryMask ?? false), "outputConfidenceMasks" in t6 && (this.outputConfidenceMasks = t6.outputConfidenceMasks ?? true), super.l(t6);
  }
  ga(t6, e5, n7, r5) {
    const i4 = "function" != typeof n7 ? n7 : {};
    this.j = "function" == typeof n7 ? n7 : r5, this.qualityScores = this.categoryMask = this.confidenceMasks = void 0, n7 = this.J + 1, r5 = new nc();
    const s3 = new Zh();
    var o5 = new Nh();
    if (Xn(o5, 1, 255), Cn(s3, 0, 12, o5), e5.keypoint && e5.scribble) throw Error("Cannot provide both keypoint and scribble.");
    if (e5.keypoint) {
      var a4 = new $h();
      Vn(a4, 3, true), Hn(a4, 1, e5.keypoint.x), Hn(a4, 2, e5.keypoint.y), On(s3, 5, Qh, a4);
    } else {
      if (!e5.scribble) throw Error("Must provide either a keypoint or a scribble.");
      for (a4 of (o5 = new Jh(), e5.scribble)) Vn(e5 = new $h(), 3, true), Hn(e5, 1, a4.x), Hn(e5, 2, a4.y), Dn(o5, 1, $h, e5);
      On(s3, 15, Qh, o5);
    }
    Dn(r5, 1, Zh, s3), this.g.addProtoToStream(r5.g(), "drishti.RenderData", "roi_in", n7), eh(this, t6, i4);
    t: {
      try {
        const t7 = new Dh(this.confidenceMasks, this.categoryMask, this.qualityScores);
        if (!this.j) {
          var h5 = t7;
          break t;
        }
        this.j(t7);
      } finally {
        ia(this);
      }
      h5 = void 0;
    }
    return h5;
  }
  m() {
    var t6 = new Di();
    Ii(t6, "image_in"), Ii(t6, "roi_in"), Ii(t6, "norm_rect_in");
    const e5 = new yi();
    Wn(e5, So, this.h);
    const n7 = new Li();
    ki(n7, "mediapipe.tasks.vision.interactive_segmenter.InteractiveSegmenterGraph"), xi(n7, "IMAGE:image_in"), xi(n7, "ROI:roi_in"), xi(n7, "NORM_RECT:norm_rect_in"), n7.o(e5), Oi(t6, n7), na(this, t6), this.outputConfidenceMasks && (Ui(t6, "confidence_masks"), Si(n7, "CONFIDENCE_MASKS:confidence_masks"), ra(this, "confidence_masks"), this.g.da("confidence_masks", (t7, e6) => {
      this.confidenceMasks = t7.map((t8) => rh(this, t8, true, !this.j)), ea(this, e6);
    }), this.g.attachEmptyPacketListener("confidence_masks", (t7) => {
      this.confidenceMasks = [], ea(this, t7);
    })), this.outputCategoryMask && (Ui(t6, "category_mask"), Si(n7, "CATEGORY_MASK:category_mask"), ra(this, "category_mask"), this.g.W("category_mask", (t7, e6) => {
      this.categoryMask = rh(this, t7, false, !this.j), ea(this, e6);
    }), this.g.attachEmptyPacketListener("category_mask", (t7) => {
      this.categoryMask = void 0, ea(this, t7);
    })), Ui(t6, "quality_scores"), Si(n7, "QUALITY_SCORES:quality_scores"), this.g.attachFloatVectorListener("quality_scores", (t7, e6) => {
      this.qualityScores = t7, ea(this, e6);
    }), this.g.attachEmptyPacketListener("quality_scores", (t7) => {
      this.categoryMask = void 0, ea(this, t7);
    }), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
rc.prototype.segment = rc.prototype.ga, rc.prototype.setOptions = rc.prototype.o, rc.createFromModelPath = function(t6, e5) {
  return Qa(rc, t6, { baseOptions: { modelAssetPath: e5 } });
}, rc.createFromModelBuffer = function(t6, e5) {
  return Qa(rc, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, rc.createFromOptions = function(t6, e5) {
  return Qa(rc, t6, e5);
};
var ic = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "input_frame_gpu", "norm_rect", false), this.j = { detections: [] }, Cn(t6 = this.h = new Lo(), 0, 1, e5 = new Cs());
  }
  get baseOptions() {
    return Rn(this.h, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.h, 0, 1, t6);
  }
  o(t6) {
    return void 0 !== t6.displayNamesLocale ? dn(this.h, 2, Me(t6.displayNamesLocale)) : "displayNamesLocale" in t6 && dn(this.h, 2), void 0 !== t6.maxResults ? Xn(this.h, 3, t6.maxResults) : "maxResults" in t6 && dn(this.h, 3), void 0 !== t6.scoreThreshold ? Hn(this.h, 4, t6.scoreThreshold) : "scoreThreshold" in t6 && dn(this.h, 4), void 0 !== t6.categoryAllowlist ? Tn(this.h, 5, t6.categoryAllowlist) : "categoryAllowlist" in t6 && dn(this.h, 5), void 0 !== t6.categoryDenylist ? Tn(this.h, 6, t6.categoryDenylist) : "categoryDenylist" in t6 && dn(this.h, 6), this.l(t6);
  }
  F(t6, e5) {
    return this.j = { detections: [] }, eh(this, t6, e5), this.j;
  }
  G(t6, e5, n7) {
    return this.j = { detections: [] }, nh(this, t6, n7, e5), this.j;
  }
  m() {
    var t6 = new Di();
    Ii(t6, "input_frame_gpu"), Ii(t6, "norm_rect"), Ui(t6, "detections");
    const e5 = new yi();
    Wn(e5, Fo, this.h);
    const n7 = new Li();
    ki(n7, "mediapipe.tasks.vision.ObjectDetectorGraph"), xi(n7, "IMAGE:input_frame_gpu"), xi(n7, "NORM_RECT:norm_rect"), Si(n7, "DETECTIONS:detections"), n7.o(e5), Oi(t6, n7), this.g.attachProtoVectorListener("detections", (t7, e6) => {
      for (const e7 of t7) t7 = ns(e7), this.j.detections.push(Oo(t7));
      ea(this, e6);
    }), this.g.attachEmptyPacketListener("detections", (t7) => {
      ea(this, t7);
    }), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
ic.prototype.detectForVideo = ic.prototype.G, ic.prototype.detect = ic.prototype.F, ic.prototype.setOptions = ic.prototype.o, ic.createFromModelPath = async function(t6, e5) {
  return Qa(ic, t6, { baseOptions: { modelAssetPath: e5 } });
}, ic.createFromModelBuffer = function(t6, e5) {
  return Qa(ic, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, ic.createFromOptions = function(t6, e5) {
  return Qa(ic, t6, e5);
};
var sc = class {
  constructor(t6, e5, n7) {
    this.landmarks = t6, this.worldLandmarks = e5, this.segmentationMasks = n7;
  }
  close() {
    this.segmentationMasks?.forEach((t6) => {
      t6.close();
    });
  }
};
function oc(t6) {
  t6.landmarks = [], t6.worldLandmarks = [], t6.segmentationMasks = void 0;
}
function ac(t6) {
  try {
    const e5 = new sc(t6.landmarks, t6.worldLandmarks, t6.segmentationMasks);
    if (!t6.j) return e5;
    t6.j(e5);
  } finally {
    ia(t6);
  }
}
sc.prototype.close = sc.prototype.close;
var hc = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "image_in", "norm_rect", false), this.landmarks = [], this.worldLandmarks = [], this.outputSegmentationMasks = false, Cn(t6 = this.h = new Ro(), 0, 1, e5 = new Cs()), this.D = new go(), Cn(this.h, 0, 3, this.D), this.v = new fo(), Cn(this.h, 0, 2, this.v), Xn(this.v, 4, 1), Hn(this.v, 2, 0.5), Hn(this.D, 2, 0.5), Hn(this.h, 4, 0.5);
  }
  get baseOptions() {
    return Rn(this.h, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.h, 0, 1, t6);
  }
  o(t6) {
    return "numPoses" in t6 && Xn(this.v, 4, t6.numPoses ?? 1), "minPoseDetectionConfidence" in t6 && Hn(this.v, 2, t6.minPoseDetectionConfidence ?? 0.5), "minTrackingConfidence" in t6 && Hn(this.h, 4, t6.minTrackingConfidence ?? 0.5), "minPosePresenceConfidence" in t6 && Hn(this.D, 2, t6.minPosePresenceConfidence ?? 0.5), "outputSegmentationMasks" in t6 && (this.outputSegmentationMasks = t6.outputSegmentationMasks ?? false), this.l(t6);
  }
  F(t6, e5, n7) {
    const r5 = "function" != typeof e5 ? e5 : {};
    return this.j = "function" == typeof e5 ? e5 : n7, oc(this), eh(this, t6, r5), ac(this);
  }
  G(t6, e5, n7, r5) {
    const i4 = "function" != typeof n7 ? n7 : {};
    return this.j = "function" == typeof n7 ? n7 : r5, oc(this), nh(this, t6, i4, e5), ac(this);
  }
  m() {
    var t6 = new Di();
    Ii(t6, "image_in"), Ii(t6, "norm_rect"), Ui(t6, "normalized_landmarks"), Ui(t6, "world_landmarks"), Ui(t6, "segmentation_masks");
    const e5 = new yi();
    Wn(e5, Mo, this.h);
    const n7 = new Li();
    ki(n7, "mediapipe.tasks.vision.pose_landmarker.PoseLandmarkerGraph"), xi(n7, "IMAGE:image_in"), xi(n7, "NORM_RECT:norm_rect"), Si(n7, "NORM_LANDMARKS:normalized_landmarks"), Si(n7, "WORLD_LANDMARKS:world_landmarks"), n7.o(e5), Oi(t6, n7), na(this, t6), this.g.attachProtoVectorListener("normalized_landmarks", (t7, e6) => {
      this.landmarks = [];
      for (const e7 of t7) t7 = us(e7), this.landmarks.push(Io(t7));
      ea(this, e6);
    }), this.g.attachEmptyPacketListener("normalized_landmarks", (t7) => {
      this.landmarks = [], ea(this, t7);
    }), this.g.attachProtoVectorListener("world_landmarks", (t7, e6) => {
      this.worldLandmarks = [];
      for (const e7 of t7) t7 = os(e7), this.worldLandmarks.push(Uo(t7));
      ea(this, e6);
    }), this.g.attachEmptyPacketListener("world_landmarks", (t7) => {
      this.worldLandmarks = [], ea(this, t7);
    }), this.outputSegmentationMasks && (Si(n7, "SEGMENTATION_MASK:segmentation_masks"), ra(this, "segmentation_masks"), this.g.da("segmentation_masks", (t7, e6) => {
      this.segmentationMasks = t7.map((t8) => rh(this, t8, true, !this.j)), ea(this, e6);
    }), this.g.attachEmptyPacketListener("segmentation_masks", (t7) => {
      this.segmentationMasks = [], ea(this, t7);
    })), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
hc.prototype.detectForVideo = hc.prototype.G, hc.prototype.detect = hc.prototype.F, hc.prototype.setOptions = hc.prototype.o, hc.createFromModelPath = function(t6, e5) {
  return Qa(hc, t6, { baseOptions: { modelAssetPath: e5 } });
}, hc.createFromModelBuffer = function(t6, e5) {
  return Qa(hc, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, hc.createFromOptions = function(t6, e5) {
  return Qa(hc, t6, e5);
}, hc.POSE_CONNECTIONS = xh;

// node_modules/ixfx/dist/chunk-XFNQJV53.js
var addArray = (map3, data) => {
  const x3 = new Map(map3.entries());
  for (const d4 of data) {
    if (d4[0] === void 0) throw new Error(`key cannot be undefined`);
    if (d4[1] === void 0) throw new Error(`value cannot be undefined`);
    x3.set(d4[0], d4[1]);
  }
  return x3;
};
var addObjects = (map3, data) => {
  const x3 = new Map(map3.entries());
  for (const d4 of data) {
    if (d4.key === void 0) throw new Error(`key cannot be undefined`);
    if (d4.value === void 0) throw new Error(`value cannot be undefined`);
    x3.set(d4.key, d4.value);
  }
  return x3;
};
var has = (map3, key) => map3.has(key);
var add = (map3, ...data) => {
  if (map3 === void 0) throw new Error(`map parameter is undefined`);
  if (data === void 0) throw new Error(`data parameter i.s undefined`);
  if (data.length === 0) return map3;
  const firstRecord = data[0];
  const isObject = typeof firstRecord.key !== `undefined` && typeof firstRecord.value !== `undefined`;
  return isObject ? addObjects(map3, data) : addArray(map3, data);
};
var set = (map3, key, value2) => {
  const x3 = new Map(map3.entries());
  x3.set(key, value2);
  return x3;
};
var del = (map3, key) => {
  const x3 = new Map(map3.entries());
  x3.delete(key);
  return x3;
};
var immutable = (dataOrMap) => {
  if (dataOrMap === void 0) return immutable([]);
  if (Array.isArray(dataOrMap)) return immutable(add(/* @__PURE__ */ new Map(), ...dataOrMap));
  const data = dataOrMap;
  return {
    add: (...itemsToAdd) => {
      const s3 = add(data, ...itemsToAdd);
      return immutable(s3);
    },
    set: (key, value2) => {
      const s3 = set(data, key, value2);
      return immutable(s3);
    },
    get: (key) => data.get(key),
    delete: (key) => immutable(del(data, key)),
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    clear: () => immutable(),
    has: (key) => data.has(key),
    entries: () => data.entries(),
    values: () => data.values(),
    isEmpty: () => data.size === 0
  };
};
var NumberMap = class extends Map {
  constructor(defaultValue = 0) {
    super();
    this.defaultValue = defaultValue;
  }
  get(key) {
    const v3 = super.get(key);
    if (v3 === void 0) return this.defaultValue;
    return v3;
  }
  reset(key) {
    super.set(key, this.defaultValue);
    return this.defaultValue;
  }
  multiply(key, amount) {
    const v3 = super.get(key);
    let value2 = v3 ?? this.defaultValue;
    value2 *= amount;
    super.set(key, value2);
    return value2;
  }
  add(key, amount = 1) {
    const v3 = super.get(key);
    let value2 = v3 ?? this.defaultValue;
    value2 += amount;
    super.set(key, value2);
    return value2;
  }
  subtract(key, amount = 1) {
    const v3 = super.get(key);
    let value2 = v3 ?? this.defaultValue;
    value2 -= amount;
    super.set(key, value2);
    return value2;
  }
};

// node_modules/ixfx/dist/chunk-BLACMGG6.js
var throwFromResult = (test) => {
  if (test[0]) return false;
  else throw new Error(test[1]);
};
var isPowerOfTwo = (x3) => Math.log2(x3) % 1 === 0;
var ifNaN = (v3, fallback) => {
  if (Number.isNaN(v3)) return fallback;
  if (typeof v3 !== `number`) {
    throw new TypeError(`v is not a number. Got: ${typeof v3}`);
  }
  return v3;
};
var integerParse = (value2, range2 = ``, defaultValue = Number.NaN) => {
  if (value2 === void 0) return defaultValue;
  if (value2 === null) return defaultValue;
  try {
    const parsed = Number.parseInt(value2);
    const r5 = integerTest(parsed, range2, `parsed`);
    return r5[0] ? parsed : defaultValue;
  } catch {
    return defaultValue;
  }
};
var numberTest = (value2, range2 = ``, parameterName = `?`) => {
  if (value2 === null) return [false, `Parameter '${parameterName}' is null`];
  if (typeof value2 === `undefined`) {
    return [false, `Parameter '${parameterName}' is undefined`];
  }
  if (Number.isNaN(value2)) {
    return [false, `Parameter '${parameterName}' is NaN`];
  }
  if (typeof value2 !== `number`) {
    return [false, `Parameter '${parameterName}' is not a number (${JSON.stringify(value2)})`];
  }
  switch (range2) {
    case `finite`: {
      if (!Number.isFinite(value2)) {
        return [false, `Parameter '${parameterName} must be finite`];
      }
    }
    case `positive`: {
      if (value2 < 0) {
        return [false, `Parameter '${parameterName}' must be at least zero (${value2})`];
      }
      break;
    }
    case `negative`: {
      if (value2 > 0) {
        return [false, `Parameter '${parameterName}' must be zero or lower (${value2})`];
      }
      break;
    }
    case `aboveZero`: {
      if (value2 <= 0) {
        return [false, `Parameter '${parameterName}' must be above zero (${value2})`];
      }
      break;
    }
    case `belowZero`: {
      if (value2 >= 0) {
        return [false, `Parameter '${parameterName}' must be below zero (${value2})`];
      }
      break;
    }
    case `percentage`: {
      if (value2 > 1 || value2 < 0) {
        return [false, `Parameter '${parameterName}' must be in percentage range (0 to 1). (${value2})`];
      }
      break;
    }
    case `nonZero`: {
      if (value2 === 0) {
        return [false, `Parameter '${parameterName}' must non-zero. (${value2})`];
      }
      break;
    }
    case `bipolar`: {
      if (value2 > 1 || value2 < -1) {
        return [false, `Parameter '${parameterName}' must be in bipolar percentage range (-1 to 1). (${value2})`];
      }
      break;
    }
  }
  return [true];
};
var throwNumberTest = (value2, range2 = ``, parameterName = `?`) => {
  throwFromResult(numberTest(value2, range2, parameterName));
};
var percentTest = (value2, parameterName = `?`) => numberTest(value2, `percentage`, parameterName);
var throwPercentTest = (value2, parameterName = `?`) => {
  throwFromResult(percentTest(value2, parameterName));
};
var integerTest = (value2, range2 = ``, parameterName = `?`) => {
  const r5 = numberTest(value2, range2, parameterName);
  if (!r5[0]) return r5;
  if (!Number.isInteger(value2)) {
    return [false, `Param '${parameterName}' is not an integer`];
  }
  return [true];
};
var throwIntegerTest = (value2, range2 = ``, parameterName = `?`) => {
  throwFromResult(integerTest(value2, range2, parameterName));
};

// node_modules/ixfx/dist/chunk-XO5G6VLT.js
function round(a4, b4) {
  throwIntegerTest(a4, `positive`, `decimalPlaces`);
  let rounder;
  if (a4 === 0) rounder = Math.round;
  else {
    const p4 = Math.pow(10, a4);
    rounder = (v3) => Math.floor(v3 * p4) / p4;
  }
  return b4 === void 0 ? rounder : rounder(b4);
}

// node_modules/ixfx/dist/chunk-GFZVK53G.js
function intervalToMs(interval2, defaultNumber) {
  if (isInterval(interval2)) {
    if (typeof interval2 === `number`) return interval2;
    let ms2 = interval2.millis ?? 0;
    ms2 += (interval2.hours ?? 0) * 60 * 60 * 1e3;
    ms2 += (interval2.mins ?? 0) * 60 * 1e3;
    ms2 += (interval2.secs ?? 0) * 1e3;
    return ms2;
  } else {
    if (typeof defaultNumber !== `undefined`) return defaultNumber;
    throw new Error(`Not a valid interval: ${interval2}`);
  }
}
function isInterval(interval2) {
  if (interval2 === void 0) return false;
  if (interval2 === null) return false;
  if (typeof interval2 === `number`) {
    if (Number.isNaN(interval2)) return false;
    if (!Number.isFinite(interval2)) return false;
    return true;
  } else if (typeof interval2 !== `object`) return false;
  const hasMillis = `millis` in interval2;
  const hasSecs = `secs` in interval2;
  const hasMins = `mins` in interval2;
  const hasHours = `hours` in interval2;
  if (hasMillis && !numberTest(interval2.millis)[0]) return false;
  if (hasSecs && !numberTest(interval2.secs)[0]) return false;
  if (hasMins && !numberTest(interval2.mins)[0]) return false;
  if (hasHours && !numberTest(interval2.hours)[0]) return false;
  if (hasMillis || hasSecs || hasHours || hasMins) return true;
  return false;
}
var elapsedToHumanString = (millisOrFunction, rounding = 2) => {
  let interval2 = {} = 0;
  if (typeof millisOrFunction === `function`) {
    const intervalResult = millisOrFunction();
    return elapsedToHumanString(intervalResult);
  } else if (typeof millisOrFunction === `number`) {
    interval2 = millisOrFunction;
  } else if (typeof millisOrFunction === `object`) {
    interval2 = intervalToMs(interval2);
  }
  let ms2 = intervalToMs(interval2);
  if (typeof ms2 === `undefined`) return `(undefined)`;
  if (ms2 < 1e3) return `${round(rounding, ms2)}ms`;
  ms2 /= 1e3;
  if (ms2 < 120) return `${ms2.toFixed(1)}secs`;
  ms2 /= 60;
  if (ms2 < 60) return `${ms2.toFixed(2)}mins`;
  ms2 /= 60;
  return `${ms2.toFixed(2)}hrs`;
};

// node_modules/ixfx/dist/chunk-6UZ3OSJO.js
var objectToString = Object.prototype.toString;
var toTypeString = (value2) => objectToString.call(value2);
var isMap = (value2) => toTypeString(value2) === `[object Map]`;
var isSet = (value2) => toTypeString(value2) === `[object Set]`;
var toStringDefault = (itemToMakeStringFor) => typeof itemToMakeStringFor === `string` ? itemToMakeStringFor : JSON.stringify(itemToMakeStringFor);
var defaultToString = (object2) => {
  if (object2 === null) return `null`;
  if (typeof object2 === `boolean` || typeof object2 === `number`) {
    return object2.toString();
  }
  if (typeof object2 === `string`) return object2;
  if (typeof object2 === `symbol`) throw new TypeError(`Symbol cannot be converted to string`);
  return JSON.stringify(object2);
};
var toStringOrdered = (itemToMakeStringFor) => {
  if (typeof itemToMakeStringFor === `string`) return itemToMakeStringFor;
  const allKeys = /* @__PURE__ */ new Set();
  JSON.stringify(itemToMakeStringFor, (key, value2) => (allKeys.add(key), value2));
  return JSON.stringify(itemToMakeStringFor, [...allKeys].sort());
};
var isEqualDefault = (a4, b4) => a4 === b4;
var isEqualValueDefault = (a4, b4) => {
  if (a4 === b4) return true;
  return toStringDefault(a4) === toStringDefault(b4);
};
var isEqualValuePartial = (a4, b4, fieldComparer) => {
  if (typeof a4 !== `object`) throw new Error(`Parameter 'a' expected to be object`);
  if (typeof b4 !== `object`) throw new Error(`Parameter 'b' expected to be object`);
  if (Object.is(a4, b4)) return true;
  const comparer = fieldComparer ?? isEqualValuePartial;
  for (const entryB of Object.entries(b4)) {
    const valueA = a4[entryB[0]];
    const valueB = entryB[1];
    if (typeof valueA === `object` && typeof valueB === `object`) {
      if (!comparer(valueA, valueB)) {
        return false;
      }
    } else {
      if (valueA !== valueB) {
        return false;
      }
    }
  }
  return true;
};
var isEqualValueIgnoreOrder = (a4, b4) => {
  if (a4 === b4) return true;
  return toStringOrdered(a4) === toStringOrdered(b4);
};

// node_modules/ixfx/dist/chunk-L5EJU35C.js
var __defProp2 = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};

// node_modules/ixfx/dist/chunk-B3EBEJZ3.js
var Events_exports = {};
__export(Events_exports, {
  SimpleEventEmitter: () => SimpleEventEmitter,
  eventRace: () => eventRace
});
var defaultKeyer = (a4) => {
  return typeof a4 === `string` ? a4 : JSON.stringify(a4);
};
var firstEntryByValue = (map3, value2, isEqual8 = isEqualDefault) => {
  for (const e5 of map3.entries()) {
    const val = e5[1];
    for (const subValue of val) {
      if (isEqual8(subValue, value2)) return e5;
    }
  }
};
var MapOfSimpleBase = class {
  /**
   * Constructor
   * @param groupBy Creates keys for values when using `addValue`. By default uses JSON.stringify
   * @param valueEq Compare values. By default uses JS logic for equality
   */
  constructor(groupBy = defaultKeyer, valueEq = isEqualDefault, initial = []) {
    this.groupBy = groupBy;
    this.valueEq = valueEq;
    this.map = new Map(initial);
  }
  /**
   * Iterate over all entries
   */
  *entriesFlat() {
    for (const key of this.map.keys()) {
      for (const value2 of this.map.get(key)) {
        yield [key, value2];
      }
    }
  }
  *entries() {
    for (const [k3, v3] of this.map.entries()) {
      yield [k3, [...v3]];
    }
  }
  firstKeyByValue(value2, eq = isEqualDefault) {
    const entry = firstEntryByValue(this, value2, eq);
    if (entry) return entry[0];
  }
  /**
   * Get all values under `key`
   * @param key
   * @returns
   */
  *get(key) {
    const m5 = this.map.get(key);
    if (!m5) return;
    yield* m5.values();
  }
  /**
   * Iterate over all keys
   */
  *keys() {
    yield* this.map.keys();
  }
  /**
   * Iterate over all values (regardless of key)
   */
  *valuesFlat() {
    for (const entries2 of this.map) {
      yield* entries2[1];
    }
  }
  /**
   * Iterate over keys and length of values stored under keys
   */
  *keysAndCounts() {
    for (const entries2 of this.map) {
      yield [entries2[0], entries2[1].length];
    }
  }
  /**
   * Returns _true_ if `key` exists
   * @param key
   * @returns
   */
  //eslint-disable-next-line functional/prefer-tacit
  has(key) {
    return this.map.has(key);
  }
  /**
   * Returns _true_ if `value` exists under `key`.
   * @param key Key
   * @param value Value to seek under `key`
   * @returns _True_ if `value` exists under `key`.
   */
  hasKeyValue(key, value2) {
    const values = this.map.get(key);
    if (!values) return false;
    for (const v3 of values) {
      if (this.valueEq(v3, value2)) return true;
    }
    return false;
  }
  /**
   * Debug dump of contents
   * @returns
   */
  debugString() {
    let r5 = ``;
    const keys = [...this.map.keys()];
    keys.every((k3) => {
      const v3 = this.map.get(k3);
      if (v3 === void 0) return;
      r5 += k3 + ` (${v3.length}) = ${JSON.stringify(v3)}\r
`;
    });
    return r5;
  }
  /**
   * _True_ if empty
   */
  get isEmpty() {
    return this.map.size === 0;
  }
  /**
   * Return number of values stored under `key`.
   * Returns 0 if `key` is not found.
   * @param key
   * @returns
   */
  count(key) {
    const values = this.map.get(key);
    if (!values) return 0;
    return values.length;
  }
  get lengthKeys() {
    return this.map.size;
  }
};
var MapOfSimpleMutable = class extends MapOfSimpleBase {
  addKeyedValues(key, ...values) {
    const existing = this.map.get(key);
    if (existing === void 0) {
      this.map.set(key, values);
    } else {
      this.map.set(key, [...existing, ...values]);
    }
  }
  /**
   * Adds a value, automatically extracting a key via the
   * `groupBy` function assigned in the constructor options.
   * @param values Adds several values
   */
  addValue(...values) {
    for (const v3 of values) {
      const key = this.groupBy(v3);
      this.addKeyedValues(key, v3);
    }
  }
  /**
   * Delete `value` under a particular `key`
   * @param key
   * @param value
   * @returns _True_ if `value` was found under `key`
   */
  deleteKeyValue(key, value2) {
    const existing = this.map.get(key);
    if (existing === void 0) return false;
    const without2 = existing.filter((existingValue) => !this.valueEq(existingValue, value2));
    this.map.set(key, without2);
    return without2.length < existing.length;
  }
  /**
   * Deletes `value` regardless of key.
   *
   * Uses the constructor-defined equality function.
   * @param value Value to delete
   * @returns
   */
  deleteByValue(value2) {
    let del2 = false;
    const entries2 = [...this.map.entries()];
    for (const keyEntries of entries2) {
      for (const values of keyEntries[1]) {
        if (this.valueEq(values, value2)) {
          del2 = true;
          this.deleteKeyValue(keyEntries[0], value2);
        }
      }
    }
    return del2;
  }
  /**
   * Deletes all values under `key`,
   * @param key
   * @returns _True_ if `key` was found and values stored
   */
  delete(key) {
    const values = this.map.get(key);
    if (!values) return false;
    if (values.length === 0) return false;
    this.map.delete(key);
    return true;
  }
  /**
   * Clear contents
   */
  clear() {
    this.map.clear();
  }
};
var ofSimpleMutable = (groupBy = defaultKeyer, valueEq = isEqualDefault) => new MapOfSimpleMutable(groupBy, valueEq);
var eventRace = (target, eventNames, options = {}) => {
  const intervalMs = intervalToMs(options.timeout, 60 * 1e3);
  const signal = options.signal;
  let triggered = false;
  let disposed = false;
  let timeout2;
  const promise = new Promise((resolve3, reject) => {
    const onEvent = (event2) => {
      if (`type` in event2) {
        if (eventNames.includes(event2.type)) {
          triggered = true;
          resolve3(event2);
          dispose();
        } else {
          console.warn(`eventRace: Got event '${event2.type}' that is not in race list`);
        }
      } else {
        console.warn(`eventRace: Event data does not have expected 'type' field`);
        console.log(event2);
      }
    };
    for (const name of eventNames) {
      target.addEventListener(name, onEvent);
    }
    const dispose = () => {
      if (disposed) return;
      if (timeout2 !== void 0) clearTimeout(timeout2);
      timeout2 = void 0;
      disposed = true;
      for (const name of eventNames) {
        target.removeEventListener(name, onEvent);
      }
    };
    timeout2 = setTimeout(() => {
      if (triggered || disposed) return;
      dispose();
      reject(new Error(`eventRace: Events not fired within interval. Events: ${JSON.stringify(eventNames)} Interval: ${intervalMs}`));
    }, intervalMs);
    signal?.addEventListener(`abort`, () => {
      if (triggered || disposed) return;
      dispose();
      reject(new Error(`Abort signal received ${signal.reason}`));
    });
  });
  return promise;
};
var SimpleEventEmitter = class {
  #listeners = ofSimpleMutable();
  #disposed = false;
  dispose() {
    if (this.#disposed) return;
    this.clearEventListeners();
  }
  get isDisposed() {
    return this.#disposed;
  }
  /**
   * Fire event
   * @param type Type of event
   * @param args Arguments for event
   * @returns
   */
  fireEvent(type2, args) {
    if (this.#disposed) throw new Error(`Disposed`);
    const listeners = this.#listeners.get(type2);
    for (const l3 of listeners) {
      l3(args, this);
    }
  }
  /**
   * Adds event listener.
   * 
   * @throws Error if emitter is disposed
   * @typeParam K - Events
   * @param name Event name
   * @param listener Event handler
   */
  addEventListener(name, listener) {
    if (this.#disposed) throw new Error(`Disposed`);
    this.#listeners.addKeyedValues(
      name,
      listener
    );
  }
  /**
   * Remove event listener
   *
   * @param listener
   */
  removeEventListener(type2, listener) {
    if (this.#disposed) return;
    this.#listeners.deleteKeyValue(
      type2,
      listener
    );
  }
  /**
   * Clear all event listeners
   * @private
   */
  clearEventListeners() {
    if (this.#disposed) return;
    this.#listeners.clear();
  }
};

// node_modules/ixfx/dist/chunk-5VWJ6TUI.js
var defaultRandom = Math.random;

// node_modules/ixfx/dist/chunk-7U6QARGK.js
var string = (lengthOrOptions = 5) => {
  const options = typeof lengthOrOptions === `number` ? { length: lengthOrOptions } : lengthOrOptions;
  const calculate = options.source ?? defaultRandom;
  return calculate().toString(36).slice(2, length + 2);
};

// node_modules/ixfx/dist/chunk-F3LKPXTP.js
var Text_exports = {};
__export(Text_exports, {
  abbreviate: () => abbreviate,
  afterMatch: () => afterMatch,
  beforeAfterMatch: () => beforeAfterMatch,
  beforeMatch: () => beforeMatch,
  between: () => between,
  betweenChomp: () => betweenChomp,
  countCharsFromStart: () => countCharsFromStart,
  htmlEntities: () => htmlEntities,
  indexOfCharCode: () => indexOfCharCode,
  lineSpan: () => lineSpan,
  omitChars: () => omitChars,
  random: () => string,
  splitByLength: () => splitByLength,
  splitRanges: () => splitRanges,
  startsEnds: () => startsEnds,
  toStringAbbreviate: () => toStringAbbreviate,
  unwrap: () => unwrap,
  wildcard: () => wildcard
});
var abbreviate = (source, maxLength = 15) => {
  throwFromResult(integerTest(maxLength, `aboveZero`, `maxLength`));
  if (typeof source !== `string`) throw new Error(`Parameter 'source' is not a string`);
  if (source.length > maxLength && source.length > 3) {
    if (maxLength > 15) {
      const chunk2 = Math.round((maxLength - 2) / 2);
      return source.slice(0, chunk2) + `...` + source.slice(-chunk2);
    }
    return source.slice(0, maxLength) + `...`;
  }
  return source;
};
var toStringAbbreviate = (source, maxLength = 20) => {
  if (source === void 0) return `(undefined)`;
  if (source === null) return `(null)`;
  return abbreviate(JSON.stringify(source), maxLength);
};
var between = (source, start, end, lastEndMatch = true) => {
  const startPos = source.indexOf(start);
  if (startPos < 0) return;
  if (end === void 0) end = start;
  const endPos = lastEndMatch ? source.lastIndexOf(end) : source.indexOf(end, startPos + 1);
  if (endPos < 0) return;
  return source.slice(startPos + 1, endPos);
};
var betweenChomp = (source, start, end, lastEndMatch = true) => {
  if (typeof source !== `string`) throw new Error(`Parameter 'source' is not a string`);
  if (typeof start !== `string`) throw new Error(`Parameter 'start' is not a string`);
  if (end !== void 0 && typeof end !== `string`) throw new Error(`Parameter 'end' is not a string`);
  const startPos = source.indexOf(start);
  if (startPos < 0) return [source, void 0];
  if (end === void 0) end = start;
  const endPos = lastEndMatch ? source.lastIndexOf(end) : source.indexOf(end, startPos + 1);
  if (endPos < 0) return [source, void 0];
  const between2 = source.slice(startPos + 1, endPos);
  const sourceResult = source.slice(0, startPos) + source.slice(endPos + 1);
  return [sourceResult, between2];
};
var indexOfCharCode = (source, code, start = 0, end = source.length - 1) => {
  for (let index = start; index <= end; index++) {
    if (source.codePointAt(index) === code) return index;
  }
  return -1;
};
var omitChars = (source, removeStart, removeLength) => source.slice(0, removeStart) + source.slice(removeStart + removeLength);
var splitByLength = (source, length5) => {
  throwFromResult(integerTest(length5, `aboveZero`, `length`));
  if (source === null) throw new Error(`source parameter null`);
  if (typeof source !== `string`) {
    throw new TypeError(`source parameter not a string`);
  }
  const chunks3 = Math.ceil(source.length / length5);
  const returnValue = [];
  let start = 0;
  for (let c6 = 0; c6 < chunks3; c6++) {
    returnValue.push(source.slice(start, start + length5));
    start += length5;
  }
  return returnValue;
};
var beforeMatch = (source, match, options = {}) => {
  const ba2 = beforeAfterMatch(source, match, options);
  return ba2[0];
};
var afterMatch = (source, match, options = {}) => {
  const ba2 = beforeAfterMatch(source, match, options);
  return ba2[1];
};
var beforeAfterMatch = (source, match, options = {}) => {
  if (source === void 0) throw new Error(`Param 'source' is undefined`);
  let fallback = options.fallback;
  const ifNoMatch = options.ifNoMatch ?? (fallback ? `fallback` : `original`);
  if (ifNoMatch === `original`) fallback = source;
  if (ifNoMatch === `fallback` && fallback === void 0) throw new Error(`Fallback must be provided`);
  const startPos = options.startPos ?? void 0;
  const fromEnd = options.fromEnd ?? false;
  const m5 = fromEnd ? source.lastIndexOf(match, startPos) : source.indexOf(match, startPos);
  if (m5 < 0 && ifNoMatch === `throw`) throw new Error(`Match '${match}' not found in source.`);
  if (m5 < 0 && ifNoMatch === `original`) return [source, source];
  if (m5 < 0 && ifNoMatch === `fallback`) {
    return [fallback, fallback];
  }
  return [
    source.slice(0, m5),
    source.slice(Math.max(0, m5 + match.length))
  ];
};
var unwrap = (source, ...wrappers) => {
  let matched = false;
  do {
    matched = false;
    for (const w3 of wrappers) {
      if (source.startsWith(w3) && source.endsWith(w3)) {
        source = source.slice(w3.length, source.length - w3.length * 2 + 1);
        matched = true;
      }
    }
  } while (matched);
  return source;
};
var lineSpan = (ranges, start, end) => {
  let s3 = -1;
  let endPos = -1;
  for (const [index, r5] of ranges.entries()) {
    s3 = index;
    if (r5.text.length === 0) continue;
    if (start < r5.end) {
      break;
    }
  }
  for (let index = s3; index < ranges.length; index++) {
    const r5 = ranges[index];
    endPos = index;
    if (end === r5.end) {
      endPos = index + 1;
      break;
    }
    if (end < r5.end) {
      break;
    }
  }
  return { length: endPos - s3, start: s3, end: endPos };
};
var splitRanges = (source, split2) => {
  let start = 0;
  let text2 = ``;
  const ranges = [];
  let index = 0;
  for (let i4 = 0; i4 < source.length; i4++) {
    if (source.indexOf(split2, i4) === i4) {
      const end = i4;
      ranges.push({
        text: text2,
        start,
        end,
        index
      });
      start = end + 1;
      text2 = ``;
      index++;
    } else {
      text2 += source.charAt(i4);
    }
  }
  if (start < source.length) {
    ranges.push({ text: text2, start, index, end: source.length });
  }
  return ranges;
};
var countCharsFromStart = (source, ...chars) => {
  let counted = 0;
  for (let index = 0; index < source.length; index++) {
    if (chars.includes(source.charAt(index))) {
      counted++;
    } else {
      break;
    }
  }
  return counted;
};
var startsEnds = (source, start, end = start) => source.startsWith(start) && source.endsWith(end);
var htmlEntities = (source) => source.replaceAll(/[&<>\u00A0-\u9999]/g, (index) => `&#${index.codePointAt(0)};`);
var wildcard = (pattern) => {
  const escapeRegex = (value2) => value2.replaceAll(/([!$()*+./:=?[\\\]^{|}])/g, `\\$1`);
  pattern = pattern.split(`*`).map((m5) => escapeRegex(m5)).join(`.*`);
  pattern = `^` + pattern + `$`;
  const regex = new RegExp(pattern);
  return (value2) => {
    return regex.test(value2);
  };
};

// node_modules/ixfx/dist/chunk-GISMJX5E.js
var guardArray = (array2, name = `?`) => {
  if (array2 === void 0) {
    throw new TypeError(`Param '${name}' is undefined. Expected array.`);
  }
  if (array2 === null) {
    throw new TypeError(`Param '${name}' is null. Expected array.`);
  }
  if (!Array.isArray(array2)) {
    throw new TypeError(`Param '${name}' not an array as expected`);
  }
};

// node_modules/ixfx/dist/chunk-5XZFO6U6.js
function* slice(it2, start = 0, end = Number.POSITIVE_INFINITY) {
  const iit = it2[Symbol.iterator]();
  if (end < start) throw new Error(`Param 'end' should be more than 'start'`);
  for (; start > 0; start--, end--) iit.next();
  for (const v3 of it2) {
    if (end-- > 0) {
      yield v3;
    } else {
      break;
    }
  }
}
var guardIndex = (array2, index, name = `index`) => {
  guardArray(array2);
  throwIntegerTest(index, `positive`, name);
  if (index > array2.length - 1) {
    throw new Error(
      `'${name}' ${index} beyond array max of ${array2.length - 1}`
    );
  }
};
var withoutUndefined = (data) => {
  return data.filter((v3) => v3 !== void 0);
};
function* filterBetween(array2, predicate, startIndex, endIndex) {
  guardArray(array2);
  if (typeof startIndex === `undefined`) startIndex = 0;
  if (typeof endIndex === `undefined`) endIndex = array2.length;
  guardIndex(array2, startIndex, `startIndex`);
  guardIndex(array2, endIndex - 1, `endIndex`);
  for (let index = startIndex; index < endIndex; index++) {
    if (predicate(array2[index], index, array2)) yield array2[index];
  }
}
var without = (sourceArray, toRemove, comparer = isEqualDefault) => {
  if (Array.isArray(toRemove)) {
    const returnArray = [];
    for (const source of sourceArray) {
      if (!toRemove.some((v3) => comparer(source, v3))) {
        returnArray.push(source);
      }
    }
    return returnArray;
  } else {
    return sourceArray.filter((v3) => !comparer(v3, toRemove));
  }
};
var minMaxAvg = (data, opts = {}) => {
  if (data === void 0) throw new Error(`'data' is undefined`);
  if (!Array.isArray(data)) {
    if (`next` in data) {
      if (opts.startIndex || opts.endIndex) {
        data = slice(data, opts.startIndex, opts.endIndex);
      }
      let total2 = 0;
      let min6 = Number.MAX_SAFE_INTEGER;
      let max5 = Number.MIN_SAFE_INTEGER;
      let samples = 0;
      for (const v3 of data) {
        if (typeof v3 !== `number`) {
          throw new TypeError(`Generator should yield numbers. Got: ${typeof v3}`);
        }
        total2 += v3;
        samples++;
        min6 = Math.min(min6, v3);
        max5 = Math.max(max5, v3);
      }
      return {
        avg: total2 / samples,
        total: total2,
        max: max5,
        min: min6
      };
    } else {
      throw new Error(`'data' parameter is neither array or iterable`);
    }
  }
  if (data.length === 0) {
    return {
      total: 0,
      min: 0,
      max: 0,
      avg: 0
    };
  }
  const startIndex = opts.startIndex ?? 0;
  const endIndex = opts.endIndex ?? data.length;
  const validNumbers = [...filterBetween(
    data,
    (d4) => typeof d4 === `number` && !Number.isNaN(d4),
    startIndex,
    endIndex
  )];
  const total = validNumbers.reduce((accumulator, v3) => accumulator + v3, 0);
  return {
    total,
    max: Math.max(...validNumbers),
    min: Math.min(...validNumbers),
    avg: total / validNumbers.length
  };
};

// node_modules/ixfx/dist/chunk-ZVECQWBZ.js
var isFunction = (object2) => object2 instanceof Function;
var functionTest = (value2, parameterName = `?`) => {
  if (value2 === void 0) return [false, `Param '${parameterName}' is undefined. Expected: function.`];
  if (value2 === null) return [false, `Param '${parameterName}' is null. Expected: function.`];
  if (typeof value2 !== `function`) return [false, `Param '${parameterName}' is type '${typeof value2}'. Expected: function`];
  return [true];
};
var throwFunctionTest = (value2, parameterName = `?`) => {
  const [ok, msg] = functionTest(value2, parameterName);
  if (ok) return;
  throw new TypeError(msg);
};
var stringTest = (value2, range2 = ``, parameterName = `?`) => {
  if (typeof value2 !== `string`) return [false, `Param '${parameterName} is not type string. Got: ${typeof value2}`];
  switch (range2) {
    case `non-empty`:
      if (value2.length === 0) return [false, `Param '${parameterName} is empty`];
      break;
  }
  return [true];
};
var throwStringTest = (value2, range2 = ``, parameterName = `?`) => {
  throwFromResult(stringTest(value2, range2, parameterName));
};

// node_modules/ixfx/dist/chunk-QCJFJKA3.js
var guards_exports = {};
__export(guards_exports, {
  arrayTest: () => arrayTest,
  defined: () => defined,
  functionTest: () => functionTest,
  ifNaN: () => ifNaN,
  integerParse: () => integerParse,
  integerTest: () => integerTest,
  isFunction: () => isFunction,
  isPlainObject: () => isPlainObject,
  isPlainObjectOrPrimitive: () => isPlainObjectOrPrimitive,
  isPowerOfTwo: () => isPowerOfTwo,
  isStringArray: () => isStringArray,
  nullUndef: () => nullUndef,
  numberTest: () => numberTest,
  percentTest: () => percentTest,
  stringTest: () => stringTest,
  throwArrayTest: () => throwArrayTest,
  throwFromResult: () => throwFromResult,
  throwFunctionTest: () => throwFunctionTest,
  throwIntegerTest: () => throwIntegerTest,
  throwNullUndef: () => throwNullUndef,
  throwNumberTest: () => throwNumberTest,
  throwPercentTest: () => throwPercentTest,
  throwStringTest: () => throwStringTest
});
var arrayTest = (value2, parameterName = `?`) => {
  if (!Array.isArray(value2)) {
    return [false, `Parameter '${parameterName}' is expected to be an array'`];
  }
  return [true];
};
var throwArrayTest = (value2, parameterName = `?`) => {
  throwFromResult(arrayTest(value2, parameterName));
};
var isStringArray = (value2) => {
  if (!Array.isArray(value2)) return false;
  return !value2.some((v3) => typeof v3 !== `string`);
};
var nullUndef = (value2, parameterName = `?`) => {
  if (typeof value2 === `undefined`) {
    return [false, `${parameterName} param is undefined`];
  }
  if (value2 === null) return [false, `${parameterName} param is null`];
  return [true];
};
var throwNullUndef = (value2, parameterName = `?`) => {
  const r5 = nullUndef(value2, parameterName);
  if (r5[0]) return;
  throw new Error(r5[1]);
};
var defined = (argument) => argument !== void 0;
var isPlainObject = (value2) => {
  if (typeof value2 !== `object` || value2 === null) return false;
  const prototype = Object.getPrototypeOf(value2);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value2) && !(Symbol.iterator in value2);
};
var isPlainObjectOrPrimitive = (value2) => {
  const t6 = typeof value2;
  if (t6 === `symbol`) return false;
  if (t6 === `function`) return false;
  if (t6 === `bigint`) return true;
  if (t6 === `number`) return true;
  if (t6 === `string`) return true;
  if (t6 === `boolean`) return true;
  return isPlainObject(value2);
};

// node_modules/ixfx/dist/chunk-HOGLR6UM.js
var mapKeys = (object2, mapFunction) => {
  const destinationObject = {};
  for (const entries2 of Object.entries(object2)) {
    const key = mapFunction(entries2[0]);
    destinationObject[key] = entries2[1];
  }
  return destinationObject;
};

// node_modules/ixfx/dist/chunk-F6WHOKNI.js
var util_exports = {};
__export(util_exports, {
  Guards: () => guards_exports,
  comparerInverse: () => comparerInverse,
  defaultComparer: () => defaultComparer,
  defaultToString: () => defaultToString,
  getSorter: () => getSorter,
  isEqualDefault: () => isEqualDefault,
  isEqualTrace: () => isEqualTrace,
  isEqualValueDefault: () => isEqualValueDefault,
  isEqualValueIgnoreOrder: () => isEqualValueIgnoreOrder,
  isEqualValuePartial: () => isEqualValuePartial,
  isInteger: () => isInteger,
  isMap: () => isMap,
  isSet: () => isSet,
  jsComparer: () => jsComparer,
  mapKeys: () => mapKeys,
  minMaxAvg: () => minMaxAvg2,
  numericComparer: () => numericComparer,
  runningiOS: () => runningiOS,
  throwResult: () => throwResult,
  toStringDefault: () => toStringDefault,
  toStringOrdered: () => toStringOrdered
});
var numericComparer = (x3, y3) => {
  if (x3 === y3) return 0;
  if (x3 > y3) return 1;
  return -1;
};
var jsComparer = (x3, y3) => {
  if (x3 === void 0 && y3 === void 0) return 0;
  if (x3 === void 0) return 1;
  if (y3 === void 0) return -1;
  const xString = defaultToString(x3);
  const yString = defaultToString(y3);
  if (xString < yString) return -1;
  if (xString > yString) return 1;
  return 0;
};
var comparerInverse = (comparer) => {
  return (x3, y3) => {
    const v3 = comparer(x3, y3);
    return v3 * -1;
  };
};
var defaultComparer = (x3, y3) => {
  if (typeof x3 === `number` && typeof y3 === `number`) {
    return numericComparer(x3, y3);
  }
  return jsComparer(x3, y3);
};
var isEqualTrace = (eq) => {
  return (a4, b4) => {
    const result = eq(a4, b4);
    console.log(`isEqualTrace eq: ${result} a: ${toStringAbbreviate(a4)} b: ${toStringAbbreviate(b4)}`);
    return result;
  };
};
var isInteger = (value2) => {
  if (value2 === void 0) return false;
  if (typeof value2 === `string`) {
    const v3 = Number.parseInt(value2);
    if (Number.isNaN(v3)) return false;
    if (v3.toString() === value2.toString()) return true;
    return false;
  }
  if (typeof value2 === `number`) {
    if (Number.isNaN(value2)) return false;
    if (!Number.isFinite(value2)) return false;
    if (Math.round(value2) === value2) return true;
    return false;
  }
  return false;
};
var runningiOS = () => [
  `iPad Simulator`,
  `iPhone Simulator`,
  `iPod Simulator`,
  `iPad`,
  `iPhone`,
  `iPod`
].includes(navigator.platform) || // iPad on iOS 13 detection
navigator.userAgent.includes(`Mac`) && `ontouchend` in document;
function throwResult(result) {
  if (result.success) return true;
  if (typeof result.error === `string`) throw new Error(result.error);
  throw result.error;
}
var sorterByValueIndex = (index, reverse = false) => {
  return (values) => {
    const s3 = values.toSorted((a4, b4) => {
      return defaultComparer(a4[index], b4[index]);
    });
    if (reverse) return s3.reverse();
    return s3;
  };
};
var getSorter = (sortStyle) => {
  switch (sortStyle) {
    case `value`: {
      return sorterByValueIndex(1, false);
    }
    case `value-reverse`: {
      return sorterByValueIndex(1, true);
    }
    case `key`: {
      return sorterByValueIndex(0, false);
    }
    case `key-reverse`: {
      return sorterByValueIndex(0, true);
    }
    default: {
      throw new Error(`Unknown sorting value '${sortStyle}'. Expecting: value, value-reverse, key or key-reverse`);
    }
  }
};
var minMaxAvg2 = (entries2, conversionFunction) => {
  const converter = conversionFunction ?? ((v3) => v3[1]);
  const values = entries2.map((entry) => converter(entry));
  return minMaxAvg(values);
};

// node_modules/ixfx/dist/chunk-XN3FNKKY.js
var getFromKeys = (data, keys) => {
  for (const key of keys) {
    if (data.has(key)) return data.get(key);
  }
};
var addKeepingExisting = (set3, hasher, ...values) => {
  const s3 = set3 === void 0 ? /* @__PURE__ */ new Map() : new Map(set3);
  for (const v3 of values) {
    const hashResult = hasher(v3);
    if (s3.has(hashResult)) continue;
    s3.set(hashResult, v3);
  }
  return s3;
};
var sortByValueProperty = (map3, property, compareFunction) => {
  const cfn = typeof compareFunction === `undefined` ? defaultComparer : compareFunction;
  return [...map3.entries()].sort((aE, bE) => {
    const a4 = aE[1];
    const b4 = bE[1];
    return cfn(a4[property], b4[property]);
  });
};
var hasAnyValue = (map3, value2, comparer) => {
  const entries2 = [...map3.entries()];
  return entries2.some((kv) => comparer(kv[1], value2));
};
function* filter(map3, predicate) {
  for (const v3 of map3.values()) {
    if (predicate(v3)) yield v3;
  }
}
var toArray = (map3) => [...map3.values()];
var find = (map3, predicate) => [...map3.values()].find((v3) => predicate(v3));
var some = (map3, predicate) => [...map3.values()].some((v3) => predicate(v3));
var zipKeyValue = (keys, values) => {
  if (keys.length !== values.length) {
    throw new Error(`Keys and values arrays should be same length`);
  }
  return Object.fromEntries(keys.map((k3, index) => [k3, values[index]]));
};

// node_modules/ixfx/dist/chunk-24WRBUZC.js
var Map_exports = {};
__export(Map_exports, {
  MapOfMutableImpl: () => MapOfMutableImpl,
  NumberMap: () => NumberMap,
  expiringMap: () => create,
  immutable: () => immutable,
  mapOfSimpleMutable: () => ofSimpleMutable,
  mutable: () => mutable,
  ofArrayMutable: () => ofArrayMutable,
  ofCircularMutable: () => ofCircularMutable,
  ofSetMutable: () => ofSetMutable
});
var create = (options = {}) => new ExpiringMap(options);
var ExpiringMap = class extends SimpleEventEmitter {
  constructor(opts = {}) {
    super();
    this.capacity = opts.capacity ?? -1;
    throwIntegerTest(this.capacity, `nonZero`, `capacity`);
    this.store = /* @__PURE__ */ new Map();
    if (opts.evictPolicy && this.capacity <= 0) {
      throw new Error(`evictPolicy is set, but no capacity limit is set`);
    }
    this.evictPolicy = opts.evictPolicy ?? `none`;
    this.autoDeleteElapsedMs = opts.autoDeleteElapsedMs ?? -1;
    this.autoDeletePolicy = opts.autoDeletePolicy ?? `none`;
    if (this.autoDeleteElapsedMs > 0) {
      setInterval(
        () => {
          this.#maintain();
        },
        Math.max(1e3, this.autoDeleteElapsedMs * 2)
      );
    }
  }
  /**
   * Returns the number of keys being stored.
   */
  get keyLength() {
    return this.store.size;
  }
  *entries() {
    for (const entry of this.store.entries()) {
      yield [entry[0], entry[1].value];
    }
  }
  *values() {
    for (const v3 of this.store.values()) {
      yield v3.value;
    }
  }
  *keys() {
    yield* this.store.keys();
  }
  /**
   * Returns the elapsed time since `key`
   * was set. Returns _undefined_ if `key`
   * does not exist
   */
  elapsedSet(key) {
    const v3 = this.store.get(key);
    if (!v3) return v3;
    return Date.now() - v3.lastSet;
  }
  /**
   * Returns the elapsed time since `key`
   * was accessed. Returns _undefined_ if `key`
   * does not exist
   */
  elapsedGet(key) {
    const v3 = this.store.get(key);
    if (!v3) return v3;
    return Date.now() - v3.lastGet;
  }
  /**
   * Returns true if `key` is stored.
   * Does not affect the key's last access time.
   * @param key
   * @returns
   */
  has(key) {
    return this.store.has(key);
  }
  /**
   * Gets an item from the map by key, returning
   * undefined if not present
   * @param key Key
   * @returns Value, or undefined
   */
  get(key) {
    const v3 = this.store.get(key);
    if (v3) {
      if (this.autoDeletePolicy === `either` || this.autoDeletePolicy === `get`) {
        this.store.set(key, {
          ...v3,
          lastGet: performance.now()
        });
      }
      return v3.value;
    }
  }
  /**
   * Deletes the value under `key`, if present.
   *
   * Returns _true_ if something was removed.
   * @param key
   * @returns
   */
  delete(key) {
    const value2 = this.store.get(key);
    if (!value2) return false;
    const d4 = this.store.delete(key);
    this.fireEvent(`removed`, {
      key,
      value: value2.value
    });
    return d4;
  }
  /**
   * Clears the contents of the map.
   * Note: does not fire `removed` event
   */
  clear() {
    this.store.clear();
  }
  /**
   * Updates the lastSet/lastGet time for a value
   * under `k`.
   *
   * Returns false if key was not found
   * @param key
   * @returns
   */
  touch(key) {
    const v3 = this.store.get(key);
    if (!v3) return false;
    this.store.set(key, {
      ...v3,
      lastSet: Date.now(),
      lastGet: Date.now()
    });
    return true;
  }
  findEvicteeKey() {
    if (this.evictPolicy === `none`) return;
    let sortBy = ``;
    if (this.evictPolicy === `oldestGet`) sortBy = `lastGet`;
    else if (this.evictPolicy === `oldestSet`) sortBy = `lastSet`;
    else throw new Error(`Unknown eviction policy ${this.evictPolicy}`);
    const sorted = sortByValueProperty(this.store, sortBy);
    return sorted[0][0];
  }
  #maintain() {
    if (this.autoDeletePolicy === `none`) return;
    this.deleteWithElapsed(this.autoDeleteElapsedMs, this.autoDeletePolicy);
  }
  /**
   * Deletes all values where elapsed time has past
   * for get/set or either.
   * ```js
   * // Delete all keys (and associated values) not accessed for a minute
   * em.deleteWithElapsed({mins:1}, `get`);
   * // Delete things that were set 1s ago
   * em.deleteWithElapsed(1000, `set`);
   * ```
   * 
   * @param interval Interval
   * @param property Basis for deletion 'get','set' or 'either'
   * @returns Items removed
   */
  deleteWithElapsed(interval2, property) {
    const entries2 = [...this.store.entries()];
    const prune = [];
    const intervalMs = intervalToMs(interval2, 1e3);
    const now = Date.now();
    for (const entry of entries2) {
      const elapsedGet = now - entry[1].lastGet;
      const elapsedSet = now - entry[1].lastSet;
      const elapsed3 = property === `get` ? elapsedGet : property === `set` ? elapsedSet : Math.max(elapsedGet, elapsedSet);
      if (elapsed3 >= intervalMs) {
        prune.push([entry[0], entry[1].value]);
      }
    }
    for (const entry of prune) {
      this.store.delete(entry[0]);
      const eventArguments = {
        key: entry[0],
        value: entry[1]
      };
      this.fireEvent(`expired`, eventArguments);
      this.fireEvent(`removed`, eventArguments);
    }
    return prune;
  }
  /**
   * Sets the `key` to be `value`.
   *
   * If the key already exists, it is updated.
   *
   * If the map is full, according to its capacity,
   * another value is selected for removal.
   * @param key
   * @param value
   * @returns
   */
  set(key, value2) {
    const existing = this.store.get(key);
    if (existing) {
      this.store.set(key, {
        ...existing,
        lastSet: performance.now()
      });
      return;
    }
    if (this.keyLength === this.capacity && this.capacity > 0) {
      const key2 = this.findEvicteeKey();
      if (!key2) {
        throw new Error(`ExpiringMap full (capacity: ${this.capacity})`);
      }
      const existing2 = this.store.get(key2);
      this.store.delete(key2);
      if (existing2) {
        const eventArguments = { key: key2, value: existing2.value };
        this.fireEvent(`expired`, eventArguments);
        this.fireEvent(`removed`, eventArguments);
      }
    }
    this.store.set(key, {
      lastGet: 0,
      lastSet: Date.now(),
      value: value2
    });
    this.fireEvent(`newKey`, { key, value: value2 });
  }
};
var mutable = (...data) => {
  let m5 = add(/* @__PURE__ */ new Map(), ...data);
  return {
    add: (...data2) => {
      m5 = add(m5, ...data2);
    },
    delete: (key) => {
      m5 = del(m5, key);
    },
    clear: () => {
      m5 = add(/* @__PURE__ */ new Map());
    },
    set: (key, value2) => {
      m5 = set(m5, key, value2);
    },
    get: (key) => m5.get(key),
    entries: () => m5.entries(),
    values: () => m5.values(),
    isEmpty: () => m5.size === 0,
    has: (key) => has(m5, key)
  };
};
var MapOfMutableImpl = class extends SimpleEventEmitter {
  /* eslint-disable-next-line functional/prefer-readonly-type */
  #map = /* @__PURE__ */ new Map();
  constructor(type2, opts = {}) {
    super();
    this.type = type2;
    this.groupBy = opts.groupBy ?? toStringDefault;
  }
  /**
   * Returns the type name. For in-built implementations, it will be one of: array, set or circular
   */
  get typeName() {
    return this.type.name;
  }
  /**
   * Returns the number of keys
   */
  get lengthKeys() {
    return this.#map.size;
  }
  /**
   * Returns the length of the longest child list
   */
  get lengthMax() {
    let m5 = 0;
    for (const v3 of this.#map.values()) {
      m5 = Math.max(m5, this.type.count(v3));
    }
    return m5;
  }
  debugString() {
    const keys = [...this.#map.keys()];
    let r5 = `Keys: ${keys.join(`, `)}\r
`;
    for (const k3 of keys) {
      const v3 = this.#map.get(k3);
      if (v3 === void 0) {
        r5 += ` - ${k3} (undefined)\r
`;
      } else {
        const asArray = this.type.toArray(v3);
        if (asArray !== void 0) {
          r5 += ` - ${k3} (${this.type.count(v3)}) = ${JSON.stringify(
            asArray
          )}\r
`;
        }
      }
    }
    ;
    return r5;
  }
  get isEmpty() {
    return this.#map.size === 0;
  }
  clear() {
    this.#map.clear();
    super.fireEvent(`clear`, true);
  }
  //eslint-disable-next-line functional/prefer-immutable-types
  addKeyedValues(key, ...values) {
    const set22 = this.#map.get(key);
    if (set22 === void 0) {
      this.#map.set(key, this.type.add(void 0, values));
      super.fireEvent(`addedKey`, { key });
      super.fireEvent(`addedValues`, { values });
    } else {
      this.#map.set(key, this.type.add(set22, values));
      super.fireEvent(`addedValues`, { values });
    }
  }
  //eslint-disable-next-line functional/prefer-immutable-types
  set(key, values) {
    this.addKeyedValues(key, ...values);
    return this;
  }
  addValue(...values) {
    for (const v3 of values) this.addKeyedValues(this.groupBy(v3), v3);
  }
  hasKeyValue(key, value2, eq) {
    const m5 = this.#map.get(key);
    if (m5 === void 0) return false;
    return this.type.has(m5, value2, eq);
  }
  //eslint-disable-next-line functional/prefer-tacit
  has(key) {
    return this.#map.has(key);
  }
  deleteKeyValue(key, value2) {
    const a4 = this.#map.get(key);
    if (a4 === void 0) return false;
    return this.deleteKeyValueFromMap(a4, key, value2);
  }
  deleteKeyValueFromMap(map3, key, value2) {
    const preCount = this.type.count(map3);
    const filtered = this.type.without(map3, value2);
    const postCount = filtered.length;
    this.#map.set(key, this.type.add(void 0, filtered));
    return preCount > postCount;
  }
  deleteByValue(value2) {
    let something = false;
    [...this.#map.keys()].filter((key) => {
      const a4 = this.#map.get(key);
      if (!a4) throw new Error(`Bug: map could not be accessed`);
      if (this.deleteKeyValueFromMap(a4, key, value2)) {
        something = true;
        if (this.count(key) === 0) this.delete(key);
      }
    });
    return something;
  }
  delete(key) {
    const a4 = this.#map.get(key);
    if (a4 === void 0) return false;
    this.#map.delete(key);
    this.fireEvent(`deleteKey`, { key });
    return true;
  }
  firstKeyByValue(value2, eq = isEqualDefault) {
    const keys = [...this.#map.keys()];
    const found = keys.find((key) => {
      const a4 = this.#map.get(key);
      if (a4 === void 0) throw new Error(`Bug: map could not be accessed`);
      const r5 = this.type.has(a4, value2, eq);
      return r5;
    });
    return found;
  }
  count(key) {
    const entry = this.#map.get(key);
    if (entry === void 0) return 0;
    return this.type.count(entry);
  }
  /**
   * Iterates over values stored under `key`
   * An empty array is returned if there are no values
   */
  *get(key) {
    const m5 = this.#map.get(key);
    if (m5 === void 0) return;
    yield* this.type.iterable(m5);
  }
  /**
   * Iterate over the values stored under `key`.
   * If key does not exist, iteration is essentially a no-op
   * @param key
   * @returns
   */
  *valuesFor(key) {
    const m5 = this.#map.get(key);
    if (m5 === void 0) return;
    yield* this.type.iterable(m5);
  }
  //eslint-disable-next-line functional/prefer-tacit
  getSource(key) {
    return this.#map.get(key);
  }
  /* eslint-disable-next-line functional/prefer-readonly-type */
  *keys() {
    yield* this.#map.keys();
  }
  *entriesFlat() {
    for (const entry of this.#map.entries()) {
      for (const v3 of this.type.iterable(entry[1])) {
        yield [entry[0], v3];
      }
    }
  }
  *valuesFlat() {
    for (const entry of this.#map.entries()) {
      yield* this.type.iterable(entry[1]);
    }
  }
  *entries() {
    for (const [k3, v3] of this.#map.entries()) {
      const temporary = [...this.type.iterable(v3)];
      yield [k3, temporary];
    }
  }
  /* eslint-disable-next-line functional/prefer-readonly-type */
  *keysAndCounts() {
    for (const key of this.keys()) {
      yield [key, this.count(key)];
    }
  }
  merge(other) {
    for (const key of other.keys()) {
      const data = other.get(key);
      this.addKeyedValues(key, ...data);
    }
  }
  get size() {
    return this.#map.size;
  }
  get [Symbol.toStringTag]() {
    return this.#map[Symbol.toStringTag];
  }
};
var ofSetMutable = (options) => {
  const hash = options?.hash ?? toStringDefault;
  const comparer = (a4, b4) => hash(a4) === hash(b4);
  const t6 = {
    get name() {
      return `set`;
    },
    iterable: (source) => source.values(),
    add: (dest, values) => addKeepingExisting(dest, hash, ...values),
    count: (source) => source.size,
    find: (source, predicate) => find(source, predicate),
    filter: (source, predicate) => filter(source, predicate),
    toArray: (source) => toArray(source),
    has: (source, value2) => hasAnyValue(source, value2, comparer),
    without: (source, value2) => without(toArray(source), value2, comparer)
  };
  const m5 = new MapOfMutableImpl(t6, options);
  return m5;
};
var CircularArray = class _CircularArray extends Array {
  //  Class is unit tested!
  /* eslint-disable-next-line functional/prefer-readonly-type */
  #capacity;
  /* eslint-disable-next-line functional/prefer-readonly-type */
  #pointer;
  constructor(capacity = 0) {
    super();
    throwIntegerTest(capacity, `positive`, `capacity`);
    this.#capacity = capacity;
    this.#pointer = 0;
  }
  /**
   * Add to array
   * @param value Thing to add
   * @returns 
   */
  add(value2) {
    const ca2 = _CircularArray.from(this);
    ca2[this.#pointer] = value2;
    ca2.#capacity = this.#capacity;
    if (this.#capacity > 0) {
      ca2.#pointer = this.#pointer + 1 === this.#capacity ? 0 : this.#pointer + 1;
    } else {
      ca2.#pointer = this.#pointer + 1;
    }
    return ca2;
  }
  get pointer() {
    return this.#pointer;
  }
  get isFull() {
    if (this.#capacity === 0) return false;
    return this.length === this.#capacity;
  }
};
var circularArray = (capacity) => new CircularArray(capacity);
var ofCircularMutable = (options) => {
  const comparer = isEqualDefault;
  const t6 = {
    get name() {
      return `circular`;
    },
    add: (destination, values) => {
      if (destination === void 0) destination = circularArray(options.capacity);
      for (const v3 of values) {
        destination = destination.add(v3);
      }
      return destination;
    },
    count: (source) => source.length,
    find: (source, predicate) => source.find(predicate),
    filter: (source, predicate) => source.filter(predicate),
    toArray: (source) => source,
    iterable: (source) => source.values(),
    has: (source, value2) => source.find((v3) => comparer(v3, value2)) !== void 0,
    without: (source, value2) => source.filter((v3) => !comparer(v3, value2))
  };
  return new MapOfMutableImpl(t6, options);
};
var ofArrayMutable = (options = {}) => {
  const convertToString = options.convertToString;
  const toStringFunction = typeof convertToString === `undefined` ? isEqualDefault : (a4, b4) => convertToString(a4) === convertToString(b4);
  const comparer = options.comparer ?? toStringFunction;
  const t6 = {
    get name() {
      return `array`;
    },
    add: (destination, values) => {
      if (destination === void 0) return [...values];
      return [...destination, ...values];
    },
    iterable: (source) => source.values(),
    count: (source) => source.length,
    find: (source, predicate) => source.find((f5) => predicate(f5)),
    filter: (source, predicate) => source.filter((f5) => predicate(f5)),
    toArray: (source) => source,
    has: (source, value2) => source.some((v3) => comparer(v3, value2)),
    without: (source, value2) => source.filter((v3) => !comparer(v3, value2))
    //[Symbol.iterator]: (source) => source[Symbol.iterator]()
  };
  const m5 = new MapOfMutableImpl(t6, options);
  return m5;
};

// node_modules/ixfx/dist/chunk-YLRZZLGG.js
var isAsyncIterable = (v3) => Symbol.asyncIterator in new Object(v3);
var isIterable = (v3) => Symbol.iterator in new Object(v3);

// node_modules/ixfx/dist/chunk-4IJNRUE7.js
var getErrorMessage = (ex) => {
  if (typeof ex === `string`) return ex;
  if (ex instanceof Error) {
    return ex.message;
  }
  return ex;
};

// node_modules/ixfx/dist/chunk-4IGV3ZF6.js
function messageIsSignal(message) {
  if (message.value !== void 0) return false;
  if (`signal` in message && message.signal !== void 0) return true;
  return false;
}
function messageIsDoneSignal(message) {
  if (message.value !== void 0) return false;
  if (`signal` in message && message.signal === `done`) return true;
  return false;
}
function messageHasValue(v3) {
  if (v3.value !== void 0) return true;
  return false;
}
var isPingable = (rx) => {
  if (!isReactive(rx)) return false;
  if (`ping` in rx) {
    return true;
  }
  return false;
};
var hasLast = (rx) => {
  if (!isReactive(rx)) return false;
  if (`last` in rx) {
    const v3 = rx.last();
    if (v3 !== void 0) return true;
  }
  return false;
};
var isReactive = (rx) => {
  if (typeof rx !== `object`) return false;
  if (rx === null) return false;
  return `on` in rx && `onValue` in rx;
};
var isWritable = (rx) => {
  if (!isReactive(rx)) return false;
  if (`set` in rx) return true;
  return false;
};
var isWrapped = (v3) => {
  if (typeof v3 !== `object`) return false;
  if (!(`source` in v3)) return false;
  if (!(`annotateElapsed` in v3)) return false;
  return true;
};
var opify = (fn2, ...args) => {
  return (source) => {
    return fn2(source, ...args);
  };
};
var isTriggerValue = (t6) => `value` in t6;
var isTriggerFunction = (t6) => `fn` in t6;
var isTriggerGenerator = (t6) => isIterable(t6);
var isTrigger = (t6) => {
  if (typeof t6 !== `object`) return false;
  if (isTriggerValue(t6)) return true;
  if (isTriggerFunction(t6)) return true;
  if (isTriggerGenerator(t6)) return true;
  return false;
};
function resolveTriggerValue(t6) {
  if (isTriggerValue(t6)) return [t6.value, false];
  if (isTriggerFunction(t6)) {
    const v3 = t6.fn();
    if (v3 === void 0) return [void 0, true];
    return [v3, false];
  }
  if (isTriggerGenerator(t6)) {
    const v3 = t6.gen.next();
    if (v3.done) return [void 0, true];
    return [v3.value, false];
  }
  throw new Error(`Invalid trigger. Missing 'value' or 'fn' fields`);
}
if (typeof window === `undefined` || !(`requestAnimationFrame` in window)) {
  if (typeof window === `undefined`) {
    globalThis.requestAnimationFrame = (callback) => {
      setTimeout(callback, 1);
    };
  }
}
var sleep = (optsOrMillis) => {
  const timeoutMs = intervalToMs(optsOrMillis, 1);
  const signal = optsOrMillis.signal;
  const value2 = optsOrMillis.value;
  throwNumberTest(timeoutMs, `positive`, `timeoutMs`);
  if (timeoutMs === 0) {
    return new Promise(
      (resolve22) => requestAnimationFrame((_3) => {
        resolve22(value2);
      })
    );
  } else {
    return new Promise((resolve22, reject) => {
      const onAbortSignal = () => {
        clearTimeout(t6);
        if (signal) {
          signal.removeEventListener(`abort`, onAbortSignal);
          reject(new Error(signal.reason));
        } else {
          reject(new Error(`Cancelled`));
        }
      };
      if (signal) {
        signal.addEventListener(`abort`, onAbortSignal);
      }
      const t6 = setTimeout(() => {
        signal?.removeEventListener(`abort`, onAbortSignal);
        if (signal?.aborted) {
          reject(new Error(signal.reason));
          return;
        }
        resolve22(value2);
      }, timeoutMs);
    });
  }
};
var sleepWhile = async (predicate, checkInterval = 100) => {
  while (predicate()) {
    await sleep(checkInterval);
  }
};
async function resolve(r5, ...args) {
  if (typeof r5 === `object`) {
    if (`next` in r5) {
      const tag = r5[Symbol.toStringTag];
      if (tag === `Generator` || tag == `Array Iterator`) {
        const v3 = r5.next();
        if (`done` in v3 && `value` in v3) return v3.value;
        return v3;
      } else if (tag === `AsyncGenerator`) {
        const v3 = await r5.next();
        if (`done` in v3 && `value` in v3) return v3.value;
        return v3;
      } else {
        throw new Error(`Object has 'next' prop, but does not have 'AsyncGenerator', 'Generator' or 'Array Iterator' string tag symbol. Got: '${tag}'`);
      }
    } else if (isReactive(r5)) {
      if (hasLast(r5)) return r5.last();
      throw new Error(`Reactive does not have last value`);
    } else {
      return r5;
    }
  } else if (typeof r5 === `function`) {
    const v3 = await r5(args);
    return v3;
  } else {
    return r5;
  }
}
function resolveSync(r5, ...args) {
  if (typeof r5 === `object`) {
    if (`next` in r5) {
      const tag = r5[Symbol.toStringTag];
      if (tag === `Generator` || tag == `Array Iterator`) {
        const v3 = r5.next();
        if (`done` in v3 && `value` in v3) return v3.value;
        return v3;
      } else if (tag === `AsyncGenerator`) {
        throw new Error(`resolveSync cannot work with an async generator`);
      } else {
        throw new Error(`Object has 'next' prop, but does not have 'Generator' or 'Array Iterator' string tag symbol. Got: '${tag}'`);
      }
    } else if (isReactive(r5)) {
      if (hasLast(r5)) return r5.last();
      throw new Error(`Reactive does not have last value`);
    } else {
      return r5;
    }
  } else if (typeof r5 === `function`) {
    return r5(args);
  } else {
    return r5;
  }
}
async function* repeat(produce, opts) {
  const signal = opts.signal ?? void 0;
  const delayWhen = opts.delayWhen ?? `before`;
  const count3 = opts.count ?? void 0;
  const allowUndefined = opts.allowUndefined ?? false;
  const minIntervalMs = opts.delayMinimum ? intervalToMs(opts.delayMinimum) : void 0;
  const whileFunc = opts.while;
  let cancelled = false;
  let sleepMs = intervalToMs(opts.delay, intervalToMs(opts.delayMinimum, 0));
  let started = performance.now();
  const doDelay = async () => {
    const elapsed3 = performance.now() - started;
    if (typeof minIntervalMs !== `undefined`) {
      sleepMs = Math.max(0, minIntervalMs - elapsed3);
    }
    if (sleepMs) {
      await sleep({ millis: sleepMs, signal });
    }
    started = performance.now();
    if (signal?.aborted) throw new Error(`Signal aborted ${signal.reason}`);
  };
  if (Array.isArray(produce)) produce = produce.values();
  if (opts.onStart) opts.onStart();
  let errored = true;
  let loopedTimes = 0;
  try {
    while (!cancelled) {
      loopedTimes++;
      if (delayWhen === `before` || delayWhen === `both`) await doDelay();
      const result = await resolve(produce);
      if (typeof result === `undefined` && !allowUndefined) {
        cancelled = true;
      } else {
        yield result;
        if (delayWhen === `after` || delayWhen === `both`) await doDelay();
        if (count3 !== void 0 && loopedTimes >= count3) cancelled = true;
      }
      if (whileFunc) {
        if (!whileFunc(loopedTimes)) {
          cancelled = true;
        }
      }
    }
    errored = false;
  } finally {
    cancelled = true;
    if (opts.onComplete) opts.onComplete(errored);
  }
}
function* repeatSync(produce, opts) {
  const signal = opts.signal ?? void 0;
  const count3 = opts.count ?? void 0;
  const allowUndefined = opts.allowUndefined ?? false;
  let cancelled = false;
  if (Array.isArray(produce)) produce = produce.values();
  if (opts.onStart) opts.onStart();
  let errored = true;
  let loopedTimes = 0;
  try {
    while (!cancelled) {
      loopedTimes++;
      const result = resolveSync(produce);
      if (typeof result === `undefined` && !allowUndefined) {
        cancelled = true;
      } else {
        yield result;
        if (count3 !== void 0 && loopedTimes >= count3) cancelled = true;
        if (signal?.aborted) cancelled = true;
      }
    }
    errored = false;
  } finally {
    cancelled = true;
    if (opts.onComplete) opts.onComplete(errored);
  }
}

// node_modules/ixfx/dist/chunk-IQEKYUOH.js
var getOrGenerateSync = (map3, fn2) => (key, args) => {
  let value2 = map3.get(key);
  if (value2 !== void 0) return value2;
  value2 = fn2(key, args);
  map3.set(key, value2);
  return value2;
};

// node_modules/ixfx/dist/chunk-BWJ5AMOD.js
var resolveLogOption = (l3, defaults3 = {}) => {
  if (l3 === void 0 || typeof l3 === `boolean` && !l3) {
    return (_3) => {
    };
  }
  const defaultCat = defaults3.category ?? ``;
  const defaultKind = defaults3.kind ?? void 0;
  if (typeof l3 === `boolean`) {
    return (messageOrString) => {
      const m5 = typeof messageOrString === `string` ? { msg: messageOrString } : messageOrString;
      const kind = m5.kind ?? defaultKind;
      const category = m5.category ?? defaultCat;
      let message = m5.msg;
      if (category) message = `[${category}] ${message}`;
      switch (kind) {
        case `error`: {
          console.error(message);
          break;
        }
        case `warn`: {
          console.warn(message);
          break;
        }
        case `info`: {
          console.info(message);
          break;
        }
        default: {
          console.log(message);
        }
      }
    };
  }
  return l3;
};
var logColourCount = 0;
var logColours = getOrGenerateSync(/* @__PURE__ */ new Map(), () => {
  const hue = ++logColourCount * 137.508;
  return `hsl(${hue},50%,75%)`;
});

// node_modules/ixfx/dist/chunk-CF6OEEVD.js
function* additionalValues(source, values, eq = isEqualDefault) {
  const sourceArray = Array.isArray(source) ? source : [...source];
  const yielded = [];
  for (const v3 of values) {
    const found = sourceArray.find((index) => eq(index, v3));
    if (!found) {
      const alreadyYielded = yielded.find((ii3) => eq(ii3, v3));
      if (!alreadyYielded) {
        yielded.push(v3);
        yield v3;
      }
    }
  }
}
var unique = (arrays, comparer = isEqualDefault) => {
  const t6 = [];
  for (const a4 of arrays) {
    if (Array.isArray(a4)) {
      for (const v3 of additionalValues(t6, a4, comparer)) {
        t6.push(v3);
      }
    } else {
      return [...additionalValues([], arrays, comparer)];
    }
  }
  return t6;
};

// node_modules/ixfx/dist/chunk-HKC65PTS.js
var weightedIndex = (weightings, rand = defaultRandom) => {
  const precompute = [];
  let total = 0;
  for (let index = 0; index < weightings.length; index++) {
    total += weightings[index];
    precompute[index] = total;
  }
  if (total !== 1) throw new Error(`Weightings should add up to 1. Got: ${total}`);
  return () => {
    const v3 = rand();
    for (let index = 0; index < precompute.length; index++) {
      if (v3 <= precompute[index]) return index;
    }
    throw new Error(`Bug: weightedIndex could not select index`);
  };
};
var randomIndex = (array2, rand = Math.random) => Math.floor(rand() * array2.length);
var randomElement = (array2, rand = Math.random) => {
  guardArray(array2, `array`);
  return array2[Math.floor(rand() * array2.length)];
};
var shuffle = (dataToShuffle, rand = Math.random) => {
  const array2 = [...dataToShuffle];
  for (let index = array2.length - 1; index > 0; index--) {
    const index_ = Math.floor(rand() * (index + 1));
    [array2[index], array2[index_]] = [array2[index_], array2[index]];
  }
  return array2;
};

// node_modules/ixfx/dist/chunk-Y22PKHUJ.js
var StateMachine_exports = {};
__export(StateMachine_exports, {
  WithEvents: () => StateMachineWithEvents,
  cloneState: () => cloneState,
  driver: () => init2,
  fromList: () => fromList,
  fromListBidirectional: () => fromListBidirectional,
  init: () => init,
  isDone: () => isDone,
  isValidTransition: () => isValidTransition,
  next: () => next,
  normaliseTargets: () => normaliseTargets,
  possible: () => possible,
  possibleTargets: () => possibleTargets,
  reset: () => reset,
  to: () => to2,
  validateMachine: () => validateMachine,
  validateTransition: () => validateTransition
});
var run = async (expressions, opts = {}, args) => {
  const results = [];
  const compareFn = opts.rank ?? defaultComparer;
  let expressionsArray = Array.isArray(expressions) ? expressions : [expressions];
  if (opts.shuffle) expressionsArray = shuffle(expressionsArray);
  for (let i4 = 0; i4 < expressionsArray.length; i4++) {
    const exp = expressionsArray[i4];
    let r5;
    if (typeof exp === "function") {
      r5 = await exp(args);
    } else {
      r5 = exp;
    }
    if (r5 !== void 0) {
      results.push(r5);
      results.sort(compareFn);
    }
    if (typeof opts.stop !== "undefined") {
      if (opts.stop(r5, results)) {
        break;
      }
    }
  }
  if (opts.filter) {
    return results.filter(opts.filter);
  }
  return results;
};
var runSingle = async (expressions, opts = {}, args) => {
  const results = await run(expressions, opts, args);
  if (!results) return;
  if (results.length === 0) return;
  const at2 = opts.at ?? -1;
  return results.at(at2);
};
async function init2(machine, handlersOrOpts) {
  const opts = Array.isArray(handlersOrOpts) ? {
    handlers: handlersOrOpts
  } : handlersOrOpts;
  const debug = resolveLogOption(opts.debug, {
    category: `StateMachineDriver`
  });
  const byState = /* @__PURE__ */ new Map();
  for (const h5 of opts.handlers) {
    const ifBlock = Array.isArray(h5.if) ? h5.if : [h5.if];
    for (const state of ifBlock) {
      if (typeof state !== `string`) {
        throw new TypeError(
          `Expected single or array of strings for the 'if' field. Got: '${typeof state}'.`
        );
      }
      if (byState.has(state)) {
        throw new Error(
          `Multiple handlers defined for state '${state}'. There should be at most one.`
        );
      }
      byState.set(state, h5);
    }
  }
  const runOpts = {
    // Rank results by score
    rank: (a4, b4) => {
      return defaultComparer(a4.score ?? 0, b4.score ?? 0);
    },
    shuffle: opts.shuffleHandlers ?? false
  };
  let sm = init(machine);
  for (const [ifState] of byState) {
    if (typeof sm.machine[ifState] === `undefined` && ifState !== `__fallback`) {
      throw new Error(
        `StateMachineDriver handler references a state ('${ifState}') which is not defined on the machine. Therefore this handler will never run.'`
      );
    }
  }
  const run22 = async () => {
    debug(`Run. State: ${sm.value}`);
    const state = sm.value;
    let handler = byState.get(state);
    if (handler === void 0) {
      debug(`  No handler for state '${state}', trying __fallback`);
      handler = byState.get(`__fallback`);
    }
    if (handler === void 0) {
      debug(`  No __fallback handler`);
      return;
    }
    const runOptionsForHandler = handler.resultChoice === `first` ? {
      ...runOpts,
      stop: (latest) => {
        if (!latest) return false;
        if (`reset` in latest) return true;
        if (`next` in latest && latest.next !== void 0) return true;
        return false;
      }
    } : runOpts;
    const results = await run(
      handler.then,
      runOptionsForHandler,
      sm
    );
    debug(
      `  In state '${sm.value}' results: ${results.length}. Choice: ${handler.resultChoice}`
    );
    let r5;
    switch (handler.resultChoice ?? `highest`) {
      case `highest`: {
        r5 = results.at(-1);
        break;
      }
      case `first`: {
        r5 = results[0];
        break;
      }
      case `lowest`: {
        r5 = results.at(0);
        break;
      }
      case `random`: {
        r5 = randomElement(results);
        break;
      }
      default: {
        throw new Error(
          `Unknown 'resultChoice' option: ${handler.resultChoice}. Expected highest, first, lowest or random`
        );
      }
    }
    debug(`  Chosen result: ${JSON.stringify(r5)}`);
    if (r5?.reset) {
      sm = reset(sm);
    } else if (r5 && r5.next) {
      if (typeof r5.next === `boolean`) {
        sm = next(sm);
      } else {
        debug(JSON.stringify(results));
        sm = to2(sm, r5.next);
      }
    }
    return sm;
  };
  return {
    reset: () => {
      sm = reset(sm);
    },
    getValue: () => sm.value,
    run: run22,
    to: (state) => {
      sm = to2(sm, state);
      return sm;
    }
  };
}
var Stopwatch_exports = {};
__export(Stopwatch_exports, {
  infinity: () => infinity,
  interval: () => interval,
  once: () => once,
  since: () => since
});
var since = () => {
  const start = performance.now();
  return () => {
    return performance.now() - start;
  };
};
var interval = () => {
  let start = performance.now();
  return () => {
    const now = performance.now();
    const x3 = now - start;
    start = now;
    return x3;
  };
};
var once = () => {
  const start = Date.now();
  let stoppedAt = 0;
  return () => {
    if (stoppedAt === 0) {
      stoppedAt = Date.now() - start;
    }
    return stoppedAt;
  };
};
var infinity = () => {
  return () => {
    return Number.POSITIVE_INFINITY;
  };
};
var StateMachineWithEvents = class extends SimpleEventEmitter {
  #sm;
  #smInitial;
  #debug;
  #isDoneNeedsFiring = false;
  #isDone = false;
  #changedAt = infinity();
  /**
   * Create a state machine with initial state, description and options
   * @param m Machine description
   * @param opts Options for machine (defaults to `{debug:false}`)
   */
  constructor(m5, opts = {}) {
    super();
    this.#debug = opts.debug ?? false;
    this.#sm = init(m5, opts.initial);
    this.#smInitial = cloneState(this.#sm);
  }
  #setIsDone(v3) {
    if (this.#isDone === v3) return;
    this.#isDone = v3;
    if (v3) {
      this.#isDoneNeedsFiring = true;
      setTimeout(() => {
        if (!this.#isDoneNeedsFiring) return;
        this.#isDoneNeedsFiring = false;
        this.fireEvent(`stop`, { state: this.#sm.value });
      }, 2);
    } else {
      this.#isDoneNeedsFiring = false;
    }
  }
  /**
   * Return a list of possible states from current state.
   *
   * If list is empty, no states are possible. Otherwise lists
   * possible states, including 'null' for terminal
   */
  get statesPossible() {
    return possible(this.#sm);
  }
  /**
   * Return a list of all defined states
   */
  get statesDefined() {
    return Object.keys(this.#sm.machine);
  }
  /**
   * Moves to the next state if possible. If multiple states are possible, it will use the first.
   * If machine is finalised, no error is thrown and null is returned.
   *
   * @returns {(string|null)} Returns new state, or null if machine is finalised
   */
  next() {
    const p4 = possible(this.#sm);
    if (p4.length === 0) return null;
    this.state = p4[0];
    return p4[0];
  }
  /**
   * Returns _true_ if state machine is in its final state
   *
   * @returns
   */
  get isDone() {
    return isDone(this.#sm);
  }
  /**
   * Resets machine to initial state
   */
  reset() {
    this.#setIsDone(false);
    this.#sm = cloneState(this.#smInitial);
    this.#changedAt = since();
  }
  /**
   * Throws if it's not valid to transition to `newState`
   * @param newState
   * @returns
   */
  validateTransition(newState) {
    validateTransition(this.#sm, newState);
  }
  /**
   * Returns _true_ if `newState` is valid transition from current state.
   * Use {@link validateTransition} if you want an explanation for the _false_ results.
   * @param newState
   * @returns
   */
  isValid(newState) {
    return isValidTransition(this.#sm, newState);
  }
  /**
   * Gets or sets state. Throws an error if an invalid transition is attempted.
   * Use `isValid()` to check validity without changing.
   *
   * If `newState` is the same as current state, the request is ignored silently.
   */
  set state(newState) {
    const priorState = this.#sm.value;
    if (newState === this.#sm.value) return;
    this.#sm = to2(this.#sm, newState);
    if (this.#debug) {
      console.log(`StateMachine: ${priorState} -> ${newState}`);
    }
    this.#changedAt = since();
    setTimeout(() => {
      this.fireEvent(`change`, { newState, priorState });
    }, 1);
    if (isDone(this.#sm)) this.#setIsDone(true);
  }
  get state() {
    return this.#sm.value;
  }
  /**
   * Returns timestamp when state was last changed.
   * See also `elapsed`
   */
  get changedAt() {
    return this.#changedAt();
  }
  /**
   * Returns milliseconds elapsed since last state change.
   * See also `changedAt`
   */
  get elapsed() {
    return this.#changedAt();
  }
};
var cloneState = (toClone) => {
  return Object.freeze({
    value: toClone.value,
    visited: [...toClone.visited],
    machine: toClone.machine
  });
};
var init = (stateMachine, initialState) => {
  const [machine, machineValidationError] = validateMachine(stateMachine);
  if (!machine) throw new Error(machineValidationError);
  const state = (
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    initialState ?? Object.keys(machine.states)[0]
  );
  if (machine.states[state] === void 0) {
    throw new TypeError(`Initial state not found`);
  }
  const transitions = validateAndNormaliseTransitions(machine.states);
  if (transitions === void 0) {
    throw new Error(`Could not normalise transitions`);
  }
  return Object.freeze({
    value: state,
    visited: [],
    machine: Object.fromEntries(transitions)
  });
};
var reset = (sm) => {
  return init(sm.machine);
};
var validateMachine = (smOrTransitions) => {
  if (smOrTransitions === void 0) {
    return [void 0, `Parameter undefined`];
  }
  if (smOrTransitions === null) {
    return [void 0, `Parameter null`];
  }
  if (`states` in smOrTransitions) {
    return [smOrTransitions, ``];
  }
  if (typeof smOrTransitions === `object`) {
    return [
      {
        // @ts-expect-error
        states: smOrTransitions
      },
      ``
    ];
  }
  return [
    void 0,
    `Unexpected type: ${typeof smOrTransitions}. Expected object`
  ];
};
var isDone = (sm) => {
  return possible(sm).length === 0;
};
var possibleTargets = (sm) => {
  validateMachineState(sm);
  const fromS = sm.machine[sm.value];
  if (fromS.length === 1 && fromS[0].state === null) return [];
  return fromS;
};
var possible = (sm) => {
  const targets = possibleTargets(sm);
  return targets.map((v3) => v3.state);
};
var normaliseTargets = (targets) => {
  const normaliseSingleTarget = (target) => {
    if (target === null) return { state: null };
    if (typeof target === `string`) {
      return {
        state: target
      };
    } else if (typeof target === `object` && `state` in target) {
      const targetState = target.state;
      if (typeof targetState !== `string`) {
        throw new TypeError(
          `Target 'state' field is not a string. Got: ${typeof targetState}`
        );
      }
      if (`preconditions` in target) {
        return {
          state: targetState,
          preconditions: target.preconditions
        };
      }
      return { state: targetState };
    } else {
      throw new Error(
        `Unexpected type: ${typeof target}. Expected string or object with 'state' field.`
      );
    }
  };
  if (Array.isArray(targets)) {
    let containsNull = false;
    const mapResults = targets.map((t6) => {
      const r5 = normaliseSingleTarget(t6);
      if (!r5) throw new Error(`Invalid target`);
      containsNull = containsNull || r5.state === null;
      return r5;
    });
    if (containsNull && mapResults.length > 1) {
      throw new Error(`Cannot have null as an possible state`);
    }
    return mapResults;
  } else {
    const target = normaliseSingleTarget(targets);
    if (!target) return;
    return [target];
  }
};
var validateAndNormaliseTransitions = (d4) => {
  const returnMap = /* @__PURE__ */ new Map();
  for (const [topLevelState, topLevelTargets] of Object.entries(d4)) {
    if (typeof topLevelState === `undefined`) {
      throw new TypeError(`Top-level undefined state`);
    }
    if (typeof topLevelTargets === `undefined`) {
      throw new TypeError(`Undefined target state for ${topLevelState}`);
    }
    if (returnMap.has(topLevelState)) {
      throw new Error(`State defined twice: ${topLevelState}`);
    }
    if (topLevelState.includes(` `)) {
      throw new Error(`State names cannot contain spaces`);
    }
    returnMap.set(topLevelState, []);
  }
  for (const [topLevelState, topLevelTargets] of Object.entries(d4)) {
    const targets = normaliseTargets(topLevelTargets);
    if (targets === void 0) throw new Error(`Could not normalise target`);
    if (targets !== null) {
      const seenStates = /* @__PURE__ */ new Set();
      for (const target of targets) {
        if (seenStates.has(target.state)) {
          throw new Error(
            `Target state '${target.state}' already exists for '${topLevelState}'`
          );
        }
        seenStates.add(target.state);
        if (target.state === null) continue;
        if (!returnMap.has(target.state)) {
          throw new Error(
            `Target state '${target.state}' is not defined as a top-level state. Defined under: '${topLevelState}'`
          );
        }
      }
      returnMap.set(topLevelState, targets);
    }
  }
  return returnMap;
};
var validateMachineState = (state) => {
  if (state === void 0) {
    throw new TypeError(`Parameter 'state' is undefined`);
  }
  if (typeof state.value !== `string`) {
    throw new TypeError(`Existing state is not a string`);
  }
};
var to2 = (sm, toState) => {
  validateMachineState(sm);
  validateTransition(sm, toState);
  return Object.freeze({
    value: toState,
    machine: sm.machine,
    visited: unique([sm.visited, [sm.value]])
  });
};
var next = (sm) => {
  const first2 = possibleTargets(sm).at(0);
  if (!first2 || first2.state === null) {
    throw new Error(
      `Not possible to move to a next state from '${sm.value}`
    );
  }
  return to2(sm, first2.state);
};
var isValidTransition = (sm, toState) => {
  try {
    validateTransition(sm, toState);
    return true;
  } catch {
    return false;
  }
};
var validateTransition = (sm, toState) => {
  if (toState === null) throw new Error(`Cannot transition to null state`);
  if (toState === void 0) {
    throw new Error(`Cannot transition to undefined state`);
  }
  if (typeof toState !== `string`) {
    throw new TypeError(
      `Parameter 'toState' should be a string. Got: ${typeof toState}`
    );
  }
  const p4 = possible(sm);
  if (p4.length === 0) throw new Error(`Machine is in terminal state`);
  if (!p4.includes(toState)) {
    throw new Error(
      `Target state '${toState}' not available at current state '${sm.value}'. Possible states: ${p4.join(`, `)}`
    );
  }
};
var fromList = (...states) => {
  const t6 = {};
  if (!Array.isArray(states)) throw new Error(`Expected array of strings`);
  if (states.length <= 2) throw new Error(`Expects at least two states`);
  for (let index = 0; index < states.length; index++) {
    const s3 = states[index];
    if (typeof s3 !== `string`) {
      throw new TypeError(
        `Expected array of strings. Got type '${typeof s3}' at index ${index}`
      );
    }
    t6[s3] = index === states.length - 1 ? null : states[index + 1];
  }
  return t6;
};
var fromListBidirectional = (...states) => {
  const t6 = {};
  if (!Array.isArray(states)) throw new Error(`Expected array of strings`);
  if (states.length < 2) throw new Error(`Expects at least two states`);
  for (const [index, s3] of states.entries()) {
    if (typeof s3 !== `string`) {
      throw new TypeError(
        `Expected array of strings. Got type '${typeof s3}' at index ${index}`
      );
    }
    t6[s3] = [];
  }
  for (let index = 0; index < states.length; index++) {
    const v3 = t6[states[index]];
    if (index === states.length - 1) {
      if (states.length > 1) {
        v3.push(states[index - 1]);
      } else {
        t6[states[index]] = null;
      }
    } else {
      v3.push(states[index + 1]);
      if (index > 0) v3.push(states[index - 1]);
    }
  }
  return t6;
};

// node_modules/ixfx/dist/chunk-4FD2KCBI.js
var timeout = (callback, interval2) => {
  if (callback === void 0) {
    throw new Error(`callback parameter is undefined`);
  }
  const intervalMs = intervalToMs(interval2);
  throwIntegerTest(intervalMs, `aboveZero`, `interval`);
  let timer;
  let startedAt = 0;
  let startCount = 0;
  let startCountTotal = 0;
  let state = `idle`;
  const clear2 = () => {
    startedAt = 0;
    globalThis.clearTimeout(timer);
    state = `idle`;
  };
  const start = async (altInterval = interval2, args) => {
    const p4 = new Promise((resolve3, reject) => {
      startedAt = performance.now();
      const altTimeoutMs = intervalToMs(altInterval);
      const it2 = integerTest(altTimeoutMs, `aboveZero`, `altTimeoutMs`);
      if (!it2[0]) {
        reject(new Error(it2[1]));
        return;
      }
      switch (state) {
        case `scheduled`: {
          cancel();
          break;
        }
        case `running`: {
          break;
        }
      }
      state = `scheduled`;
      timer = globalThis.setTimeout(async () => {
        if (state !== `scheduled`) {
          console.warn(`Timeout skipping execution since state is not 'scheduled'`);
          clear2();
          return;
        }
        const args_ = args ?? [];
        startCount++;
        startCountTotal++;
        state = `running`;
        await callback(performance.now() - startedAt, ...args_);
        state = `idle`;
        clear2();
        resolve3();
      }, altTimeoutMs);
    });
    return p4;
  };
  const cancel = () => {
    if (state === `idle`) return;
    clear2();
  };
  return {
    // eslint-disable-next-line @typescript-eslint/no-misused-promises
    start,
    cancel,
    get runState() {
      return state;
    },
    get startCount() {
      return startCount;
    },
    get startCountTotal() {
      return startCountTotal;
    }
  };
};
var rateMinimum = (options) => {
  let disposed = false;
  const t6 = timeout(() => {
    if (disposed) return;
    t6.start();
    options.whatToCall(options.fallback());
  }, options.interval);
  if (options.abort) {
    options.abort.addEventListener(`abort`, (_3) => {
      disposed = true;
      t6.cancel();
    });
  }
  t6.start();
  return (args) => {
    if (disposed) throw new Error(`AbortSignal has been fired`);
    t6.start();
    options.whatToCall(args);
  };
};

// node_modules/ixfx/dist/chunk-L6MUVYKY.js
var trimQueue = (opts, queue, toAdd) => {
  const potentialLength = queue.length + toAdd.length;
  const capacity = opts.capacity ?? potentialLength;
  const toRemove = potentialLength - capacity;
  const policy = opts.discardPolicy ?? `additions`;
  switch (policy) {
    case `additions`: {
      if (queue.length === 0) return toAdd.slice(0, toAdd.length - toRemove);
      if (queue.length === opts.capacity) {
        return queue;
      } else {
        return [...queue, ...toAdd.slice(0, toRemove - 1)];
      }
    }
    case `newer`: {
      if (toRemove >= queue.length) {
        if (queue.length === 0) {
          return [...toAdd.slice(0, capacity - 1), toAdd.at(-1)];
        }
        return toAdd.slice(
          Math.max(0, toAdd.length - capacity),
          Math.min(toAdd.length, capacity) + 1
        );
      } else {
        const countToAdd = Math.max(1, toAdd.length - queue.length);
        const toAddFinal = toAdd.slice(toAdd.length - countToAdd, toAdd.length);
        const toKeep = queue.slice(0, Math.min(queue.length, capacity - 1));
        const t6 = [...toKeep, ...toAddFinal];
        return t6;
      }
    }
    case `older`: {
      return [...queue, ...toAdd].slice(toRemove);
    }
    default: {
      throw new Error(`Unknown overflow policy ${policy}`);
    }
  }
};
var enqueue = (opts, queue, ...toAdd) => {
  if (opts === void 0) throw new Error(`opts parameter undefined`);
  const potentialLength = queue.length + toAdd.length;
  const overSize = opts.capacity && potentialLength > opts.capacity;
  const toReturn = overSize ? trimQueue(opts, queue, toAdd) : [...queue, ...toAdd];
  if (opts.capacity && toReturn.length !== opts.capacity && overSize) {
    throw new Error(
      `Bug! Expected return to be at capacity. Return len: ${toReturn.length} capacity: ${opts.capacity} opts: ${JSON.stringify(opts)}`
    );
  }
  if (!opts.capacity && toReturn.length !== potentialLength) {
    throw new Error(
      `Bug! Return length not expected. Return len: ${toReturn.length} expected: ${potentialLength} opts: ${JSON.stringify(opts)}`
    );
  }
  return toReturn;
};
var dequeue = (opts, queue) => {
  if (queue.length === 0) throw new Error(`Queue is empty`);
  return queue.slice(1);
};
var peek = (opts, queue) => queue[0];
var isEmpty = (opts, queue) => queue.length === 0;
var isFull = (opts, queue) => {
  if (opts.capacity) {
    return queue.length >= opts.capacity;
  }
  return false;
};
var QueueMutable = class extends SimpleEventEmitter {
  constructor(opts = {}, data = []) {
    super();
    if (opts === void 0) throw new Error(`opts parameter undefined`);
    this.options = opts;
    this.data = data;
    this.eq = opts.eq ?? isEqualDefault;
  }
  clear() {
    const copy = [...this.data];
    this.data = [];
    this.fireEvent(`removed`, { finalData: this.data, removed: copy });
    this.onClear();
  }
  /**
   * Called when all data is cleared
   */
  onClear() {
  }
  at(index) {
    if (index >= this.data.length) throw new Error(`Index outside bounds of queue`);
    const v3 = this.data.at(index);
    if (v3 === void 0) throw new Error(`Index appears to be outside range of queue`);
    return v3;
  }
  enqueue(...toAdd) {
    this.data = enqueue(this.options, this.data, ...toAdd);
    const length5 = this.data.length;
    this.onEnqueue(this.data, toAdd);
    return length5;
  }
  onEnqueue(result, attemptedToAdd) {
    this.fireEvent(`enqueue`, { added: attemptedToAdd, finalData: result });
  }
  dequeue() {
    const v3 = peek(this.options, this.data);
    if (v3 === void 0) return;
    this.data = dequeue(this.options, this.data);
    this.fireEvent(`dequeue`, { removed: v3, finalData: this.data });
    this.onRemoved([v3], this.data);
    return v3;
  }
  onRemoved(removed, finalData) {
    this.fireEvent(`removed`, { removed, finalData });
  }
  /**
   * Removes values that match `predicate`.
   * @param predicate 
   * @returns Returns number of items removed.
   */
  removeWhere(predicate) {
    const countPre = this.data.length;
    const toRemove = this.data.filter((v3) => predicate(v3));
    if (toRemove.length === 0) return 0;
    this.data = this.data.filter((element) => !predicate(element));
    this.onRemoved(toRemove, this.data);
    return countPre - this.data.length;
  }
  /**
  * Return a copy of the array
  * @returns 
  */
  toArray() {
    return [...this.data];
  }
  get isEmpty() {
    return isEmpty(this.options, this.data);
  }
  get isFull() {
    return isFull(this.options, this.data);
  }
  get length() {
    return this.data.length;
  }
  get peek() {
    return peek(this.options, this.data);
  }
};
function mutable2(options = {}, ...startingItems) {
  return new QueueMutable({ ...options }, [...startingItems]);
}

// node_modules/ixfx/dist/chunk-ZJSCF2A4.js
var clamp = (value2, min6 = 0, max5 = 1) => {
  if (Number.isNaN(value2)) throw new Error(`'value' parameter is NaN`);
  if (Number.isNaN(min6)) throw new Error(`'min' parameter is NaN`);
  if (Number.isNaN(max5)) throw new Error(`'max' parameter is NaN`);
  if (value2 < min6) return min6;
  if (value2 > max5) return max5;
  return value2;
};
var clampIndex = (v3, arrayOrLength) => {
  if (!Number.isInteger(v3)) {
    throw new TypeError(`v parameter must be an integer (${v3})`);
  }
  const length5 = Array.isArray(arrayOrLength) ? arrayOrLength.length : arrayOrLength;
  if (!Number.isInteger(length5)) {
    throw new TypeError(
      `length parameter must be an integer (${length5}, ${typeof length5})`
    );
  }
  v3 = Math.round(v3);
  if (v3 < 0) return 0;
  if (v3 >= length5) return length5 - 1;
  return v3;
};

// node_modules/ixfx/dist/chunk-2VXZ54M3.js
function hasElapsed(elapsed3) {
  const t6 = relative(intervalToMs(elapsed3, 0), { timer: elapsedMillisecondsAbsolute(), clampValue: true });
  return () => t6.isDone;
}
function ofTotal(duration, opts = {}) {
  const totalMs = intervalToMs(duration);
  if (!totalMs) throw new Error(`Param 'duration' not valid`);
  const timerOpts = {
    ...opts,
    timer: elapsedMillisecondsAbsolute()
  };
  let t6;
  return () => {
    if (!t6) {
      t6 = relative(totalMs, timerOpts);
    }
    return t6.elapsed;
  };
}
function ofTotalTicks(totalTicks, opts = {}) {
  const timerOpts = {
    ...opts,
    timer: elapsedTicksAbsolute()
  };
  let t6;
  return () => {
    if (!t6) {
      t6 = relative(totalTicks, timerOpts);
    }
    return t6.elapsed;
  };
}
var relative = (total, options = {}) => {
  const clampValue = options.clampValue ?? false;
  const wrapValue = options.wrapValue ?? false;
  if (clampValue && wrapValue) throw new Error(`clampValue and wrapValue cannot both be enabled`);
  let modulationAmount = 1;
  const timer = options.timer ?? elapsedMillisecondsAbsolute();
  let lastValue = 0;
  const computeElapsed = (value2) => {
    lastValue = value2;
    let v3 = value2 / (total * modulationAmount);
    if (clampValue) v3 = clamp(v3);
    else if (wrapValue && v3 >= 1) v3 = v3 % 1;
    return v3;
  };
  return {
    mod(amt) {
      modulationAmount = amt;
    },
    get isDone() {
      return computeElapsed(lastValue) >= 1;
    },
    get elapsed() {
      return computeElapsed(timer.elapsed);
    },
    reset: () => {
      timer.reset();
    }
  };
};
var frequencyTimer = (frequency, options = {}) => {
  const timer = options.timer ?? elapsedMillisecondsAbsolute();
  const cyclesPerSecond = frequency / 1e3;
  let modulationAmount = 1;
  const computeElapsed = () => {
    const v3 = timer.elapsed * (cyclesPerSecond * modulationAmount);
    const f5 = v3 - Math.floor(v3);
    if (f5 < 0) {
      throw new Error(
        `Unexpected cycle fraction less than 0. Elapsed: ${v3} f: ${f5}`
      );
    }
    if (f5 > 1) {
      throw new Error(
        `Unexpected cycle fraction more than 1. Elapsed: ${v3} f: ${f5}`
      );
    }
    return f5;
  };
  return {
    mod: (amt) => {
      modulationAmount = amt;
    },
    reset: () => {
      timer.reset();
    },
    get isDone() {
      return computeElapsed() >= 1;
    },
    get elapsed() {
      return computeElapsed();
    }
  };
};
var elapsedMillisecondsAbsolute = () => {
  let start = performance.now();
  return {
    /**
     * Reset timer
     */
    reset: () => {
      start = performance.now();
    },
    /**
     * Returns elapsed time since start
     */
    get elapsed() {
      return performance.now() - start;
    }
  };
};
var elapsedTicksAbsolute = () => {
  let start = 0;
  return {
    /**
     * Reset ticks to 0. The next call to `elapsed` will return 1.
     */
    reset: () => {
      start = 0;
    },
    /**
     * Get current ticks without incrementing.
     */
    get peek() {
      return start;
    },
    /**
     * Returns the number of elapsed ticks as well as
     * incrementing the tick count. 
     * 
     * Minimum is 1
     * 
     * Use {@link peek} to get the current ticks without incrementing.
     */
    get elapsed() {
      return ++start;
    }
  };
};
var timerWithFunction = (fn2, timer) => {
  if (typeof fn2 !== `function`) throw new Error(`Param 'fn' should be a function. Got: ${typeof fn2}`);
  let startCount = 1;
  return {
    get elapsed() {
      return timer.elapsed;
    },
    get isDone() {
      return timer.isDone;
    },
    get runState() {
      if (timer.isDone) return `idle`;
      return `scheduled`;
    },
    /**
     * Returns 1 if it has been created, returns +1 for each additional time the timer has been reset.
     */
    get startCount() {
      return startCount;
    },
    get startCountTotal() {
      return startCount;
    },
    compute: () => {
      const elapsed3 = timer.elapsed;
      return fn2(elapsed3);
    },
    reset: () => {
      timer.reset();
      startCount++;
    }
  };
};

// node_modules/ixfx/dist/chunk-SCQC6LJE.js
var flow_exports = {};
__export(flow_exports, {
  BehaviourTree: () => BehaviourTree_exports,
  DispatchList: () => DispatchList,
  Elapsed: () => Stopwatch_exports,
  RequestResponseMatch: () => RequestResponseMatch,
  StateMachine: () => StateMachine_exports,
  SyncWait: () => SyncWait,
  TaskQueueMutable: () => TaskQueueMutable,
  WaitForValue: () => WaitForValue,
  backoffGenerator: () => backoffGenerator,
  continuously: () => continuously,
  debounce: () => debounce,
  delay: () => delay,
  delayLoop: () => delayLoop,
  elapsedMillisecondsAbsolute: () => elapsedMillisecondsAbsolute,
  elapsedTicksAbsolute: () => elapsedTicksAbsolute,
  elapsedToHumanString: () => elapsedToHumanString,
  everyNth: () => everyNth,
  frequencyTimer: () => frequencyTimer,
  hasElapsed: () => hasElapsed,
  intervalToMs: () => intervalToMs,
  isInterval: () => isInterval,
  ofTotal: () => ofTotal,
  ofTotalTicks: () => ofTotalTicks,
  promiseFromEvent: () => promiseFromEvent,
  promiseWithResolvers: () => promiseWithResolvers,
  rateMinimum: () => rateMinimum,
  relative: () => relative,
  repeat: () => repeat,
  repeatSync: () => repeatSync,
  retryFunction: () => retryFunction,
  retryTask: () => retryTask,
  run: () => run,
  runOnce: () => runOnce,
  runSingle: () => runSingle,
  singleItem: () => singleItem,
  sleep: () => sleep,
  sleepWhile: () => sleepWhile,
  throttle: () => throttle,
  timeout: () => timeout,
  timerWithFunction: () => timerWithFunction,
  updateOutdated: () => updateOutdated,
  waitFor: () => waitFor
});
var BehaviourTree_exports = {};
__export(BehaviourTree_exports, {
  iterateBreadth: () => iterateBreadth,
  iterateDepth: () => iterateDepth
});
var getName = (t6, defaultValue = ``) => {
  if (typeof t6 === `object` && `name` in t6 && t6.name !== void 0) return t6.name;
  return defaultValue;
};
function* iterateBreadth(t6, pathPrefix) {
  if (typeof pathPrefix === `undefined`) {
    pathPrefix = getName(t6);
  }
  for (const [index, n7] of entries(t6)) {
    yield [n7, pathPrefix];
  }
  for (const [index, n7] of entries(t6)) {
    const name = getName(n7, `?`);
    const prefix = pathPrefix.length > 0 ? pathPrefix + `.` + name : name;
    yield* iterateBreadth(n7, prefix);
  }
}
function* iterateDepth(t6, pathPrefix) {
  if (typeof pathPrefix === `undefined`) {
    pathPrefix = getName(t6);
  }
  for (const [index, n7] of entries(t6)) {
    yield [n7, pathPrefix];
    const name = getName(n7, `?`);
    const prefix = pathPrefix.length > 0 ? pathPrefix + `.` + name : name;
    yield* iterateBreadth(n7, prefix);
  }
}
function isSeqNode(n7) {
  return n7.seq !== void 0;
}
function isSelNode(n7) {
  return n7.sel !== void 0;
}
function* entries(n7) {
  if (isSeqNode(n7)) {
    yield* n7.seq.entries();
  } else if (isSelNode(n7)) {
    yield* n7.sel.entries();
  } else if (typeof n7 === `string`) {
  } else {
    throw new TypeError(`Unexpected shape of node. seq/sel missing`);
  }
}
var continuously = (callback, interval2, options = {}) => {
  let intervalMs = intervalToMs(interval2, 0);
  throwIntegerTest(intervalMs, `positive`, `interval`);
  const fireBeforeWait = options.fireBeforeWait ?? false;
  const onStartCalled = options.onStartCalled;
  const signal = options.signal;
  let disposed = false;
  let runState = `idle`;
  let startCount = 0;
  let startCountTotal = 0;
  let startedAt = performance.now();
  let intervalUsed = interval2 ?? 0;
  let cancelled = false;
  let currentTimer;
  const deschedule = () => {
    if (currentTimer === void 0) return;
    globalThis.clearTimeout(currentTimer);
    currentTimer = void 0;
    startCount = 0;
    startedAt = Number.NaN;
  };
  const schedule = (scheduledCallback) => {
    if (intervalMs === 0) {
      if (typeof requestAnimationFrame === `undefined`) {
        currentTimer = globalThis.setTimeout(scheduledCallback, 0);
      } else {
        currentTimer = void 0;
        requestAnimationFrame(scheduledCallback);
      }
    } else {
      currentTimer = globalThis.setTimeout(scheduledCallback, intervalMs);
    }
  };
  const cancel = () => {
    if (cancelled) return;
    cancelled = true;
    if (runState === `idle`) return;
    runState = `idle`;
    deschedule();
  };
  const loop = async () => {
    if (signal?.aborted) {
      runState = `idle`;
    }
    if (runState === `idle`) return;
    runState = `running`;
    startCount++;
    startCountTotal++;
    const valueOrPromise = callback(startCount, performance.now() - startedAt);
    const value2 = typeof valueOrPromise === `object` ? await valueOrPromise : valueOrPromise;
    if (cancelled) {
      return;
    }
    runState = `scheduled`;
    if (value2 !== void 0 && !value2) {
      cancel();
      return;
    }
    if (cancelled) return;
    schedule(loop);
  };
  const start = () => {
    if (disposed) throw new Error(`Disposed`);
    cancelled = false;
    if (onStartCalled !== void 0) {
      const doWhat = onStartCalled(startCount, performance.now() - startedAt);
      switch (doWhat) {
        case `cancel`: {
          cancel();
          return;
        }
        case `reset`: {
          reset2();
          return;
        }
        case `dispose`: {
          disposed = true;
          cancel();
          return;
        }
      }
    }
    if (runState === `idle`) {
      startCount = 0;
      startedAt = performance.now();
      runState = `scheduled`;
      if (fireBeforeWait) {
        void loop();
      } else {
        schedule(loop);
      }
    }
  };
  const reset2 = () => {
    if (disposed) throw new Error(`Disposed`);
    cancelled = false;
    startCount = 0;
    startedAt = Number.NaN;
    if (runState !== `idle`) {
      cancel();
    }
    start();
  };
  return {
    start,
    reset: reset2,
    cancel,
    get interval() {
      return intervalUsed;
    },
    get runState() {
      return runState;
    },
    get startCountTotal() {
      return startCountTotal;
    },
    get startCount() {
      return startCount;
    },
    set interval(interval22) {
      const ms2 = intervalToMs(interval22, 0);
      throwIntegerTest(ms2, `positive`, `interval`);
      intervalMs = ms2;
      intervalUsed = interval22;
    },
    get isDisposed() {
      return disposed;
    },
    get elapsedMs() {
      return performance.now() - startedAt;
    }
  };
};
var debounce = (callback, interval2) => {
  const t6 = timeout(callback, interval2);
  return (...args) => {
    t6.start(void 0, args);
  };
};
var delay = async (callback, optsOrMillis) => {
  const opts = typeof optsOrMillis === `number` ? { millis: optsOrMillis } : optsOrMillis;
  const delayWhen = opts.delay ?? `before`;
  if (delayWhen === `before` || delayWhen === `both`) {
    await sleep(opts);
  }
  const r5 = Promise.resolve(await callback());
  if (delayWhen === `after` || delayWhen === `both`) {
    await sleep(opts);
  }
  return r5;
};
async function* delayAnimationLoop() {
  let resolve3;
  let p4 = new Promise((r5) => resolve3 = r5);
  let timer = 0;
  const callback = () => {
    if (resolve3) resolve3();
    p4 = new Promise((r5) => resolve3 = r5);
  };
  try {
    while (true) {
      timer = globalThis.requestAnimationFrame(callback);
      const _3 = await p4;
      yield _3;
    }
  } finally {
    if (resolve3) resolve3();
    globalThis.cancelAnimationFrame(timer);
  }
}
async function* delayLoop(timeout2) {
  const timeoutMs = intervalToMs(timeout2);
  if (typeof timeoutMs === `undefined`) throw new Error(`timeout is undefined`);
  if (timeoutMs < 0) throw new Error(`Timeout is less than zero`);
  if (timeoutMs === 0) return yield* delayAnimationLoop();
  let resolve3;
  let p4 = new Promise((r5) => resolve3 = r5);
  let timer;
  const callback = () => {
    if (resolve3) resolve3();
    p4 = new Promise((r5) => resolve3 = r5);
  };
  try {
    while (true) {
      timer = globalThis.setTimeout(callback, timeoutMs);
      const _3 = await p4;
      yield _3;
    }
  } finally {
    if (resolve3) resolve3();
    if (timer !== void 0) globalThis.clearTimeout(timer);
    timer = void 0;
  }
}
var DispatchList = class {
  #handlers;
  #counter = 0;
  #id = Math.floor(Math.random() * 100);
  constructor() {
    this.#handlers = [];
  }
  /**
   * Returns _true_ if list is empty
   * @returns 
   */
  isEmpty() {
    return this.#handlers.length === 0;
  }
  /**
   * Adds a handler
   * @param handler 
   * @param options 
   * @returns 
   */
  add(handler, options = {}) {
    this.#counter++;
    const once2 = options.once ?? false;
    const wrap5 = {
      id: `${this.#id} - ${this.#counter}`,
      handler,
      once: once2
    };
    this.#handlers.push(wrap5);
    return wrap5.id;
  }
  remove(id) {
    const length5 = this.#handlers.length;
    this.#handlers = this.#handlers.filter((handler) => handler.id !== id);
    return this.#handlers.length !== length5;
  }
  notify(value2) {
    for (const handler of this.#handlers) {
      handler.handler(value2);
      if (handler.once) {
        this.remove(handler.id);
      }
    }
  }
  clear() {
    this.#handlers = [];
  }
};
var everyNth = (nth, callback) => {
  throwIntegerTest(nth, `positive`, `nth`);
  let counter = 0;
  return (data) => {
    counter++;
    if (counter === nth) {
      counter = 0;
      if (callback) callback(data);
      return true;
    }
    return false;
  };
};
var promiseFromEvent = (target, name) => {
  return new Promise((resolve3) => {
    const handler = (...args) => {
      target.removeEventListener(name, handler);
      if (Array.isArray(args) && args.length === 1) resolve3(args[0]);
      else resolve3(args);
    };
    target.addEventListener(name, handler);
  });
};
function promiseWithResolvers() {
  let resolve3;
  let reject;
  const promise = new Promise(
    (_resolve, _reject) => {
      resolve3 = _resolve;
      reject = _reject;
    }
  );
  return { promise, resolve: resolve3, reject };
}
var RequestResponseMatch = class extends SimpleEventEmitter {
  #outgoing = /* @__PURE__ */ new Map();
  #maintainLoop;
  constructor(options = {}) {
    super();
    if (typeof window === `undefined`) {
      globalThis.window = {
        setTimeout,
        clearTimeout
      };
    }
    this.timeoutMs = options.timeoutMs ?? 1e3;
    this.whenUnmatchedResponse = options.whenUnmatchedResponse ?? `throw`;
    this.#maintainLoop = continuously(() => this.#maintain(), this.timeoutMs * 2);
    if (options.key) {
      if (options.keyRequest) throw new Error(`Cannot set 'keyRequest' when 'key' is set `);
      if (options.keyResponse) throw new Error(`Cannot set 'keyResponse' when 'key' is set `);
      this.keyRequest = options.key;
      this.keyResponse = options.key;
    } else {
      if (!options.keyRequest || !options.keyResponse) {
        throw new Error(`Expects 'keyRequest' & 'keyResponse' fields to be set if 'key' is not set`);
      }
      this.keyRequest = options.keyRequest;
      this.keyResponse = options.keyResponse;
    }
  }
  #maintain() {
    const values = [...this.#outgoing.values()];
    const now = Date.now();
    for (const v3 of values) {
      if (v3.expiresAt <= now) {
        if (v3.promiseReject) {
          v3.promiseReject(`Request timeout`);
        }
        const callback = v3.callback;
        if (callback) {
          setTimeout(() => {
            callback(true, `Request timeout`);
          }, 1);
        }
        this.fireEvent(`completed`, { request: v3.req, response: `Request timeout`, success: false });
        this.#outgoing.delete(v3.id);
      }
    }
    this.debugDump();
    return this.#outgoing.size > 0;
  }
  debugDump() {
    const values = [...this.#outgoing.values()];
    const now = Date.now();
    for (const v3 of values) {
      const expire = now - v3.expiresAt;
      console.log(`${v3.id} Expires in: ${Math.floor(expire / 1e3)}s`);
    }
  }
  /**
   * Makes a request.
   * If `callback` is set, it's equivalent to calling `requestCallback`.
   * If `callback` is not set, a promise is returned
   * @param request 
   * @param callback 
   * @returns 
   */
  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
  request(request, callback) {
    if (callback !== void 0) {
      this.#requestCallback(request, callback);
      return;
    }
    return this.#requestAwait(request);
  }
  /**
   * Make a request and don't wait for the outcome.
   * @param request 
   */
  requestAndForget(request) {
    const id = this.keyRequest(request);
    if (this.#outgoing.has(id)) throw new Error(`Already a request pending with id '${id}'`);
    const r5 = {
      expiresAt: Date.now() + this.timeoutMs,
      id,
      req: request
    };
    this.#outgoing.set(id, r5);
    this.#maintainLoop.start();
  }
  /**
   * Make a request, returning a Promise for the outcome.
   * Errors will throw an exception.
   * @param request 
   * @returns 
   */
  #requestAwait(request) {
    const id = this.keyRequest(request);
    if (this.#outgoing.has(id)) throw new Error(`Already a request pending with id '${id}'`);
    const p4 = new Promise((resolve3, reject) => {
      const r5 = {
        expiresAt: Date.now() + this.timeoutMs,
        id,
        req: request,
        promiseResolve: resolve3,
        promiseReject: reject
      };
      this.#outgoing.set(id, r5);
      this.#maintainLoop.start();
    });
    return p4;
  }
  /**
   * Make a request, and get notified of outcome with a callback
   * @param request 
   * @param callback 
   */
  #requestCallback(request, callback) {
    const id = this.keyRequest(request);
    if (this.#outgoing.has(id)) throw new Error(`Already a request pending with id '${id}'`);
    const r5 = {
      expiresAt: Date.now() + this.timeoutMs,
      id,
      req: request,
      callback
    };
    this.#outgoing.set(id, r5);
    this.#maintainLoop.start();
  }
  /**
   * Response has been received
   * @param response Response
   * @returns _True_ if response matched a request 
   */
  response(response, keepAlive) {
    const id = this.keyResponse(response);
    const request = this.#outgoing.get(id);
    if (!request) {
      if (this.whenUnmatchedResponse === `throw`) throw new Error(`Unmatched response with id: '${id}'`, { cause: response });
      return false;
    }
    if (keepAlive) {
      request.expiresAt = Date.now() + this.timeoutMs;
    } else {
      this.#outgoing.delete(id);
    }
    if (request.promiseResolve) {
      request.promiseResolve(response);
    }
    if (request.callback) {
      request.callback(false, response);
    }
    this.fireEvent(`match`, { request: request.req, response });
    if (!keepAlive) {
      this.fireEvent(`completed`, { request: request.req, response, success: true });
    }
    return true;
  }
};
function* backoffGenerator(options = {}) {
  const startAt = options.startAt ?? 1;
  let limitAttempts = options.limitAttempts ?? Number.MAX_SAFE_INTEGER;
  const limitValue = options.limitValue;
  const power = options.power ?? 1.1;
  let value2 = startAt;
  throwIntegerTest(limitAttempts, `aboveZero`, `limitAttempts`);
  throwNumberTest(startAt, ``, `startAt`);
  throwNumberTest(limitAttempts, ``, `limitAttempts`);
  if (limitValue !== void 0) throwNumberTest(limitValue, ``, `limitValue`);
  throwNumberTest(power, ``, `power`);
  while (limitAttempts > 0) {
    if (limitValue && value2 >= limitValue) return;
    limitAttempts--;
    yield value2;
    value2 += Math.pow(value2, power);
  }
}
var retryFunction = (callback, options = {}) => {
  const task = {
    async probe() {
      try {
        const v3 = await callback();
        if (v3 === void 0) return { value: options.taskValueFallback, success: false };
        return { value: v3, success: true };
      } catch (error) {
        return { success: false, message: getErrorMessage(error) };
      }
    }
  };
  return retryTask(task, options);
};
var retryTask = async (task, opts = {}) => {
  const signal = opts.abort;
  const log = resolveLogOption(opts.log);
  const predelayMs = opts.predelayMs ?? 0;
  const startedAt = since();
  let attempts = 0;
  const initialValue = opts.startAt ?? 1e3;
  const limitAttempts = opts.limitAttempts ?? Number.MAX_SAFE_INTEGER;
  const backoffGen = backoffGenerator({ ...opts, startAt: initialValue, limitAttempts });
  if (initialValue <= 0) throw new Error(`Param 'initialValue' must be above zero`);
  if (predelayMs > 0) {
    try {
      await sleep({ millis: predelayMs, signal });
    } catch (error) {
      return {
        success: false,
        attempts,
        value: opts.taskValueFallback,
        elapsed: startedAt(),
        message: getErrorMessage(error)
      };
    }
  }
  for (const t6 of backoffGen) {
    attempts++;
    const result = await task.probe(attempts);
    if (result.success) {
      return { success: result.success, value: result.value, attempts, elapsed: startedAt() };
    }
    log({
      msg: `retry attempts: ${attempts} t: ${elapsedToHumanString(t6)}`
    });
    if (attempts >= limitAttempts) {
      break;
    }
    try {
      await sleep({ millis: t6, signal });
    } catch (error) {
      return {
        success: false,
        attempts,
        value: opts.taskValueFallback,
        message: getErrorMessage(error),
        elapsed: startedAt()
      };
    }
  }
  return {
    message: `Giving up after ${attempts} attempts.`,
    success: false,
    attempts,
    value: opts.taskValueFallback,
    elapsed: startedAt()
  };
};
var runOnce = (onRun) => {
  let run22 = false;
  let success = false;
  return () => {
    if (run22) return success;
    run22 = true;
    success = onRun();
    return success;
  };
};
var SyncWait = class {
  #resolve;
  #reject;
  #promise;
  signal() {
    if (this.#resolve) {
      this.#resolve();
      this.#resolve = void 0;
    }
    this.#promise = Promise.resolve();
  }
  /**
   * Throw away any previous signalled state.
   * This will cause any currently waiters to throw
   */
  flush() {
    if (this.#reject) {
      this.#reject(`Flushed`);
      this.#reject = void 0;
    }
    this.#resolve = void 0;
    this.#promise = void 0;
  }
  #initPromise() {
    const p4 = new Promise((resolve3, reject) => {
      this.#resolve = resolve3;
      this.#reject = reject;
    });
    this.#promise = p4;
    return p4;
  }
  /**
   * Call with `await` to wait until .signal() happens.
   * If a wait period is specified, an exception is thrown if signal does not happen within this time.
   * @param maximumWaitMs 
   */
  async forSignal(maximumWaitMs) {
    let p4 = this.#promise;
    if (!p4) p4 = this.#initPromise();
    if (maximumWaitMs) {
      const reject = this.#reject;
      setTimeout(() => {
        if (reject) {
          reject(`Timeout elapsed ${maximumWaitMs}`);
        }
      }, maximumWaitMs);
    }
    await p4;
    this.#promise = void 0;
    this.#resolve = void 0;
    this.#reject = void 0;
  }
  /**
   * An alternative to {@link forSignal}, returning _true_
   * if signalled, or _false_ if wait period was exceeded 
   * 
   * ```js
   * const s = await sw.didSignal(5000);
   * ```
   * @param maximumWaitMs 
   * @returns 
   */
  async didSignal(maximumWaitMs) {
    try {
      await this.forSignal(maximumWaitMs);
      return true;
    } catch {
      return false;
    }
  }
};
var TaskQueueMutable = class _TaskQueueMutable extends SimpleEventEmitter {
  static {
    this.shared = new _TaskQueueMutable();
  }
  constructor() {
    super();
    this._queue = mutable2();
    this._loop = continuously(() => {
      return this.processQueue();
    }, 100);
  }
  /**
   * Adds a task. This triggers processing loop if not already started.
   *
   * ```js
   * queue.add(async () => {
   *  await sleep(1000);
   * });
   * ```
   * @param task Task to run
   */
  enqueue(task) {
    const length5 = this._queue.enqueue(task);
    if (this._loop.runState === `idle`) {
      this.fireEvent(`started`, {});
      this._loop.start();
    }
    return length5;
  }
  dequeue() {
    return this._queue.dequeue();
  }
  async processQueue() {
    const task = this._queue.dequeue();
    if (task === void 0) {
      this.fireEvent(`empty`, {});
      return false;
    }
    try {
      await task();
    } catch (error) {
      console.error(error);
    }
  }
  /**
   * Clears all tasks, and stops any scheduled processing.
   * Currently running tasks will continue.
   * @returns 
   */
  clear() {
    if (this._queue.length === 0) return;
    this._queue.clear();
    this._loop.cancel();
    this.fireEvent(`empty`, {});
  }
  /**
  * Returns true if queue is empty
  */
  get isEmpty() {
    return this._queue.isEmpty;
  }
  /**
   * Number of items in queue
   */
  get length() {
    return this._queue.length;
  }
};
var throttle = (callback, intervalMinMs) => {
  let trigger = 0;
  return async (...args) => {
    const elapsed3 = performance.now() - trigger;
    if (elapsed3 >= intervalMinMs) {
      const r5 = callback(elapsed3, ...args);
      if (typeof r5 === `object`) await r5;
      trigger = performance.now();
    }
  };
};
var updateOutdated = (fn2, interval2, updateFail = `slow`) => {
  let lastRun = 0;
  let lastValue;
  let intervalMsCurrent = intervalToMs(interval2, 1e3);
  return () => (
    // eslint-disable-next-line @typescript-eslint/no-misused-promises
    new Promise(async (resolve3, reject) => {
      const elapsed3 = performance.now() - lastRun;
      if (lastValue === void 0 || elapsed3 > intervalMsCurrent) {
        try {
          lastRun = performance.now();
          lastValue = await fn2(elapsed3);
          intervalMsCurrent = intervalToMs(interval2, 1e3);
        } catch (error) {
          if (updateFail === `fast`) {
            lastValue = void 0;
            lastRun = 0;
          } else if (updateFail === `backoff`) {
            intervalMsCurrent = Math.floor(intervalMsCurrent * 1.2);
          }
          reject(error);
          return;
        }
      }
      resolve3(lastValue);
    })
  );
};
var waitFor = (timeoutMs, onAborted, onComplete) => {
  let t6;
  let success = false;
  const done = (error) => {
    if (t6 !== void 0) {
      window.clearTimeout(t6);
      t6 = void 0;
    }
    if (error) {
      onAborted(error);
    } else {
      success = true;
    }
    if (onComplete !== void 0) onComplete(success);
  };
  t6 = globalThis.setTimeout(() => {
    t6 = void 0;
    try {
      onAborted(`Timeout after ${timeoutMs}ms`);
    } finally {
      if (onComplete !== void 0) onComplete(success);
    }
  }, timeoutMs);
  return done;
};
var WaitForValue = class {
  #promise;
  #resolve;
  #written = false;
  constructor() {
    const { promise, resolve: resolve3 } = promiseWithResolvers();
    this.#promise = promise;
    this.#resolve = resolve3;
  }
  get() {
    return this.#promise;
  }
  add(value2) {
    if (this.#written) throw new Error(`QueueSingleUse has already been used`);
    this.#written = true;
    this.#resolve(value2);
  }
  /**
   * Returns _true_ if a value has been added
   * and therefore no more values can be written
   */
  get isUsed() {
    return this.#written;
  }
};
var singleItem = () => new WaitForValue();

// node_modules/ixfx/dist/chunk-R3Z53AZM.js
var Video_exports = {};
__export(Video_exports, {
  capture: () => capture,
  frames: () => frames,
  manualCapture: () => manualCapture
});
async function* frames(sourceVideoEl, opts = {}) {
  const maxIntervalMs = opts.maxIntervalMs ?? 0;
  const showCanvas = opts.showCanvas ?? false;
  let canvasEl = opts.canvasEl;
  let w3, h5;
  w3 = h5 = 0;
  if (canvasEl === void 0) {
    canvasEl = document.createElement(`CANVAS`);
    canvasEl.classList.add(`ixfx-frames`);
    if (!showCanvas) {
      canvasEl.style.display = `none`;
    }
    document.body.appendChild(canvasEl);
  }
  const updateSize = () => {
    if (canvasEl === void 0) return;
    w3 = sourceVideoEl.videoWidth;
    h5 = sourceVideoEl.videoHeight;
    canvasEl.width = w3;
    canvasEl.height = h5;
  };
  let c6 = null;
  const looper = delayLoop(maxIntervalMs);
  for await (const _3 of looper) {
    if (w3 === 0 || h5 === 0) updateSize();
    if (w3 === 0 || h5 === 0) continue;
    if (c6 === null) c6 = canvasEl.getContext(`2d`);
    if (c6 === null) return;
    c6.drawImage(sourceVideoEl, 0, 0, w3, h5);
    const pixels = c6.getImageData(0, 0, w3, h5);
    yield pixels;
  }
}
var capture = (sourceVideoEl, opts = {}) => {
  const maxIntervalMs = opts.maxIntervalMs ?? 0;
  const showCanvas = opts.showCanvas ?? false;
  const onFrame = opts.onFrame;
  const w3 = sourceVideoEl.videoWidth;
  const h5 = sourceVideoEl.videoHeight;
  const canvasEl = document.createElement(`CANVAS`);
  canvasEl.classList.add(`ixfx-capture`);
  if (!showCanvas) {
    canvasEl.style.display = `none`;
  }
  canvasEl.width = w3;
  canvasEl.height = h5;
  let c6 = null;
  let worker;
  if (opts.workerScript) {
    worker = new Worker(opts.workerScript);
  }
  const getPixels = worker || onFrame;
  if (!getPixels && !showCanvas) {
    console.warn(
      `Video will be captured to hidden element without any processing. Is this what you want?`
    );
  }
  const loop = continuously(() => {
    if (c6 === null) c6 = canvasEl.getContext(`2d`);
    if (c6 === null) return;
    c6.drawImage(sourceVideoEl, 0, 0, w3, h5);
    let pixels;
    if (getPixels) {
      pixels = c6.getImageData(0, 0, w3, h5);
    }
    if (worker) {
      worker.postMessage(
        {
          pixels: pixels.data.buffer,
          width: w3,
          height: h5,
          channels: 4
        },
        [pixels.data.buffer]
      );
    }
    if (onFrame) {
      try {
        onFrame(pixels);
      } catch (e5) {
        console.error(e5);
      }
    }
  }, maxIntervalMs);
  return {
    start: () => loop.start(),
    cancel: () => loop.cancel(),
    canvasEl
  };
};
var manualCapture = (sourceVideoEl, opts = {}) => {
  const showCanvas = opts.showCanvas ?? false;
  const w3 = sourceVideoEl.videoWidth;
  const h5 = sourceVideoEl.videoHeight;
  const definedCanvasEl = opts.canvasEl !== void 0;
  let canvasEl = opts.canvasEl;
  if (!canvasEl) {
    canvasEl = document.createElement(`CANVAS`);
    canvasEl.classList.add(`ixfx-capture`);
    document.body.append(canvasEl);
    if (!showCanvas) canvasEl.style.display = `none`;
  }
  canvasEl.width = w3;
  canvasEl.height = h5;
  const capture2 = () => {
    let c23;
    if (!c23) c23 = canvasEl?.getContext(`2d`, { willReadFrequently: true });
    if (!c23) throw new Error(`Could not create graphics context`);
    c23.drawImage(sourceVideoEl, 0, 0, w3, h5);
    const pixels = c23.getImageData(0, 0, w3, h5);
    pixels.currentTime = sourceVideoEl.currentTime;
    if (opts.postCaptureDraw) opts.postCaptureDraw(c23, w3, h5);
    return pixels;
  };
  const dispose = () => {
    if (definedCanvasEl) return;
    try {
      canvasEl?.remove();
    } catch (_3) {
    }
  };
  const c6 = {
    canvasEl,
    capture: capture2,
    dispose
  };
  return c6;
};

// node_modules/ixfx/dist/chunk-UTOEERYG.js
var floatSource = (maxOrOptions = 1) => {
  const options = typeof maxOrOptions === `number` ? { max: maxOrOptions } : maxOrOptions;
  let max5 = options.max;
  let min6 = options.min ?? 0;
  const source = options.source ?? defaultRandom;
  throwNumberTest(min6, ``, `min`);
  throwNumberTest(max5, ``, `max`);
  if (!options.min && max5 < 0) {
    min6 = max5;
    max5 = 0;
  }
  if (min6 > max5) {
    throw new Error(`Min is greater than max. Min: ${min6} max: ${max5}`);
  }
  return () => source() * (max5 - min6) + min6;
};
var float = (maxOrOptions = 1) => floatSource(maxOrOptions)();
function* count(amount, offset2 = 0) {
  throwIntegerTest(amount, ``, `amount`);
  throwIntegerTest(offset2, ``, `offset`);
  if (amount === 0) return;
  let index = 0;
  do {
    yield amount < 0 ? -index + offset2 : index + offset2;
  } while (index++ < Math.abs(amount) - 1);
}

// node_modules/ixfx/dist/chunk-XZAKN3JC.js
var pow = Math.pow;
var gaussianA = 1 / Math.sqrt(2 * Math.PI);
var gaussian = (standardDeviation = 0.4) => {
  const mean = 0.5;
  return (t6) => {
    const f5 = gaussianA / standardDeviation;
    let p4 = -2.5;
    let c6 = (t6 - mean) / standardDeviation;
    c6 *= c6;
    p4 *= c6;
    const v3 = f5 * pow(Math.E, p4);
    if (v3 > 1) return 1;
    if (v3 < 0) return 0;
    return v3;
  };
};
var time = (fn2, duration) => {
  throwFunctionTest(fn2, `fn`);
  let relative2;
  return () => {
    if (relative2 === void 0) relative2 = ofTotal(duration, { clampValue: true });
    return fn2(relative2());
  };
};
var timeModulator = (fn2, duration) => {
  throwFunctionTest(fn2, `fn`);
  const timer = elapsedMillisecondsAbsolute();
  const durationMs = intervalToMs(duration);
  if (durationMs === void 0) throw new Error(`Param 'duration' not provided`);
  const relativeTimer = relative(
    durationMs,
    {
      timer,
      clampValue: true
    }
  );
  return timerWithFunction(fn2, relativeTimer);
};
var ticks = (fn2, totalTicks) => {
  throwFunctionTest(fn2, `fn`);
  let relative2;
  return () => {
    if (relative2 === void 0) relative2 = ofTotalTicks(totalTicks, { clampValue: true });
    return fn2(relative2());
  };
};
var tickModulator = (fn2, durationTicks) => {
  throwFunctionTest(fn2, `fn`);
  const timer = elapsedTicksAbsolute();
  const relativeTimer = relative(
    durationTicks,
    {
      timer,
      clampValue: true
    }
  );
  return timerWithFunction(fn2, relativeTimer);
};
var easing_exports = {};
__export(easing_exports, {
  Named: () => EasingsNamed_exports,
  create: () => create2,
  get: () => get,
  getEasingNames: () => getEasingNames,
  tickEasing: () => tickEasing,
  ticks: () => ticks2,
  time: () => time2,
  timeEasing: () => timeEasing
});
var EasingsNamed_exports = {};
__export(EasingsNamed_exports, {
  arch: () => arch,
  backIn: () => backIn,
  backInOut: () => backInOut,
  backOut: () => backOut,
  bell: () => bell,
  bounceIn: () => bounceIn,
  bounceInOut: () => bounceInOut,
  bounceOut: () => bounceOut,
  circIn: () => circIn,
  circInOut: () => circInOut,
  circOut: () => circOut,
  cubicIn: () => cubicIn,
  cubicOut: () => cubicOut,
  elasticIn: () => elasticIn,
  elasticInOut: () => elasticInOut,
  elasticOut: () => elasticOut,
  expoIn: () => expoIn,
  expoInOut: () => expoInOut,
  expoOut: () => expoOut,
  quadIn: () => quadIn,
  quadInOut: () => quadInOut,
  quadOut: () => quadOut,
  quartIn: () => quartIn,
  quartOut: () => quartOut,
  quintIn: () => quintIn,
  quintInOut: () => quintInOut,
  quintOut: () => quintOut,
  sineIn: () => sineIn,
  sineInOut: () => sineInOut,
  sineOut: () => sineOut,
  smootherstep: () => smootherstep,
  smoothstep: () => smoothstep
});
var sqrt = Math.sqrt;
var pow2 = Math.pow;
var cos = Math.cos;
var pi2 = Math.PI;
var sin = Math.sin;
var bounceOut = (x3) => {
  const n1 = 7.5625;
  const d1 = 2.75;
  if (x3 < 1 / d1) {
    return n1 * x3 * x3;
  } else if (x3 < 2 / d1) {
    return n1 * (x3 -= 1.5 / d1) * x3 + 0.75;
  } else if (x3 < 2.5 / d1) {
    return n1 * (x3 -= 2.25 / d1) * x3 + 0.9375;
  } else {
    return n1 * (x3 -= 2.625 / d1) * x3 + 0.984375;
  }
};
var quintIn = (x3) => x3 * x3 * x3 * x3 * x3;
var quintOut = (x3) => 1 - pow2(1 - x3, 5);
var arch = (x3) => x3 * (1 - x3) * 4;
var smoothstep = (x3) => x3 * x3 * (3 - 2 * x3);
var smootherstep = (x3) => (x3 * (x3 * 6 - 15) + 10) * x3 * x3 * x3;
var sineIn = (x3) => 1 - cos(x3 * pi2 / 2);
var sineOut = (x3) => sin(x3 * pi2 / 2);
var quadIn = (x3) => x3 * x3;
var quadOut = (x3) => 1 - (1 - x3) * (1 - x3);
var sineInOut = (x3) => -(cos(pi2 * x3) - 1) / 2;
var quadInOut = (x3) => x3 < 0.5 ? 2 * x3 * x3 : 1 - pow2(-2 * x3 + 2, 2) / 2;
var cubicIn = (x3) => x3 * x3 * x3;
var cubicOut = (x3) => 1 - pow2(1 - x3, 3);
var quartIn = (x3) => x3 * x3 * x3 * x3;
var quartOut = (x3) => 1 - pow2(1 - x3, 4);
var expoIn = (x3) => x3 === 0 ? 0 : pow2(2, 10 * x3 - 10);
var expoOut = (x3) => x3 === 1 ? 1 : 1 - pow2(2, -10 * x3);
var quintInOut = (x3) => x3 < 0.5 ? 16 * x3 * x3 * x3 * x3 * x3 : 1 - pow2(-2 * x3 + 2, 5) / 2;
var expoInOut = (x3) => x3 === 0 ? 0 : x3 === 1 ? 1 : x3 < 0.5 ? pow2(2, 20 * x3 - 10) / 2 : (2 - pow2(2, -20 * x3 + 10)) / 2;
var circIn = (x3) => 1 - sqrt(1 - pow2(x3, 2));
var circOut = (x3) => sqrt(1 - pow2(x3 - 1, 2));
var backIn = (x3) => {
  const c12 = 1.70158;
  const c33 = c12 + 1;
  return c33 * x3 * x3 * x3 - c12 * x3 * x3;
};
var backOut = (x3) => {
  const c12 = 1.70158;
  const c33 = c12 + 1;
  return 1 + c33 * pow2(x3 - 1, 3) + c12 * pow2(x3 - 1, 2);
};
var circInOut = (x3) => x3 < 0.5 ? (1 - sqrt(1 - pow2(2 * x3, 2))) / 2 : (sqrt(1 - pow2(-2 * x3 + 2, 2)) + 1) / 2;
var backInOut = (x3) => {
  const c12 = 1.70158;
  const c23 = c12 * 1.525;
  return x3 < 0.5 ? pow2(2 * x3, 2) * ((c23 + 1) * 2 * x3 - c23) / 2 : (pow2(2 * x3 - 2, 2) * ((c23 + 1) * (x3 * 2 - 2) + c23) + 2) / 2;
};
var elasticIn = (x3) => {
  const c42 = 2 * pi2 / 3;
  return x3 === 0 ? 0 : x3 === 1 ? 1 : -pow2(2, 10 * x3 - 10) * sin((x3 * 10 - 10.75) * c42);
};
var elasticOut = (x3) => {
  const c42 = 2 * pi2 / 3;
  return x3 === 0 ? 0 : x3 === 1 ? 1 : pow2(2, -10 * x3) * sin((x3 * 10 - 0.75) * c42) + 1;
};
var bounceIn = (x3) => 1 - bounceOut(1 - x3);
var bell = gaussian();
var elasticInOut = (x3) => {
  const c52 = 2 * pi2 / 4.5;
  return x3 === 0 ? 0 : x3 === 1 ? 1 : x3 < 0.5 ? -(pow2(2, 20 * x3 - 10) * sin((20 * x3 - 11.125) * c52)) / 2 : pow2(2, -20 * x3 + 10) * sin((20 * x3 - 11.125) * c52) / 2 + 1;
};
var bounceInOut = (x3) => x3 < 0.5 ? (1 - bounceOut(1 - 2 * x3)) / 2 : (1 + bounceOut(2 * x3 - 1)) / 2;
var create2 = (options) => {
  let name = resolveEasingName(options.name ?? `quintIn`);
  const fn2 = name ?? options.fn;
  if (!fn2) throw new Error(`Either 'name' or 'fn' must be set`);
  if (`duration` in options) {
    return time2(fn2, options.duration);
  } else if (`ticks` in options) {
    return ticks2(fn2, options.ticks);
  } else {
    throw new Error(`Expected 'duration' or 'ticks' in options`);
  }
};
var timeEasing = (nameOrFunction, duration) => {
  const fn2 = resolveEasingName(nameOrFunction);
  return timeModulator(fn2, duration);
};
var time2 = (nameOrFunction, duration) => {
  const fn2 = resolveEasingName(nameOrFunction);
  return time(fn2, duration);
};
var ticks2 = (nameOrFunction, totalTicks) => {
  const fn2 = resolveEasingName(nameOrFunction);
  return ticks(fn2, totalTicks);
};
var tickEasing = (nameOrFunction, durationTicks) => {
  const fn2 = resolveEasingName(nameOrFunction);
  return tickModulator(fn2, durationTicks);
};
var resolveEasingName = (nameOrFunction) => {
  const fn2 = typeof nameOrFunction === `function` ? nameOrFunction : get(nameOrFunction);
  if (fn2 === void 0) {
    const error = typeof nameOrFunction === `string` ? new Error(`Easing function not found: '${nameOrFunction}'`) : new Error(`Easing function not found`);
    throw error;
  }
  return fn2;
};
var easingsMap;
var get = function(easingName) {
  throwStringTest(easingName, `non-empty`, `easingName`);
  const found = cacheEasings().get(easingName.toLowerCase());
  if (found === void 0) throw new Error(`Easing not found: '${easingName}'`);
  return found;
};
function cacheEasings() {
  if (easingsMap === void 0) {
    easingsMap = /* @__PURE__ */ new Map();
    for (const [k3, v3] of Object.entries(EasingsNamed_exports)) {
      easingsMap.set(k3.toLowerCase(), v3);
    }
    return easingsMap;
  } else return easingsMap;
}
function* getEasingNames() {
  const map3 = cacheEasings();
  yield* map3.keys();
}

// node_modules/ixfx/dist/chunk-KN7UFPTB.js
var wrap2 = (v3, min6 = 0, max5 = 1) => {
  throwNumberTest(v3, ``, `min`);
  throwNumberTest(min6, ``, `min`);
  throwNumberTest(max5, ``, `max`);
  if (v3 === min6) return min6;
  if (v3 === max5) return min6;
  while (v3 <= min6 || v3 >= max5) {
    if (v3 === max5) break;
    if (v3 === min6) break;
    if (v3 > max5) {
      v3 = min6 + (v3 - max5);
    } else if (v3 < min6) {
      v3 = max5 - (min6 - v3);
    }
  }
  return v3;
};

// node_modules/ixfx/dist/chunk-ODFCQPOV.js
var piPi = Math.PI * 2;
function interpolate(pos1, pos2, pos3, pos4) {
  let amountProcess;
  let limits = `clamp`;
  const handleAmount = (amount) => {
    if (amountProcess) amount = amountProcess(amount);
    if (limits === void 0 || limits === `clamp`) {
      amount = clamp(amount);
    } else if (limits === `wrap`) {
      if (amount > 1) amount = amount % 1;
      else if (amount < 0) {
        amount = 1 + amount % 1;
      }
    }
    return amount;
  };
  const doTheEase = (_amt, _a2, _b) => {
    throwNumberTest(_a2, ``, `a`);
    throwNumberTest(_b, ``, `b`);
    throwNumberTest(_amt, ``, `amount`);
    _amt = handleAmount(_amt);
    return (1 - _amt) * _a2 + _amt * _b;
  };
  const readOpts = (o5 = {}) => {
    if (o5.easing) {
      const easingFn = get(o5.easing);
      if (!easingFn) throw new Error(`Easing function '${o5.easing}' not found`);
      amountProcess = easingFn;
    } else if (o5.transform) {
      if (typeof o5.transform !== `function`) throw new Error(`Param 'transform' is expected to be a function. Got: ${typeof o5.transform}`);
      amountProcess = o5.transform;
    }
    limits = o5.limits ?? `clamp`;
  };
  const rawEase = (_amt, _a2, _b) => (1 - _amt) * _a2 + _amt * _b;
  if (typeof pos1 !== `number`) throw new TypeError(`First param is expected to be a number. Got: ${typeof pos1}`);
  if (typeof pos2 === `number`) {
    let a4;
    let b4;
    if (pos3 === void 0 || typeof pos3 === `object`) {
      a4 = pos1;
      b4 = pos2;
      readOpts(pos3);
      return (amount) => doTheEase(amount, a4, b4);
    } else if (typeof pos3 === `number`) {
      a4 = pos2;
      b4 = pos3;
      readOpts(pos4);
      return doTheEase(pos1, a4, b4);
    } else {
      throw new Error(`Values for 'a' and 'b' not defined`);
    }
  } else if (pos2 === void 0 || typeof pos2 === `object`) {
    let amount = handleAmount(pos1);
    readOpts(pos2);
    throwNumberTest(amount, ``, `amount`);
    return (aValue, bValue) => rawEase(amount, aValue, bValue);
  }
}

// node_modules/ixfx/dist/chunk-GHCV5Z5H.js
var scale = (v3, inMin, inMax, outMin, outMax, easing) => scaler(inMin, inMax, outMin, outMax, easing)(v3);
var scaler = (inMin, inMax, outMin, outMax, easing) => {
  const oMax = outMax ?? 1;
  const oMin = outMin ?? 0;
  return (v3) => {
    if (inMin === inMax) return oMax;
    let a4 = (v3 - inMin) / (inMax - inMin);
    if (easing !== void 0) a4 = easing(a4);
    return a4 * (oMax - oMin) + oMin;
  };
};

// node_modules/ixfx/dist/chunk-DTSGJWNP.js
var Bipolar_exports = {};
__export(Bipolar_exports, {
  clamp: () => clamp2,
  fromScalar: () => fromScalar,
  immutable: () => immutable2,
  random: () => random,
  randomSource: () => randomSource,
  scale: () => scale2,
  scaleUnclamped: () => scaleUnclamped,
  toScalar: () => toScalar,
  towardZero: () => towardZero
});
var immutable2 = (startingValueOrBipolar = 0) => {
  if (typeof startingValueOrBipolar === `undefined`) throw new Error(`Start value is undefined`);
  const startingValue = typeof startingValueOrBipolar === `number` ? startingValueOrBipolar : startingValueOrBipolar.value;
  if (startingValue > 1) throw new Error(`Start value cannot be larger than 1`);
  if (startingValue < -1) throw new Error(`Start value cannot be smaller than -1`);
  if (Number.isNaN(startingValue)) throw new Error(`Start value is NaN`);
  const v3 = startingValue;
  return {
    [Symbol.toPrimitive](hint) {
      if (hint === `number`) return v3;
      else if (hint === `string`) return v3.toString();
      return true;
    },
    value: v3,
    towardZero: (amt) => {
      return immutable2(towardZero(v3, amt));
    },
    add: (amt) => {
      return immutable2(clamp2(v3 + amt));
    },
    multiply: (amt) => {
      return immutable2(clamp2(v3 * amt));
    },
    inverse: () => {
      return immutable2(-v3);
    },
    interpolate: (amt, b4) => {
      return immutable2(clamp2(interpolate(amt, v3, b4)));
    },
    asScalar: () => {
      return toScalar(v3);
    }
  };
};
var toScalar = (bipolarValue) => {
  if (typeof bipolarValue !== `number`) throw new Error(`Expected v to be a number. Got: ${typeof bipolarValue}`);
  if (Number.isNaN(bipolarValue)) throw new Error(`Parameter is NaN`);
  return (bipolarValue + 1) / 2;
};
var fromScalar = (scalarValue) => {
  throwNumberTest(scalarValue, `percentage`, `v`);
  return scalarValue * 2 - 1;
};
var scale2 = (inputValue, inMin, inMax) => {
  return clamp2(scaler(inMin, inMax, -1, 1)(inputValue));
};
var scaleUnclamped = (inputValue, inMin, inMax) => {
  return scaler(inMin, inMax, -1, 1)(inputValue);
};
var randomSource = (maxOrOptions) => {
  const source = floatSource(maxOrOptions);
  return () => source() * 2 - 1;
};
var random = (maxOrOptions) => {
  const source = randomSource(maxOrOptions);
  return source();
};
var clamp2 = (bipolarValue) => {
  if (typeof bipolarValue !== `number`) throw new Error(`Param 'bipolarValue' must be a number. Got: ${typeof bipolarValue}`);
  if (Number.isNaN(bipolarValue)) throw new Error(`Param 'bipolarValue' is NaN`);
  if (bipolarValue > 1) return 1;
  if (bipolarValue < -1) return -1;
  return bipolarValue;
};
var towardZero = (bipolarValue, amount) => {
  if (typeof bipolarValue !== `number`) throw new Error(`Parameter 'v' must be a number. Got: ${typeof bipolarValue}`);
  if (typeof amount !== `number`) throw new Error(`Parameter 'amt' must be a number. Got: ${typeof amount}`);
  if (amount < 0) throw new Error(`Parameter 'amt' must be positive`);
  if (bipolarValue < 0) {
    bipolarValue += amount;
    if (bipolarValue > 0) bipolarValue = 0;
  } else if (bipolarValue > 0) {
    bipolarValue -= amount;
    if (bipolarValue < 0) bipolarValue = 0;
  }
  return bipolarValue;
};
var flip = (v3) => {
  if (typeof v3 === `function`) v3 = v3();
  throwNumberTest(v3, `percentage`, `v`);
  return 1 - v3;
};

// node_modules/ixfx/dist/chunk-MZFSDYZE.js
var containsDuplicateInstances = (array2) => {
  if (!Array.isArray(array2)) throw new Error(`Parameter needs to be an array`);
  for (let index = 0; index < array2.length; index++) {
    for (let x3 = 0; x3 < array2.length; x3++) {
      if (index === x3) continue;
      if (array2[index] === array2[x3]) return true;
    }
  }
  return false;
};

// node_modules/ixfx/dist/chunk-XA3MFF52.js
function reduce(it2, f5, start) {
  for (const v3 of it2) start = f5(start, v3);
  return start;
}
var IterableSync_exports = {};
__export(IterableSync_exports, {
  asCallback: () => asCallback,
  chunks: () => chunks,
  chunksOverlapping: () => chunksOverlapping,
  concat: () => concat,
  dropWhile: () => dropWhile,
  equals: () => equals,
  every: () => every,
  fill: () => fill,
  filter: () => filter2,
  find: () => find2,
  first: () => first,
  flatten: () => flatten,
  forEach: () => forEach,
  fromArray: () => fromArray,
  fromIterable: () => fromIterable,
  last: () => last,
  map: () => map,
  max: () => max,
  min: () => min,
  next: () => next2,
  reduce: () => reduce,
  repeat: () => repeat2,
  slice: () => slice,
  some: () => some2,
  toArray: () => toArray2,
  unique: () => unique2,
  uniqueByValue: () => uniqueByValue,
  until: () => until,
  yieldNumber: () => yieldNumber,
  zip: () => zip
});
function* uniqueByValue(input, toString23 = toStringDefault, seen = /* @__PURE__ */ new Set()) {
  for (const v3 of input) {
    const key = toString23(v3);
    if (seen.has(key)) continue;
    seen.add(key);
    yield v3;
  }
}
function asCallback(input, callback, onDone) {
  for (const value2 of input) {
    callback(value2);
  }
  if (onDone) onDone();
}
function yieldNumber(generator, defaultValue) {
  return () => {
    const v3 = generator.next().value;
    if (v3 === void 0) return defaultValue;
    return v3;
  };
}
function first(it2) {
  for (const value2 of it2) {
    return value2;
  }
}
function last(it2) {
  let returnValue;
  for (const value2 of it2) {
    returnValue = value2;
  }
  return returnValue;
}
function* chunksOverlapping(it2, size) {
  if (size <= 1) throw new Error(`Size should be at least 2`);
  let buffer = [];
  for (const v3 of it2) {
    buffer.push(v3);
    if (buffer.length === size) {
      yield buffer;
      buffer = [buffer.at(-1)];
    }
  }
  if (buffer.length <= 1) return;
  if (buffer.length > 0) yield buffer;
}
function* chunks(it2, size) {
  let buffer = [];
  for (const v3 of it2) {
    buffer.push(v3);
    if (buffer.length === size) {
      yield buffer;
      buffer = [];
    }
  }
  if (buffer.length > 0) yield buffer;
}
function* concat(...its) {
  for (const it2 of its) yield* it2;
}
function* dropWhile(it2, f5) {
  for (const v3 of it2) {
    if (!f5(v3)) {
      yield v3;
    }
  }
}
var until = (it2, callback) => {
  for (const _3 of it2) {
    const value2 = callback();
    if (typeof value2 === `boolean` && !value2) break;
  }
};
var next2 = (it2) => {
  return () => {
    const r5 = it2.next();
    if (r5.done) return;
    return r5.value;
  };
};
function equals(it1, it2, equality) {
  while (true) {
    const index1 = it1.next(), index2 = it2.next();
    if (equality !== void 0) {
      if (!equality(index1.value, index2.value)) return false;
    } else if (index1.value !== index2.value) return false;
    if (index1.done ?? index2.done) return index1.done && index2.done;
  }
}
function every(it2, f5) {
  for (const v3 of it2) {
    const result = f5(v3);
    if (!result) return false;
  }
  return true;
}
function* fill(it2, v3) {
  for (const _3 of it2) yield v3;
}
function forEach(iterator2, fn2) {
  for (const v3 of iterator2) {
    const result = fn2(v3);
    if (typeof result === `boolean` && !result) break;
  }
}
function* filter2(it2, f5) {
  for (const v3 of it2) {
    if (!f5(v3)) continue;
    yield v3;
  }
}
function find2(it2, f5) {
  for (const v3 of it2) {
    if (f5(v3)) return v3;
  }
}
function* flatten(it2) {
  for (const v3 of it2) {
    if (typeof v3 === `object`) {
      if (Array.isArray(v3)) {
        for (const vv of v3) yield vv;
      } else if (isIterable(v3)) {
        for (const vv of v3) {
          yield vv;
        }
      }
    } else {
      yield v3;
    }
  }
}
function* map(it2, f5) {
  for (const v3 of it2) {
    yield f5(v3);
  }
}
function* max(it2, gt3 = (a4, b4) => a4 > b4) {
  let max23;
  for (const v3 of it2) {
    if (max23 === void 0) {
      max23 = v3;
      yield max23;
      continue;
    }
    if (gt3(v3, max23)) {
      max23 = v3;
      yield max23;
    }
  }
  return max23;
}
function* min(it2, gt3 = (a4, b4) => a4 > b4) {
  let min23;
  for (const v3 of it2) {
    if (min23 === void 0) {
      min23 = v3;
      yield min23;
    }
    if (gt3(min23, v3)) {
      min23 = v3;
      yield min23;
    }
  }
}
function some2(it2, f5) {
  for (const v3 of it2) {
    if (f5(v3)) return true;
  }
  return false;
}
function* repeat2(genCreator, repeatsOrSignal) {
  const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;
  const signal = typeof repeatsOrSignal === `number` ? void 0 : repeatsOrSignal;
  let count3 = repeats;
  while (true) {
    for (const v3 of genCreator()) {
      yield v3;
      if (signal?.aborted) break;
    }
    if (Number.isFinite(repeats)) {
      count3--;
      if (count3 === 0) break;
    }
    if (signal?.aborted) break;
  }
}
function* unique2(iterable) {
  const buffer = [];
  let itera = [];
  itera = Array.isArray(iterable) ? iterable : [iterable];
  for (const it2 of itera) {
    for (const v3 of it2) {
      if (buffer.includes(v3)) continue;
      buffer.push(v3);
      yield v3;
    }
  }
}
function* zip(...its) {
  const iits = its.map((it2) => it2[Symbol.iterator]());
  while (true) {
    const vs2 = iits.map((it2) => it2.next());
    if (vs2.some((v3) => v3.done)) return;
    yield vs2.map((v3) => v3.value);
  }
}
function* fromIterable(iterable) {
  for (const v3 of iterable) {
    yield v3;
  }
}
function toArray2(it2, options = {}) {
  const result = [];
  const started = Date.now();
  const whileFunc = options.while;
  const maxItems = options.limit ?? Number.POSITIVE_INFINITY;
  const maxElapsed = intervalToMs(options.elapsed, Number.POSITIVE_INFINITY);
  for (const v3 of it2) {
    if (whileFunc) {
      if (!whileFunc(result.length)) break;
    }
    if (result.length >= maxItems) break;
    if (Date.now() - started > maxElapsed) break;
    result.push(v3);
  }
  return result;
}
function* fromArray(array2) {
  for (const v3 of array2) {
    yield v3;
  }
}
var trimStack = (opts, stack, toAdd) => {
  const potentialLength = stack.length + toAdd.length;
  const policy = opts.discardPolicy ?? `additions`;
  const capacity = opts.capacity ?? potentialLength;
  const toRemove = potentialLength - capacity;
  if (opts.debug) {
    console.log(
      `Stack.push: stackLen: ${stack.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${policy}`
    );
  }
  switch (policy) {
    case `additions`: {
      if (opts.debug) {
        console.log(
          `Stack.push:DiscardAdditions: stackLen: ${stack.length} slice: ${potentialLength - capacity} toAddLen: ${toAdd.length}`
        );
      }
      if (stack.length === opts.capacity) {
        return stack;
      } else {
        return [...stack, ...toAdd.slice(0, toAdd.length - toRemove)];
      }
    }
    case `newer`: {
      if (toRemove >= stack.length) {
        return toAdd.slice(
          Math.max(0, toAdd.length - capacity),
          Math.min(toAdd.length, capacity) + 1
        );
      } else {
        if (opts.debug) {
          console.log(` from orig: ${JSON.stringify(stack.slice(0, stack.length - toRemove))}`);
        }
        return [
          ...stack.slice(0, stack.length - toRemove),
          ...toAdd.slice(0, Math.min(toAdd.length, capacity - toRemove + 1))
        ];
      }
    }
    case `older`: {
      return [...stack, ...toAdd].slice(toRemove);
    }
    default: {
      throw new Error(`Unknown discard policy ${policy}`);
    }
  }
};
var push = (opts, stack, ...toAdd) => {
  const potentialLength = stack.length + toAdd.length;
  const overSize = opts.capacity && potentialLength > opts.capacity;
  const toReturn = overSize ? trimStack(opts, stack, toAdd) : [...stack, ...toAdd];
  return toReturn;
};
var pop = (opts, stack) => {
  if (stack.length === 0) throw new Error(`Stack is empty`);
  return stack.slice(0, -1);
};
var peek2 = (opts, stack) => stack.at(-1);
var isEmpty2 = (opts, stack) => stack.length === 0;
var isFull2 = (opts, stack) => {
  if (opts.capacity) {
    return stack.length >= opts.capacity;
  }
  return false;
};
var StackMutable = class {
  constructor(opts = {}, data = []) {
    this.opts = opts;
    this.data = data;
  }
  /**
   * Push data onto the stack.
   * If `toAdd` is empty, nothing happens
   * @param toAdd Data to add
   * @returns Length of stack
   */
  push(...toAdd) {
    if (toAdd.length === 0) return this.data.length;
    this.data = push(this.opts, this.data, ...toAdd);
    return this.data.length;
  }
  forEach(fn2) {
    this.data.forEach(fn2);
  }
  forEachFromTop(fn2) {
    [...this.data].reverse().forEach(fn2);
  }
  pop() {
    const v3 = peek2(this.opts, this.data);
    this.data = pop(this.opts, this.data);
    return v3;
  }
  get isEmpty() {
    return isEmpty2(this.opts, this.data);
  }
  get isFull() {
    return isFull2(this.opts, this.data);
  }
  get peek() {
    return peek2(this.opts, this.data);
  }
  get length() {
    return this.data.length;
  }
};
var TreeMutable_exports = {};
__export(TreeMutable_exports, {
  add: () => add2,
  addValue: () => addValue,
  asDynamicTraversable: () => asDynamicTraversable,
  breadthFirst: () => breadthFirst,
  children: () => children,
  childrenLength: () => childrenLength,
  compare: () => compare2,
  computeMaxDepth: () => computeMaxDepth,
  createNode: () => createNode,
  depthFirst: () => depthFirst,
  findAnyChildByValue: () => findAnyChildByValue,
  findChildByValue: () => findChildByValue,
  followValue: () => followValue,
  fromPlainObject: () => fromPlainObject,
  getRoot: () => getRoot,
  hasAnyChild: () => hasAnyChild,
  hasAnyParent: () => hasAnyParent,
  hasChild: () => hasChild,
  hasParent: () => hasParent,
  nodeDepth: () => nodeDepth,
  parents: () => parents,
  queryByValue: () => queryByValue,
  remove: () => remove,
  root: () => root,
  rootWrapped: () => rootWrapped,
  setChildren: () => setChildren,
  stripParentage: () => stripParentage,
  throwTreeTest: () => throwTreeTest,
  toStringDeep: () => toStringDeep,
  treeTest: () => treeTest,
  value: () => value,
  wrap: () => wrap3
});
var compare2 = (a4, b4, eq) => {
  return compare(asDynamicTraversable(a4), asDynamicTraversable(b4), eq);
};
var stripParentage = (node) => {
  const n7 = {
    value: node.value,
    childrenStore: node.childrenStore.map((c6) => stripParentage(c6))
  };
  return n7;
};
var unwrapped = (node) => `wraps` in node ? node.wraps : node;
var wrapped = (node) => `wraps` in node ? node : wrap3(node);
var wrap3 = (n7) => {
  return {
    *children() {
      for (const c6 of n7.childrenStore) {
        yield wrap3(c6);
      }
    },
    getValue: () => n7.value,
    getIdentity: () => n7,
    *queryValue(value2) {
      for (const v3 of queryByValue(value2, unwrapped(n7))) {
        yield wrap3(v3);
      }
    },
    getParent: () => n7.parent === void 0 ? void 0 : wrap3(n7.parent),
    hasParent: (parent) => {
      return hasParent(n7, unwrapped(parent));
    },
    hasAnyParent: (parent) => {
      return hasAnyParent(n7, unwrapped(parent));
    },
    hasChild: (child) => {
      return hasChild(unwrapped(child), n7);
    },
    hasAnyChild: (child) => {
      return hasAnyChild(unwrapped(child), n7);
    },
    remove: () => {
      remove(n7);
    },
    addValue: (value2) => {
      const nodeValue = addValue(value2, n7);
      return wrap3(nodeValue);
    },
    add: (child) => {
      add2(unwrapped(child), n7);
      return wrapped(child);
    },
    wraps: n7
  };
};
var remove = (child) => {
  const p4 = child.parent;
  if (p4 === void 0) return;
  child.parent = void 0;
  p4.childrenStore = without(p4.childrenStore, child);
};
function* depthFirst(node) {
  if (!root) return;
  const stack = new StackMutable();
  stack.push(...node.childrenStore);
  let entry = stack.pop();
  while (entry) {
    yield entry;
    if (entry) {
      stack.push(...entry.childrenStore);
    }
    if (stack.isEmpty) break;
    entry = stack.pop();
  }
}
function* breadthFirst(node) {
  if (!node) return;
  const queue = new QueueMutable();
  queue.enqueue(...node.childrenStore);
  let entry = queue.dequeue();
  while (entry) {
    yield entry;
    if (entry) {
      queue.enqueue(...entry.childrenStore);
    }
    if (queue.isEmpty) break;
    entry = queue.dequeue();
  }
}
function treeTest(root2, seen = []) {
  if (root2.parent === root2) return [false, `Root has itself as parent`, root2];
  if (seen.includes(root2)) return [false, `Same node instance is appearing further in tree`, root2];
  seen.push(root2);
  if (containsDuplicateInstances(root2.childrenStore)) return [false, `Children list contains duplicates`, root2];
  for (const c6 of root2.childrenStore) {
    if (c6.parent !== root2) return [false, `Member of childrenStore does not have .parent set`, c6];
    if (hasAnyChild(root2, c6)) return [false, `Child has parent as its own child`, c6];
    const v3 = treeTest(c6, seen);
    if (!v3[0]) return v3;
  }
  return [true, ``, root2];
}
function throwTreeTest(root2) {
  const v3 = treeTest(root2);
  if (v3[0]) return;
  throw new Error(`${v3[1]} Node: ${toStringAbbreviate(v3[2].value, 30)}`, { cause: v3[2] });
}
function* children(root2) {
  for (const c6 of root2.childrenStore) {
    yield c6;
  }
}
function* parents(root2) {
  let p4 = root2.parent;
  while (p4) {
    yield p4;
    p4 = p4.parent;
  }
}
function nodeDepth(node) {
  const p4 = [...parents(node)];
  return p4.length;
}
var hasChild = (child, parent) => {
  for (const c6 of parent.childrenStore) {
    if (c6 === child) return true;
  }
  return false;
};
var findChildByValue = (value2, parent, eq = isEqualDefault) => {
  for (const c6 of parent.childrenStore) {
    if (eq(value2, c6.value)) return c6;
  }
};
function* queryByValue(value2, parent, eq = isEqualDefault) {
  for (const c6 of parent.childrenStore) {
    if (eq(value2, c6.value)) yield c6;
  }
}
var hasAnyChild = (prospectiveChild, parent) => {
  for (const c6 of breadthFirst(parent)) {
    if (c6 === prospectiveChild) return true;
  }
  return false;
};
var findAnyChildByValue = (value2, parent, eq = isEqualDefault) => {
  for (const c6 of breadthFirst(parent)) {
    if (eq(c6.value, value2)) return c6;
  }
};
var getRoot = (node) => {
  if (node.parent) return getRoot(node.parent);
  return node;
};
var hasAnyParent = (child, prospectiveParent) => {
  for (const p4 of parents(child)) {
    if (p4 === prospectiveParent) return true;
  }
  return false;
};
var hasParent = (child, prospectiveParent) => {
  return child.parent === prospectiveParent;
};
var computeMaxDepth = (node) => {
  return computeMaxDepthImpl(node, 0);
};
var computeMaxDepthImpl = (node, startingDepth = 0) => {
  let depth = startingDepth;
  for (const c6 of node.childrenStore) {
    depth = Math.max(depth, computeMaxDepthImpl(c6, startingDepth + 1));
  }
  return depth;
};
var add2 = (child, parent) => {
  throwAttemptedChild(child, parent);
  const p4 = child.parent;
  parent.childrenStore = [...parent.childrenStore, child];
  child.parent = parent;
  if (p4) {
    p4.childrenStore = without(p4.childrenStore, child);
  }
};
var addValue = (value2, parent) => {
  return createNode(value2, parent);
};
var root = (value2) => {
  return createNode(value2);
};
var fromPlainObject = (value2, label = ``, parent, seen = []) => {
  const entries2 = Object.entries(value2);
  parent = parent === void 0 ? root() : addValue({ label, value: value2 }, parent);
  for (const entry of entries2) {
    const value3 = entry[1];
    if (seen.includes(value3)) continue;
    seen.push(value3);
    if (typeof entry[1] === `object`) {
      fromPlainObject(value3, entry[0], parent, seen);
    } else {
      addValue({ label: entry[0], value: value3 }, parent);
    }
  }
  return parent;
};
var rootWrapped = (value2) => {
  return wrap3(createNode(value2));
};
var createNode = (value2, parent) => {
  const n7 = {
    childrenStore: [],
    parent,
    value: value2
  };
  if (parent !== void 0) {
    parent.childrenStore = [...parent.childrenStore, n7];
  }
  return n7;
};
var childrenLength = (node) => {
  return node.childrenStore.length;
};
var value = (node) => {
  return node.value;
};
var asDynamicTraversable = (node) => {
  const t6 = {
    *children() {
      for (const c6 of node.childrenStore) {
        yield asDynamicTraversable(c6);
      }
    },
    getParent() {
      if (node.parent === void 0) return;
      return asDynamicTraversable(node.parent);
    },
    getValue() {
      return node.value;
    },
    getIdentity() {
      return node;
    }
  };
  return t6;
};
var throwAttemptedChild = (c6, parent) => {
  if (parent === c6) throw new Error(`Cannot add self as child`);
  if (c6.parent === parent) return;
  if (hasAnyParent(parent, c6)) throw new Error(`Child contains parent (1)`, { cause: c6 });
  if (hasAnyParent(c6, parent)) throw new Error(`Parent already contains child`, { cause: c6 });
  if (hasAnyChild(parent, c6)) throw new Error(`Child contains parent (2)`, { cause: c6 });
};
var setChildren = (parent, children3) => {
  for (const c6 of children3) {
    throwAttemptedChild(c6, parent);
  }
  parent.childrenStore = [...children3];
  for (const c6 of children3) {
    c6.parent = parent;
  }
};
var toStringDeep = (node, indent = 0) => {
  const t6 = `${`  `.repeat(indent)} + ${node.value ? JSON.stringify(node.value) : `-`}`;
  return node.childrenStore.length > 0 ? t6 + `
` + node.childrenStore.map((d4) => toStringDeep(d4, indent + 1)).join(`
`) : t6;
};
function* followValue(root2, continuePredicate, depth = 1) {
  for (const c6 of root2.childrenStore) {
    const value2 = c6.value;
    if (value2 === void 0) continue;
    if (continuePredicate(value2, depth)) {
      yield c6.value;
      yield* followValue(c6, continuePredicate, depth + 1);
    }
  }
}
var compare = (a4, b4, eq = isEqualValueIgnoreOrder, parent) => {
  const valueEqual = valueOrIdentityEqual(a4, b4, eq);
  const childrenCompare = compareChildren(a4, b4, eq);
  const diff = {
    valueChanged: !valueEqual,
    a: a4,
    b: b4,
    added: childrenCompare.added,
    removed: childrenCompare.removed,
    childChanged: false
  };
  const diffNode = {
    value: diff,
    childrenStore: [],
    parent
  };
  const childrenDiff = childrenCompare.identical.map((c6) => compare(c6[0], c6[1], eq, diffNode));
  const someChildChange = hasChange(diff) || childrenDiff.some((v3) => hasChange(v3.value));
  setChildren(diffNode, childrenDiff);
  diffNode.toString = () => toString(diffNode, 0);
  diffNode.value.childChanged = someChildChange;
  throwTreeTest(diffNode);
  return diffNode;
};
var hasChange = (vv) => {
  if (vv === void 0) return false;
  if (vv.valueChanged) return true;
  if (vv.childChanged) return true;
  if (vv.added.length > 0) return true;
  if (vv.removed.length > 0) return true;
  return false;
};
var compareChildren = (a4, b4, eq = isEqualValueIgnoreOrder) => {
  const childrenOfA = [...a4.children()];
  const childrenOfB = [...b4.children()];
  const identical = [];
  const removed = [];
  for (const childA of childrenOfA) {
    let foundIndex = -1;
    for (const [index, childOfB] of childrenOfB.entries()) {
      const d4 = valueOrIdentityEqual(childA, childOfB, eq);
      if (d4) {
        identical.push([childA, childOfB]);
        foundIndex = index;
        break;
      }
    }
    if (foundIndex === -1) {
      removed.push(childA);
    } else {
      childrenOfB.splice(foundIndex, 1);
    }
  }
  const added = [...childrenOfB];
  return { added, identical, removed };
};
var valueOrIdentityEqual = (a4, b4, eq) => {
  if (a4.getIdentity() === b4.getIdentity()) return true;
  if (eq(a4.getValue(), b4.getValue())) return true;
  return false;
};
var toStringSingle = (n7) => {
  return JSON.stringify(n7.getValue());
};
var toString = (n7, indent = 0) => {
  if (n7 === void 0) return `(undefined)`;
  let t6 = toStringDiff(n7.value, indent);
  for (const c6 of n7.childrenStore) {
    t6 += toString(c6, indent + 2);
  }
  return t6;
};
var toStringDiff = (n7, indent) => {
  const spaces2 = ` `.repeat(indent);
  if (n7 === void 0) return `${spaces2}(undefined)`;
  const t6 = [];
  t6.push(`a: ${toStringSingle(n7.a)} b: ${toStringSingle(n7.b)}`);
  if (n7.valueChanged) t6.push(`Value changed. Child changed: ${n7.childChanged}`);
  else t6.push(`Value unchanged. Child changed: ${n7.childChanged}`);
  if (n7.added.length > 0) {
    t6.push(`Added:`);
    for (const c6 of n7.added) {
      t6.push(` - ` + toStringSingle(c6));
    }
  }
  if (n7.removed.length > 0) {
    t6.push(`Removed: ${n7.removed.length}`);
    for (const c6 of n7.removed) {
      t6.push(` - ` + toStringSingle(c6));
    }
  }
  t6.push(`----
`);
  return t6.map((line3) => spaces2 + line3).join(`
`);
};
var TraverseObject_exports = {};
__export(TraverseObject_exports, {
  asDynamicTraversable: () => asDynamicTraversable2,
  children: () => children2,
  create: () => create3,
  createSimplified: () => createSimplified,
  createWrapped: () => createWrapped,
  depthFirst: () => depthFirst2,
  getByPath: () => getByPath,
  prettyPrint: () => prettyPrint,
  prettyPrintEntries: () => prettyPrintEntries,
  toStringDeep: () => toStringDeep2,
  traceByPath: () => traceByPath
});
function isPrimitive(value2) {
  if (typeof value2 === `number`) return true;
  if (typeof value2 === `string`) return true;
  if (typeof value2 === `bigint`) return true;
  if (typeof value2 === `boolean`) return true;
  return false;
}
function prettyPrintEntries(entries2) {
  if (entries2.length === 0) return `(empty)`;
  let t6 = ``;
  for (const [index, entry] of entries2.entries()) {
    t6 += `  `.repeat(index);
    t6 += entry.name + ` = ` + JSON.stringify(entry.nodeValue) + `
`;
  }
  return t6;
}
var prettyPrint = (node, indent = 0, options = {}) => {
  throwNullUndef(node, `node`);
  const defaultName = options.name ?? `node`;
  const entry = getNamedEntry(node, defaultName);
  const t6 = `${`  `.repeat(indent)} + name: ${entry.name} value: ${JSON.stringify(entry.nodeValue)}`;
  const childrenAsArray = [...children2(node, options)];
  return childrenAsArray.length > 0 ? t6 + `
` + childrenAsArray.map((d4) => prettyPrint(d4.nodeValue, indent + 1, { ...options, name: d4.name })).join(`
`) : t6;
};
var toStringDeep2 = (node, indent = 0) => {
  let t6 = ` `.repeat(indent) + ` ${node.value?.name}`;
  if (node.value !== void 0) {
    if (`sourceValue` in node.value && `nodeValue` in node.value) {
      let sourceValue = toStringAbbreviate(node.value?.sourceValue, 20);
      const nodeValue = toStringAbbreviate(node.value?.nodeValue, 20);
      sourceValue = sourceValue === nodeValue ? `` : `source: ` + sourceValue;
      t6 += ` = ${nodeValue} ${sourceValue}`;
    } else if (`value` in node.value && node.value.value !== void 0) t6 += ` = ${node.value.value}`;
    if (`ancestors` in node.value) {
      t6 += ` (ancestors: ${node.value.ancestors.join(`, `)})`;
    }
  }
  t6 += `
`;
  for (const c6 of node.childrenStore) {
    t6 += toStringDeep2(c6, indent + 1);
  }
  return t6;
};
function* children2(node, options = {}) {
  throwNullUndef(node, `node`);
  const filter23 = options.filter ?? `none`;
  const filterByValue = (v3) => {
    if (filter23 === `none`) return [true, isPrimitive(v3)];
    else if (filter23 === `leaves` && isPrimitive(v3)) return [true, true];
    else if (filter23 === `branches` && !isPrimitive(v3)) return [true, false];
    return [false, isPrimitive(v3)];
  };
  if (Array.isArray(node)) {
    for (const [index, element] of node.entries()) {
      const f5 = filterByValue(element);
      if (f5[0]) {
        yield { name: index.toString(), sourceValue: element, nodeValue: f5[1] ? element : void 0 };
      }
    }
  } else if (typeof node === `object`) {
    const entriesIter = `entries` in node ? node.entries() : Object.entries(node);
    for (const [name, value2] of entriesIter) {
      const f5 = filterByValue(value2);
      if (f5[0]) {
        yield { name, sourceValue: value2, nodeValue: f5[1] ? value2 : void 0 };
      }
    }
  }
}
function* depthFirst2(node, options = {}, ancestors = []) {
  for (const c6 of children2(node, options)) {
    yield { ...c6, ancestors: [...ancestors] };
    yield* depthFirst2(c6.sourceValue, options, [...ancestors, c6.name]);
  }
}
function childByName(name, node) {
  for (const d4 of children2(node)) {
    if (d4.name === name) return d4;
  }
}
function getByPath(path2, node, options = {}) {
  const v3 = last(traceByPath(path2, node, options));
  if (!v3) throw new Error(`Could not trace path: ${path2} `);
  return v3;
}
function* traceByPath(path2, node, options = {}) {
  throwNullUndef(path2, `path`);
  throwNullUndef(node, `node`);
  const separator = options.separator ?? `.`;
  const pathSplit = path2.split(separator);
  const ancestors = [];
  for (const p4 of pathSplit) {
    const entry = childByName(p4, node);
    if (!entry) {
      yield { name: p4, sourceValue: void 0, nodeValue: void 0, ancestors };
      return;
    }
    node = entry.sourceValue;
    yield { ...entry, ancestors: [...ancestors] };
    ancestors.push(p4);
  }
}
var asDynamicTraversable2 = (node, options = {}, ancestors = [], parent) => {
  const name = options.name ?? `object`;
  const t6 = {
    *children() {
      for (const c6 of children2(node, options)) {
        yield asDynamicTraversable2(c6.sourceValue, { ...options, name: c6.name }, [...ancestors, name], t6);
      }
    },
    getParent() {
      return parent;
    },
    getValue() {
      return { name, value: node, ancestors };
    },
    getIdentity() {
      return node;
    }
  };
  return t6;
};
var createWrapped = (node, options) => {
  return wrap3(create3(node, options));
};
var create3 = (node, options = {}) => {
  const valuesAtLeaves = options.valuesAtLeaves ?? false;
  const valueFor = valuesAtLeaves ? (v3) => {
    if (isPrimitive(v3)) return v3;
  } : (v3) => v3;
  return createImpl(node, valueFor(node), options, []);
};
var createImpl = (sourceValue, nodeValue, options = {}, ancestors) => {
  const defaultName = options.name ?? `object_ci`;
  const r5 = root({ name: defaultName, value: nodeValue, ancestors: [...ancestors] });
  ancestors = [...ancestors, defaultName];
  for (const c6 of children2(sourceValue, options)) {
    const v3 = options.valuesAtLeaves ? c6.nodeValue : c6.sourceValue;
    add2(createImpl(c6.sourceValue, v3, { ...options, name: c6.name }, ancestors), r5);
  }
  return r5;
};
var createSimplified = (node, options = {}) => {
  return stripParentage(create3(node, options));
};
function getNamedEntry(node, defaultName = ``) {
  if (`name` in node && `nodeValue` in node && `sourceValue` in node) return node;
  if (`name` in node) {
    return { name: node.name, nodeValue: node, sourceValue: node };
  }
  return { name: defaultName, nodeValue: node, sourceValue: node };
}

// node_modules/ixfx/dist/chunk-22HPBYMV.js
var StackImmutable = class _StackImmutable {
  constructor(opts = {}, data = []) {
    this.opts = opts;
    this.data = data;
  }
  push(...toAdd) {
    return new _StackImmutable(
      this.opts,
      push(this.opts, this.data, ...toAdd)
    );
  }
  pop() {
    return new _StackImmutable(this.opts, pop(this.opts, this.data));
  }
  forEach(fn2) {
    this.data.forEach(fn2);
  }
  forEachFromTop(fn2) {
    [...this.data].reverse().forEach(fn2);
  }
  get isEmpty() {
    return isEmpty2(this.opts, this.data);
  }
  get isFull() {
    return isFull2(this.opts, this.data);
  }
  get peek() {
    return peek2(this.opts, this.data);
  }
  get length() {
    return this.data.length;
  }
};

// node_modules/ixfx/dist/chunk-ZNCB3DZ2.js
var resolveEl = (domQueryOrEl) => {
  if (typeof domQueryOrEl === `string`) {
    const d4 = document.querySelector(domQueryOrEl);
    if (d4 === null) {
      const error = domQueryOrEl.startsWith(`#`) ? new Error(
        `Query '${domQueryOrEl}' did not match anything. Try '#id', 'div', or '.class'`
      ) : new Error(
        `Query '${domQueryOrEl}' did not match anything. Did you mean '#${domQueryOrEl}?`
      );
      throw error;
    }
    domQueryOrEl = d4;
  } else if (domQueryOrEl === null) {
    throw new Error(`Param 'domQueryOrEl' is null`);
  } else if (domQueryOrEl === void 0) {
    throw new Error(`Param 'domQueryOrEl' is undefined`);
  }
  const el = domQueryOrEl;
  return el;
};
var resolveEls = (selectors) => {
  if (selectors === void 0) return [];
  if (selectors === null) return [];
  if (Array.isArray(selectors)) return selectors;
  if (typeof selectors === `string`) {
    const elements2 = [...document.querySelectorAll(selectors)];
    return elements2;
  }
  return [selectors];
};

// node_modules/ixfx/dist/chunk-BGQOJZFW.js
function* pairwise(values) {
  guardArray(values, `values`);
  if (values.length < 2) throw new Error(`Array needs to have at least two entries. Length: ${values.length}`);
  for (let index = 1; index < values.length; index++) {
    yield [values[index - 1], values[index]];
  }
}

// node_modules/ixfx/dist/chunk-BZFRTFR3.js
var Colour_exports = {};
__export(Colour_exports, {
  cssLinearGradient: () => cssLinearGradient,
  fromHsl: () => fromHsl,
  getCssVariable: () => getCssVariable,
  goldenAngleColour: () => goldenAngleColour,
  interpolator: () => interpolator,
  opacity: () => opacity,
  randomHue: () => randomHue,
  resolve: () => resolve2,
  resolveToString: () => resolveToString,
  scale: () => scale3,
  toHex: () => toHex,
  toHsl: () => toHsl,
  toRgb: () => toRgb,
  toString: () => toString2
});
function multiplyMatrices(A2, B3) {
  let m32 = A2.length;
  if (!Array.isArray(A2[0])) {
    A2 = [A2];
  }
  if (!Array.isArray(B3[0])) {
    B3 = B3.map((x3) => [x3]);
  }
  let p22 = B3[0].length;
  let B_cols = B3[0].map((_3, i4) => B3.map((x3) => x3[i4]));
  let product = A2.map((row) => B_cols.map((col) => {
    let ret = 0;
    if (!Array.isArray(row)) {
      for (let c42 of col) {
        ret += row * c42;
      }
      return ret;
    }
    for (let i4 = 0; i4 < row.length; i4++) {
      ret += row[i4] * (col[i4] || 0);
    }
    return ret;
  }));
  if (m32 === 1) {
    product = product[0];
  }
  if (p22 === 1) {
    return product.map((x3) => x3[0]);
  }
  return product;
}
function isString(str) {
  return type(str) === "string";
}
function type(o5) {
  let str = Object.prototype.toString.call(o5);
  return (str.match(/^\[object\s+(.*?)\]$/)[1] || "").toLowerCase();
}
function serializeNumber(n22, { precision, unit }) {
  if (isNone(n22)) {
    return "none";
  }
  return toPrecision(n22, precision) + (unit ?? "");
}
function isNone(n22) {
  return Number.isNaN(n22) || n22 instanceof Number && n22?.none;
}
function skipNone(n22) {
  return isNone(n22) ? 0 : n22;
}
function toPrecision(n22, precision) {
  if (n22 === 0) {
    return 0;
  }
  let integer2 = ~~n22;
  let digits = 0;
  if (integer2 && precision) {
    digits = ~~Math.log10(Math.abs(integer2)) + 1;
  }
  const multiplier = 10 ** (precision - digits);
  return Math.floor(n22 * multiplier + 0.5) / multiplier;
}
var angleFactor = {
  deg: 1,
  grad: 0.9,
  rad: 180 / Math.PI,
  turn: 360
};
function parseFunction(str) {
  if (!str) {
    return;
  }
  str = str.trim();
  const isFunctionRegex = /^([a-z]+)\((.+?)\)$/i;
  const isNumberRegex = /^-?[\d.]+$/;
  const unitValueRegex = /%|deg|g?rad|turn$/;
  const singleArgument = /\/?\s*(none|[-\w.]+(?:%|deg|g?rad|turn)?)/g;
  let parts = str.match(isFunctionRegex);
  if (parts) {
    let args = [];
    parts[2].replace(singleArgument, ($0, rawArg) => {
      let match = rawArg.match(unitValueRegex);
      let arg = rawArg;
      if (match) {
        let unit = match[0];
        let unitlessArg = arg.slice(0, -unit.length);
        if (unit === "%") {
          arg = new Number(unitlessArg / 100);
          arg.type = "<percentage>";
        } else {
          arg = new Number(unitlessArg * angleFactor[unit]);
          arg.type = "<angle>";
          arg.unit = unit;
        }
      } else if (isNumberRegex.test(arg)) {
        arg = new Number(arg);
        arg.type = "<number>";
      } else if (arg === "none") {
        arg = new Number(NaN);
        arg.none = true;
      }
      if ($0.startsWith("/")) {
        arg = arg instanceof Number ? arg : new Number(arg);
        arg.alpha = true;
      }
      if (typeof arg === "object" && arg instanceof Number) {
        arg.raw = rawArg;
      }
      args.push(arg);
    });
    return {
      name: parts[1].toLowerCase(),
      rawName: parts[1],
      rawArgs: parts[2],
      // An argument could be (as of css-color-4):
      // a number, percentage, degrees (hue), ident (in color())
      args
    };
  }
}
function last2(arr) {
  return arr[arr.length - 1];
}
function interpolate2(start, end, p22) {
  if (isNaN(start)) {
    return end;
  }
  if (isNaN(end)) {
    return start;
  }
  return start + (end - start) * p22;
}
function interpolateInv(start, end, value2) {
  return (value2 - start) / (end - start);
}
function mapRange(from2, to22, value2) {
  return interpolate2(to22[0], to22[1], interpolateInv(from2[0], from2[1], value2));
}
function parseCoordGrammar(coordGrammars) {
  return coordGrammars.map((coordGrammar2) => {
    return coordGrammar2.split("|").map((type2) => {
      type2 = type2.trim();
      let range2 = type2.match(/^(<[a-z]+>)\[(-?[.\d]+),\s*(-?[.\d]+)\]?$/);
      if (range2) {
        let ret = new String(range2[1]);
        ret.range = [+range2[2], +range2[3]];
        return ret;
      }
      return type2;
    });
  });
}
function clamp22(min6, val, max23) {
  return Math.max(Math.min(max23, val), min6);
}
function copySign(to22, from2) {
  return Math.sign(to22) === Math.sign(from2) ? to22 : -to22;
}
function spow(base, exp) {
  return copySign(Math.abs(base) ** exp, base);
}
function zdiv(n22, d22) {
  return d22 === 0 ? 0 : n22 / d22;
}
function bisectLeft(arr, value2, lo2 = 0, hi2 = arr.length) {
  while (lo2 < hi2) {
    const mid = lo2 + hi2 >> 1;
    if (arr[mid] < value2) {
      lo2 = mid + 1;
    } else {
      hi2 = mid;
    }
  }
  return lo2;
}
var util = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  bisectLeft,
  clamp: clamp22,
  copySign,
  interpolate: interpolate2,
  interpolateInv,
  isNone,
  isString,
  last: last2,
  mapRange,
  multiplyMatrices,
  parseCoordGrammar,
  parseFunction,
  serializeNumber,
  skipNone,
  spow,
  toPrecision,
  type,
  zdiv
});
var Hooks = class {
  add(name, callback, first2) {
    if (typeof arguments[0] != "string") {
      for (var name in arguments[0]) {
        this.add(name, arguments[0][name], arguments[1]);
      }
      return;
    }
    (Array.isArray(name) ? name : [name]).forEach(function(name2) {
      this[name2] = this[name2] || [];
      if (callback) {
        this[name2][first2 ? "unshift" : "push"](callback);
      }
    }, this);
  }
  run(name, env) {
    this[name] = this[name] || [];
    this[name].forEach(function(callback) {
      callback.call(env && env.context ? env.context : env, env);
    });
  }
};
var hooks = new Hooks();
var defaults = {
  gamut_mapping: "css",
  precision: 5,
  deltaE: "76",
  // Default deltaE method
  verbose: globalThis?.process?.env?.NODE_ENV?.toLowerCase() !== "test",
  warn: function warn(msg) {
    if (this.verbose) {
      globalThis?.console?.warn?.(msg);
    }
  }
};
var WHITES = {
  // for compatibility, the four-digit chromaticity-derived ones everyone else uses
  D50: [0.3457 / 0.3585, 1, (1 - 0.3457 - 0.3585) / 0.3585],
  D65: [0.3127 / 0.329, 1, (1 - 0.3127 - 0.329) / 0.329]
};
function getWhite(name) {
  if (Array.isArray(name)) {
    return name;
  }
  return WHITES[name];
}
function adapt$2(W1, W2, XYZ, options = {}) {
  W1 = getWhite(W1);
  W2 = getWhite(W2);
  if (!W1 || !W2) {
    throw new TypeError(`Missing white point to convert ${!W1 ? "from" : ""}${!W1 && !W2 ? "/" : ""}${!W2 ? "to" : ""}`);
  }
  if (W1 === W2) {
    return XYZ;
  }
  let env = { W1, W2, XYZ, options };
  hooks.run("chromatic-adaptation-start", env);
  if (!env.M) {
    if (env.W1 === WHITES.D65 && env.W2 === WHITES.D50) {
      env.M = [
        [1.0479297925449969, 0.022946870601609652, -0.05019226628920524],
        [0.02962780877005599, 0.9904344267538799, -0.017073799063418826],
        [-0.009243040646204504, 0.015055191490298152, 0.7518742814281371]
      ];
    } else if (env.W1 === WHITES.D50 && env.W2 === WHITES.D65) {
      env.M = [
        [0.955473421488075, -0.02309845494876471, 0.06325924320057072],
        [-0.0283697093338637, 1.0099953980813041, 0.021041441191917323],
        [0.012314014864481998, -0.020507649298898964, 1.330365926242124]
      ];
    }
  }
  hooks.run("chromatic-adaptation-end", env);
  if (env.M) {
    return multiplyMatrices(env.M, env.XYZ);
  } else {
    throw new TypeError("Only Bradford CAT with white points D50 and D65 supported for now.");
  }
}
var noneTypes = /* @__PURE__ */ new Set(["<number>", "<percentage>", "<angle>"]);
function coerceCoords(space, format, name, coords) {
  let types = Object.entries(space.coords).map(([id, coordMeta], i4) => {
    let coordGrammar2 = format.coordGrammar[i4];
    let arg = coords[i4];
    let providedType = arg?.type;
    let type2;
    if (arg.none) {
      type2 = coordGrammar2.find((c42) => noneTypes.has(c42));
    } else {
      type2 = coordGrammar2.find((c42) => c42 == providedType);
    }
    if (!type2) {
      let coordName = coordMeta.name || id;
      throw new TypeError(`${providedType ?? arg.raw} not allowed for ${coordName} in ${name}()`);
    }
    let fromRange = type2.range;
    if (providedType === "<percentage>") {
      fromRange ||= [0, 1];
    }
    let toRange = coordMeta.range || coordMeta.refRange;
    if (fromRange && toRange) {
      coords[i4] = mapRange(fromRange, toRange, coords[i4]);
    }
    return type2;
  });
  return types;
}
function parse(str, { meta } = {}) {
  let env = { "str": String(str)?.trim() };
  hooks.run("parse-start", env);
  if (env.color) {
    return env.color;
  }
  env.parsed = parseFunction(env.str);
  if (env.parsed) {
    let name = env.parsed.name;
    if (name === "color") {
      let id = env.parsed.args.shift();
      let alternateId = id.startsWith("--") ? id.substring(2) : `--${id}`;
      let ids = [id, alternateId];
      let alpha = env.parsed.rawArgs.indexOf("/") > 0 ? env.parsed.args.pop() : 1;
      for (let space of ColorSpace.all) {
        let colorSpec = space.getFormat("color");
        if (colorSpec) {
          if (ids.includes(colorSpec.id) || colorSpec.ids?.filter((specId) => ids.includes(specId)).length) {
            const coords = Object.keys(space.coords).map((_3, i4) => env.parsed.args[i4] || 0);
            let types;
            if (colorSpec.coordGrammar) {
              types = coerceCoords(space, colorSpec, "color", coords);
            }
            if (meta) {
              Object.assign(meta, { formatId: "color", types });
            }
            if (colorSpec.id.startsWith("--") && !id.startsWith("--")) {
              defaults.warn(`${space.name} is a non-standard space and not currently supported in the CSS spec. Use prefixed color(${colorSpec.id}) instead of color(${id}).`);
            }
            if (id.startsWith("--") && !colorSpec.id.startsWith("--")) {
              defaults.warn(`${space.name} is a standard space and supported in the CSS spec. Use color(${colorSpec.id}) instead of prefixed color(${id}).`);
            }
            return { spaceId: space.id, coords, alpha };
          }
        }
      }
      let didYouMean = "";
      let registryId = id in ColorSpace.registry ? id : alternateId;
      if (registryId in ColorSpace.registry) {
        let cssId = ColorSpace.registry[registryId].formats?.color?.id;
        if (cssId) {
          didYouMean = `Did you mean color(${cssId})?`;
        }
      }
      throw new TypeError(`Cannot parse color(${id}). ` + (didYouMean || "Missing a plugin?"));
    } else {
      for (let space of ColorSpace.all) {
        let format = space.getFormat(name);
        if (format && format.type === "function") {
          let alpha = 1;
          if (format.lastAlpha || last2(env.parsed.args).alpha) {
            alpha = env.parsed.args.pop();
          }
          let coords = env.parsed.args;
          let types;
          if (format.coordGrammar) {
            types = coerceCoords(space, format, name, coords);
          }
          if (meta) {
            Object.assign(meta, { formatId: format.name, types });
          }
          return {
            spaceId: space.id,
            coords,
            alpha
          };
        }
      }
    }
  } else {
    for (let space of ColorSpace.all) {
      for (let formatId in space.formats) {
        let format = space.formats[formatId];
        if (format.type !== "custom") {
          continue;
        }
        if (format.test && !format.test(env.str)) {
          continue;
        }
        let color = format.parse(env.str);
        if (color) {
          color.alpha ??= 1;
          if (meta) {
            meta.formatId = formatId;
          }
          return color;
        }
      }
    }
  }
  throw new TypeError(`Could not parse ${str} as a color. Missing a plugin?`);
}
function getColor(color) {
  if (Array.isArray(color)) {
    return color.map(getColor);
  }
  if (!color) {
    throw new TypeError("Empty color reference");
  }
  if (isString(color)) {
    color = parse(color);
  }
  let space = color.space || color.spaceId;
  if (!(space instanceof ColorSpace)) {
    color.space = ColorSpace.get(space);
  }
  if (color.alpha === void 0) {
    color.alpha = 1;
  }
  return color;
}
var \u03B5$7 = 75e-6;
var ColorSpace = class _ColorSpace {
  constructor(options) {
    this.id = options.id;
    this.name = options.name;
    this.base = options.base ? _ColorSpace.get(options.base) : null;
    this.aliases = options.aliases;
    if (this.base) {
      this.fromBase = options.fromBase;
      this.toBase = options.toBase;
    }
    let coords = options.coords ?? this.base.coords;
    for (let name in coords) {
      if (!("name" in coords[name])) {
        coords[name].name = name;
      }
    }
    this.coords = coords;
    let white2 = options.white ?? this.base.white ?? "D65";
    this.white = getWhite(white2);
    this.formats = options.formats ?? {};
    for (let name in this.formats) {
      let format = this.formats[name];
      format.type ||= "function";
      format.name ||= name;
    }
    if (!this.formats.color?.id) {
      this.formats.color = {
        ...this.formats.color ?? {},
        id: options.cssId || this.id
      };
    }
    if (options.gamutSpace) {
      this.gamutSpace = options.gamutSpace === "self" ? this : _ColorSpace.get(options.gamutSpace);
    } else {
      if (this.isPolar) {
        this.gamutSpace = this.base;
      } else {
        this.gamutSpace = this;
      }
    }
    if (this.gamutSpace.isUnbounded) {
      this.inGamut = (coords2, options2) => {
        return true;
      };
    }
    this.referred = options.referred;
    Object.defineProperty(this, "path", {
      value: getPath(this).reverse(),
      writable: false,
      enumerable: true,
      configurable: true
    });
    hooks.run("colorspace-init-end", this);
  }
  inGamut(coords, { epsilon: epsilon2 = \u03B5$7 } = {}) {
    if (!this.equals(this.gamutSpace)) {
      coords = this.to(this.gamutSpace, coords);
      return this.gamutSpace.inGamut(coords, { epsilon: epsilon2 });
    }
    let coordMeta = Object.values(this.coords);
    return coords.every((c42, i4) => {
      let meta = coordMeta[i4];
      if (meta.type !== "angle" && meta.range) {
        if (Number.isNaN(c42)) {
          return true;
        }
        let [min6, max23] = meta.range;
        return (min6 === void 0 || c42 >= min6 - epsilon2) && (max23 === void 0 || c42 <= max23 + epsilon2);
      }
      return true;
    });
  }
  get isUnbounded() {
    return Object.values(this.coords).every((coord) => !("range" in coord));
  }
  get cssId() {
    return this.formats?.color?.id || this.id;
  }
  get isPolar() {
    for (let id in this.coords) {
      if (this.coords[id].type === "angle") {
        return true;
      }
    }
    return false;
  }
  getFormat(format) {
    if (typeof format === "object") {
      format = processFormat(format, this);
      return format;
    }
    let ret;
    if (format === "default") {
      ret = Object.values(this.formats)[0];
    } else {
      ret = this.formats[format];
    }
    if (ret) {
      ret = processFormat(ret, this);
      return ret;
    }
    return null;
  }
  /**
   * Check if this color space is the same as another color space reference.
   * Allows proxying color space objects and comparing color spaces with ids.
   * @param {string | ColorSpace} space ColorSpace object or id to compare to
   * @returns {boolean}
   */
  equals(space) {
    if (!space) {
      return false;
    }
    return this === space || this.id === space || this.id === space.id;
  }
  to(space, coords) {
    if (arguments.length === 1) {
      const color = getColor(space);
      [space, coords] = [color.space, color.coords];
    }
    space = _ColorSpace.get(space);
    if (this.equals(space)) {
      return coords;
    }
    coords = coords.map((c42) => Number.isNaN(c42) ? 0 : c42);
    let myPath = this.path;
    let otherPath = space.path;
    let connectionSpace, connectionSpaceIndex;
    for (let i4 = 0; i4 < myPath.length; i4++) {
      if (myPath[i4].equals(otherPath[i4])) {
        connectionSpace = myPath[i4];
        connectionSpaceIndex = i4;
      } else {
        break;
      }
    }
    if (!connectionSpace) {
      throw new Error(`Cannot convert between color spaces ${this} and ${space}: no connection space was found`);
    }
    for (let i4 = myPath.length - 1; i4 > connectionSpaceIndex; i4--) {
      coords = myPath[i4].toBase(coords);
    }
    for (let i4 = connectionSpaceIndex + 1; i4 < otherPath.length; i4++) {
      coords = otherPath[i4].fromBase(coords);
    }
    return coords;
  }
  from(space, coords) {
    if (arguments.length === 1) {
      const color = getColor(space);
      [space, coords] = [color.space, color.coords];
    }
    space = _ColorSpace.get(space);
    return space.to(this, coords);
  }
  toString() {
    return `${this.name} (${this.id})`;
  }
  getMinCoords() {
    let ret = [];
    for (let id in this.coords) {
      let meta = this.coords[id];
      let range2 = meta.range || meta.refRange;
      ret.push(range2?.min ?? 0);
    }
    return ret;
  }
  static registry = {};
  // Returns array of unique color spaces
  static get all() {
    return [...new Set(Object.values(_ColorSpace.registry))];
  }
  static register(id, space) {
    if (arguments.length === 1) {
      space = arguments[0];
      id = space.id;
    }
    space = this.get(space);
    if (this.registry[id] && this.registry[id] !== space) {
      throw new Error(`Duplicate color space registration: '${id}'`);
    }
    this.registry[id] = space;
    if (arguments.length === 1 && space.aliases) {
      for (let alias of space.aliases) {
        this.register(alias, space);
      }
    }
    return space;
  }
  /**
   * Lookup ColorSpace object by name
   * @param {ColorSpace | string} name
   */
  static get(space, ...alternatives) {
    if (!space || space instanceof _ColorSpace) {
      return space;
    }
    let argType = type(space);
    if (argType === "string") {
      let ret = _ColorSpace.registry[space.toLowerCase()];
      if (!ret) {
        throw new TypeError(`No color space found with id = "${space}"`);
      }
      return ret;
    }
    if (alternatives.length) {
      return _ColorSpace.get(...alternatives);
    }
    throw new TypeError(`${space} is not a valid color space`);
  }
  /**
   * Get metadata about a coordinate of a color space
   *
   * @static
   * @param {Array | string} ref
   * @param {ColorSpace | string} [workingSpace]
   * @return {Object}
   */
  static resolveCoord(ref, workingSpace) {
    let coordType = type(ref);
    let space, coord;
    if (coordType === "string") {
      if (ref.includes(".")) {
        [space, coord] = ref.split(".");
      } else {
        [space, coord] = [, ref];
      }
    } else if (Array.isArray(ref)) {
      [space, coord] = ref;
    } else {
      space = ref.space;
      coord = ref.coordId;
    }
    space = _ColorSpace.get(space);
    if (!space) {
      space = workingSpace;
    }
    if (!space) {
      throw new TypeError(`Cannot resolve coordinate reference ${ref}: No color space specified and relative references are not allowed here`);
    }
    coordType = type(coord);
    if (coordType === "number" || coordType === "string" && coord >= 0) {
      let meta = Object.entries(space.coords)[coord];
      if (meta) {
        return { space, id: meta[0], index: coord, ...meta[1] };
      }
    }
    space = _ColorSpace.get(space);
    let normalizedCoord = coord.toLowerCase();
    let i4 = 0;
    for (let id in space.coords) {
      let meta = space.coords[id];
      if (id.toLowerCase() === normalizedCoord || meta.name?.toLowerCase() === normalizedCoord) {
        return { space, id, index: i4, ...meta };
      }
      i4++;
    }
    throw new TypeError(`No "${coord}" coordinate found in ${space.name}. Its coordinates are: ${Object.keys(space.coords).join(", ")}`);
  }
  static DEFAULT_FORMAT = {
    type: "functions",
    name: "color"
  };
};
function getPath(space) {
  let ret = [space];
  for (let s3 = space; s3 = s3.base; ) {
    ret.push(s3);
  }
  return ret;
}
function processFormat(format, { coords } = {}) {
  if (format.coords && !format.coordGrammar) {
    format.type ||= "function";
    format.name ||= "color";
    format.coordGrammar = parseCoordGrammar(format.coords);
    let coordFormats = Object.entries(coords).map(([id, coordMeta], i4) => {
      let outputType = format.coordGrammar[i4][0];
      let fromRange = coordMeta.range || coordMeta.refRange;
      let toRange = outputType.range, suffix = "";
      if (outputType == "<percentage>") {
        toRange = [0, 100];
        suffix = "%";
      } else if (outputType == "<angle>") {
        suffix = "deg";
      }
      return { fromRange, toRange, suffix };
    });
    format.serializeCoords = (coords2, precision) => {
      return coords2.map((c42, i4) => {
        let { fromRange, toRange, suffix } = coordFormats[i4];
        if (fromRange && toRange) {
          c42 = mapRange(fromRange, toRange, c42);
        }
        c42 = serializeNumber(c42, { precision, unit: suffix });
        return c42;
      });
    };
  }
  return format;
}
var xyz_d65 = new ColorSpace({
  id: "xyz-d65",
  name: "XYZ D65",
  coords: {
    x: { name: "X" },
    y: { name: "Y" },
    z: { name: "Z" }
  },
  white: "D65",
  formats: {
    color: {
      ids: ["xyz-d65", "xyz"]
    }
  },
  aliases: ["xyz"]
});
var RGBColorSpace = class extends ColorSpace {
  /**
   * Creates a new RGB ColorSpace.
   * If coords are not specified, they will use the default RGB coords.
   * Instead of `fromBase()` and `toBase()` functions,
   * you can specify to/from XYZ matrices and have `toBase()` and `fromBase()` automatically generated.
   * @param {*} options - Same options as {@link ColorSpace} plus:
   * @param {number[][]} options.toXYZ_M - Matrix to convert to XYZ
   * @param {number[][]} options.fromXYZ_M - Matrix to convert from XYZ
   */
  constructor(options) {
    if (!options.coords) {
      options.coords = {
        r: {
          range: [0, 1],
          name: "Red"
        },
        g: {
          range: [0, 1],
          name: "Green"
        },
        b: {
          range: [0, 1],
          name: "Blue"
        }
      };
    }
    if (!options.base) {
      options.base = xyz_d65;
    }
    if (options.toXYZ_M && options.fromXYZ_M) {
      options.toBase ??= (rgb) => {
        let xyz = multiplyMatrices(options.toXYZ_M, rgb);
        if (this.white !== this.base.white) {
          xyz = adapt$2(this.white, this.base.white, xyz);
        }
        return xyz;
      };
      options.fromBase ??= (xyz) => {
        xyz = adapt$2(this.base.white, this.white, xyz);
        return multiplyMatrices(options.fromXYZ_M, xyz);
      };
    }
    options.referred ??= "display";
    super(options);
  }
};
function getAll(color, space) {
  color = getColor(color);
  if (!space || color.space.equals(space)) {
    return color.coords.slice();
  }
  space = ColorSpace.get(space);
  return space.from(color);
}
function get2(color, prop) {
  color = getColor(color);
  let { space, index } = ColorSpace.resolveCoord(prop, color.space);
  let coords = getAll(color, space);
  return coords[index];
}
function setAll(color, space, coords) {
  color = getColor(color);
  space = ColorSpace.get(space);
  color.coords = space.to(color.space, coords);
  return color;
}
setAll.returns = "color";
function set2(color, prop, value2) {
  color = getColor(color);
  if (arguments.length === 2 && type(arguments[1]) === "object") {
    let object2 = arguments[1];
    for (let p22 in object2) {
      set2(color, p22, object2[p22]);
    }
  } else {
    if (typeof value2 === "function") {
      value2 = value2(get2(color, prop));
    }
    let { space, index } = ColorSpace.resolveCoord(prop, color.space);
    let coords = getAll(color, space);
    coords[index] = value2;
    setAll(color, space, coords);
  }
  return color;
}
set2.returns = "color";
var XYZ_D50 = new ColorSpace({
  id: "xyz-d50",
  name: "XYZ D50",
  white: "D50",
  base: xyz_d65,
  fromBase: (coords) => adapt$2(xyz_d65.white, "D50", coords),
  toBase: (coords) => adapt$2("D50", xyz_d65.white, coords)
});
var \u03B5$6 = 216 / 24389;
var \u03B53$1 = 24 / 116;
var \u03BA$4 = 24389 / 27;
var white$4 = WHITES.D50;
var lab = new ColorSpace({
  id: "lab",
  name: "Lab",
  coords: {
    l: {
      refRange: [0, 100],
      name: "Lightness"
    },
    a: {
      refRange: [-125, 125]
    },
    b: {
      refRange: [-125, 125]
    }
  },
  // Assuming XYZ is relative to D50, convert to CIE Lab
  // from CIE standard, which now defines these as a rational fraction
  white: white$4,
  base: XYZ_D50,
  // Convert D50-adapted XYX to Lab
  //  CIE 15.3:2004 section 8.2.1.1
  fromBase(XYZ) {
    let xyz = XYZ.map((value2, i4) => value2 / white$4[i4]);
    let f5 = xyz.map((value2) => value2 > \u03B5$6 ? Math.cbrt(value2) : (\u03BA$4 * value2 + 16) / 116);
    return [
      116 * f5[1] - 16,
      // L
      500 * (f5[0] - f5[1]),
      // a
      200 * (f5[1] - f5[2])
      // b
    ];
  },
  // Convert Lab to D50-adapted XYZ
  // Same result as CIE 15.3:2004 Appendix D although the derivation is different
  // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
  toBase(Lab) {
    let f5 = [];
    f5[1] = (Lab[0] + 16) / 116;
    f5[0] = Lab[1] / 500 + f5[1];
    f5[2] = f5[1] - Lab[2] / 200;
    let xyz = [
      f5[0] > \u03B53$1 ? Math.pow(f5[0], 3) : (116 * f5[0] - 16) / \u03BA$4,
      Lab[0] > 8 ? Math.pow((Lab[0] + 16) / 116, 3) : Lab[0] / \u03BA$4,
      f5[2] > \u03B53$1 ? Math.pow(f5[2], 3) : (116 * f5[2] - 16) / \u03BA$4
    ];
    return xyz.map((value2, i4) => value2 * white$4[i4]);
  },
  formats: {
    "lab": {
      coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
    }
  }
});
function constrain(angle) {
  return (angle % 360 + 360) % 360;
}
function adjust(arc2, angles2) {
  if (arc2 === "raw") {
    return angles2;
  }
  let [a1, a22] = angles2.map(constrain);
  let angleDiff = a22 - a1;
  if (arc2 === "increasing") {
    if (angleDiff < 0) {
      a22 += 360;
    }
  } else if (arc2 === "decreasing") {
    if (angleDiff > 0) {
      a1 += 360;
    }
  } else if (arc2 === "longer") {
    if (-180 < angleDiff && angleDiff < 180) {
      if (angleDiff > 0) {
        a1 += 360;
      } else {
        a22 += 360;
      }
    }
  } else if (arc2 === "shorter") {
    if (angleDiff > 180) {
      a1 += 360;
    } else if (angleDiff < -180) {
      a22 += 360;
    }
  }
  return [a1, a22];
}
var lch = new ColorSpace({
  id: "lch",
  name: "LCH",
  coords: {
    l: {
      refRange: [0, 100],
      name: "Lightness"
    },
    c: {
      refRange: [0, 150],
      name: "Chroma"
    },
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    }
  },
  base: lab,
  fromBase(Lab) {
    let [L2, a22, b22] = Lab;
    let hue;
    const \u03B52 = 0.02;
    if (Math.abs(a22) < \u03B52 && Math.abs(b22) < \u03B52) {
      hue = NaN;
    } else {
      hue = Math.atan2(b22, a22) * 180 / Math.PI;
    }
    return [
      L2,
      // L is still L
      Math.sqrt(a22 ** 2 + b22 ** 2),
      // Chroma
      constrain(hue)
      // Hue, in degrees [0 to 360)
    ];
  },
  toBase(LCH) {
    let [Lightness, Chroma, Hue] = LCH;
    if (Chroma < 0) {
      Chroma = 0;
    }
    if (isNaN(Hue)) {
      Hue = 0;
    }
    return [
      Lightness,
      // L is still L
      Chroma * Math.cos(Hue * Math.PI / 180),
      // a
      Chroma * Math.sin(Hue * Math.PI / 180)
      // b
    ];
  },
  formats: {
    "lch": {
      coords: ["<number> | <percentage>", "<number> | <percentage>", "<number> | <angle>"]
    }
  }
});
var Gfactor = 25 ** 7;
var \u03C0$1 = Math.PI;
var r2d = 180 / \u03C0$1;
var d2r$1 = \u03C0$1 / 180;
function pow7(x3) {
  const x22 = x3 * x3;
  const x7 = x22 * x22 * x22 * x3;
  return x7;
}
function deltaE2000(color, sample, { kL = 1, kC = 1, kH = 1 } = {}) {
  [color, sample] = getColor([color, sample]);
  let [L1, a1, b1] = lab.from(color);
  let C1 = lch.from(lab, [L1, a1, b1])[1];
  let [L2, a22, b22] = lab.from(sample);
  let C2 = lch.from(lab, [L2, a22, b22])[1];
  if (C1 < 0) {
    C1 = 0;
  }
  if (C2 < 0) {
    C2 = 0;
  }
  let Cbar = (C1 + C2) / 2;
  let C7 = pow7(Cbar);
  let G3 = 0.5 * (1 - Math.sqrt(C7 / (C7 + Gfactor)));
  let adash1 = (1 + G3) * a1;
  let adash2 = (1 + G3) * a22;
  let Cdash1 = Math.sqrt(adash1 ** 2 + b1 ** 2);
  let Cdash2 = Math.sqrt(adash2 ** 2 + b22 ** 2);
  let h1 = adash1 === 0 && b1 === 0 ? 0 : Math.atan2(b1, adash1);
  let h22 = adash2 === 0 && b22 === 0 ? 0 : Math.atan2(b22, adash2);
  if (h1 < 0) {
    h1 += 2 * \u03C0$1;
  }
  if (h22 < 0) {
    h22 += 2 * \u03C0$1;
  }
  h1 *= r2d;
  h22 *= r2d;
  let \u0394L = L2 - L1;
  let \u0394C = Cdash2 - Cdash1;
  let hdiff = h22 - h1;
  let hsum = h1 + h22;
  let habs = Math.abs(hdiff);
  let \u0394h;
  if (Cdash1 * Cdash2 === 0) {
    \u0394h = 0;
  } else if (habs <= 180) {
    \u0394h = hdiff;
  } else if (hdiff > 180) {
    \u0394h = hdiff - 360;
  } else if (hdiff < -180) {
    \u0394h = hdiff + 360;
  } else {
    defaults.warn("the unthinkable has happened");
  }
  let \u0394H = 2 * Math.sqrt(Cdash2 * Cdash1) * Math.sin(\u0394h * d2r$1 / 2);
  let Ldash = (L1 + L2) / 2;
  let Cdash = (Cdash1 + Cdash2) / 2;
  let Cdash7 = pow7(Cdash);
  let hdash;
  if (Cdash1 * Cdash2 === 0) {
    hdash = hsum;
  } else if (habs <= 180) {
    hdash = hsum / 2;
  } else if (hsum < 360) {
    hdash = (hsum + 360) / 2;
  } else {
    hdash = (hsum - 360) / 2;
  }
  let lsq = (Ldash - 50) ** 2;
  let SL = 1 + 0.015 * lsq / Math.sqrt(20 + lsq);
  let SC = 1 + 0.045 * Cdash;
  let T3 = 1;
  T3 -= 0.17 * Math.cos((hdash - 30) * d2r$1);
  T3 += 0.24 * Math.cos(2 * hdash * d2r$1);
  T3 += 0.32 * Math.cos((3 * hdash + 6) * d2r$1);
  T3 -= 0.2 * Math.cos((4 * hdash - 63) * d2r$1);
  let SH = 1 + 0.015 * Cdash * T3;
  let \u0394\u03B8 = 30 * Math.exp(-1 * ((hdash - 275) / 25) ** 2);
  let RC = 2 * Math.sqrt(Cdash7 / (Cdash7 + Gfactor));
  let RT = -1 * Math.sin(2 * \u0394\u03B8 * d2r$1) * RC;
  let dE = (\u0394L / (kL * SL)) ** 2;
  dE += (\u0394C / (kC * SC)) ** 2;
  dE += (\u0394H / (kH * SH)) ** 2;
  dE += RT * (\u0394C / (kC * SC)) * (\u0394H / (kH * SH));
  return Math.sqrt(dE);
}
var XYZtoLMS_M$1 = [
  [0.819022437996703, 0.3619062600528904, -0.1288737815209879],
  [0.0329836539323885, 0.9292868615863434, 0.0361446663506424],
  [0.0481771893596242, 0.2642395317527308, 0.6335478284694309]
];
var LMStoXYZ_M$1 = [
  [1.2268798758459243, -0.5578149944602171, 0.2813910456659647],
  [-0.0405757452148008, 1.112286803280317, -0.0717110580655164],
  [-0.0763729366746601, -0.4214933324022432, 1.5869240198367816]
];
var LMStoLab_M = [
  [0.210454268309314, 0.7936177747023054, -0.0040720430116193],
  [1.9779985324311684, -2.42859224204858, 0.450593709617411],
  [0.0259040424655478, 0.7827717124575296, -0.8086757549230774]
];
var LabtoLMS_M = [
  [1, 0.3963377773761749, 0.2158037573099136],
  [1, -0.1055613458156586, -0.0638541728258133],
  [1, -0.0894841775298119, -1.2914855480194092]
];
var OKLab = new ColorSpace({
  id: "oklab",
  name: "Oklab",
  coords: {
    l: {
      refRange: [0, 1],
      name: "Lightness"
    },
    a: {
      refRange: [-0.4, 0.4]
    },
    b: {
      refRange: [-0.4, 0.4]
    }
  },
  // Note that XYZ is relative to D65
  white: "D65",
  base: xyz_d65,
  fromBase(XYZ) {
    let LMS = multiplyMatrices(XYZtoLMS_M$1, XYZ);
    let LMSg = LMS.map((val) => Math.cbrt(val));
    return multiplyMatrices(LMStoLab_M, LMSg);
  },
  toBase(OKLab2) {
    let LMSg = multiplyMatrices(LabtoLMS_M, OKLab2);
    let LMS = LMSg.map((val) => val ** 3);
    return multiplyMatrices(LMStoXYZ_M$1, LMS);
  },
  formats: {
    "oklab": {
      coords: ["<percentage> | <number>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
    }
  }
});
function deltaEOK(color, sample) {
  [color, sample] = getColor([color, sample]);
  let [L1, a1, b1] = OKLab.from(color);
  let [L2, a22, b22] = OKLab.from(sample);
  let \u0394L = L1 - L2;
  let \u0394a = a1 - a22;
  let \u0394b = b1 - b22;
  return Math.sqrt(\u0394L ** 2 + \u0394a ** 2 + \u0394b ** 2);
}
var \u03B5$5 = 75e-6;
function inGamut(color, space, { epsilon: epsilon2 = \u03B5$5 } = {}) {
  color = getColor(color);
  if (!space) {
    space = color.space;
  }
  space = ColorSpace.get(space);
  let coords = color.coords;
  if (space !== color.space) {
    coords = space.from(color);
  }
  return space.inGamut(coords, { epsilon: epsilon2 });
}
function clone(color) {
  return {
    space: color.space,
    coords: color.coords.slice(),
    alpha: color.alpha
  };
}
function distance(color1, color2, space = "lab") {
  space = ColorSpace.get(space);
  let coords1 = space.from(color1);
  let coords2 = space.from(color2);
  return Math.sqrt(coords1.reduce((acc, c12, i4) => {
    let c222 = coords2[i4];
    if (isNaN(c12) || isNaN(c222)) {
      return acc;
    }
    return acc + (c222 - c12) ** 2;
  }, 0));
}
function deltaE76(color, sample) {
  return distance(color, sample, "lab");
}
var \u03C0 = Math.PI;
var d2r = \u03C0 / 180;
function deltaECMC(color, sample, { l: l3 = 2, c: c42 = 1 } = {}) {
  [color, sample] = getColor([color, sample]);
  let [L1, a1, b1] = lab.from(color);
  let [, C1, H1] = lch.from(lab, [L1, a1, b1]);
  let [L2, a22, b22] = lab.from(sample);
  let C2 = lch.from(lab, [L2, a22, b22])[1];
  if (C1 < 0) {
    C1 = 0;
  }
  if (C2 < 0) {
    C2 = 0;
  }
  let \u0394L = L1 - L2;
  let \u0394C = C1 - C2;
  let \u0394a = a1 - a22;
  let \u0394b = b1 - b22;
  let H2 = \u0394a ** 2 + \u0394b ** 2 - \u0394C ** 2;
  let SL = 0.511;
  if (L1 >= 16) {
    SL = 0.040975 * L1 / (1 + 0.01765 * L1);
  }
  let SC = 0.0638 * C1 / (1 + 0.0131 * C1) + 0.638;
  let T3;
  if (Number.isNaN(H1)) {
    H1 = 0;
  }
  if (H1 >= 164 && H1 <= 345) {
    T3 = 0.56 + Math.abs(0.2 * Math.cos((H1 + 168) * d2r));
  } else {
    T3 = 0.36 + Math.abs(0.4 * Math.cos((H1 + 35) * d2r));
  }
  let C4 = Math.pow(C1, 4);
  let F3 = Math.sqrt(C4 / (C4 + 1900));
  let SH = SC * (F3 * T3 + 1 - F3);
  let dE = (\u0394L / (l3 * SL)) ** 2;
  dE += (\u0394C / (c42 * SC)) ** 2;
  dE += H2 / SH ** 2;
  return Math.sqrt(dE);
}
var Yw$1 = 203;
var XYZ_Abs_D65 = new ColorSpace({
  // Absolute CIE XYZ, with a D65 whitepoint,
  // as used in most HDR colorspaces as a starting point.
  // SDR spaces are converted per BT.2048
  // so that diffuse, media white is 203 cd/m
  id: "xyz-abs-d65",
  cssId: "--xyz-abs-d65",
  name: "Absolute XYZ D65",
  coords: {
    x: {
      refRange: [0, 9504.7],
      name: "Xa"
    },
    y: {
      refRange: [0, 1e4],
      name: "Ya"
    },
    z: {
      refRange: [0, 10888.3],
      name: "Za"
    }
  },
  base: xyz_d65,
  fromBase(XYZ) {
    return XYZ.map((v3) => Math.max(v3 * Yw$1, 0));
  },
  toBase(AbsXYZ) {
    return AbsXYZ.map((v3) => Math.max(v3 / Yw$1, 0));
  }
});
var b$1 = 1.15;
var g4 = 0.66;
var n$1 = 2610 / 2 ** 14;
var ninv$1 = 2 ** 14 / 2610;
var c1$2 = 3424 / 2 ** 12;
var c2$2 = 2413 / 2 ** 7;
var c3$2 = 2392 / 2 ** 7;
var p3 = 1.7 * 2523 / 2 ** 5;
var pinv = 2 ** 5 / (1.7 * 2523);
var d3 = -0.56;
var d0 = 16295499532821565e-27;
var XYZtoCone_M = [
  [0.41478972, 0.579999, 0.014648],
  [-0.20151, 1.120649, 0.0531008],
  [-0.0166008, 0.2648, 0.6684799]
];
var ConetoXYZ_M = [
  [1.9242264357876067, -1.0047923125953657, 0.037651404030618],
  [0.35031676209499907, 0.7264811939316552, -0.06538442294808501],
  [-0.09098281098284752, -0.3127282905230739, 1.5227665613052603]
];
var ConetoIab_M = [
  [0.5, 0.5, 0],
  [3.524, -4.066708, 0.542708],
  [0.199076, 1.096799, -1.295875]
];
var IabtoCone_M = [
  [1, 0.1386050432715393, 0.05804731615611886],
  [0.9999999999999999, -0.1386050432715393, -0.05804731615611886],
  [0.9999999999999998, -0.09601924202631895, -0.8118918960560388]
];
var Jzazbz = new ColorSpace({
  id: "jzazbz",
  name: "Jzazbz",
  coords: {
    jz: {
      refRange: [0, 1],
      name: "Jz"
    },
    az: {
      refRange: [-0.5, 0.5]
    },
    bz: {
      refRange: [-0.5, 0.5]
    }
  },
  base: XYZ_Abs_D65,
  fromBase(XYZ) {
    let [Xa2, Ya2, Za2] = XYZ;
    let Xm = b$1 * Xa2 - (b$1 - 1) * Za2;
    let Ym = g4 * Ya2 - (g4 - 1) * Xa2;
    let LMS = multiplyMatrices(XYZtoCone_M, [Xm, Ym, Za2]);
    let PQLMS = LMS.map(function(val) {
      let num = c1$2 + c2$2 * (val / 1e4) ** n$1;
      let denom = 1 + c3$2 * (val / 1e4) ** n$1;
      return (num / denom) ** p3;
    });
    let [Iz, az, bz] = multiplyMatrices(ConetoIab_M, PQLMS);
    let Jz = (1 + d3) * Iz / (1 + d3 * Iz) - d0;
    return [Jz, az, bz];
  },
  toBase(Jzazbz2) {
    let [Jz, az, bz] = Jzazbz2;
    let Iz = (Jz + d0) / (1 + d3 - d3 * (Jz + d0));
    let PQLMS = multiplyMatrices(IabtoCone_M, [Iz, az, bz]);
    let LMS = PQLMS.map(function(val) {
      let num = c1$2 - val ** pinv;
      let denom = c3$2 * val ** pinv - c2$2;
      let x3 = 1e4 * (num / denom) ** ninv$1;
      return x3;
    });
    let [Xm, Ym, Za2] = multiplyMatrices(ConetoXYZ_M, LMS);
    let Xa2 = (Xm + (b$1 - 1) * Za2) / b$1;
    let Ya2 = (Ym + (g4 - 1) * Xa2) / g4;
    return [Xa2, Ya2, Za2];
  },
  formats: {
    // https://drafts.csswg.org/css-color-hdr/#Jzazbz
    "color": {
      coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
    }
  }
});
var jzczhz = new ColorSpace({
  id: "jzczhz",
  name: "JzCzHz",
  coords: {
    jz: {
      refRange: [0, 1],
      name: "Jz"
    },
    cz: {
      refRange: [0, 1],
      name: "Chroma"
    },
    hz: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    }
  },
  base: Jzazbz,
  fromBase(jzazbz) {
    let [Jz, az, bz] = jzazbz;
    let hue;
    const \u03B52 = 2e-4;
    if (Math.abs(az) < \u03B52 && Math.abs(bz) < \u03B52) {
      hue = NaN;
    } else {
      hue = Math.atan2(bz, az) * 180 / Math.PI;
    }
    return [
      Jz,
      // Jz is still Jz
      Math.sqrt(az ** 2 + bz ** 2),
      // Chroma
      constrain(hue)
      // Hue, in degrees [0 to 360)
    ];
  },
  toBase(jzczhz2) {
    return [
      jzczhz2[0],
      // Jz is still Jz
      jzczhz2[1] * Math.cos(jzczhz2[2] * Math.PI / 180),
      // az
      jzczhz2[1] * Math.sin(jzczhz2[2] * Math.PI / 180)
      // bz
    ];
  }
});
function deltaEJz(color, sample) {
  [color, sample] = getColor([color, sample]);
  let [Jz1, Cz1, Hz1] = jzczhz.from(color);
  let [Jz2, Cz2, Hz2] = jzczhz.from(sample);
  let \u0394J = Jz1 - Jz2;
  let \u0394C = Cz1 - Cz2;
  if (Number.isNaN(Hz1) && Number.isNaN(Hz2)) {
    Hz1 = 0;
    Hz2 = 0;
  } else if (Number.isNaN(Hz1)) {
    Hz1 = Hz2;
  } else if (Number.isNaN(Hz2)) {
    Hz2 = Hz1;
  }
  let \u0394h = Hz1 - Hz2;
  let \u0394H = 2 * Math.sqrt(Cz1 * Cz2) * Math.sin(\u0394h / 2 * (Math.PI / 180));
  return Math.sqrt(\u0394J ** 2 + \u0394C ** 2 + \u0394H ** 2);
}
var c1$1 = 3424 / 4096;
var c2$1 = 2413 / 128;
var c3$1 = 2392 / 128;
var m1$1 = 2610 / 16384;
var m22 = 2523 / 32;
var im1 = 16384 / 2610;
var im2 = 32 / 2523;
var XYZtoLMS_M = [
  [0.3592832590121217, 0.6976051147779502, -0.035891593232029],
  [-0.1920808463704993, 1.100476797037432, 0.0753748658519118],
  [0.0070797844607479, 0.0748396662186362, 0.8433265453898765]
];
var LMStoIPT_M = [
  [2048 / 4096, 2048 / 4096, 0],
  [6610 / 4096, -13613 / 4096, 7003 / 4096],
  [17933 / 4096, -17390 / 4096, -543 / 4096]
];
var IPTtoLMS_M = [
  [0.9999999999999998, 0.0086090370379328, 0.111029625003026],
  [0.9999999999999998, -0.0086090370379328, -0.1110296250030259],
  [0.9999999999999998, 0.5600313357106791, -0.3206271749873188]
];
var LMStoXYZ_M = [
  [2.0701522183894223, -1.3263473389671563, 0.2066510476294053],
  [0.3647385209748072, 0.6805660249472273, -0.0453045459220347],
  [-0.0497472075358123, -0.0492609666966131, 1.1880659249923042]
];
var ictcp = new ColorSpace({
  id: "ictcp",
  name: "ICTCP",
  // From BT.2100-2 page 7:
  // During production, signal values are expected to exceed the
  // range E = [0.0 : 1.0]. This provides processing headroom and avoids
  // signal degradation during cascaded processing. Such values of E,
  // below 0.0 or exceeding 1.0, should not be clipped during production
  // and exchange.
  // Values below 0.0 should not be clipped in reference displays (even
  // though they represent negative light) to allow the black level of
  // the signal (LB) to be properly set using test signals known as PLUGE
  coords: {
    i: {
      refRange: [0, 1],
      // Constant luminance,
      name: "I"
    },
    ct: {
      refRange: [-0.5, 0.5],
      // Full BT.2020 gamut in range [-0.5, 0.5]
      name: "CT"
    },
    cp: {
      refRange: [-0.5, 0.5],
      name: "CP"
    }
  },
  base: XYZ_Abs_D65,
  fromBase(XYZ) {
    let LMS = multiplyMatrices(XYZtoLMS_M, XYZ);
    return LMStoICtCp(LMS);
  },
  toBase(ICtCp) {
    let LMS = ICtCptoLMS(ICtCp);
    return multiplyMatrices(LMStoXYZ_M, LMS);
  }
});
function LMStoICtCp(LMS) {
  let PQLMS = LMS.map(function(val) {
    let num = c1$1 + c2$1 * (val / 1e4) ** m1$1;
    let denom = 1 + c3$1 * (val / 1e4) ** m1$1;
    return (num / denom) ** m22;
  });
  return multiplyMatrices(LMStoIPT_M, PQLMS);
}
function ICtCptoLMS(ICtCp) {
  let PQLMS = multiplyMatrices(IPTtoLMS_M, ICtCp);
  let LMS = PQLMS.map(function(val) {
    let num = Math.max(val ** im2 - c1$1, 0);
    let denom = c2$1 - c3$1 * val ** im2;
    return 1e4 * (num / denom) ** im1;
  });
  return LMS;
}
function deltaEITP(color, sample) {
  [color, sample] = getColor([color, sample]);
  let [I1, T1, P1] = ictcp.from(color);
  let [I22, T22, P22] = ictcp.from(sample);
  return 720 * Math.sqrt((I1 - I22) ** 2 + 0.25 * (T1 - T22) ** 2 + (P1 - P22) ** 2);
}
var white$3 = WHITES.D65;
var adaptedCoef = 0.42;
var adaptedCoefInv = 1 / adaptedCoef;
var tau = 2 * Math.PI;
var cat16 = [
  [0.401288, 0.650173, -0.051461],
  [-0.250268, 1.204414, 0.045854],
  [-2079e-6, 0.048952, 0.953127]
];
var cat16Inv = [
  [1.8620678550872327, -1.0112546305316843, 0.14918677544445175],
  [0.38752654323613717, 0.6214474419314753, -0.008973985167612518],
  [-0.015841498849333856, -0.03412293802851557, 1.0499644368778496]
];
var m1 = [
  [460, 451, 288],
  [460, -891, -261],
  [460, -220, -6300]
];
var surroundMap = {
  dark: [0.8, 0.525, 0.8],
  dim: [0.9, 0.59, 0.9],
  average: [1, 0.69, 1]
};
var hueQuadMap = {
  // Red, Yellow, Green, Blue, Red
  h: [20.14, 90, 164.25, 237.53, 380.14],
  e: [0.8, 0.7, 1, 1.2, 0.8],
  H: [0, 100, 200, 300, 400]
};
var rad2deg = 180 / Math.PI;
var deg2rad$1 = Math.PI / 180;
function adapt$1(coords, fl) {
  const temp = coords.map((c42) => {
    const x3 = spow(fl * Math.abs(c42) * 0.01, adaptedCoef);
    return 400 * copySign(x3, c42) / (x3 + 27.13);
  });
  return temp;
}
function unadapt(adapted, fl) {
  const constant = 100 / fl * 27.13 ** adaptedCoefInv;
  return adapted.map((c42) => {
    const cabs = Math.abs(c42);
    return copySign(constant * spow(cabs / (400 - cabs), adaptedCoefInv), c42);
  });
}
function hueQuadrature(h5) {
  let hp = constrain(h5);
  if (hp <= hueQuadMap.h[0]) {
    hp += 360;
  }
  const i4 = bisectLeft(hueQuadMap.h, hp) - 1;
  const [hi2, hii] = hueQuadMap.h.slice(i4, i4 + 2);
  const [ei2, eii] = hueQuadMap.e.slice(i4, i4 + 2);
  const Hi2 = hueQuadMap.H[i4];
  const t6 = (hp - hi2) / ei2;
  return Hi2 + 100 * t6 / (t6 + (hii - hp) / eii);
}
function invHueQuadrature(H2) {
  let Hp = (H2 % 400 + 400) % 400;
  const i4 = Math.floor(0.01 * Hp);
  Hp = Hp % 100;
  const [hi2, hii] = hueQuadMap.h.slice(i4, i4 + 2);
  const [ei2, eii] = hueQuadMap.e.slice(i4, i4 + 2);
  return constrain(
    (Hp * (eii * hi2 - ei2 * hii) - 100 * hi2 * eii) / (Hp * (eii - ei2) - 100 * eii)
  );
}
function environment(refWhite, adaptingLuminance, backgroundLuminance, surround, discounting) {
  const env = {};
  env.discounting = discounting;
  env.refWhite = refWhite;
  env.surround = surround;
  const xyzW = refWhite.map((c42) => {
    return c42 * 100;
  });
  env.la = adaptingLuminance;
  env.yb = backgroundLuminance;
  const yw = xyzW[1];
  const rgbW = multiplyMatrices(cat16, xyzW);
  surround = surroundMap[env.surround];
  const f5 = surround[0];
  env.c = surround[1];
  env.nc = surround[2];
  const k3 = 1 / (5 * env.la + 1);
  const k4 = k3 ** 4;
  env.fl = k4 * env.la + 0.1 * (1 - k4) * (1 - k4) * Math.cbrt(5 * env.la);
  env.flRoot = env.fl ** 0.25;
  env.n = env.yb / yw;
  env.z = 1.48 + Math.sqrt(env.n);
  env.nbb = 0.725 * env.n ** -0.2;
  env.ncb = env.nbb;
  const d22 = discounting ? 1 : Math.max(
    Math.min(f5 * (1 - 1 / 3.6 * Math.exp((-env.la - 42) / 92)), 1),
    0
  );
  env.dRgb = rgbW.map((c42) => {
    return interpolate2(1, yw / c42, d22);
  });
  env.dRgbInv = env.dRgb.map((c42) => {
    return 1 / c42;
  });
  const rgbCW = rgbW.map((c42, i4) => {
    return c42 * env.dRgb[i4];
  });
  const rgbAW = adapt$1(rgbCW, env.fl);
  env.aW = env.nbb * (2 * rgbAW[0] + rgbAW[1] + 0.05 * rgbAW[2]);
  return env;
}
var viewingConditions$1 = environment(
  white$3,
  64 / Math.PI * 0.2,
  20,
  "average",
  false
);
function fromCam16(cam162, env) {
  if (!(cam162.J !== void 0 ^ cam162.Q !== void 0)) {
    throw new Error("Conversion requires one and only one: 'J' or 'Q'");
  }
  if (!(cam162.C !== void 0 ^ cam162.M !== void 0 ^ cam162.s !== void 0)) {
    throw new Error("Conversion requires one and only one: 'C', 'M' or 's'");
  }
  if (!(cam162.h !== void 0 ^ cam162.H !== void 0)) {
    throw new Error("Conversion requires one and only one: 'h' or 'H'");
  }
  if (cam162.J === 0 || cam162.Q === 0) {
    return [0, 0, 0];
  }
  let hRad = 0;
  if (cam162.h !== void 0) {
    hRad = constrain(cam162.h) * deg2rad$1;
  } else {
    hRad = invHueQuadrature(cam162.H) * deg2rad$1;
  }
  const cosh = Math.cos(hRad);
  const sinh = Math.sin(hRad);
  let Jroot = 0;
  if (cam162.J !== void 0) {
    Jroot = spow(cam162.J, 1 / 2) * 0.1;
  } else if (cam162.Q !== void 0) {
    Jroot = 0.25 * env.c * cam162.Q / ((env.aW + 4) * env.flRoot);
  }
  let alpha = 0;
  if (cam162.C !== void 0) {
    alpha = cam162.C / Jroot;
  } else if (cam162.M !== void 0) {
    alpha = cam162.M / env.flRoot / Jroot;
  } else if (cam162.s !== void 0) {
    alpha = 4e-4 * cam162.s ** 2 * (env.aW + 4) / env.c;
  }
  const t6 = spow(
    alpha * Math.pow(1.64 - Math.pow(0.29, env.n), -0.73),
    10 / 9
  );
  const et4 = 0.25 * (Math.cos(hRad + 2) + 3.8);
  const A2 = env.aW * spow(Jroot, 2 / env.c / env.z);
  const p1 = 5e4 / 13 * env.nc * env.ncb * et4;
  const p22 = A2 / env.nbb;
  const r5 = 23 * (p22 + 0.305) * zdiv(t6, 23 * p1 + t6 * (11 * cosh + 108 * sinh));
  const a22 = r5 * cosh;
  const b22 = r5 * sinh;
  const rgb_c = unadapt(
    multiplyMatrices(m1, [p22, a22, b22]).map((c42) => {
      return c42 * 1 / 1403;
    }),
    env.fl
  );
  return multiplyMatrices(
    cat16Inv,
    rgb_c.map((c42, i4) => {
      return c42 * env.dRgbInv[i4];
    })
  ).map((c42) => {
    return c42 / 100;
  });
}
function toCam16(xyzd65, env) {
  const xyz100 = xyzd65.map((c42) => {
    return c42 * 100;
  });
  const rgbA = adapt$1(
    multiplyMatrices(cat16, xyz100).map((c42, i4) => {
      return c42 * env.dRgb[i4];
    }),
    env.fl
  );
  const a22 = rgbA[0] + (-12 * rgbA[1] + rgbA[2]) / 11;
  const b22 = (rgbA[0] + rgbA[1] - 2 * rgbA[2]) / 9;
  const hRad = (Math.atan2(b22, a22) % tau + tau) % tau;
  const et4 = 0.25 * (Math.cos(hRad + 2) + 3.8);
  const t6 = 5e4 / 13 * env.nc * env.ncb * zdiv(
    et4 * Math.sqrt(a22 ** 2 + b22 ** 2),
    rgbA[0] + rgbA[1] + 1.05 * rgbA[2] + 0.305
  );
  const alpha = spow(t6, 0.9) * Math.pow(1.64 - Math.pow(0.29, env.n), 0.73);
  const A2 = env.nbb * (2 * rgbA[0] + rgbA[1] + 0.05 * rgbA[2]);
  const Jroot = spow(A2 / env.aW, 0.5 * env.c * env.z);
  const J2 = 100 * spow(Jroot, 2);
  const Q3 = 4 / env.c * Jroot * (env.aW + 4) * env.flRoot;
  const C2 = alpha * Jroot;
  const M3 = C2 * env.flRoot;
  const h5 = constrain(hRad * rad2deg);
  const H2 = hueQuadrature(h5);
  const s3 = 50 * spow(env.c * alpha / (env.aW + 4), 1 / 2);
  return { J: J2, C: C2, h: h5, s: s3, Q: Q3, M: M3, H: H2 };
}
var cam16 = new ColorSpace({
  id: "cam16-jmh",
  cssId: "--cam16-jmh",
  name: "CAM16-JMh",
  coords: {
    j: {
      refRange: [0, 100],
      name: "J"
    },
    m: {
      refRange: [0, 105],
      name: "Colorfulness"
    },
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    }
  },
  base: xyz_d65,
  fromBase(xyz) {
    const cam162 = toCam16(xyz, viewingConditions$1);
    return [cam162.J, cam162.M, cam162.h];
  },
  toBase(cam162) {
    return fromCam16(
      { J: cam162[0], M: cam162[1], h: cam162[2] },
      viewingConditions$1
    );
  }
});
var white$2 = WHITES.D65;
var \u03B5$4 = 216 / 24389;
var \u03BA$3 = 24389 / 27;
function toLstar(y3) {
  const fy = y3 > \u03B5$4 ? Math.cbrt(y3) : (\u03BA$3 * y3 + 16) / 116;
  return 116 * fy - 16;
}
function fromLstar(lstar) {
  return lstar > 8 ? Math.pow((lstar + 16) / 116, 3) : lstar / \u03BA$3;
}
function fromHct(coords, env) {
  let [h5, c42, t6] = coords;
  let xyz = [];
  let j3 = 0;
  if (t6 === 0) {
    return [0, 0, 0];
  }
  let y3 = fromLstar(t6);
  if (t6 > 0) {
    j3 = 0.00379058511492914 * t6 ** 2 + 0.608983189401032 * t6 + 0.9155088574762233;
  } else {
    j3 = 9514440756550361e-21 * t6 ** 2 + 0.08693057439788597 * t6 - 21.928975842194614;
  }
  const threshold = 2e-12;
  const max_attempts = 15;
  let attempt = 0;
  let last22 = Infinity;
  while (attempt <= max_attempts) {
    xyz = fromCam16({ J: j3, C: c42, h: h5 }, env);
    const delta = Math.abs(xyz[1] - y3);
    if (delta < last22) {
      if (delta <= threshold) {
        return xyz;
      }
      last22 = delta;
    }
    j3 = j3 - (xyz[1] - y3) * j3 / (2 * xyz[1]);
    attempt += 1;
  }
  return fromCam16({ J: j3, C: c42, h: h5 }, env);
}
function toHct(xyz, env) {
  const t6 = toLstar(xyz[1]);
  if (t6 === 0) {
    return [0, 0, 0];
  }
  const cam162 = toCam16(xyz, viewingConditions);
  return [constrain(cam162.h), cam162.C, t6];
}
var viewingConditions = environment(
  white$2,
  200 / Math.PI * fromLstar(50),
  fromLstar(50) * 100,
  "average",
  false
);
var hct = new ColorSpace({
  id: "hct",
  name: "HCT",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    c: {
      refRange: [0, 145],
      name: "Colorfulness"
    },
    t: {
      refRange: [0, 100],
      name: "Tone"
    }
  },
  base: xyz_d65,
  fromBase(xyz) {
    return toHct(xyz);
  },
  toBase(hct2) {
    return fromHct(hct2, viewingConditions);
  },
  formats: {
    color: {
      id: "--hct",
      coords: ["<number> | <angle>", "<percentage> | <number>", "<percentage> | <number>"]
    }
  }
});
var deg2rad = Math.PI / 180;
var ucsCoeff = [1, 7e-3, 0.0228];
function convertUcsAb(coords) {
  if (coords[1] < 0) {
    coords = hct.fromBase(hct.toBase(coords));
  }
  const M3 = Math.log(Math.max(1 + ucsCoeff[2] * coords[1] * viewingConditions.flRoot, 1)) / ucsCoeff[2];
  const hrad = coords[0] * deg2rad;
  const a22 = M3 * Math.cos(hrad);
  const b22 = M3 * Math.sin(hrad);
  return [coords[2], a22, b22];
}
function deltaEHCT(color, sample) {
  [color, sample] = getColor([color, sample]);
  let [t1, a1, b1] = convertUcsAb(hct.from(color));
  let [t22, a22, b22] = convertUcsAb(hct.from(sample));
  return Math.sqrt((t1 - t22) ** 2 + (a1 - a22) ** 2 + (b1 - b22) ** 2);
}
var deltaEMethods = {
  deltaE76,
  deltaECMC,
  deltaE2000,
  deltaEJz,
  deltaEITP,
  deltaEOK,
  deltaEHCT
};
function calcEpsilon(jnd) {
  const order = !jnd ? 0 : Math.floor(Math.log10(Math.abs(jnd)));
  return Math.max(parseFloat(`1e${order - 2}`), 1e-6);
}
var GMAPPRESET = {
  "hct": {
    method: "hct.c",
    jnd: 2,
    deltaEMethod: "hct",
    blackWhiteClamp: {}
  },
  "hct-tonal": {
    method: "hct.c",
    jnd: 0,
    deltaEMethod: "hct",
    blackWhiteClamp: { channel: "hct.t", min: 0, max: 100 }
  }
};
function toGamut(color, {
  method = defaults.gamut_mapping,
  space = void 0,
  deltaEMethod = "",
  jnd = 2,
  blackWhiteClamp = {}
} = {}) {
  color = getColor(color);
  if (isString(arguments[1])) {
    space = arguments[1];
  } else if (!space) {
    space = color.space;
  }
  space = ColorSpace.get(space);
  if (inGamut(color, space, { epsilon: 0 })) {
    return color;
  }
  let spaceColor;
  if (method === "css") {
    spaceColor = toGamutCSS(color, { space });
  } else {
    if (method !== "clip" && !inGamut(color, space)) {
      if (Object.prototype.hasOwnProperty.call(GMAPPRESET, method)) {
        ({ method, jnd, deltaEMethod, blackWhiteClamp } = GMAPPRESET[method]);
      }
      let de2 = deltaE2000;
      if (deltaEMethod !== "") {
        for (let m32 in deltaEMethods) {
          if ("deltae" + deltaEMethod.toLowerCase() === m32.toLowerCase()) {
            de2 = deltaEMethods[m32];
            break;
          }
        }
      }
      let clipped = toGamut(to3(color, space), { method: "clip", space });
      if (de2(color, clipped) > jnd) {
        if (Object.keys(blackWhiteClamp).length === 3) {
          let channelMeta = ColorSpace.resolveCoord(blackWhiteClamp.channel);
          let channel = get2(to3(color, channelMeta.space), channelMeta.id);
          if (isNone(channel)) {
            channel = 0;
          }
          if (channel >= blackWhiteClamp.max) {
            return to3({ space: "xyz-d65", coords: WHITES["D65"] }, color.space);
          } else if (channel <= blackWhiteClamp.min) {
            return to3({ space: "xyz-d65", coords: [0, 0, 0] }, color.space);
          }
        }
        let coordMeta = ColorSpace.resolveCoord(method);
        let mapSpace = coordMeta.space;
        let coordId = coordMeta.id;
        let mappedColor = to3(color, mapSpace);
        mappedColor.coords.forEach((c42, i4) => {
          if (isNone(c42)) {
            mappedColor.coords[i4] = 0;
          }
        });
        let bounds = coordMeta.range || coordMeta.refRange;
        let min6 = bounds[0];
        let \u03B52 = calcEpsilon(jnd);
        let low = min6;
        let high = get2(mappedColor, coordId);
        while (high - low > \u03B52) {
          let clipped2 = clone(mappedColor);
          clipped2 = toGamut(clipped2, { space, method: "clip" });
          let deltaE2 = de2(mappedColor, clipped2);
          if (deltaE2 - jnd < \u03B52) {
            low = get2(mappedColor, coordId);
          } else {
            high = get2(mappedColor, coordId);
          }
          set2(mappedColor, coordId, (low + high) / 2);
        }
        spaceColor = to3(mappedColor, space);
      } else {
        spaceColor = clipped;
      }
    } else {
      spaceColor = to3(color, space);
    }
    if (method === "clip" || !inGamut(spaceColor, space, { epsilon: 0 })) {
      let bounds = Object.values(space.coords).map((c42) => c42.range || []);
      spaceColor.coords = spaceColor.coords.map((c42, i4) => {
        let [min6, max23] = bounds[i4];
        if (min6 !== void 0) {
          c42 = Math.max(min6, c42);
        }
        if (max23 !== void 0) {
          c42 = Math.min(c42, max23);
        }
        return c42;
      });
    }
  }
  if (space !== color.space) {
    spaceColor = to3(spaceColor, color.space);
  }
  color.coords = spaceColor.coords;
  return color;
}
toGamut.returns = "color";
var COLORS = {
  WHITE: { space: OKLab, coords: [1, 0, 0] },
  BLACK: { space: OKLab, coords: [0, 0, 0] }
};
function toGamutCSS(origin, { space } = {}) {
  const JND = 0.02;
  const \u03B52 = 1e-4;
  origin = getColor(origin);
  if (!space) {
    space = origin.space;
  }
  space = ColorSpace.get(space);
  const oklchSpace = ColorSpace.get("oklch");
  if (space.isUnbounded) {
    return to3(origin, space);
  }
  const origin_OKLCH = to3(origin, oklchSpace);
  let L2 = origin_OKLCH.coords[0];
  if (L2 >= 1) {
    const white2 = to3(COLORS.WHITE, space);
    white2.alpha = origin.alpha;
    return to3(white2, space);
  }
  if (L2 <= 0) {
    const black = to3(COLORS.BLACK, space);
    black.alpha = origin.alpha;
    return to3(black, space);
  }
  if (inGamut(origin_OKLCH, space, { epsilon: 0 })) {
    return to3(origin_OKLCH, space);
  }
  function clip(_color) {
    const destColor = to3(_color, space);
    const spaceCoords = Object.values(space.coords);
    destColor.coords = destColor.coords.map((coord, index) => {
      if ("range" in spaceCoords[index]) {
        const [min23, max33] = spaceCoords[index].range;
        return clamp22(min23, coord, max33);
      }
      return coord;
    });
    return destColor;
  }
  let min6 = 0;
  let max23 = origin_OKLCH.coords[1];
  let min_inGamut = true;
  let current = clone(origin_OKLCH);
  let clipped = clip(current);
  let E3 = deltaEOK(clipped, current);
  if (E3 < JND) {
    return clipped;
  }
  while (max23 - min6 > \u03B52) {
    const chroma = (min6 + max23) / 2;
    current.coords[1] = chroma;
    if (min_inGamut && inGamut(current, space, { epsilon: 0 })) {
      min6 = chroma;
    } else {
      clipped = clip(current);
      E3 = deltaEOK(clipped, current);
      if (E3 < JND) {
        if (JND - E3 < \u03B52) {
          break;
        } else {
          min_inGamut = false;
          min6 = chroma;
        }
      } else {
        max23 = chroma;
      }
    }
  }
  return clipped;
}
function to3(color, space, { inGamut: inGamut2 } = {}) {
  color = getColor(color);
  space = ColorSpace.get(space);
  let coords = space.from(color);
  let ret = { space, coords, alpha: color.alpha };
  if (inGamut2) {
    ret = toGamut(ret, inGamut2 === true ? void 0 : inGamut2);
  }
  return ret;
}
to3.returns = "color";
function serialize(color, {
  precision = defaults.precision,
  format = "default",
  inGamut: inGamut$1 = true,
  ...customOptions
} = {}) {
  let ret;
  color = getColor(color);
  let formatId = format;
  format = color.space.getFormat(format) ?? color.space.getFormat("default") ?? ColorSpace.DEFAULT_FORMAT;
  let coords = color.coords.slice();
  inGamut$1 ||= format.toGamut;
  if (inGamut$1 && !inGamut(color)) {
    coords = toGamut(clone(color), inGamut$1 === true ? void 0 : inGamut$1).coords;
  }
  if (format.type === "custom") {
    customOptions.precision = precision;
    if (format.serialize) {
      ret = format.serialize(coords, color.alpha, customOptions);
    } else {
      throw new TypeError(`format ${formatId} can only be used to parse colors, not for serialization`);
    }
  } else {
    let name = format.name || "color";
    if (format.serializeCoords) {
      coords = format.serializeCoords(coords, precision);
    } else {
      if (precision !== null) {
        coords = coords.map((c42) => {
          return serializeNumber(c42, { precision });
        });
      }
    }
    let args = [...coords];
    if (name === "color") {
      let cssId = format.id || format.ids?.[0] || color.space.id;
      args.unshift(cssId);
    }
    let alpha = color.alpha;
    if (precision !== null) {
      alpha = serializeNumber(alpha, { precision });
    }
    let strAlpha = color.alpha >= 1 || format.noAlpha ? "" : `${format.commas ? "," : " /"} ${alpha}`;
    ret = `${name}(${args.join(format.commas ? ", " : " ")}${strAlpha})`;
  }
  return ret;
}
var toXYZ_M$5 = [
  [0.6369580483012914, 0.14461690358620832, 0.1688809751641721],
  [0.2627002120112671, 0.6779980715188708, 0.05930171646986196],
  [0, 0.028072693049087428, 1.060985057710791]
];
var fromXYZ_M$5 = [
  [1.716651187971268, -0.355670783776392, -0.25336628137366],
  [-0.666684351832489, 1.616481236634939, 0.0157685458139111],
  [0.017639857445311, -0.042770613257809, 0.942103121235474]
];
var REC2020Linear = new RGBColorSpace({
  id: "rec2020-linear",
  cssId: "--rec2020-linear",
  name: "Linear REC.2020",
  white: "D65",
  toXYZ_M: toXYZ_M$5,
  fromXYZ_M: fromXYZ_M$5
});
var \u03B1 = 1.09929682680944;
var \u03B2 = 0.018053968510807;
var REC2020 = new RGBColorSpace({
  id: "rec2020",
  name: "REC.2020",
  base: REC2020Linear,
  // Non-linear transfer function from Rec. ITU-R BT.2020-2 table 4
  toBase(RGB) {
    return RGB.map(function(val) {
      if (val < \u03B2 * 4.5) {
        return val / 4.5;
      }
      return Math.pow((val + \u03B1 - 1) / \u03B1, 1 / 0.45);
    });
  },
  fromBase(RGB) {
    return RGB.map(function(val) {
      if (val >= \u03B2) {
        return \u03B1 * Math.pow(val, 0.45) - (\u03B1 - 1);
      }
      return 4.5 * val;
    });
  }
});
var toXYZ_M$4 = [
  [0.4865709486482162, 0.26566769316909306, 0.1982172852343625],
  [0.2289745640697488, 0.6917385218365064, 0.079286914093745],
  [0, 0.04511338185890264, 1.043944368900976]
];
var fromXYZ_M$4 = [
  [2.493496911941425, -0.9313836179191239, -0.40271078445071684],
  [-0.8294889695615747, 1.7626640603183463, 0.023624685841943577],
  [0.03584583024378447, -0.07617238926804182, 0.9568845240076872]
];
var P3Linear = new RGBColorSpace({
  id: "p3-linear",
  cssId: "--display-p3-linear",
  name: "Linear P3",
  white: "D65",
  toXYZ_M: toXYZ_M$4,
  fromXYZ_M: fromXYZ_M$4
});
var toXYZ_M$3 = [
  [0.41239079926595934, 0.357584339383878, 0.1804807884018343],
  [0.21263900587151027, 0.715168678767756, 0.07219231536073371],
  [0.01933081871559182, 0.11919477979462598, 0.9505321522496607]
];
var fromXYZ_M$3 = [
  [3.2409699419045226, -1.537383177570094, -0.4986107602930034],
  [-0.9692436362808796, 1.8759675015077202, 0.04155505740717559],
  [0.05563007969699366, -0.20397695888897652, 1.0569715142428786]
];
var sRGBLinear = new RGBColorSpace({
  id: "srgb-linear",
  name: "Linear sRGB",
  white: "D65",
  toXYZ_M: toXYZ_M$3,
  fromXYZ_M: fromXYZ_M$3
});
var KEYWORDS = {
  "aliceblue": [240 / 255, 248 / 255, 1],
  "antiquewhite": [250 / 255, 235 / 255, 215 / 255],
  "aqua": [0, 1, 1],
  "aquamarine": [127 / 255, 1, 212 / 255],
  "azure": [240 / 255, 1, 1],
  "beige": [245 / 255, 245 / 255, 220 / 255],
  "bisque": [1, 228 / 255, 196 / 255],
  "black": [0, 0, 0],
  "blanchedalmond": [1, 235 / 255, 205 / 255],
  "blue": [0, 0, 1],
  "blueviolet": [138 / 255, 43 / 255, 226 / 255],
  "brown": [165 / 255, 42 / 255, 42 / 255],
  "burlywood": [222 / 255, 184 / 255, 135 / 255],
  "cadetblue": [95 / 255, 158 / 255, 160 / 255],
  "chartreuse": [127 / 255, 1, 0],
  "chocolate": [210 / 255, 105 / 255, 30 / 255],
  "coral": [1, 127 / 255, 80 / 255],
  "cornflowerblue": [100 / 255, 149 / 255, 237 / 255],
  "cornsilk": [1, 248 / 255, 220 / 255],
  "crimson": [220 / 255, 20 / 255, 60 / 255],
  "cyan": [0, 1, 1],
  "darkblue": [0, 0, 139 / 255],
  "darkcyan": [0, 139 / 255, 139 / 255],
  "darkgoldenrod": [184 / 255, 134 / 255, 11 / 255],
  "darkgray": [169 / 255, 169 / 255, 169 / 255],
  "darkgreen": [0, 100 / 255, 0],
  "darkgrey": [169 / 255, 169 / 255, 169 / 255],
  "darkkhaki": [189 / 255, 183 / 255, 107 / 255],
  "darkmagenta": [139 / 255, 0, 139 / 255],
  "darkolivegreen": [85 / 255, 107 / 255, 47 / 255],
  "darkorange": [1, 140 / 255, 0],
  "darkorchid": [153 / 255, 50 / 255, 204 / 255],
  "darkred": [139 / 255, 0, 0],
  "darksalmon": [233 / 255, 150 / 255, 122 / 255],
  "darkseagreen": [143 / 255, 188 / 255, 143 / 255],
  "darkslateblue": [72 / 255, 61 / 255, 139 / 255],
  "darkslategray": [47 / 255, 79 / 255, 79 / 255],
  "darkslategrey": [47 / 255, 79 / 255, 79 / 255],
  "darkturquoise": [0, 206 / 255, 209 / 255],
  "darkviolet": [148 / 255, 0, 211 / 255],
  "deeppink": [1, 20 / 255, 147 / 255],
  "deepskyblue": [0, 191 / 255, 1],
  "dimgray": [105 / 255, 105 / 255, 105 / 255],
  "dimgrey": [105 / 255, 105 / 255, 105 / 255],
  "dodgerblue": [30 / 255, 144 / 255, 1],
  "firebrick": [178 / 255, 34 / 255, 34 / 255],
  "floralwhite": [1, 250 / 255, 240 / 255],
  "forestgreen": [34 / 255, 139 / 255, 34 / 255],
  "fuchsia": [1, 0, 1],
  "gainsboro": [220 / 255, 220 / 255, 220 / 255],
  "ghostwhite": [248 / 255, 248 / 255, 1],
  "gold": [1, 215 / 255, 0],
  "goldenrod": [218 / 255, 165 / 255, 32 / 255],
  "gray": [128 / 255, 128 / 255, 128 / 255],
  "green": [0, 128 / 255, 0],
  "greenyellow": [173 / 255, 1, 47 / 255],
  "grey": [128 / 255, 128 / 255, 128 / 255],
  "honeydew": [240 / 255, 1, 240 / 255],
  "hotpink": [1, 105 / 255, 180 / 255],
  "indianred": [205 / 255, 92 / 255, 92 / 255],
  "indigo": [75 / 255, 0, 130 / 255],
  "ivory": [1, 1, 240 / 255],
  "khaki": [240 / 255, 230 / 255, 140 / 255],
  "lavender": [230 / 255, 230 / 255, 250 / 255],
  "lavenderblush": [1, 240 / 255, 245 / 255],
  "lawngreen": [124 / 255, 252 / 255, 0],
  "lemonchiffon": [1, 250 / 255, 205 / 255],
  "lightblue": [173 / 255, 216 / 255, 230 / 255],
  "lightcoral": [240 / 255, 128 / 255, 128 / 255],
  "lightcyan": [224 / 255, 1, 1],
  "lightgoldenrodyellow": [250 / 255, 250 / 255, 210 / 255],
  "lightgray": [211 / 255, 211 / 255, 211 / 255],
  "lightgreen": [144 / 255, 238 / 255, 144 / 255],
  "lightgrey": [211 / 255, 211 / 255, 211 / 255],
  "lightpink": [1, 182 / 255, 193 / 255],
  "lightsalmon": [1, 160 / 255, 122 / 255],
  "lightseagreen": [32 / 255, 178 / 255, 170 / 255],
  "lightskyblue": [135 / 255, 206 / 255, 250 / 255],
  "lightslategray": [119 / 255, 136 / 255, 153 / 255],
  "lightslategrey": [119 / 255, 136 / 255, 153 / 255],
  "lightsteelblue": [176 / 255, 196 / 255, 222 / 255],
  "lightyellow": [1, 1, 224 / 255],
  "lime": [0, 1, 0],
  "limegreen": [50 / 255, 205 / 255, 50 / 255],
  "linen": [250 / 255, 240 / 255, 230 / 255],
  "magenta": [1, 0, 1],
  "maroon": [128 / 255, 0, 0],
  "mediumaquamarine": [102 / 255, 205 / 255, 170 / 255],
  "mediumblue": [0, 0, 205 / 255],
  "mediumorchid": [186 / 255, 85 / 255, 211 / 255],
  "mediumpurple": [147 / 255, 112 / 255, 219 / 255],
  "mediumseagreen": [60 / 255, 179 / 255, 113 / 255],
  "mediumslateblue": [123 / 255, 104 / 255, 238 / 255],
  "mediumspringgreen": [0, 250 / 255, 154 / 255],
  "mediumturquoise": [72 / 255, 209 / 255, 204 / 255],
  "mediumvioletred": [199 / 255, 21 / 255, 133 / 255],
  "midnightblue": [25 / 255, 25 / 255, 112 / 255],
  "mintcream": [245 / 255, 1, 250 / 255],
  "mistyrose": [1, 228 / 255, 225 / 255],
  "moccasin": [1, 228 / 255, 181 / 255],
  "navajowhite": [1, 222 / 255, 173 / 255],
  "navy": [0, 0, 128 / 255],
  "oldlace": [253 / 255, 245 / 255, 230 / 255],
  "olive": [128 / 255, 128 / 255, 0],
  "olivedrab": [107 / 255, 142 / 255, 35 / 255],
  "orange": [1, 165 / 255, 0],
  "orangered": [1, 69 / 255, 0],
  "orchid": [218 / 255, 112 / 255, 214 / 255],
  "palegoldenrod": [238 / 255, 232 / 255, 170 / 255],
  "palegreen": [152 / 255, 251 / 255, 152 / 255],
  "paleturquoise": [175 / 255, 238 / 255, 238 / 255],
  "palevioletred": [219 / 255, 112 / 255, 147 / 255],
  "papayawhip": [1, 239 / 255, 213 / 255],
  "peachpuff": [1, 218 / 255, 185 / 255],
  "peru": [205 / 255, 133 / 255, 63 / 255],
  "pink": [1, 192 / 255, 203 / 255],
  "plum": [221 / 255, 160 / 255, 221 / 255],
  "powderblue": [176 / 255, 224 / 255, 230 / 255],
  "purple": [128 / 255, 0, 128 / 255],
  "rebeccapurple": [102 / 255, 51 / 255, 153 / 255],
  "red": [1, 0, 0],
  "rosybrown": [188 / 255, 143 / 255, 143 / 255],
  "royalblue": [65 / 255, 105 / 255, 225 / 255],
  "saddlebrown": [139 / 255, 69 / 255, 19 / 255],
  "salmon": [250 / 255, 128 / 255, 114 / 255],
  "sandybrown": [244 / 255, 164 / 255, 96 / 255],
  "seagreen": [46 / 255, 139 / 255, 87 / 255],
  "seashell": [1, 245 / 255, 238 / 255],
  "sienna": [160 / 255, 82 / 255, 45 / 255],
  "silver": [192 / 255, 192 / 255, 192 / 255],
  "skyblue": [135 / 255, 206 / 255, 235 / 255],
  "slateblue": [106 / 255, 90 / 255, 205 / 255],
  "slategray": [112 / 255, 128 / 255, 144 / 255],
  "slategrey": [112 / 255, 128 / 255, 144 / 255],
  "snow": [1, 250 / 255, 250 / 255],
  "springgreen": [0, 1, 127 / 255],
  "steelblue": [70 / 255, 130 / 255, 180 / 255],
  "tan": [210 / 255, 180 / 255, 140 / 255],
  "teal": [0, 128 / 255, 128 / 255],
  "thistle": [216 / 255, 191 / 255, 216 / 255],
  "tomato": [1, 99 / 255, 71 / 255],
  "turquoise": [64 / 255, 224 / 255, 208 / 255],
  "violet": [238 / 255, 130 / 255, 238 / 255],
  "wheat": [245 / 255, 222 / 255, 179 / 255],
  "white": [1, 1, 1],
  "whitesmoke": [245 / 255, 245 / 255, 245 / 255],
  "yellow": [1, 1, 0],
  "yellowgreen": [154 / 255, 205 / 255, 50 / 255]
};
var coordGrammar = Array(3).fill("<percentage> | <number>[0, 255]");
var coordGrammarNumber = Array(3).fill("<number>[0, 255]");
var sRGB = new RGBColorSpace({
  id: "srgb",
  name: "sRGB",
  base: sRGBLinear,
  fromBase: (rgb) => {
    return rgb.map((val) => {
      let sign = val < 0 ? -1 : 1;
      let abs4 = val * sign;
      if (abs4 > 31308e-7) {
        return sign * (1.055 * abs4 ** (1 / 2.4) - 0.055);
      }
      return 12.92 * val;
    });
  },
  toBase: (rgb) => {
    return rgb.map((val) => {
      let sign = val < 0 ? -1 : 1;
      let abs4 = val * sign;
      if (abs4 <= 0.04045) {
        return val / 12.92;
      }
      return sign * ((abs4 + 0.055) / 1.055) ** 2.4;
    });
  },
  formats: {
    "rgb": {
      coords: coordGrammar
    },
    "rgb_number": {
      name: "rgb",
      commas: true,
      coords: coordGrammarNumber,
      noAlpha: true
    },
    "color": {
      /* use defaults */
    },
    "rgba": {
      coords: coordGrammar,
      commas: true,
      lastAlpha: true
    },
    "rgba_number": {
      name: "rgba",
      commas: true,
      coords: coordGrammarNumber
    },
    "hex": {
      type: "custom",
      toGamut: true,
      test: (str) => /^#([a-f0-9]{3,4}){1,2}$/i.test(str),
      parse(str) {
        if (str.length <= 5) {
          str = str.replace(/[a-f0-9]/gi, "$&$&");
        }
        let rgba = [];
        str.replace(/[a-f0-9]{2}/gi, (component) => {
          rgba.push(parseInt(component, 16) / 255);
        });
        return {
          spaceId: "srgb",
          coords: rgba.slice(0, 3),
          alpha: rgba.slice(3)[0]
        };
      },
      serialize: (coords, alpha, {
        collapse = true
        // collapse to 3-4 digit hex when possible?
      } = {}) => {
        if (alpha < 1) {
          coords.push(alpha);
        }
        coords = coords.map((c42) => Math.round(c42 * 255));
        let collapsible = collapse && coords.every((c42) => c42 % 17 === 0);
        let hex = coords.map((c42) => {
          if (collapsible) {
            return (c42 / 17).toString(16);
          }
          return c42.toString(16).padStart(2, "0");
        }).join("");
        return "#" + hex;
      }
    },
    "keyword": {
      type: "custom",
      test: (str) => /^[a-z]+$/i.test(str),
      parse(str) {
        str = str.toLowerCase();
        let ret = { spaceId: "srgb", coords: null, alpha: 1 };
        if (str === "transparent") {
          ret.coords = KEYWORDS.black;
          ret.alpha = 0;
        } else {
          ret.coords = KEYWORDS[str];
        }
        if (ret.coords) {
          return ret;
        }
      }
    }
  }
});
var P3 = new RGBColorSpace({
  id: "p3",
  cssId: "display-p3",
  name: "P3",
  base: P3Linear,
  // Gamma encoding/decoding is the same as sRGB
  fromBase: sRGB.fromBase,
  toBase: sRGB.toBase
});
defaults.display_space = sRGB;
var supportsNone;
if (typeof CSS !== "undefined" && CSS.supports) {
  for (let space of [lab, REC2020, P3]) {
    let coords = space.getMinCoords();
    let color = { space, coords, alpha: 1 };
    let str = serialize(color);
    if (CSS.supports("color", str)) {
      defaults.display_space = space;
      break;
    }
  }
}
function display(color, { space = defaults.display_space, ...options } = {}) {
  let ret = serialize(color, options);
  if (typeof CSS === "undefined" || CSS.supports("color", ret) || !defaults.display_space) {
    ret = new String(ret);
    ret.color = color;
  } else {
    let fallbackColor = color;
    let hasNone = color.coords.some(isNone) || isNone(color.alpha);
    if (hasNone) {
      if (!(supportsNone ??= CSS.supports("color", "hsl(none 50% 50%)"))) {
        fallbackColor = clone(color);
        fallbackColor.coords = fallbackColor.coords.map(skipNone);
        fallbackColor.alpha = skipNone(fallbackColor.alpha);
        ret = serialize(fallbackColor, options);
        if (CSS.supports("color", ret)) {
          ret = new String(ret);
          ret.color = fallbackColor;
          return ret;
        }
      }
    }
    fallbackColor = to3(fallbackColor, space);
    ret = new String(serialize(fallbackColor, options));
    ret.color = fallbackColor;
  }
  return ret;
}
function equals2(color1, color2) {
  color1 = getColor(color1);
  color2 = getColor(color2);
  return color1.space === color2.space && color1.alpha === color2.alpha && color1.coords.every((c42, i4) => c42 === color2.coords[i4]);
}
function getLuminance(color) {
  return get2(color, [xyz_d65, "y"]);
}
function setLuminance(color, value2) {
  set2(color, [xyz_d65, "y"], value2);
}
function register$2(Color2) {
  Object.defineProperty(Color2.prototype, "luminance", {
    get() {
      return getLuminance(this);
    },
    set(value2) {
      setLuminance(this, value2);
    }
  });
}
var luminance = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  getLuminance,
  register: register$2,
  setLuminance
});
function contrastWCAG21(color1, color2) {
  color1 = getColor(color1);
  color2 = getColor(color2);
  let Y1 = Math.max(getLuminance(color1), 0);
  let Y22 = Math.max(getLuminance(color2), 0);
  if (Y22 > Y1) {
    [Y1, Y22] = [Y22, Y1];
  }
  return (Y1 + 0.05) / (Y22 + 0.05);
}
var normBG = 0.56;
var normTXT = 0.57;
var revTXT = 0.62;
var revBG = 0.65;
var blkThrs = 0.022;
var blkClmp = 1.414;
var loClip = 0.1;
var deltaYmin = 5e-4;
var scaleBoW = 1.14;
var loBoWoffset = 0.027;
var scaleWoB = 1.14;
function fclamp(Y3) {
  if (Y3 >= blkThrs) {
    return Y3;
  }
  return Y3 + (blkThrs - Y3) ** blkClmp;
}
function linearize(val) {
  let sign = val < 0 ? -1 : 1;
  let abs4 = Math.abs(val);
  return sign * Math.pow(abs4, 2.4);
}
function contrastAPCA(background, foreground) {
  foreground = getColor(foreground);
  background = getColor(background);
  let S4;
  let C2;
  let Sapc;
  let R3, G3, B3;
  foreground = to3(foreground, "srgb");
  [R3, G3, B3] = foreground.coords;
  let lumTxt = linearize(R3) * 0.2126729 + linearize(G3) * 0.7151522 + linearize(B3) * 0.072175;
  background = to3(background, "srgb");
  [R3, G3, B3] = background.coords;
  let lumBg = linearize(R3) * 0.2126729 + linearize(G3) * 0.7151522 + linearize(B3) * 0.072175;
  let Ytxt = fclamp(lumTxt);
  let Ybg = fclamp(lumBg);
  let BoW = Ybg > Ytxt;
  if (Math.abs(Ybg - Ytxt) < deltaYmin) {
    C2 = 0;
  } else {
    if (BoW) {
      S4 = Ybg ** normBG - Ytxt ** normTXT;
      C2 = S4 * scaleBoW;
    } else {
      S4 = Ybg ** revBG - Ytxt ** revTXT;
      C2 = S4 * scaleWoB;
    }
  }
  if (Math.abs(C2) < loClip) {
    Sapc = 0;
  } else if (C2 > 0) {
    Sapc = C2 - loBoWoffset;
  } else {
    Sapc = C2 + loBoWoffset;
  }
  return Sapc * 100;
}
function contrastMichelson(color1, color2) {
  color1 = getColor(color1);
  color2 = getColor(color2);
  let Y1 = Math.max(getLuminance(color1), 0);
  let Y22 = Math.max(getLuminance(color2), 0);
  if (Y22 > Y1) {
    [Y1, Y22] = [Y22, Y1];
  }
  let denom = Y1 + Y22;
  return denom === 0 ? 0 : (Y1 - Y22) / denom;
}
var max2 = 5e4;
function contrastWeber(color1, color2) {
  color1 = getColor(color1);
  color2 = getColor(color2);
  let Y1 = Math.max(getLuminance(color1), 0);
  let Y22 = Math.max(getLuminance(color2), 0);
  if (Y22 > Y1) {
    [Y1, Y22] = [Y22, Y1];
  }
  return Y22 === 0 ? max2 : (Y1 - Y22) / Y22;
}
function contrastLstar(color1, color2) {
  color1 = getColor(color1);
  color2 = getColor(color2);
  let L1 = get2(color1, [lab, "l"]);
  let L2 = get2(color2, [lab, "l"]);
  return Math.abs(L1 - L2);
}
var \u03B5$3 = 216 / 24389;
var \u03B53 = 24 / 116;
var \u03BA$2 = 24389 / 27;
var white$1 = WHITES.D65;
var lab_d65 = new ColorSpace({
  id: "lab-d65",
  name: "Lab D65",
  coords: {
    l: {
      refRange: [0, 100],
      name: "Lightness"
    },
    a: {
      refRange: [-125, 125]
    },
    b: {
      refRange: [-125, 125]
    }
  },
  // Assuming XYZ is relative to D65, convert to CIE Lab
  // from CIE standard, which now defines these as a rational fraction
  white: white$1,
  base: xyz_d65,
  // Convert D65-adapted XYZ to Lab
  //  CIE 15.3:2004 section 8.2.1.1
  fromBase(XYZ) {
    let xyz = XYZ.map((value2, i4) => value2 / white$1[i4]);
    let f5 = xyz.map((value2) => value2 > \u03B5$3 ? Math.cbrt(value2) : (\u03BA$2 * value2 + 16) / 116);
    return [
      116 * f5[1] - 16,
      // L
      500 * (f5[0] - f5[1]),
      // a
      200 * (f5[1] - f5[2])
      // b
    ];
  },
  // Convert Lab to D65-adapted XYZ
  // Same result as CIE 15.3:2004 Appendix D although the derivation is different
  // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
  toBase(Lab) {
    let f5 = [];
    f5[1] = (Lab[0] + 16) / 116;
    f5[0] = Lab[1] / 500 + f5[1];
    f5[2] = f5[1] - Lab[2] / 200;
    let xyz = [
      f5[0] > \u03B53 ? Math.pow(f5[0], 3) : (116 * f5[0] - 16) / \u03BA$2,
      Lab[0] > 8 ? Math.pow((Lab[0] + 16) / 116, 3) : Lab[0] / \u03BA$2,
      f5[2] > \u03B53 ? Math.pow(f5[2], 3) : (116 * f5[2] - 16) / \u03BA$2
    ];
    return xyz.map((value2, i4) => value2 * white$1[i4]);
  },
  formats: {
    "lab-d65": {
      coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
    }
  }
});
var phi = Math.pow(5, 0.5) * 0.5 + 0.5;
function contrastDeltaPhi(color1, color2) {
  color1 = getColor(color1);
  color2 = getColor(color2);
  let Lstr1 = get2(color1, [lab_d65, "l"]);
  let Lstr2 = get2(color2, [lab_d65, "l"]);
  let deltaPhiStar = Math.abs(Math.pow(Lstr1, phi) - Math.pow(Lstr2, phi));
  let contrast2 = Math.pow(deltaPhiStar, 1 / phi) * Math.SQRT2 - 40;
  return contrast2 < 7.5 ? 0 : contrast2;
}
var contrastMethods = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  contrastAPCA,
  contrastDeltaPhi,
  contrastLstar,
  contrastMichelson,
  contrastWCAG21,
  contrastWeber
});
function contrast(background, foreground, o5 = {}) {
  if (isString(o5)) {
    o5 = { algorithm: o5 };
  }
  let { algorithm, ...rest } = o5;
  if (!algorithm) {
    let algorithms = Object.keys(contrastMethods).map((a22) => a22.replace(/^contrast/, "")).join(", ");
    throw new TypeError(`contrast() function needs a contrast algorithm. Please specify one of: ${algorithms}`);
  }
  background = getColor(background);
  foreground = getColor(foreground);
  for (let a22 in contrastMethods) {
    if ("contrast" + algorithm.toLowerCase() === a22.toLowerCase()) {
      return contrastMethods[a22](background, foreground, rest);
    }
  }
  throw new TypeError(`Unknown contrast algorithm: ${algorithm}`);
}
function uv(color) {
  let [X2, Y3, Z3] = getAll(color, xyz_d65);
  let denom = X2 + 15 * Y3 + 3 * Z3;
  return [4 * X2 / denom, 9 * Y3 / denom];
}
function xy(color) {
  let [X2, Y3, Z3] = getAll(color, xyz_d65);
  let sum5 = X2 + Y3 + Z3;
  return [X2 / sum5, Y3 / sum5];
}
function register$1(Color2) {
  Object.defineProperty(Color2.prototype, "uv", {
    get() {
      return uv(this);
    }
  });
  Object.defineProperty(Color2.prototype, "xy", {
    get() {
      return xy(this);
    }
  });
}
var chromaticity = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  register: register$1,
  uv,
  xy
});
function deltaE(c12, c222, o5 = {}) {
  if (isString(o5)) {
    o5 = { method: o5 };
  }
  let { method = defaults.deltaE, ...rest } = o5;
  for (let m32 in deltaEMethods) {
    if ("deltae" + method.toLowerCase() === m32.toLowerCase()) {
      return deltaEMethods[m32](c12, c222, rest);
    }
  }
  throw new TypeError(`Unknown deltaE method: ${method}`);
}
function lighten(color, amount = 0.25) {
  let space = ColorSpace.get("oklch", "lch");
  let lightness = [space, "l"];
  return set2(color, lightness, (l3) => l3 * (1 + amount));
}
function darken(color, amount = 0.25) {
  let space = ColorSpace.get("oklch", "lch");
  let lightness = [space, "l"];
  return set2(color, lightness, (l3) => l3 * (1 - amount));
}
var variations = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  darken,
  lighten
});
function mix(c12, c222, p22 = 0.5, o5 = {}) {
  [c12, c222] = [getColor(c12), getColor(c222)];
  if (type(p22) === "object") {
    [p22, o5] = [0.5, p22];
  }
  let r5 = range(c12, c222, o5);
  return r5(p22);
}
function steps(c12, c222, options = {}) {
  let colorRange;
  if (isRange(c12)) {
    [colorRange, options] = [c12, c222];
    [c12, c222] = colorRange.rangeArgs.colors;
  }
  let {
    maxDeltaE,
    deltaEMethod,
    steps: steps2 = 2,
    maxSteps = 1e3,
    ...rangeOptions
  } = options;
  if (!colorRange) {
    [c12, c222] = [getColor(c12), getColor(c222)];
    colorRange = range(c12, c222, rangeOptions);
  }
  let totalDelta = deltaE(c12, c222);
  let actualSteps = maxDeltaE > 0 ? Math.max(steps2, Math.ceil(totalDelta / maxDeltaE) + 1) : steps2;
  let ret = [];
  if (maxSteps !== void 0) {
    actualSteps = Math.min(actualSteps, maxSteps);
  }
  if (actualSteps === 1) {
    ret = [{ p: 0.5, color: colorRange(0.5) }];
  } else {
    let step = 1 / (actualSteps - 1);
    ret = Array.from({ length: actualSteps }, (_3, i4) => {
      let p22 = i4 * step;
      return { p: p22, color: colorRange(p22) };
    });
  }
  if (maxDeltaE > 0) {
    let maxDelta = ret.reduce((acc, cur, i4) => {
      if (i4 === 0) {
        return 0;
      }
      let \u0394\u0395 = deltaE(cur.color, ret[i4 - 1].color, deltaEMethod);
      return Math.max(acc, \u0394\u0395);
    }, 0);
    while (maxDelta > maxDeltaE) {
      maxDelta = 0;
      for (let i4 = 1; i4 < ret.length && ret.length < maxSteps; i4++) {
        let prev = ret[i4 - 1];
        let cur = ret[i4];
        let p22 = (cur.p + prev.p) / 2;
        let color = colorRange(p22);
        maxDelta = Math.max(maxDelta, deltaE(color, prev.color), deltaE(color, cur.color));
        ret.splice(i4, 0, { p: p22, color: colorRange(p22) });
        i4++;
      }
    }
  }
  ret = ret.map((a22) => a22.color);
  return ret;
}
function range(color1, color2, options = {}) {
  if (isRange(color1)) {
    let [r5, options2] = [color1, color2];
    return range(...r5.rangeArgs.colors, { ...r5.rangeArgs.options, ...options2 });
  }
  let { space, outputSpace, progression, premultiplied } = options;
  color1 = getColor(color1);
  color2 = getColor(color2);
  color1 = clone(color1);
  color2 = clone(color2);
  let rangeArgs = { colors: [color1, color2], options };
  if (space) {
    space = ColorSpace.get(space);
  } else {
    space = ColorSpace.registry[defaults.interpolationSpace] || color1.space;
  }
  outputSpace = outputSpace ? ColorSpace.get(outputSpace) : space;
  color1 = to3(color1, space);
  color2 = to3(color2, space);
  color1 = toGamut(color1);
  color2 = toGamut(color2);
  if (space.coords.h && space.coords.h.type === "angle") {
    let arc2 = options.hue = options.hue || "shorter";
    let hue = [space, "h"];
    let [\u03B81, \u03B82] = [get2(color1, hue), get2(color2, hue)];
    if (isNaN(\u03B81) && !isNaN(\u03B82)) {
      \u03B81 = \u03B82;
    } else if (isNaN(\u03B82) && !isNaN(\u03B81)) {
      \u03B82 = \u03B81;
    }
    [\u03B81, \u03B82] = adjust(arc2, [\u03B81, \u03B82]);
    set2(color1, hue, \u03B81);
    set2(color2, hue, \u03B82);
  }
  if (premultiplied) {
    color1.coords = color1.coords.map((c42) => c42 * color1.alpha);
    color2.coords = color2.coords.map((c42) => c42 * color2.alpha);
  }
  return Object.assign((p22) => {
    p22 = progression ? progression(p22) : p22;
    let coords = color1.coords.map((start, i4) => {
      let end = color2.coords[i4];
      return interpolate2(start, end, p22);
    });
    let alpha = interpolate2(color1.alpha, color2.alpha, p22);
    let ret = { space, coords, alpha };
    if (premultiplied) {
      ret.coords = ret.coords.map((c42) => c42 / alpha);
    }
    if (outputSpace !== space) {
      ret = to3(ret, outputSpace);
    }
    return ret;
  }, {
    rangeArgs
  });
}
function isRange(val) {
  return type(val) === "function" && !!val.rangeArgs;
}
defaults.interpolationSpace = "lab";
function register(Color2) {
  Color2.defineFunction("mix", mix, { returns: "color" });
  Color2.defineFunction("range", range, { returns: "function<color>" });
  Color2.defineFunction("steps", steps, { returns: "array<color>" });
}
var interpolation = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isRange,
  mix,
  range,
  register,
  steps
});
var HSL = new ColorSpace({
  id: "hsl",
  name: "HSL",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    s: {
      range: [0, 100],
      name: "Saturation"
    },
    l: {
      range: [0, 100],
      name: "Lightness"
    }
  },
  base: sRGB,
  // Adapted from https://drafts.csswg.org/css-color-4/better-rgbToHsl.js
  fromBase: (rgb) => {
    let max23 = Math.max(...rgb);
    let min6 = Math.min(...rgb);
    let [r5, g22, b22] = rgb;
    let [h5, s3, l3] = [NaN, 0, (min6 + max23) / 2];
    let d22 = max23 - min6;
    if (d22 !== 0) {
      s3 = l3 === 0 || l3 === 1 ? 0 : (max23 - l3) / Math.min(l3, 1 - l3);
      switch (max23) {
        case r5:
          h5 = (g22 - b22) / d22 + (g22 < b22 ? 6 : 0);
          break;
        case g22:
          h5 = (b22 - r5) / d22 + 2;
          break;
        case b22:
          h5 = (r5 - g22) / d22 + 4;
      }
      h5 = h5 * 60;
    }
    if (s3 < 0) {
      h5 += 180;
      s3 = Math.abs(s3);
    }
    if (h5 >= 360) {
      h5 -= 360;
    }
    return [h5, s3 * 100, l3 * 100];
  },
  // Adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative
  toBase: (hsl) => {
    let [h5, s3, l3] = hsl;
    h5 = h5 % 360;
    if (h5 < 0) {
      h5 += 360;
    }
    s3 /= 100;
    l3 /= 100;
    function f5(n22) {
      let k3 = (n22 + h5 / 30) % 12;
      let a22 = s3 * Math.min(l3, 1 - l3);
      return l3 - a22 * Math.max(-1, Math.min(k3 - 3, 9 - k3, 1));
    }
    return [f5(0), f5(8), f5(4)];
  },
  formats: {
    "hsl": {
      coords: ["<number> | <angle>", "<percentage>", "<percentage>"]
    },
    "hsla": {
      coords: ["<number> | <angle>", "<percentage>", "<percentage>"],
      commas: true,
      lastAlpha: true
    }
  }
});
var HSV = new ColorSpace({
  id: "hsv",
  name: "HSV",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    s: {
      range: [0, 100],
      name: "Saturation"
    },
    v: {
      range: [0, 100],
      name: "Value"
    }
  },
  base: HSL,
  // https://en.wikipedia.org/wiki/HSL_and_HSV#Interconversion
  fromBase(hsl) {
    let [h5, s3, l3] = hsl;
    s3 /= 100;
    l3 /= 100;
    let v3 = l3 + s3 * Math.min(l3, 1 - l3);
    return [
      h5,
      // h is the same
      v3 === 0 ? 0 : 200 * (1 - l3 / v3),
      // s
      100 * v3
    ];
  },
  // https://en.wikipedia.org/wiki/HSL_and_HSV#Interconversion
  toBase(hsv) {
    let [h5, s3, v3] = hsv;
    s3 /= 100;
    v3 /= 100;
    let l3 = v3 * (1 - s3 / 2);
    return [
      h5,
      // h is the same
      l3 === 0 || l3 === 1 ? 0 : (v3 - l3) / Math.min(l3, 1 - l3) * 100,
      l3 * 100
    ];
  },
  formats: {
    color: {
      id: "--hsv",
      coords: ["<number> | <angle>", "<percentage> | <number>", "<percentage> | <number>"]
    }
  }
});
var hwb = new ColorSpace({
  id: "hwb",
  name: "HWB",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    w: {
      range: [0, 100],
      name: "Whiteness"
    },
    b: {
      range: [0, 100],
      name: "Blackness"
    }
  },
  base: HSV,
  fromBase(hsv) {
    let [h5, s3, v3] = hsv;
    return [h5, v3 * (100 - s3) / 100, 100 - v3];
  },
  toBase(hwb2) {
    let [h5, w3, b22] = hwb2;
    w3 /= 100;
    b22 /= 100;
    let sum5 = w3 + b22;
    if (sum5 >= 1) {
      let gray = w3 / sum5;
      return [h5, 0, gray * 100];
    }
    let v3 = 1 - b22;
    let s3 = v3 === 0 ? 0 : 1 - w3 / v3;
    return [h5, s3 * 100, v3 * 100];
  },
  formats: {
    "hwb": {
      coords: ["<number> | <angle>", "<percentage> | <number>", "<percentage> | <number>"]
    }
  }
});
var toXYZ_M$2 = [
  [0.5766690429101305, 0.1855582379065463, 0.1882286462349947],
  [0.29734497525053605, 0.6273635662554661, 0.07529145849399788],
  [0.02703136138641234, 0.07068885253582723, 0.9913375368376388]
];
var fromXYZ_M$2 = [
  [2.0415879038107465, -0.5650069742788596, -0.34473135077832956],
  [-0.9692436362808795, 1.8759675015077202, 0.04155505740717557],
  [0.013444280632031142, -0.11836239223101838, 1.0151749943912054]
];
var A98Linear = new RGBColorSpace({
  id: "a98rgb-linear",
  cssId: "--a98-rgb-linear",
  name: "Linear Adobe\xAE 98 RGB compatible",
  white: "D65",
  toXYZ_M: toXYZ_M$2,
  fromXYZ_M: fromXYZ_M$2
});
var a98rgb = new RGBColorSpace({
  id: "a98rgb",
  cssId: "a98-rgb",
  name: "Adobe\xAE 98 RGB compatible",
  base: A98Linear,
  toBase: (RGB) => RGB.map((val) => Math.pow(Math.abs(val), 563 / 256) * Math.sign(val)),
  fromBase: (RGB) => RGB.map((val) => Math.pow(Math.abs(val), 256 / 563) * Math.sign(val))
});
var toXYZ_M$1 = [
  [0.7977666449006423, 0.13518129740053308, 0.0313477341283922],
  [0.2880748288194013, 0.711835234241873, 8993693872564e-17],
  [0, 0, 0.8251046025104602]
];
var fromXYZ_M$1 = [
  [1.3457868816471583, -0.25557208737979464, -0.05110186497554526],
  [-0.5446307051249019, 1.5082477428451468, 0.02052744743642139],
  [0, 0, 1.2119675456389452]
];
var ProPhotoLinear = new RGBColorSpace({
  id: "prophoto-linear",
  cssId: "--prophoto-rgb-linear",
  name: "Linear ProPhoto",
  white: "D50",
  base: XYZ_D50,
  toXYZ_M: toXYZ_M$1,
  fromXYZ_M: fromXYZ_M$1
});
var Et2 = 1 / 512;
var Et22 = 16 / 512;
var prophoto = new RGBColorSpace({
  id: "prophoto",
  cssId: "prophoto-rgb",
  name: "ProPhoto",
  base: ProPhotoLinear,
  toBase(RGB) {
    return RGB.map((v3) => v3 < Et22 ? v3 / 16 : v3 ** 1.8);
  },
  fromBase(RGB) {
    return RGB.map((v3) => v3 >= Et2 ? v3 ** (1 / 1.8) : 16 * v3);
  }
});
var oklch = new ColorSpace({
  id: "oklch",
  name: "Oklch",
  coords: {
    l: {
      refRange: [0, 1],
      name: "Lightness"
    },
    c: {
      refRange: [0, 0.4],
      name: "Chroma"
    },
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    }
  },
  white: "D65",
  base: OKLab,
  fromBase(oklab) {
    let [L2, a22, b22] = oklab;
    let h5;
    const \u03B52 = 2e-4;
    if (Math.abs(a22) < \u03B52 && Math.abs(b22) < \u03B52) {
      h5 = NaN;
    } else {
      h5 = Math.atan2(b22, a22) * 180 / Math.PI;
    }
    return [
      L2,
      // OKLab L is still L
      Math.sqrt(a22 ** 2 + b22 ** 2),
      // Chroma
      constrain(h5)
      // Hue, in degrees [0 to 360)
    ];
  },
  // Convert from polar form
  toBase(oklch2) {
    let [L2, C2, h5] = oklch2;
    let a22, b22;
    if (isNaN(h5)) {
      a22 = 0;
      b22 = 0;
    } else {
      a22 = C2 * Math.cos(h5 * Math.PI / 180);
      b22 = C2 * Math.sin(h5 * Math.PI / 180);
    }
    return [L2, a22, b22];
  },
  formats: {
    "oklch": {
      coords: ["<percentage> | <number>", "<number> | <percentage>[0,1]", "<number> | <angle>"]
    }
  }
});
var white = WHITES.D65;
var \u03B5$2 = 216 / 24389;
var \u03BA$1 = 24389 / 27;
var [U_PRIME_WHITE, V_PRIME_WHITE] = uv({ space: xyz_d65, coords: white });
var Luv = new ColorSpace({
  id: "luv",
  name: "Luv",
  coords: {
    l: {
      refRange: [0, 100],
      name: "Lightness"
    },
    // Reference ranges from https://facelessuser.github.io/coloraide/colors/luv/
    u: {
      refRange: [-215, 215]
    },
    v: {
      refRange: [-215, 215]
    }
  },
  white,
  base: xyz_d65,
  // Convert D65-adapted XYZ to Luv
  // https://en.wikipedia.org/wiki/CIELUV#The_forward_transformation
  fromBase(XYZ) {
    let xyz = [skipNone(XYZ[0]), skipNone(XYZ[1]), skipNone(XYZ[2])];
    let y3 = xyz[1];
    let [up, vp] = uv({ space: xyz_d65, coords: xyz });
    if (!Number.isFinite(up) || !Number.isFinite(vp)) {
      return [0, 0, 0];
    }
    let L2 = y3 <= \u03B5$2 ? \u03BA$1 * y3 : 116 * Math.cbrt(y3) - 16;
    return [
      L2,
      13 * L2 * (up - U_PRIME_WHITE),
      13 * L2 * (vp - V_PRIME_WHITE)
    ];
  },
  // Convert Luv to D65-adapted XYZ
  // https://en.wikipedia.org/wiki/CIELUV#The_reverse_transformation
  toBase(Luv2) {
    let [L2, u3, v3] = Luv2;
    if (L2 === 0 || isNone(L2)) {
      return [0, 0, 0];
    }
    u3 = skipNone(u3);
    v3 = skipNone(v3);
    let up = u3 / (13 * L2) + U_PRIME_WHITE;
    let vp = v3 / (13 * L2) + V_PRIME_WHITE;
    let y3 = L2 <= 8 ? L2 / \u03BA$1 : Math.pow((L2 + 16) / 116, 3);
    return [
      y3 * (9 * up / (4 * vp)),
      y3,
      y3 * ((12 - 3 * up - 20 * vp) / (4 * vp))
    ];
  },
  formats: {
    color: {
      id: "--luv",
      coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
    }
  }
});
var LCHuv = new ColorSpace({
  id: "lchuv",
  name: "LChuv",
  coords: {
    l: {
      refRange: [0, 100],
      name: "Lightness"
    },
    c: {
      refRange: [0, 220],
      name: "Chroma"
    },
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    }
  },
  base: Luv,
  fromBase(Luv2) {
    let [L2, u3, v3] = Luv2;
    let hue;
    const \u03B52 = 0.02;
    if (Math.abs(u3) < \u03B52 && Math.abs(v3) < \u03B52) {
      hue = NaN;
    } else {
      hue = Math.atan2(v3, u3) * 180 / Math.PI;
    }
    return [
      L2,
      // L is still L
      Math.sqrt(u3 ** 2 + v3 ** 2),
      // Chroma
      constrain(hue)
      // Hue, in degrees [0 to 360)
    ];
  },
  toBase(LCH) {
    let [Lightness, Chroma, Hue] = LCH;
    if (Chroma < 0) {
      Chroma = 0;
    }
    if (isNaN(Hue)) {
      Hue = 0;
    }
    return [
      Lightness,
      // L is still L
      Chroma * Math.cos(Hue * Math.PI / 180),
      // u
      Chroma * Math.sin(Hue * Math.PI / 180)
      // v
    ];
  },
  formats: {
    color: {
      id: "--lchuv",
      coords: ["<number> | <percentage>", "<number> | <percentage>", "<number> | <angle>"]
    }
  }
});
var \u03B5$1 = 216 / 24389;
var \u03BA = 24389 / 27;
var m_r0 = fromXYZ_M$3[0][0];
var m_r1 = fromXYZ_M$3[0][1];
var m_r2 = fromXYZ_M$3[0][2];
var m_g0 = fromXYZ_M$3[1][0];
var m_g1 = fromXYZ_M$3[1][1];
var m_g2 = fromXYZ_M$3[1][2];
var m_b0 = fromXYZ_M$3[2][0];
var m_b1 = fromXYZ_M$3[2][1];
var m_b2 = fromXYZ_M$3[2][2];
function distanceFromOriginAngle(slope2, intercept, angle) {
  const d22 = intercept / (Math.sin(angle) - slope2 * Math.cos(angle));
  return d22 < 0 ? Infinity : d22;
}
function calculateBoundingLines(l3) {
  const sub1 = Math.pow(l3 + 16, 3) / 1560896;
  const sub2 = sub1 > \u03B5$1 ? sub1 : l3 / \u03BA;
  const s1r = sub2 * (284517 * m_r0 - 94839 * m_r2);
  const s2r = sub2 * (838422 * m_r2 + 769860 * m_r1 + 731718 * m_r0);
  const s3r = sub2 * (632260 * m_r2 - 126452 * m_r1);
  const s1g = sub2 * (284517 * m_g0 - 94839 * m_g2);
  const s2g = sub2 * (838422 * m_g2 + 769860 * m_g1 + 731718 * m_g0);
  const s3g = sub2 * (632260 * m_g2 - 126452 * m_g1);
  const s1b = sub2 * (284517 * m_b0 - 94839 * m_b2);
  const s2b = sub2 * (838422 * m_b2 + 769860 * m_b1 + 731718 * m_b0);
  const s3b = sub2 * (632260 * m_b2 - 126452 * m_b1);
  return {
    r0s: s1r / s3r,
    r0i: s2r * l3 / s3r,
    r1s: s1r / (s3r + 126452),
    r1i: (s2r - 769860) * l3 / (s3r + 126452),
    g0s: s1g / s3g,
    g0i: s2g * l3 / s3g,
    g1s: s1g / (s3g + 126452),
    g1i: (s2g - 769860) * l3 / (s3g + 126452),
    b0s: s1b / s3b,
    b0i: s2b * l3 / s3b,
    b1s: s1b / (s3b + 126452),
    b1i: (s2b - 769860) * l3 / (s3b + 126452)
  };
}
function calcMaxChromaHsluv(lines, h5) {
  const hueRad = h5 / 360 * Math.PI * 2;
  const r0 = distanceFromOriginAngle(lines.r0s, lines.r0i, hueRad);
  const r1 = distanceFromOriginAngle(lines.r1s, lines.r1i, hueRad);
  const g0 = distanceFromOriginAngle(lines.g0s, lines.g0i, hueRad);
  const g1 = distanceFromOriginAngle(lines.g1s, lines.g1i, hueRad);
  const b0 = distanceFromOriginAngle(lines.b0s, lines.b0i, hueRad);
  const b1 = distanceFromOriginAngle(lines.b1s, lines.b1i, hueRad);
  return Math.min(r0, r1, g0, g1, b0, b1);
}
var hsluv = new ColorSpace({
  id: "hsluv",
  name: "HSLuv",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    s: {
      range: [0, 100],
      name: "Saturation"
    },
    l: {
      range: [0, 100],
      name: "Lightness"
    }
  },
  base: LCHuv,
  gamutSpace: sRGB,
  // Convert LCHuv to HSLuv
  fromBase(lch2) {
    let [l3, c42, h5] = [skipNone(lch2[0]), skipNone(lch2[1]), skipNone(lch2[2])];
    let s3;
    if (l3 > 99.9999999) {
      s3 = 0;
      l3 = 100;
    } else if (l3 < 1e-8) {
      s3 = 0;
      l3 = 0;
    } else {
      let lines = calculateBoundingLines(l3);
      let max23 = calcMaxChromaHsluv(lines, h5);
      s3 = c42 / max23 * 100;
    }
    return [h5, s3, l3];
  },
  // Convert HSLuv to LCHuv
  toBase(hsl) {
    let [h5, s3, l3] = [skipNone(hsl[0]), skipNone(hsl[1]), skipNone(hsl[2])];
    let c42;
    if (l3 > 99.9999999) {
      l3 = 100;
      c42 = 0;
    } else if (l3 < 1e-8) {
      l3 = 0;
      c42 = 0;
    } else {
      let lines = calculateBoundingLines(l3);
      let max23 = calcMaxChromaHsluv(lines, h5);
      c42 = max23 / 100 * s3;
    }
    return [l3, c42, h5];
  },
  formats: {
    color: {
      id: "--hsluv",
      coords: ["<number> | <angle>", "<percentage> | <number>", "<percentage> | <number>"]
    }
  }
});
fromXYZ_M$3[0][0];
fromXYZ_M$3[0][1];
fromXYZ_M$3[0][2];
fromXYZ_M$3[1][0];
fromXYZ_M$3[1][1];
fromXYZ_M$3[1][2];
fromXYZ_M$3[2][0];
fromXYZ_M$3[2][1];
fromXYZ_M$3[2][2];
function distanceFromOrigin(slope2, intercept) {
  return Math.abs(intercept) / Math.sqrt(Math.pow(slope2, 2) + 1);
}
function calcMaxChromaHpluv(lines) {
  let r0 = distanceFromOrigin(lines.r0s, lines.r0i);
  let r1 = distanceFromOrigin(lines.r1s, lines.r1i);
  let g0 = distanceFromOrigin(lines.g0s, lines.g0i);
  let g1 = distanceFromOrigin(lines.g1s, lines.g1i);
  let b0 = distanceFromOrigin(lines.b0s, lines.b0i);
  let b1 = distanceFromOrigin(lines.b1s, lines.b1i);
  return Math.min(r0, r1, g0, g1, b0, b1);
}
var hpluv = new ColorSpace({
  id: "hpluv",
  name: "HPLuv",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    s: {
      range: [0, 100],
      name: "Saturation"
    },
    l: {
      range: [0, 100],
      name: "Lightness"
    }
  },
  base: LCHuv,
  gamutSpace: "self",
  // Convert LCHuv to HPLuv
  fromBase(lch2) {
    let [l3, c42, h5] = [skipNone(lch2[0]), skipNone(lch2[1]), skipNone(lch2[2])];
    let s3;
    if (l3 > 99.9999999) {
      s3 = 0;
      l3 = 100;
    } else if (l3 < 1e-8) {
      s3 = 0;
      l3 = 0;
    } else {
      let lines = calculateBoundingLines(l3);
      let max23 = calcMaxChromaHpluv(lines);
      s3 = c42 / max23 * 100;
    }
    return [h5, s3, l3];
  },
  // Convert HPLuv to LCHuv
  toBase(hsl) {
    let [h5, s3, l3] = [skipNone(hsl[0]), skipNone(hsl[1]), skipNone(hsl[2])];
    let c42;
    if (l3 > 99.9999999) {
      l3 = 100;
      c42 = 0;
    } else if (l3 < 1e-8) {
      l3 = 0;
      c42 = 0;
    } else {
      let lines = calculateBoundingLines(l3);
      let max23 = calcMaxChromaHpluv(lines);
      c42 = max23 / 100 * s3;
    }
    return [l3, c42, h5];
  },
  formats: {
    color: {
      id: "--hpluv",
      coords: ["<number> | <angle>", "<percentage> | <number>", "<percentage> | <number>"]
    }
  }
});
var Yw = 203;
var n6 = 2610 / 2 ** 14;
var ninv = 2 ** 14 / 2610;
var m4 = 2523 / 2 ** 5;
var minv = 2 ** 5 / 2523;
var c1 = 3424 / 2 ** 12;
var c22 = 2413 / 2 ** 7;
var c32 = 2392 / 2 ** 7;
var rec2100Pq = new RGBColorSpace({
  id: "rec2100pq",
  cssId: "rec2100-pq",
  name: "REC.2100-PQ",
  base: REC2020Linear,
  toBase(RGB) {
    return RGB.map(function(val) {
      let x3 = (Math.max(val ** minv - c1, 0) / (c22 - c32 * val ** minv)) ** ninv;
      return x3 * 1e4 / Yw;
    });
  },
  fromBase(RGB) {
    return RGB.map(function(val) {
      let x3 = Math.max(val * Yw / 1e4, 0);
      let num = c1 + c22 * x3 ** n6;
      let denom = 1 + c32 * x3 ** n6;
      return (num / denom) ** m4;
    });
  }
});
var a3 = 0.17883277;
var b3 = 0.28466892;
var c5 = 0.55991073;
var scale22 = 3.7743;
var rec2100Hlg = new RGBColorSpace({
  id: "rec2100hlg",
  cssId: "rec2100-hlg",
  name: "REC.2100-HLG",
  referred: "scene",
  base: REC2020Linear,
  toBase(RGB) {
    return RGB.map(function(val) {
      if (val <= 0.5) {
        return val ** 2 / 3 * scale22;
      }
      return (Math.exp((val - c5) / a3) + b3) / 12 * scale22;
    });
  },
  fromBase(RGB) {
    return RGB.map(function(val) {
      val /= scale22;
      if (val <= 1 / 12) {
        return Math.sqrt(3 * val);
      }
      return a3 * Math.log(12 * val - b3) + c5;
    });
  }
});
var CATs = {};
hooks.add("chromatic-adaptation-start", (env) => {
  if (env.options.method) {
    env.M = adapt(env.W1, env.W2, env.options.method);
  }
});
hooks.add("chromatic-adaptation-end", (env) => {
  if (!env.M) {
    env.M = adapt(env.W1, env.W2, env.options.method);
  }
});
function defineCAT({ id, toCone_M, fromCone_M }) {
  CATs[id] = arguments[0];
}
function adapt(W1, W2, id = "Bradford") {
  let method = CATs[id];
  let [\u03C1s, \u03B3s, \u03B2s] = multiplyMatrices(method.toCone_M, W1);
  let [\u03C1d, \u03B3d, \u03B2d] = multiplyMatrices(method.toCone_M, W2);
  let scale4 = [
    [\u03C1d / \u03C1s, 0, 0],
    [0, \u03B3d / \u03B3s, 0],
    [0, 0, \u03B2d / \u03B2s]
  ];
  let scaled_cone_M = multiplyMatrices(scale4, method.toCone_M);
  let adapt_M = multiplyMatrices(method.fromCone_M, scaled_cone_M);
  return adapt_M;
}
defineCAT({
  id: "von Kries",
  toCone_M: [
    [0.40024, 0.7076, -0.08081],
    [-0.2263, 1.16532, 0.0457],
    [0, 0, 0.91822]
  ],
  fromCone_M: [
    [1.8599363874558397, -1.1293816185800916, 0.21989740959619328],
    [0.3611914362417676, 0.6388124632850422, -6370596838649899e-21],
    [0, 0, 1.0890636230968613]
  ]
});
defineCAT({
  id: "Bradford",
  // Convert an array of XYZ values in the range 0.0 - 1.0
  // to cone fundamentals
  toCone_M: [
    [0.8951, 0.2664, -0.1614],
    [-0.7502, 1.7135, 0.0367],
    [0.0389, -0.0685, 1.0296]
  ],
  // and back
  fromCone_M: [
    [0.9869929054667121, -0.14705425642099013, 0.15996265166373122],
    [0.4323052697233945, 0.5183602715367774, 0.049291228212855594],
    [-0.00852866457517732, 0.04004282165408486, 0.96848669578755]
  ]
});
defineCAT({
  id: "CAT02",
  // with complete chromatic adaptation to W2, so D = 1.0
  toCone_M: [
    [0.7328, 0.4296, -0.1624],
    [-0.7036, 1.6975, 61e-4],
    [3e-3, 0.0136, 0.9834]
  ],
  fromCone_M: [
    [1.0961238208355142, -0.27886900021828726, 0.18274517938277307],
    [0.4543690419753592, 0.4735331543074117, 0.07209780371722911],
    [-0.009627608738429355, -0.00569803121611342, 1.0153256399545427]
  ]
});
defineCAT({
  id: "CAT16",
  toCone_M: [
    [0.401288, 0.650173, -0.051461],
    [-0.250268, 1.204414, 0.045854],
    [-2079e-6, 0.048952, 0.953127]
  ],
  // the extra precision is needed to avoid roundtripping errors
  fromCone_M: [
    [1.862067855087233, -1.0112546305316845, 0.14918677544445172],
    [0.3875265432361372, 0.6214474419314753, -0.008973985167612521],
    [-0.01584149884933386, -0.03412293802851557, 1.0499644368778496]
  ]
});
Object.assign(WHITES, {
  // whitepoint values from ASTM E308-01 with 10nm spacing, 1931 2 degree observer
  // all normalized to Y (luminance) = 1.00000
  // Illuminant A is a tungsten electric light, giving a very warm, orange light.
  A: [1.0985, 1, 0.35585],
  // Illuminant C was an early approximation to daylight: illuminant A with a blue filter.
  C: [0.98074, 1, 1.18232],
  // The daylight series of illuminants simulate natural daylight.
  // The color temperature (in degrees Kelvin/100) ranges from
  // cool, overcast daylight (D50) to bright, direct sunlight (D65).
  D55: [0.95682, 1, 0.92149],
  D75: [0.94972, 1, 1.22638],
  // Equal-energy illuminant, used in two-stage CAT16
  E: [1, 1, 1],
  // The F series of illuminants represent fluorescent lights
  F2: [0.99186, 1, 0.67393],
  F7: [0.95041, 1, 1.08747],
  F11: [1.00962, 1, 0.6435]
});
WHITES.ACES = [0.32168 / 0.33767, 1, (1 - 0.32168 - 0.33767) / 0.33767];
var toXYZ_M = [
  [0.6624541811085053, 0.13400420645643313, 0.1561876870049078],
  [0.27222871678091454, 0.6740817658111484, 0.05368951740793705],
  [-0.005574649490394108, 0.004060733528982826, 1.0103391003129971]
];
var fromXYZ_M = [
  [1.6410233796943257, -0.32480329418479, -0.23642469523761225],
  [-0.6636628587229829, 1.6153315916573379, 0.016756347685530137],
  [0.011721894328375376, -0.008284441996237409, 0.9883948585390215]
];
var ACEScg = new RGBColorSpace({
  id: "acescg",
  cssId: "--acescg",
  name: "ACEScg",
  // ACEScg  A scene-referred, linear-light encoding of ACES Data
  // https://docs.acescentral.com/specifications/acescg/
  // uses the AP1 primaries, see section 4.3.1 Color primaries
  coords: {
    r: {
      range: [0, 65504],
      name: "Red"
    },
    g: {
      range: [0, 65504],
      name: "Green"
    },
    b: {
      range: [0, 65504],
      name: "Blue"
    }
  },
  referred: "scene",
  white: WHITES.ACES,
  toXYZ_M,
  fromXYZ_M
});
var \u03B5 = 2 ** -16;
var ACES_min_nonzero = -0.35828683;
var ACES_cc_max = (Math.log2(65504) + 9.72) / 17.52;
var acescc = new RGBColorSpace({
  id: "acescc",
  cssId: "--acescc",
  name: "ACEScc",
  // see S-2014-003 ACEScc  A Logarithmic Encoding of ACES Data
  // https://docs.acescentral.com/specifications/acescc/
  // uses the AP1 primaries, see section 4.3.1 Color primaries
  // Appendix A: "Very small ACES scene referred values below 7 1/4 stops
  // below 18% middle gray are encoded as negative ACEScc values.
  // These values should be preserved per the encoding in Section 4.4
  // so that all positive ACES values are maintained."
  coords: {
    r: {
      range: [ACES_min_nonzero, ACES_cc_max],
      name: "Red"
    },
    g: {
      range: [ACES_min_nonzero, ACES_cc_max],
      name: "Green"
    },
    b: {
      range: [ACES_min_nonzero, ACES_cc_max],
      name: "Blue"
    }
  },
  referred: "scene",
  base: ACEScg,
  // from section 4.4.2 Decoding Function
  toBase(RGB) {
    const low = (9.72 - 15) / 17.52;
    return RGB.map(function(val) {
      if (val <= low) {
        return (2 ** (val * 17.52 - 9.72) - \u03B5) * 2;
      } else if (val < ACES_cc_max) {
        return 2 ** (val * 17.52 - 9.72);
      } else {
        return 65504;
      }
    });
  },
  // Non-linear encoding function from S-2014-003, section 4.4.1 Encoding Function
  fromBase(RGB) {
    return RGB.map(function(val) {
      if (val <= 0) {
        return (Math.log2(\u03B5) + 9.72) / 17.52;
      } else if (val < \u03B5) {
        return (Math.log2(\u03B5 + val * 0.5) + 9.72) / 17.52;
      } else {
        return (Math.log2(val) + 9.72) / 17.52;
      }
    });
  }
  // encoded media white (rgb 1,1,1) => linear  [ 222.861, 222.861, 222.861 ]
  // encoded media black (rgb 0,0,0) => linear [ 0.0011857, 0.0011857, 0.0011857]
});
var spaces = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  A98RGB: a98rgb,
  A98RGB_Linear: A98Linear,
  ACEScc: acescc,
  ACEScg,
  CAM16_JMh: cam16,
  HCT: hct,
  HPLuv: hpluv,
  HSL,
  HSLuv: hsluv,
  HSV,
  HWB: hwb,
  ICTCP: ictcp,
  JzCzHz: jzczhz,
  Jzazbz,
  LCH: lch,
  LCHuv,
  Lab: lab,
  Lab_D65: lab_d65,
  Luv,
  OKLCH: oklch,
  OKLab,
  P3,
  P3_Linear: P3Linear,
  ProPhoto: prophoto,
  ProPhoto_Linear: ProPhotoLinear,
  REC_2020: REC2020,
  REC_2020_Linear: REC2020Linear,
  REC_2100_HLG: rec2100Hlg,
  REC_2100_PQ: rec2100Pq,
  XYZ_ABS_D65: XYZ_Abs_D65,
  XYZ_D50,
  XYZ_D65: xyz_d65,
  sRGB,
  sRGB_Linear: sRGBLinear
});
var Color = class _Color {
  /**
   * Creates an instance of Color.
   * Signatures:
   * - `new Color(stringToParse)`
   * - `new Color(otherColor)`
   * - `new Color({space, coords, alpha})`
   * - `new Color(space, coords, alpha)`
   * - `new Color(spaceId, coords, alpha)`
   */
  constructor(...args) {
    let color;
    if (args.length === 1) {
      color = getColor(args[0]);
    }
    let space, coords, alpha;
    if (color) {
      space = color.space || color.spaceId;
      coords = color.coords;
      alpha = color.alpha;
    } else {
      [space, coords, alpha] = args;
    }
    Object.defineProperty(this, "space", {
      value: ColorSpace.get(space),
      writable: false,
      enumerable: true,
      configurable: true
      // see note in https://262.ecma-international.org/8.0/#sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver
    });
    this.coords = coords ? coords.slice() : [0, 0, 0];
    this.alpha = alpha > 1 || alpha === void 0 ? 1 : alpha < 0 ? 0 : alpha;
    for (let i4 = 0; i4 < this.coords.length; i4++) {
      if (this.coords[i4] === "NaN") {
        this.coords[i4] = NaN;
      }
    }
    for (let id in this.space.coords) {
      Object.defineProperty(this, id, {
        get: () => this.get(id),
        set: (value2) => this.set(id, value2)
      });
    }
  }
  get spaceId() {
    return this.space.id;
  }
  clone() {
    return new _Color(this.space, this.coords, this.alpha);
  }
  toJSON() {
    return {
      spaceId: this.spaceId,
      coords: this.coords,
      alpha: this.alpha
    };
  }
  display(...args) {
    let ret = display(this, ...args);
    ret.color = new _Color(ret.color);
    return ret;
  }
  /**
   * Get a color from the argument passed
   * Basically gets us the same result as new Color(color) but doesn't clone an existing color object
   */
  static get(color, ...args) {
    if (color instanceof _Color) {
      return color;
    }
    return new _Color(color, ...args);
  }
  static defineFunction(name, code, o5 = code) {
    let { instance = true, returns } = o5;
    let func2 = function(...args) {
      let ret = code(...args);
      if (returns === "color") {
        ret = _Color.get(ret);
      } else if (returns === "function<color>") {
        let f5 = ret;
        ret = function(...args2) {
          let ret2 = f5(...args2);
          return _Color.get(ret2);
        };
        Object.assign(ret, f5);
      } else if (returns === "array<color>") {
        ret = ret.map((c42) => _Color.get(c42));
      }
      return ret;
    };
    if (!(name in _Color)) {
      _Color[name] = func2;
    }
    if (instance) {
      _Color.prototype[name] = function(...args) {
        return func2(this, ...args);
      };
    }
  }
  static defineFunctions(o5) {
    for (let name in o5) {
      _Color.defineFunction(name, o5[name], o5[name]);
    }
  }
  static extend(exports) {
    if (exports.register) {
      exports.register(_Color);
    } else {
      for (let name in exports) {
        _Color.defineFunction(name, exports[name]);
      }
    }
  }
};
Color.defineFunctions({
  get: get2,
  getAll,
  set: set2,
  setAll,
  to: to3,
  equals: equals2,
  inGamut,
  toGamut,
  distance,
  toString: serialize
});
Object.assign(Color, {
  util,
  hooks,
  WHITES,
  Space: ColorSpace,
  spaces: ColorSpace.registry,
  parse,
  // Global defaults one may want to configure
  defaults
});
for (let key of Object.keys(spaces)) {
  ColorSpace.register(spaces[key]);
}
for (let id in ColorSpace.registry) {
  addSpaceAccessors(id, ColorSpace.registry[id]);
}
hooks.add("colorspace-init-end", (space) => {
  addSpaceAccessors(space.id, space);
  space.aliases?.forEach((alias) => {
    addSpaceAccessors(alias, space);
  });
});
function addSpaceAccessors(id, space) {
  let propId = id.replace(/-/g, "_");
  Object.defineProperty(Color.prototype, propId, {
    // Convert coords to coords in another colorspace and return them
    // Source colorspace: this.spaceId
    // Target colorspace: id
    get() {
      let ret = this.getAll(id);
      if (typeof Proxy === "undefined") {
        return ret;
      }
      return new Proxy(ret, {
        has: (obj, property) => {
          try {
            ColorSpace.resolveCoord([space, property]);
            return true;
          } catch (e5) {
          }
          return Reflect.has(obj, property);
        },
        get: (obj, property, receiver) => {
          if (property && typeof property !== "symbol" && !(property in obj)) {
            let { index } = ColorSpace.resolveCoord([space, property]);
            if (index >= 0) {
              return obj[index];
            }
          }
          return Reflect.get(obj, property, receiver);
        },
        set: (obj, property, value2, receiver) => {
          if (property && typeof property !== "symbol" && !(property in obj) || property >= 0) {
            let { index } = ColorSpace.resolveCoord([space, property]);
            if (index >= 0) {
              obj[index] = value2;
              this.setAll(id, obj);
              return true;
            }
          }
          return Reflect.set(obj, property, value2, receiver);
        }
      });
    },
    // Convert coords in another colorspace to internal coords and set them
    // Target colorspace: this.spaceId
    // Source colorspace: id
    set(coords) {
      this.setAll(id, coords);
    },
    configurable: true,
    enumerable: true
  });
}
Color.extend(deltaEMethods);
Color.extend({ deltaE });
Object.assign(Color, { deltaEMethods });
Color.extend(variations);
Color.extend({ contrast });
Color.extend(chromaticity);
Color.extend(luminance);
Color.extend(interpolation);
Color.extend(contrastMethods);
var toHsl = (colour2, safe = false) => {
  if (typeof colour2 === `string` && colour2 === `transparent`) return { h: 0, s: 0, l: 0, opacity: 0, space: `hsl` };
  const c42 = resolve2(colour2);
  const hsl = c42.hsl;
  let hue = hsl[0];
  if (Number.isNaN(hue) && safe) hue = 0;
  let sat = hsl[1];
  if (Number.isNaN(sat) && safe) sat = 0;
  const parsedHsl = {
    h: hue / 360,
    s: sat / 100,
    l: hsl[2] / 100,
    opacity: 1,
    space: `hsl`
  };
  if (c42.alpha !== 1) {
    if (`type` in c42.alpha) {
      const alphaRaw = Number.parseFloat(c42.alpha.raw);
      return { ...parsedHsl, opacity: alphaRaw };
    }
    return { ...parsedHsl, opacity: c42.alpha / 100 };
  }
  return parsedHsl;
};
var hslToColorJs = (hsl, safe) => {
  let h5 = hsl.h === null ? safe ? 0 : null : hsl.h;
  let opacity2 = hsl.opacity === void 0 ? 1 : hsl.opacity;
  throwNumberTest(h5, `percentage`, `hsl.h`);
  throwNumberTest(hsl.s, `percentage`, `hsl.s`);
  throwNumberTest(hsl.l, `percentage`, `hsl.l`);
  throwNumberTest(opacity2, `percentage`, `hsl.opacity`);
  const coords = [
    h5 * 360,
    hsl.s * 100,
    hsl.l * 100
  ];
  return new Color(`hsl`, coords, opacity2);
};
var oklchToColorJs = (oklch2) => {
  throwNumberTest(oklch2.l, `percentage`, `oklch.l`);
  throwNumberTest(oklch2.c, `percentage`, `oklch.c`);
  throwNumberTest(oklch2.h, `percentage`, `oklch.h`);
  throwNumberTest(oklch2.opacity, `percentage`, `oklch.opacity`);
  const coords = [
    oklch2.l,
    oklch2.c * 0.4,
    oklch2.h * 360
  ];
  return new Color(`oklch`, coords, oklch2.opacity);
};
var rgbToColorJs = (rgb) => {
  const coords = [
    rgb.r,
    rgb.g,
    rgb.b
  ];
  return `opacity` in rgb ? new Color(`srgb`, coords, rgb.opacity) : new Color(`srgb`, coords);
};
var toString2 = (colour2) => {
  const c42 = resolve2(colour2);
  return c42.display();
};
var goldenAngleColour = (index, saturation = 0.5, lightness = 0.75, alpha = 1) => {
  throwNumberTest(index, `positive`, `index`);
  throwNumberTest(saturation, `percentage`, `saturation`);
  throwNumberTest(lightness, `percentage`, `lightness`);
  throwNumberTest(alpha, `percentage`, `alpha`);
  const hue = index * 137.508;
  return alpha === 1 ? `hsl(${hue},${saturation * 100}%,${lightness * 100}%)` : `hsl(${hue},${saturation * 100}%,${lightness * 100}%,${alpha * 100}%)`;
};
var randomHue = (rand = defaultRandom) => {
  const r5 = rand();
  return r5 * 360;
};
var fromHsl = (h5, s3 = 1, l3 = 0.5, opacity2 = 1) => {
  throwNumberTest(h5, `percentage`, `h`);
  throwNumberTest(s3, `percentage`, `s`);
  throwNumberTest(l3, `percentage`, `l`);
  return resolve2({ h: h5, s: s3, l: l3, opacity: opacity2, space: `hsl` });
};
var toRgb = (colour2) => {
  const c42 = resolve2(colour2);
  const rgb = c42.srgb;
  return c42.alpha < 1 ? { r: rgb.r, g: rgb.g, b: rgb.b, opacity: c42.alpha, space: `srgb` } : { r: rgb.r, g: rgb.g, b: rgb.b, opacity: 1, space: `srgb` };
};
var resolve2 = (colour2, safe = false) => {
  if (typeof colour2 === `string`) {
    if (colour2.startsWith(`--`)) {
      colour2 = getComputedStyle(document.body).getPropertyValue(colour2);
    }
    return new Color(colour2);
  } else {
    if (isHsl(colour2)) return new Color(hslToColorJs(colour2, safe));
    if (isRgb(colour2)) return new Color(rgbToColorJs(colour2));
    if (isOklch(colour2)) return new Color(oklchToColorJs(colour2));
  }
  return colour2;
};
var resolveToString = (...colours) => {
  for (const colour2 of colours) {
    if (colour2 === void 0) continue;
    if (colour2 === null) continue;
    const c42 = resolve2(colour2);
    try {
      return c42.display();
    } catch (ex) {
      if (typeof colour2 === `string`) return colour2;
      throw ex;
    }
  }
  return `rebeccapurple`;
};
var toHex = (colour2, safe = false) => {
  if (typeof colour2 === `string` && colour2 === `transparent`) return `#00000000`;
  return resolve2(colour2, safe).to(`srgb`).toString({ format: `hex`, collapse: false });
};
var opacity = (colour2, amt) => {
  const c42 = resolve2(colour2);
  c42.alpha *= amt;
  return c42.toString();
};
var getCssVariable = (name, fallbackColour = `black`, root2) => {
  if (root2 === void 0) root2 = document.body;
  if (name.startsWith(`--`)) name = name.substring(2);
  const fromCss = getComputedStyle(root2).getPropertyValue(`--${name}`).trim();
  if (fromCss === void 0 || fromCss.length === 0) return fallbackColour;
  return fromCss;
};
var interpolator = (colours, opts = {}) => {
  const space = opts.space ?? `lch`;
  const hue = opts.hue ?? `shorter`;
  const pieces = interpolatorInit(colours);
  const ranges = pieces.map((piece) => piece[0].range(piece[1], { space, hue }));
  return (amt) => {
    amt = clamp(amt);
    const s3 = scale(amt, 0, 1, 0, ranges.length);
    const index = Math.floor(s3);
    const amtAdjusted = s3 - index;
    return ranges[index](amtAdjusted);
  };
};
var interpolatorInit = (colours) => {
  if (!Array.isArray(colours)) throw new Error(`Param 'colours' is not an array as expected. Got: ${typeof colours}`);
  if (colours.length < 2) throw new Error(`Param 'colours' should be at least two in length. Got: ${colours.length}`);
  const c42 = colours.map((colour2) => resolve2(colour2));
  return [...pairwise(c42)];
};
var scale3 = (colours, numberOfSteps, opts = {}) => {
  const space = opts.space ?? `lch`;
  const hue = opts.hue ?? `shorter`;
  const pieces = interpolatorInit(colours);
  const stepsPerPair = Math.floor(numberOfSteps / pieces.length);
  const steps2 = pieces.map((piece) => piece[0].steps(
    piece[1],
    { space, hue, steps: stepsPerPair, outputSpace: `srgb` }
  ));
  return steps2.flat();
};
var cssLinearGradient = (colours) => {
  const c42 = colours.map((c52) => resolve2(c52));
  return `linear-gradient(to right, ${c42.map((v3) => v3.display()).join(`, `)})`;
};
var isHsl = (p22) => {
  if (p22 === void 0 || p22 === null) return false;
  if (typeof p22 !== `object`) return false;
  if (p22.spaceId !== void 0) return false;
  if (p22.coords !== void 0) return false;
  const space = p22.space;
  if (space !== `hsl` && space !== void 0) return false;
  const pp = p22;
  if (pp.h === void 0) return false;
  if (pp.s === void 0) return false;
  if (pp.l === void 0) return false;
  return true;
};
var isOklch = (p22) => {
  if (p22 === void 0 || p22 === null) return false;
  if (typeof p22 !== `object`) return false;
  if (p22.spaceId !== void 0) return false;
  if (p22.coords !== void 0) return false;
  if (p22.space !== `oklch`) return false;
  if (p22.l === void 0) return false;
  if (p22.c === void 0) return false;
  if (p22.h === void 0) return false;
  return true;
};
var isRgb = (p22) => {
  if (p22 === void 0 || p22 === null) return false;
  if (typeof p22 !== `object`) return false;
  if (p22.space !== `srgb` && p22.space !== void 0) return false;
  if (p22.r === void 0) return false;
  if (p22.g === void 0) return false;
  if (p22.b === void 0) return false;
  return true;
};

// node_modules/ixfx/dist/chunk-QEOF2KQ6.js
var insertAt = (data, index, ...values) => {
  if (!Array.isArray(data)) {
    throw new TypeError(`Param 'data' is not an arry`);
  }
  return [...data.slice(0, index), ...values, ...data.slice(index + 1)];
};
var remove2 = (data, index) => {
  if (!Array.isArray(data)) {
    throw new TypeError(`'data' parameter should be an array`);
  }
  guardIndex(data, index, `index`);
  return [...data.slice(0, index), ...data.slice(index + 1)];
};

// node_modules/ixfx/dist/chunk-54PXOMGL.js
var maxScore = (iterable, scorer) => {
  let highestValue;
  let highestScore = Number.MIN_SAFE_INTEGER;
  for (const value2 of iterable) {
    const score = scorer(value2);
    if (score >= highestScore) {
      highestScore = score;
      highestValue = value2;
    }
  }
  return highestValue;
};
var min2 = (iterable, scorer) => {
  let lowestValue;
  let lowestScore = Number.MAX_SAFE_INTEGER;
  for (const value2 of iterable) {
    const score = scorer(value2);
    if (score <= lowestScore) {
      lowestScore = score;
      lowestValue = value2;
    }
  }
  return lowestValue;
};
var compareValuesShallow = (a4, b4, eq = isEqualDefault) => {
  const shared = [];
  const aUnique = [];
  const bUnique = [];
  for (const elementOfA of a4) {
    let seenInB = false;
    for (const elementOfB of b4) {
      if (eq(elementOfA, elementOfB)) {
        seenInB = true;
        break;
      }
    }
    if (seenInB) {
      shared.push(elementOfA);
    } else {
      aUnique.push(elementOfA);
    }
  }
  for (const elementOfB of b4) {
    let seenInA = false;
    for (const elementOfA of a4) {
      if (eq(elementOfB, elementOfA)) {
        seenInA = true;
      }
    }
    if (!seenInA) {
      bUnique.push(elementOfB);
    }
  }
  const isSame = aUnique.length === 0 && bUnique.length === 0;
  return {
    shared,
    isSame,
    a: aUnique,
    b: bUnique
  };
};
var compareKeys = (a4, b4) => {
  const c6 = compareValuesShallow(Object.keys(a4), Object.keys(b4));
  return c6;
};
var compareArrays = (a4, b4, eq = isEqualDefault) => {
  if (!Array.isArray(a4)) throw new Error(`Param 'a' is not an array`);
  if (!Array.isArray(b4)) throw new Error(`Param 'b' is not an array`);
  const c6 = compareData(a4, b4, false, eq);
  if (!c6.isArray) throw new Error(`Change set does not have arrays as parameters`);
  const convert = (key) => {
    if (key.startsWith(`_`)) {
      return Number.parseInt(key.slice(1));
    } else throw new Error(`Unexpected key '${key}'`);
  };
  const cc = {
    ...c6,
    added: mapKeys(c6.added, convert),
    changed: mapKeys(c6.changed, convert),
    removed: c6.removed.map((v3) => convert(v3)),
    summary: c6.summary.map((value2) => {
      return [value2[0], convert(value2[1]), value2[2]];
    })
  };
  return cc;
};
var compareData = (a4, b4, assumeSameShape = false, eq = isEqualDefault) => {
  const entriesA = Object.entries(a4);
  const entriesB = Object.entries(b4);
  const scannedKeys = /* @__PURE__ */ new Set();
  const changed = {};
  const added = {};
  const children3 = {};
  const removed = [];
  const isArray = Array.isArray(a4);
  const summary = new Array();
  let hasChanged = false;
  for (const entry of entriesA) {
    const outputKey = isArray ? `_${entry[0]}` : entry[0];
    const aValue = entry[1];
    const bValue = b4[entry[0]];
    scannedKeys.add(entry[0]);
    if (bValue === void 0) {
      hasChanged = true;
      if (assumeSameShape && !isArray) {
        changed[outputKey] = bValue;
        summary.push([`mutate`, outputKey, bValue]);
      } else {
        removed.push(outputKey);
        summary.push([`del`, outputKey, aValue]);
      }
      continue;
    }
    if (typeof aValue === `object`) {
      const r5 = compareData(aValue, bValue, assumeSameShape, eq);
      if (r5.hasChanged) hasChanged = true;
      children3[outputKey] = r5;
      const childSummary = r5.summary.map((sum5) => {
        return [sum5[0], outputKey + `.` + sum5[1], sum5[2]];
      });
      summary.push(...childSummary);
    } else {
      if (!eq(aValue, bValue)) {
        changed[outputKey] = bValue;
        hasChanged = true;
        summary.push([`mutate`, outputKey, bValue]);
      }
    }
  }
  if (!assumeSameShape || isArray) {
    for (const entry of entriesB) {
      const key = isArray ? `_${entry[0]}` : entry[0];
      if (scannedKeys.has(entry[0])) continue;
      added[key] = entry[1];
      hasChanged = true;
      summary.push([`add`, key, entry[1]]);
    }
  }
  return {
    changed,
    added,
    removed,
    children: children3,
    hasChanged,
    isArray,
    summary
  };
};

// node_modules/ixfx/dist/chunk-ZCVS6SFU.js
var rx_exports = {};
__export(rx_exports, {
  Dom: () => Dom_exports,
  From: () => sources_exports,
  Ops: () => Ops,
  Sinks: () => Sinks,
  annotate: () => annotate,
  annotateWithOp: () => annotateWithOp,
  average: () => average2,
  chunk: () => chunk,
  cloneFromFields: () => cloneFromFields,
  combineLatestToArray: () => combineLatestToArray,
  combineLatestToObject: () => combineLatestToObject,
  computeWithPrevious: () => computeWithPrevious,
  count: () => count2,
  debounce: () => debounce2,
  drop: () => drop,
  elapsed: () => elapsed,
  field: () => field,
  filter: () => filter22,
  hasLast: () => hasLast,
  interpolate: () => interpolate22,
  isPingable: () => isPingable,
  isReactive: () => isReactive,
  isTrigger: () => isTrigger,
  isTriggerFunction: () => isTriggerFunction,
  isTriggerGenerator: () => isTriggerGenerator,
  isTriggerValue: () => isTriggerValue,
  isWrapped: () => isWrapped,
  isWritable: () => isWritable,
  manual: () => manual,
  max: () => max32,
  messageHasValue: () => messageHasValue,
  messageIsDoneSignal: () => messageIsDoneSignal,
  messageIsSignal: () => messageIsSignal,
  min: () => min4,
  opify: () => opify,
  pipe: () => pipe,
  prepare: () => prepare,
  rank: () => rank2,
  resolveSource: () => resolveSource,
  resolveTriggerValue: () => resolveTriggerValue,
  run: () => run2,
  setHtmlText: () => setHtmlText,
  singleFromArray: () => singleFromArray,
  split: () => split,
  splitLabelled: () => splitLabelled,
  sum: () => sum2,
  switcher: () => switcher,
  symbol: () => symbol,
  syncToArray: () => syncToArray,
  syncToObject: () => syncToObject,
  takeNextValue: () => takeNextValue,
  tally: () => tally2,
  tapOps: () => tapOps,
  tapProcess: () => tapProcess,
  tapStream: () => tapStream,
  throttle: () => throttle2,
  timeoutPing: () => timeoutPing,
  timeoutValue: () => timeoutValue,
  to: () => to4,
  toArray: () => toArray22,
  toArrayOrThrow: () => toArrayOrThrow,
  toGenerator: () => toGenerator,
  transform: () => transform,
  valueToPing: () => valueToPing,
  withValue: () => withValue,
  wrap: () => wrap4,
  writable: () => writable
});
function func(callback, options = {}) {
  const maximumRepeats = options.maximumRepeats ?? Number.MAX_SAFE_INTEGER;
  const closeOnError = options.closeOnError ?? true;
  const intervalMs = options.interval ? intervalToMs(options.interval) : -1;
  let manual2 = options.manual ?? false;
  if (options.interval === void 0 && options.manual === void 0) manual2 = true;
  if (manual2 && options.interval) throw new Error(`If option 'manual' is set, option 'interval' cannot be used`);
  const predelay = intervalToMs(options.predelay, 0);
  const lazy = options.lazy ?? `very`;
  const signal = options.signal;
  const internalAbort = new AbortController();
  const internalAbortCallback = (reason) => {
    internalAbort.abort(reason);
  };
  let sentResults = 0;
  let enabled = false;
  const done = (reason) => {
    events.dispose(reason);
    enabled = false;
    if (run22) run22.cancel();
  };
  const ping = async () => {
    if (!enabled) return false;
    if (predelay) await sleep(predelay);
    if (sentResults >= maximumRepeats) {
      done(`Maximum repeats reached ${maximumRepeats.toString()}`);
      return false;
    }
    try {
      if (signal?.aborted) {
        done(`Signal (${signal.aborted})`);
        return false;
      }
      const value2 = await callback(internalAbortCallback);
      sentResults++;
      events.set(value2);
      return true;
    } catch (error) {
      if (closeOnError) {
        done(`Function error: ${getErrorMessage(error)}`);
        return false;
      } else {
        events.signal(`warn`, getErrorMessage(error));
        return true;
      }
    }
  };
  const run22 = manual2 ? void 0 : continuously(async () => {
    const pingResult = await ping();
    if (!pingResult) return false;
    if (internalAbort.signal.aborted) {
      done(`callback function aborted (${internalAbort.signal.reason})`);
      return false;
    }
  }, intervalMs);
  const events = initLazyStream({
    lazy,
    onStart() {
      enabled = true;
      if (run22) run22.start();
    },
    onStop() {
      console.log(`onStop`);
      enabled = false;
      if (run22) run22.cancel();
    }
  });
  if (lazy === `never` && run22) run22.start();
  return { ...events, ping };
}
var IterableAsync_exports = {};
__export(IterableAsync_exports, {
  asCallback: () => asCallback2,
  chunks: () => chunks2,
  concat: () => concat2,
  dropWhile: () => dropWhile2,
  equals: () => equals3,
  every: () => every2,
  fill: () => fill2,
  filter: () => filter3,
  find: () => find3,
  flatten: () => flatten2,
  forEach: () => forEach2,
  fromArray: () => fromArray2,
  fromIterable: () => fromIterable2,
  map: () => map2,
  max: () => max3,
  min: () => min22,
  nextWithTimeout: () => nextWithTimeout,
  reduce: () => reduce2,
  repeat: () => repeat3,
  slice: () => slice2,
  some: () => some22,
  toArray: () => toArray3,
  unique: () => unique3,
  uniqueByValue: () => uniqueByValue2,
  until: () => until2,
  withDelay: () => withDelay,
  zip: () => zip2
});
async function* fromArray2(array2, interval2 = 1) {
  for (const v3 of array2) {
    yield v3;
    await sleep(interval2);
  }
}
async function* fromIterable2(iterable, interval2 = 1) {
  for await (const v3 of iterable) {
    yield v3;
    await sleep(interval2);
  }
}
async function* chunks2(it2, size) {
  let buffer = [];
  for await (const v3 of it2) {
    buffer.push(v3);
    if (buffer.length === size) {
      yield buffer;
      buffer = [];
    }
  }
  if (buffer.length > 0) yield buffer;
}
async function* concat2(...its) {
  for await (const it2 of its) yield* it2;
}
async function* dropWhile2(it2, f5) {
  for await (const v3 of it2) {
    if (!f5(v3)) {
      yield v3;
    }
  }
}
var until2 = async (it2, callback) => {
  for await (const _3 of it2) {
    const value2 = await callback();
    if (typeof value2 === `boolean` && !value2) break;
  }
};
var repeat3 = async function* (genCreator, repeatsOrSignal) {
  const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;
  const signal = typeof repeatsOrSignal === `number` ? void 0 : repeatsOrSignal;
  let count22 = repeats;
  while (true) {
    for await (const v3 of genCreator()) {
      yield v3;
      if (signal?.aborted) break;
    }
    if (Number.isFinite(repeats)) {
      count22--;
      if (count22 === 0) break;
    }
    if (signal?.aborted) break;
  }
};
async function equals3(it1, it2, equality) {
  const iit1 = it1[Symbol.asyncIterator]();
  const iit2 = it2[Symbol.asyncIterator]();
  while (true) {
    const index1 = await iit1.next();
    const index2 = await iit2.next();
    if (equality !== void 0) {
      if (!equality(index1.value, index2.value)) return false;
    } else if (index1.value !== index2.value) return false;
    if (index1.done ?? index2.done) return index1.done && index2.done;
  }
}
async function every2(it2, f5) {
  for await (const v3 of it2) {
    const result = await f5(v3);
    if (!result) return false;
  }
  return true;
}
async function* fill2(it2, v3) {
  for await (const _3 of it2) yield v3;
}
async function* filter3(it2, f5) {
  for await (const v3 of it2) {
    if (!await f5(v3)) continue;
    yield v3;
  }
}
async function find3(it2, f5) {
  for await (const v3 of it2) {
    if (await f5(v3)) return v3;
  }
}
async function* flatten2(it2) {
  for await (const v3 of it2) {
    if (typeof v3 === `object`) {
      if (Array.isArray(v3)) {
        for (const vv of v3) yield vv;
      } else if (isAsyncIterable(v3)) {
        for await (const vv of v3) {
          yield vv;
        }
      } else if (isIterable(v3)) {
        for (const vv of v3) {
          yield vv;
        }
      }
    } else {
      yield v3;
    }
  }
}
var forEach2 = async function(iterator2, fn2, options = {}) {
  const interval2 = options.interval;
  if (Array.isArray(iterator2)) {
    for (const x3 of iterator2) {
      const r5 = await fn2(x3);
      if (typeof r5 === `boolean` && !r5) break;
      if (interval2) await sleep(interval2);
    }
  } else {
    for await (const x3 of iterator2) {
      const r5 = await fn2(x3);
      if (typeof r5 === `boolean` && !r5) break;
      if (interval2) await sleep(interval2);
    }
  }
};
async function* map2(it2, f5) {
  for await (const v3 of it2) {
    yield f5(v3);
  }
}
async function* max3(it2, gt3 = (a4, b4) => a4 > b4) {
  let max42;
  for await (const v3 of it2) {
    if (max42 === void 0) {
      max42 = v3;
      yield max42;
      continue;
    }
    if (gt3(v3, max42)) {
      max42 = v3;
      yield v3;
    }
  }
}
async function* min22(it2, gt3 = (a4, b4) => a4 > b4) {
  let min52;
  for await (const v3 of it2) {
    if (min52 === void 0) {
      min52 = v3;
      yield min52;
      continue;
    }
    if (gt3(min52, v3)) {
      min52 = v3;
      yield v3;
    }
  }
  return min52;
}
async function reduce2(it2, f5, start) {
  for await (const v3 of it2) start = f5(start, v3);
  return start;
}
async function asCallback2(input, callback, onDone) {
  for await (const value2 of input) {
    callback(value2);
  }
  if (onDone) onDone();
}
async function* slice2(it2, start = 0, end = Number.POSITIVE_INFINITY) {
  const iit = it2[Symbol.asyncIterator]();
  if (end < start) throw new Error(`Param 'end' should be more than 'start'`);
  for (; start > 0; start--, end--) await iit.next();
  for await (const v3 of it2) {
    if (end-- > 0) {
      yield v3;
    } else {
      break;
    }
  }
}
async function* withDelay(it2, delay2) {
  for (const v3 of it2) {
    await sleep(delay2);
    yield v3;
  }
}
async function nextWithTimeout(it2, options) {
  const ms2 = intervalToMs(options, 1e3);
  const value2 = await Promise.race([
    (async () => {
      await sleep({ millis: ms2, signal: options.signal });
      return void 0;
    })(),
    (async () => {
      return await it2.next();
    })()
  ]);
  if (value2 === void 0) throw new Error(`Timeout`);
  return value2;
}
async function some22(it2, f5) {
  for await (const v3 of it2) {
    if (await f5(v3)) return true;
  }
  return false;
}
async function toArray3(it2, options = {}) {
  const result = [];
  const iterator2 = it2[Symbol.asyncIterator]();
  const started = Date.now();
  const maxItems = options.limit ?? Number.POSITIVE_INFINITY;
  const whileFunc = options.while;
  const maxElapsed = intervalToMs(options.elapsed, Number.POSITIVE_INFINITY);
  while (result.length < maxItems && Date.now() - started < maxElapsed) {
    if (whileFunc) {
      if (!whileFunc(result.length)) break;
    }
    const r5 = await iterator2.next();
    if (r5.done) break;
    result.push(r5.value);
  }
  return result;
}
async function* unique3(iterable) {
  const buffer = [];
  const itera = Array.isArray(iterable) ? iterable : [iterable];
  for await (const it2 of itera) {
    for await (const v3 of it2) {
      if (buffer.includes(v3)) continue;
      buffer.push(v3);
      yield v3;
    }
  }
}
async function* uniqueByValue2(input, toString6 = toStringDefault, seen = /* @__PURE__ */ new Set()) {
  for await (const v3 of input) {
    const key = toString6(v3);
    if (seen.has(key)) continue;
    seen.add(key);
    yield v3;
  }
}
async function* zip2(...its) {
  const iits = its.map((it2) => it2[Symbol.asyncIterator]());
  while (true) {
    const vs2 = await Promise.all(iits.map((it2) => it2.next()));
    if (vs2.some((v3) => v3.done)) return;
    yield vs2.map((v3) => v3.value);
  }
}
function iterator(source, options = {}) {
  const lazy = options.lazy ?? `very`;
  const log = options.traceLifecycle ? (message) => {
    console.log(`Rx.From.iterator ${message}`);
  } : (_3) => {
  };
  const readIntervalMs = intervalToMs(options.readInterval, 5);
  const readTimeoutMs = intervalToMs(options.readTimeout, 5 * 60 * 1e3);
  const whenStopped = options.whenStopped ?? `continue`;
  let iterator2;
  let ourAc;
  let sm = StateMachine_exports.init({
    idle: [`wait_for_next`],
    wait_for_next: [`processing_result`, `stopping`, `disposed`],
    processing_result: [`queued`, `disposed`, `stopping`],
    queued: [`wait_for_next`, `disposed`, `stopping`],
    stopping: `idle`,
    // eslint-disable-next-line unicorn/no-null
    disposed: null
  }, `idle`);
  const onExternalSignal = () => {
    log(`onExternalSignal`);
    ourAc?.abort(options.signal?.reason);
  };
  if (options.signal) {
    options.signal.addEventListener(`abort`, onExternalSignal, { once: true });
  }
  ;
  const read = async () => {
    log(`read. State: ${sm.value}`);
    ourAc = new AbortController();
    try {
      sm = StateMachine_exports.to(sm, `wait_for_next`);
      const v3 = await nextWithTimeout(iterator2, { signal: ourAc.signal, millis: readTimeoutMs });
      sm = StateMachine_exports.to(sm, `processing_result`);
      ourAc?.abort(`nextWithTimeout completed`);
      if (v3.done) {
        log(`read v.done true`);
        events.dispose(`Generator complete`);
        sm = StateMachine_exports.to(sm, `disposed`);
      }
      if (sm.value === `stopping`) {
        log(`read. sm.value = stopping`);
        sm = StateMachine_exports.to(sm, `idle`);
        return;
      }
      if (sm.value === `disposed`) {
        log(`read. sm.value = disposed`);
        return;
      }
      events.set(v3.value);
    } catch (error) {
      events.dispose(`Generator error: ${error.toString()}`);
      return;
    }
    if (sm.value === `processing_result`) {
      sm = StateMachine_exports.to(sm, `queued`);
      log(`scheduling read. State: ${sm.value}`);
      setTimeout(read, readIntervalMs);
    } else {
      sm = StateMachine_exports.to(sm, `idle`);
    }
  };
  const events = initLazyStream({
    ...options,
    lazy,
    onStart() {
      log(`onStart state: ${sm.value} whenStopped: ${whenStopped}`);
      if (sm.value !== `idle`) return;
      if (sm.value === `idle` && whenStopped === `reset` || iterator2 === void 0) {
        iterator2 = isAsyncIterable(source) ? source[Symbol.asyncIterator]() : source[Symbol.iterator]();
      }
      void read();
    },
    onStop() {
      log(`onStop state: ${sm.value} whenStopped: ${whenStopped}`);
      sm = StateMachine_exports.to(sm, `stopping`);
      if (whenStopped === `reset`) {
        log(`onStop reiniting iterator`);
        iterator2 = isAsyncIterable(source) ? source[Symbol.asyncIterator]() : source[Symbol.iterator]();
      }
    },
    onDispose(reason) {
      log(`onDispose (${reason})`);
      ourAc?.abort(`Rx.From.iterator disposed (${reason})`);
      if (options.signal) options.signal.removeEventListener(`abort`, onExternalSignal);
    }
  });
  return events;
}
var resolveSource = (source, options = {}) => {
  if (isReactive(source)) return source;
  const generatorOptions = options.generator ?? { lazy: `initial`, interval: 5 };
  const functionOptions = options.function ?? { lazy: `very` };
  if (Array.isArray(source)) {
    return iterator(source.values(), generatorOptions);
  } else if (typeof source === `function`) {
    return func(source, functionOptions);
  } else if (typeof source === `object`) {
    if (isWrapped(source)) {
      return source.source;
    }
    if (isIterable(source) || isAsyncIterable(source)) {
      return iterator(source, generatorOptions);
    }
  }
  throw new TypeError(`Unable to resolve source. Supports: array, Reactive, Async/Iterable. Got type: ${typeof source}`);
};
function cache(r5, initialValue) {
  let lastValue = initialValue;
  r5.onValue((value2) => {
    lastValue = value2;
  });
  return {
    ...r5,
    last() {
      return lastValue;
    },
    resetCachedValue() {
      lastValue = void 0;
    }
  };
}
function initUpstream(upstreamSource, options) {
  const lazy = options.lazy ?? `initial`;
  const disposeIfSourceDone = options.disposeIfSourceDone ?? true;
  const onValue = options.onValue ?? ((_v) => {
  });
  const source = resolveSource(upstreamSource);
  let unsub;
  const debugLabel = options.debugLabel ? `[${options.debugLabel}]` : ``;
  const onStart = () => {
    if (unsub !== void 0) return;
    if (options.onStart) options.onStart();
    unsub = source.on((value2) => {
      if (messageIsSignal(value2)) {
        if (value2.signal === `done`) {
          stop();
          events.signal(value2.signal, value2.context);
          if (disposeIfSourceDone) events.dispose(`Upstream source ${debugLabel} has completed (${value2.context ?? ``})`);
        } else {
          events.signal(value2.signal, value2.context);
        }
      } else if (messageHasValue(value2)) {
        onValue(value2.value);
      }
    });
  };
  const onStop = () => {
    if (unsub === void 0) return;
    unsub();
    unsub = void 0;
    if (options.onStop) options.onStop();
  };
  const events = initLazyStream({
    ...options,
    lazy,
    onStart,
    onStop
  });
  return events;
}
function initLazyStream(options) {
  const lazy = options.lazy ?? `initial`;
  const onStop = options.onStop ?? (() => {
  });
  const onStart = options.onStart ?? (() => {
  });
  const debugLabel = options.debugLabel ? `[${options.debugLabel}]` : ``;
  const events = initStream({
    ...options,
    onFirstSubscribe() {
      if (lazy !== `never`) {
        onStart();
      }
    },
    onNoSubscribers() {
      if (lazy === `very`) {
        onStop();
      }
    }
  });
  if (lazy === `never`) onStart();
  return events;
}
function initStream(options = {}) {
  let dispatcher;
  let disposed = false;
  let firstSubscribe = false;
  let emptySubscriptions = true;
  const onFirstSubscribe = options.onFirstSubscribe ?? void 0;
  const onNoSubscribers = options.onNoSubscribers ?? void 0;
  const debugLabel = options.debugLabel ? `[${options.debugLabel}]` : ``;
  const isEmpty5 = () => {
    if (dispatcher === void 0) return;
    if (!dispatcher.isEmpty) return;
    if (!emptySubscriptions) {
      emptySubscriptions = true;
      firstSubscribe = false;
      if (onNoSubscribers) onNoSubscribers();
    }
  };
  const subscribe = (handler) => {
    if (disposed) throw new Error(`Disposed, cannot subscribe ${debugLabel}`);
    if (dispatcher === void 0) dispatcher = new DispatchList();
    const id = dispatcher.add(handler);
    emptySubscriptions = false;
    if (!firstSubscribe) {
      firstSubscribe = true;
      if (onFirstSubscribe) onFirstSubscribe();
    }
    return () => {
      dispatcher?.remove(id);
      isEmpty5();
    };
  };
  return {
    dispose: (reason) => {
      if (disposed) return;
      dispatcher?.notify({ value: void 0, signal: `done`, context: `Disposed: ${reason}` });
      disposed = true;
      if (options.onDispose) options.onDispose(reason);
    },
    isDisposed: () => {
      return disposed;
    },
    removeAllSubscribers: () => {
      dispatcher?.clear();
      isEmpty5();
    },
    set: (v3) => {
      if (disposed) throw new Error(`${debugLabel} Disposed, cannot set`);
      dispatcher?.notify({ value: v3 });
    },
    // through: (pass: Passed<V>) => {
    //   if (disposed) throw new Error(`Disposed, cannot through`);
    //   dispatcher?.notify(pass)
    // },
    signal: (signal, context) => {
      if (disposed) throw new Error(`${debugLabel} Disposed, cannot signal`);
      dispatcher?.notify({ signal, value: void 0, context });
    },
    on: (handler) => subscribe(handler),
    onValue: (handler) => {
      const unsub = subscribe((message) => {
        if (messageHasValue(message)) {
          handler(message.value);
        }
      });
      return unsub;
    }
  };
}
function setProperty(property, selectors, value2) {
  let elements2 = [];
  const set3 = (v3) => {
    const typ = typeof v3;
    const vv = typ === `string` || typ === `number` || typ === `boolean` ? v3 : JSON.stringify(v3);
    if (elements2.length === 0) {
      elements2 = resolveEls(selectors);
    }
    for (const element of elements2) {
      element[property] = vv;
    }
    return vv;
  };
  return value2 === void 0 ? set3 : set3(value2);
}
var setHtmlText = (rxOrSource, optionsOrElementOrQuery) => {
  let el;
  let options;
  if (typeof optionsOrElementOrQuery === `string`) {
    options = { query: optionsOrElementOrQuery };
  }
  if (typeof optionsOrElementOrQuery === `object`) {
    if (`nodeName` in optionsOrElementOrQuery) {
      options = { el: optionsOrElementOrQuery };
    } else {
      options = optionsOrElementOrQuery;
    }
  }
  if (options === void 0) throw new TypeError(`Missing element as second parameter or option`);
  if (`el` in options) {
    el = options.el;
  } else if (`query` in options) {
    el = document.querySelector(options.query);
  } else {
    throw new TypeError(`Options does not include 'el' or 'query' fields`);
  }
  if (el === null || el === void 0) throw new Error(`Element could not be resolved.`);
  const stream = resolveSource(rxOrSource);
  const setter = setProperty(options.asHtml ? `innerHTML` : `textContent`, el);
  const off = stream.onValue((value2) => {
    setter(value2);
  });
  return off;
};
var toReadable = (stream) => ({
  on: stream.on,
  dispose: stream.dispose,
  isDisposed: stream.isDisposed,
  onValue: stream.onValue
});
function annotate(input, annotator, options = {}) {
  const upstream = initUpstream(input, {
    ...options,
    onValue(value2) {
      const annotation = annotator(value2);
      upstream.set({ value: value2, annotation });
    }
  });
  return toReadable(upstream);
}
function annotateWithOp(input, annotatorOp) {
  const inputStream = resolveSource(input);
  const stream = annotatorOp(inputStream);
  const synced = syncToObject({
    value: inputStream,
    annotation: stream
  });
  return synced;
}
function chunk(source, options = {}) {
  const queue = new QueueMutable();
  const quantity = options.quantity ?? 0;
  const returnRemainder = options.returnRemainder ?? true;
  const upstreamOpts = {
    ...options,
    onStop() {
      if (returnRemainder && !queue.isEmpty) {
        const data = queue.toArray();
        queue.clear();
        upstream.set(data);
      }
    },
    onValue(value2) {
      queue.enqueue(value2);
      if (quantity > 0 && queue.length >= quantity) {
        send();
      }
      if (timer !== void 0 && timer.runState === `idle`) {
        timer.start();
      }
    }
  };
  const upstream = initUpstream(source, upstreamOpts);
  const send = () => {
    if (queue.isEmpty) return;
    if (timer !== void 0) timer.start();
    const data = queue.toArray();
    queue.clear();
    upstream.set(data);
  };
  const timer = options.elapsed ? timeout(send, options.elapsed) : void 0;
  return toReadable(upstream);
}
function transform(input, transformer, options = {}) {
  const traceInput = options.traceInput ?? false;
  const traceOutput = options.traceOutput ?? false;
  const upstream = initUpstream(input, {
    lazy: `initial`,
    ...options,
    onValue(value2) {
      const t6 = transformer(value2);
      if (traceInput && traceOutput) {
        console.log(`Rx.Ops.transform input: ${JSON.stringify(value2)} output: ${JSON.stringify(t6)}`);
      } else if (traceInput) {
        console.log(`Rx.Ops.transform input: ${JSON.stringify(value2)}`);
      } else if (traceOutput) {
        console.log(`Rx.Ops.transform output: ${JSON.stringify(t6)}`);
      }
      upstream.set(t6);
    }
  });
  return toReadable(upstream);
}
var cloneFromFields = (source) => {
  return transform(source, (v3) => {
    const entries2 = [];
    for (const field2 in v3) {
      const value2 = v3[field2];
      if (isPlainObjectOrPrimitive(value2)) {
        entries2.push([field2, value2]);
      }
    }
    return Object.fromEntries(entries2);
  });
};
function combineLatestToArray(reactiveSources, options = {}) {
  const event2 = initStream();
  const onSourceDone = options.onSourceDone ?? `break`;
  const data = [];
  const sources = reactiveSources.map((source) => resolveSource(source));
  const noop = () => {
  };
  const sourceOff = sources.map((_3) => noop);
  const doneSources = sources.map((_3) => false);
  const unsub = () => {
    for (const v3 of sourceOff) {
      v3();
    }
  };
  for (const [index, v3] of sources.entries()) {
    data[index] = void 0;
    sourceOff[index] = v3.on((message) => {
      if (messageIsDoneSignal(message)) {
        doneSources[index] = true;
        sourceOff[index]();
        sourceOff[index] = noop;
        if (onSourceDone === `break`) {
          unsub();
          event2.dispose(`Source has completed and 'break' is set`);
          return;
        }
        if (!doneSources.includes(false)) {
          unsub();
          event2.dispose(`All sources completed`);
        }
      } else if (messageHasValue(message)) {
        data[index] = message.value;
        event2.set([...data]);
      }
    });
  }
  return {
    dispose: event2.dispose,
    isDisposed: event2.isDisposed,
    on: event2.on,
    onValue: event2.onValue
  };
}
var Pathed_exports = {};
__export(Pathed_exports, {
  applyChanges: () => applyChanges,
  compareData: () => compareData2,
  getField: () => getField,
  getPaths: () => getPaths,
  getPathsAndData: () => getPathsAndData,
  updateByPath: () => updateByPath
});
var isEqualContextString = (a4, b4, _path) => {
  return JSON.stringify(a4) === JSON.stringify(b4);
};
var getEntries = (target, deepProbe) => {
  if (target === void 0) throw new Error(`Param 'target' is undefined`);
  if (target === null) throw new Error(`Param 'target' is null`);
  if (typeof target !== `object`) throw new Error(`Param 'target' is not an object (got: ${typeof target})`);
  if (deepProbe) {
    const entries2 = [];
    for (const field2 in target) {
      const value2 = target[field2];
      if (isPlainObjectOrPrimitive(value2)) {
        entries2.push([field2, value2]);
      }
    }
    return entries2;
  } else {
    return Object.entries(target);
  }
};
function* compareData2(a4, b4, options = {}) {
  if (a4 === void 0) {
    yield {
      path: options.pathPrefix ?? ``,
      value: b4,
      state: `added`
    };
    return;
  }
  if (b4 === void 0) {
    yield { path: options.pathPrefix ?? ``, previous: a4, value: void 0, state: `removed` };
    return;
  }
  const asPartial = options.asPartial ?? false;
  const undefinedValueMeansRemoved = options.undefinedValueMeansRemoved ?? false;
  const pathPrefix = options.pathPrefix ?? ``;
  const deepEntries = options.deepEntries ?? false;
  const eq = options.eq ?? isEqualContextString;
  const includeMissingFromA = options.includeMissingFromA ?? false;
  const includeParents = options.includeParents ?? false;
  if (isPrimitive(a4) && isPrimitive(b4)) {
    if (a4 !== b4) yield { path: pathPrefix, value: b4, previous: a4, state: `change` };
    return;
  }
  if (isPrimitive(b4)) {
    yield { path: pathPrefix, value: b4, previous: a4, state: `change` };
    return;
  }
  const entriesA = getEntries(a4, deepEntries);
  const entriesAKeys = /* @__PURE__ */ new Set();
  for (const [key, valueA] of entriesA) {
    entriesAKeys.add(key);
    const keyOfAInB = key in b4;
    const valueOfKeyInB = b4[key];
    if (typeof valueA === `object` && valueA !== null) {
      if (keyOfAInB) {
        if (valueOfKeyInB === void 0) {
          throw new Error(`Pathed.compareData Value for key ${key} is undefined`);
        } else {
          const sub = [...compareData2(valueA, valueOfKeyInB, {
            ...options,
            pathPrefix: pathPrefix + key + `.`
          })];
          if (sub.length > 0) {
            for (const s3 of sub) yield s3;
            if (includeParents) {
              yield { path: pathPrefix + key, value: b4[key], previous: valueA, state: `change` };
            }
          }
        }
      } else {
        if (asPartial) continue;
        yield { path: pathPrefix + key, value: void 0, previous: valueA, state: `removed` };
      }
    } else {
      const subPath = pathPrefix + key;
      if (keyOfAInB) {
        if (valueOfKeyInB === void 0 && undefinedValueMeansRemoved) {
          yield { path: subPath, previous: valueA, value: void 0, state: `removed` };
        } else {
          if (!eq(valueA, valueOfKeyInB, subPath)) {
            yield { path: subPath, previous: valueA, value: valueOfKeyInB, state: `change` };
          }
        }
      } else {
        if (asPartial) continue;
        yield { path: subPath, previous: valueA, value: void 0, state: `removed` };
      }
    }
  }
  if (includeMissingFromA) {
    const entriesB = getEntries(b4, deepEntries);
    for (const [key, valueB] of entriesB) {
      if (entriesAKeys.has(key)) continue;
      yield { path: pathPrefix + key, previous: void 0, value: valueB, state: `added` };
    }
  }
}
var applyChanges = (source, changes) => {
  for (const change of changes) {
    source = updateByPath(source, change.path, change.value);
  }
  return source;
};
var updateByPath = (target, path2, value2, allowShapeChange = false) => {
  if (path2 === void 0) throw new Error(`Parameter 'path' is undefined`);
  if (typeof path2 !== `string`) throw new Error(`Parameter 'path' should be a string. Got: ${typeof path2}`);
  if (target === void 0) throw new Error(`Parameter 'target' is undefined`);
  if (target === null) throw new Error(`Parameter 'target' is null`);
  const split2 = path2.split(`.`);
  const r5 = updateByPathImpl(target, split2, value2, allowShapeChange);
  return r5;
};
var updateByPathImpl = (o5, split2, value2, allowShapeChange) => {
  if (split2.length === 0) {
    if (allowShapeChange) return value2;
    if (Array.isArray(o5) && !Array.isArray(value2)) throw new Error(`Expected array value, got: '${JSON.stringify(value2)}'. Set allowShapeChange=true to ignore.`);
    if (!Array.isArray(o5) && Array.isArray(value2)) throw new Error(`Unexpected array value, got: '${JSON.stringify(value2)}'. Set allowShapeChange=true to ignore.`);
    if (typeof o5 !== typeof value2) throw new Error(`Cannot reassign object type. (${typeof o5} -> ${typeof value2}). Set allowShapeChange=true to ignore.`);
    if (typeof o5 === `object` && !Array.isArray(o5)) {
      const c6 = compareKeys(o5, value2);
      if (c6.a.length > 0) {
        throw new Error(`New value is missing key(s): ${c6.a.join(`,`)}`);
      }
      if (c6.b.length > 0) {
        throw new Error(`New value cannot add new key(s): ${c6.b.join(`,`)}`);
      }
    }
    return value2;
  }
  const start = split2.shift();
  if (!start) return value2;
  const isInt = isInteger(start);
  if (isInt && Array.isArray(o5)) {
    const index = Number.parseInt(start);
    if (index >= o5.length && !allowShapeChange) throw new Error(`Array index ${index.toString()} is outside of the existing length of ${o5.length.toString()}. Use allowShapeChange=true to permit this.`);
    const copy = [...o5];
    copy[index] = updateByPathImpl(copy[index], split2, value2, allowShapeChange);
    return copy;
  } else if (start in o5) {
    const copy = { ...o5 };
    copy[start] = updateByPathImpl(copy[start], split2, value2, allowShapeChange);
    return copy;
  } else {
    throw new Error(`Path ${start} not found in data`);
  }
};
var getField = (object2, path2) => {
  if (typeof path2 !== `string`) throw new Error(`Param 'path' ought to be a string. Got: '${typeof path2}'`);
  if (path2.length === 0) throw new Error(`Param string 'path' is empty`);
  if (object2 === void 0) throw new Error(`Param 'object' is undefined`);
  if (object2 === null) throw new Error(`Param 'object' is null`);
  const split2 = path2.split(`.`);
  const v3 = getFieldImpl(object2, split2);
  return v3;
};
var getFieldImpl = (object2, split2) => {
  if (object2 === void 0) throw new Error(`Param 'object' is undefined`);
  if (split2.length === 0) throw new Error(`Path has run out`);
  const start = split2.shift();
  if (!start) throw new Error(`Unexpected empty split path`);
  const isInt = isInteger(start);
  if (isInt && Array.isArray(object2)) {
    const index = Number.parseInt(start);
    if (typeof object2[index] === `undefined`) {
      return { success: false, error: `Index ${index} is not present` };
    }
    if (split2.length === 0) {
      return { value: object2[index], success: true };
    } else {
      return getFieldImpl(object2[index], split2);
    }
  } else if (typeof object2 === `object` && start in object2) {
    if (split2.length === 0) {
      return { value: object2[start], success: true };
    } else {
      return getFieldImpl(object2[start], split2);
    }
  } else {
    return { success: false, error: `Path '${start}' not found` };
  }
};
function* getPaths(object2, onlyLeaves = false) {
  if (object2 === void 0 || object2 === null) return;
  const iter = depthFirst2(object2);
  for (const c6 of iter) {
    if (c6.nodeValue === void 0 && onlyLeaves) continue;
    let path2 = c6.name;
    if (c6.ancestors.length > 0) path2 = c6.ancestors.join(`.`) + `.` + path2;
    yield path2;
  }
}
function* getPathsAndData(o5, onlyLeaves = false, maxDepth = Number.MAX_SAFE_INTEGER, prefix = ``) {
  if (o5 === null) return;
  if (o5 === void 0) return;
  yield* getPathsAndDataImpl(o5, prefix, onlyLeaves, maxDepth);
}
function* getPathsAndDataImpl(o5, prefix, onlyLeaves = false, maxDepth) {
  if (maxDepth <= 0) return;
  if (typeof o5 !== `object`) return;
  for (const entries2 of Object.entries(o5)) {
    const sub = (prefix.length > 0 ? prefix + `.` : ``) + entries2[0];
    const value2 = entries2[1];
    const leaf = typeof value2 !== `object`;
    if (onlyLeaves && leaf || !onlyLeaves) {
      yield { path: sub, value: value2 };
    }
    yield* getPathsAndDataImpl(value2, sub, onlyLeaves, maxDepth - 1);
  }
}
function object(initialValue, options = {}) {
  const eq = options.eq ?? isEqualContextString;
  const setEvent = initStream();
  const diffEvent = initStream();
  const fieldChangeEvents = [];
  let value2 = initialValue;
  let disposed = false;
  const set3 = (v3) => {
    const diff = [...compareData2(value2 ?? {}, v3, { ...options, includeMissingFromA: true })];
    if (diff.length === 0) return;
    value2 = v3;
    setEvent.set(v3);
    diffEvent.set(diff);
  };
  const fireFieldUpdate = (field2, value22) => {
    for (const [matcher, pattern, list] of fieldChangeEvents) {
      if (matcher(field2)) {
        list.notify({ fieldName: field2, pattern, value: value22 });
      }
    }
  };
  const updateCompareOptions = {
    asPartial: true,
    includeParents: true
  };
  const update = (toMerge) => {
    if (value2 === void 0) {
      value2 = toMerge;
      setEvent.set(value2);
      for (const [k3, v3] of Object.entries(toMerge)) {
        fireFieldUpdate(k3, v3);
      }
      return value2;
    } else {
      const diff = [...compareData2(value2, toMerge, updateCompareOptions)];
      if (diff.length === 0) return value2;
      value2 = {
        ...value2,
        ...toMerge
      };
      setEvent.set(value2);
      diffEvent.set(diff);
      for (const d4 of diff) {
        fireFieldUpdate(d4.path, d4.value);
      }
      return value2;
    }
  };
  const updateField = (path2, valueForField) => {
    if (value2 === void 0) throw new Error(`Cannot update value when it has not already been set`);
    const existing = getField(value2, path2);
    throwResult(existing);
    if (eq(existing.value, valueForField, path2)) {
      return;
    }
    let diff = [...compareData2(existing.value, valueForField, { ...options, includeMissingFromA: true })];
    diff = diff.map((d4) => {
      if (d4.path.length > 0) return { ...d4, path: path2 + `.` + d4.path };
      return { ...d4, path: path2 };
    });
    const o5 = updateByPath(value2, path2, valueForField, true);
    value2 = o5;
    setEvent.set(o5);
    diffEvent.set(diff);
    fireFieldUpdate(path2, valueForField);
  };
  const dispose = (reason) => {
    if (disposed) return;
    diffEvent.dispose(reason);
    setEvent.dispose(reason);
    disposed = true;
  };
  return {
    dispose,
    isDisposed() {
      return disposed;
    },
    /**
     * Update a field.
     * Exception is thrown if field does not exist
     */
    updateField,
    last: () => value2,
    on: setEvent.on,
    onValue: setEvent.onValue,
    onDiff: diffEvent.onValue,
    onField(fieldPattern, handler) {
      const matcher = wildcard(fieldPattern);
      const listeners = new DispatchList();
      fieldChangeEvents.push([matcher, fieldPattern, listeners]);
      const id = listeners.add(handler);
      return () => listeners.remove(id);
    },
    /**
     * Set the whole object
     */
    set: set3,
    /**
     * Update the object with a partial set of fields and values
     */
    update
  };
}
function combineLatestToObject(reactiveSources, options = {}) {
  const disposeSources = options.disposeSources ?? true;
  const event2 = object(void 0);
  const onSourceDone = options.onSourceDone ?? `break`;
  const emitInitial = options.emitInitial ?? true;
  let emitInitialDone = false;
  const states = /* @__PURE__ */ new Map();
  for (const [key, source] of Object.entries(reactiveSources)) {
    const initialData = `last` in source ? source.last() : void 0;
    const s3 = {
      source: resolveSource(source),
      done: false,
      data: initialData,
      off: () => {
      }
    };
    states.set(key, s3);
  }
  const sources = Object.fromEntries(Object.entries(states).map((entry) => [entry[0], entry[1].source]));
  const someUnfinished = () => some(states, (v3) => !v3.done);
  const unsub = () => {
    for (const state of states.values()) state.off();
  };
  const getData = () => {
    const r5 = {};
    for (const [key, state] of states) {
      const d4 = state.data;
      if (d4 !== void 0) {
        r5[key] = state.data;
      }
    }
    return r5;
  };
  const trigger = () => {
    emitInitialDone = true;
    const d4 = getData();
    event2.set(d4);
  };
  const wireUpState = (state) => {
    state.off = state.source.on((message) => {
      if (messageIsDoneSignal(message)) {
        state.done = true;
        state.off();
        state.off = () => {
        };
        if (onSourceDone === `break`) {
          unsub();
          event2.dispose(`Source has completed and 'break' is behaviour`);
          return;
        }
        if (!someUnfinished()) {
          unsub();
          event2.dispose(`All sources completed`);
        }
      } else if (messageHasValue(message)) {
        state.data = message.value;
        trigger();
      }
    });
  };
  for (const state of states.values()) {
    wireUpState(state);
  }
  if (!emitInitialDone && emitInitial) {
    trigger();
  }
  return {
    ...event2,
    hasSource(field2) {
      return states.has(field2);
    },
    replaceSource(field2, source) {
      const state = states.get(field2);
      if (state === void 0) throw new Error(`Field does not exist: '${field2}'`);
      state.off();
      const s3 = resolveSource(source);
      state.source = s3;
      wireUpState(state);
    },
    setWith(data) {
      let written = {};
      for (const [key, value2] of Object.entries(data)) {
        const state = states.get(key);
        if (state !== void 0) {
          if (isWritable(state.source)) {
            state.source.set(value2);
            written[key] = value2;
          }
          state.data = value2;
        }
      }
      return written;
    },
    sources,
    last() {
      return getData();
    },
    dispose(reason) {
      unsub();
      event2.dispose(reason);
      if (disposeSources) {
        for (const v3 of states.values()) {
          v3.source.dispose(`Part of disposed mergeToObject`);
        }
      }
    }
  };
}
function computeWithPrevious(input, fn2) {
  let previousValue;
  let currentValue;
  if (hasLast(input)) {
    currentValue = previousValue = input.last();
  }
  const trigger = () => {
    if (previousValue === void 0 && currentValue !== void 0) {
      previousValue = currentValue;
      upstream.set(previousValue);
    } else if (previousValue !== void 0 && currentValue !== void 0) {
      const vv = fn2(previousValue, currentValue);
      previousValue = vv;
      upstream.set(vv);
    }
  };
  const upstream = initUpstream(input, {
    lazy: "very",
    debugLabel: `computeWithPrevious`,
    onValue(value2) {
      currentValue = value2;
      trigger();
    }
  });
  if (currentValue) trigger();
  return {
    ...toReadable(upstream),
    ping: () => {
      if (currentValue !== void 0) trigger();
    }
  };
}
function debounce2(source, options = {}) {
  const elapsed22 = intervalToMs(options.elapsed, 50);
  let lastValue;
  const timer = timeout(() => {
    const v3 = lastValue;
    if (v3) {
      upstream.set(v3);
      lastValue = void 0;
    }
  }, elapsed22);
  const upstream = initUpstream(source, {
    ...options,
    onValue(value2) {
      lastValue = value2;
      timer.start();
    }
  });
  return toReadable(upstream);
}
var elapsed = (input) => {
  let last3 = 0;
  return transform(input, (_ignored) => {
    const elapsed22 = last3 === 0 ? 0 : Date.now() - last3;
    last3 = Date.now();
    return elapsed22;
  });
};
function field(fieldSource, fieldName, options = {}) {
  const fallbackFieldValue = options.fallbackFieldValue;
  const fallbackObject = options.fallbackObject;
  const upstream = initUpstream(fieldSource, {
    disposeIfSourceDone: true,
    ...options,
    onValue(value2) {
      let v3;
      if (fieldName in value2) {
        v3 = value2[fieldName];
      } else if (fallbackObject && fieldName in fallbackObject) {
        v3 = fallbackObject[fieldName];
      }
      if (v3 === void 0) {
        v3 = fallbackFieldValue;
      }
      if (v3 !== void 0) {
        upstream.set(v3);
      }
    }
  });
  return toReadable(upstream);
}
function filter22(input, predicate, options) {
  const upstream = initUpstream(input, {
    ...options,
    onValue(value2) {
      if (predicate(value2)) {
        upstream.set(value2);
      }
    }
  });
  return toReadable(upstream);
}
function drop(input, predicate, options) {
  const upstream = initUpstream(input, {
    ...options,
    onValue(value2) {
      if (!predicate(value2)) {
        upstream.set(value2);
      }
    }
  });
  return toReadable(upstream);
}
function interpolate22(input, options = {}) {
  const amount = options.amount ?? 0.1;
  const snapAt = options.snapAt ?? 0.99;
  const i4 = interpolate(amount, options);
  return computeWithPrevious(input, (previous, target) => {
    const v3 = i4(previous, target);
    if (target > previous) {
      if (v3 / target >= snapAt) return target;
    }
    return v3;
  });
}
var max22 = () => {
  let max42 = Number.MIN_SAFE_INTEGER;
  const compute = (value2) => {
    const valueArray = Array.isArray(value2) ? value2 : [value2];
    for (const subValue of valueArray) {
      if (typeof subValue !== `number`) break;
      max42 = Math.max(subValue, max42);
    }
    return max42;
  };
  return compute;
};
var min3 = () => {
  let min52 = Number.MAX_SAFE_INTEGER;
  const compute = (value2) => {
    const valueArray = Array.isArray(value2) ? value2 : [value2];
    for (const subValue of valueArray) {
      if (typeof subValue !== `number`) break;
      min52 = Math.min(subValue, min52);
    }
    return min52;
  };
  return compute;
};
var sum = () => {
  let t6 = 0;
  const compute = (value2) => {
    const valueArray = Array.isArray(value2) ? value2 : [value2];
    for (const subValue of valueArray) {
      if (typeof subValue !== `number`) continue;
      t6 += subValue;
    }
    return t6;
  };
  return compute;
};
var average = () => {
  let total = 0;
  let tally3 = 0;
  const compute = (value2) => {
    const valueArray = Array.isArray(value2) ? value2 : [value2];
    for (const subValue of valueArray) {
      if (typeof subValue !== `number`) continue;
      tally3++;
      total += subValue;
    }
    return total / tally3;
  };
  return compute;
};
var tally = (countArrayItems) => {
  let t6 = 0;
  const compute = (value2) => {
    if (countArrayItems) {
      if (Array.isArray(value2)) t6 += value2.length;
      else t6++;
    } else {
      t6++;
    }
    return t6;
  };
  return compute;
};
function rank(r5, options = {}) {
  const includeType = options.includeType;
  const emitEqualRanked = options.emitEqualRanked ?? false;
  const emitRepeatHighest = options.emitRepeatHighest ?? false;
  let best;
  return (value2) => {
    if (includeType && typeof value2 !== includeType) return;
    if (best === void 0) {
      best = value2;
      return best;
    } else {
      const result = r5(value2, best);
      if (result == `a`) {
        best = value2;
        return best;
      } else if (result === `eq` && emitEqualRanked) {
        return best;
      } else if (emitRepeatHighest) {
        return best;
      }
    }
  };
}
function max32(input, options) {
  const p4 = max22();
  return process2(p4, `max`, input, options);
}
function min4(input, options) {
  const p4 = min3();
  return process2(p4, `min`, input, options);
}
function average2(input, options) {
  const p4 = average();
  return process2(p4, `average`, input, options);
}
function sum2(input, options) {
  const p4 = sum();
  return process2(p4, `sum`, input, options);
}
function tally2(input, options = {}) {
  const countArrayItems = options.countArrayItems ?? true;
  const p4 = tally(countArrayItems);
  return process2(p4, `tally`, input, options);
}
function rank2(input, rank3, options) {
  const p4 = rank(rank3, options);
  return process2(p4, `rank`, input, options);
}
function process2(processor, annotationField, input, options = {}) {
  const annotate2 = options.annotate;
  let previous;
  const skipUndefined = options.skipUndefined ?? true;
  const skipIdentical = options.skipIdentical ?? true;
  const upstream = initUpstream(input, {
    ...options,
    onValue(value2) {
      const x3 = processor(value2);
      if (x3 === void 0 && skipUndefined) return;
      if (skipIdentical && x3 === previous) return;
      previous = x3;
      if (annotate2) {
        const ret = { value: value2 };
        ret[annotationField] = x3;
        upstream.set(ret);
      } else {
        upstream.set(x3);
      }
    }
  });
  return toReadable(upstream);
}
var pipe = (...streams) => {
  const event2 = initStream();
  const unsubs = [];
  const performDispose = (reason) => {
    for (const s3 of streams) {
      if (!s3.isDisposed) s3.dispose(reason);
    }
    for (const s3 of unsubs) {
      s3();
    }
    event2.dispose(reason);
  };
  for (let index = 0; index < streams.length; index++) {
    unsubs.push(streams[index].on((message) => {
      const isLast = index === streams.length - 1;
      if (messageHasValue(message)) {
        if (isLast) {
          event2.set(message.value);
        } else {
          streams[index + 1].set(message.value);
        }
      } else if (messageIsDoneSignal(message)) {
        performDispose(`Upstream disposed`);
      }
    }));
  }
  return {
    on: event2.on,
    onValue: event2.onValue,
    dispose(reason) {
      performDispose(reason);
    },
    isDisposed() {
      return event2.isDisposed();
    }
  };
};
function singleFromArray(source, options = {}) {
  const order = options.order ?? `default`;
  if (!options.at && !options.predicate) throw new Error(`Options must have 'predicate' or 'at' fields`);
  let preprocess = (values) => values;
  if (order === `random`) preprocess = shuffle;
  else if (typeof order === `function`) preprocess = (values) => values.toSorted(order);
  const upstream = initUpstream(source, {
    onValue(values) {
      values = preprocess(values);
      if (options.predicate) {
        for (const v3 of values) {
          if (options.predicate(v3)) {
            upstream.set(v3);
          }
        }
      } else if (options.at) {
        upstream.set(values.at(options.at));
      }
    }
  });
  return upstream;
}
var split = (rxOrSource, options = {}) => {
  const quantity = options.quantity ?? 2;
  const outputs = [];
  const source = resolveSource(rxOrSource);
  for (let index = 0; index < quantity; index++) {
    outputs.push(initUpstream(source, { disposeIfSourceDone: true, lazy: `initial` }));
  }
  return outputs;
};
var splitLabelled = (rxOrSource, labels) => {
  const source = resolveSource(rxOrSource);
  const t6 = {};
  for (const label of labels) {
    t6[label] = initUpstream(source, { lazy: `initial`, disposeIfSourceDone: true });
  }
  return t6;
};
var switcher = (reactiveOrSource, cases, options = {}) => {
  const match = options.match ?? `first`;
  const source = resolveSource(reactiveOrSource);
  let disposed = false;
  const t6 = {};
  for (const label of Object.keys(cases)) {
    t6[label] = initStream();
  }
  const performDispose = () => {
    if (disposed) return;
    unsub();
    disposed = true;
    for (const stream of Object.values(t6)) {
      stream.dispose(`switcher source dispose`);
    }
  };
  const unsub = source.on((message) => {
    if (messageHasValue(message)) {
      for (const [lbl, pred] of Object.entries(cases)) {
        if (pred(message.value)) {
          t6[lbl].set(message.value);
          if (match === `first`) break;
        }
      }
    } else if (messageIsDoneSignal(message)) {
      performDispose();
    }
  });
  return t6;
};
function syncToArray(reactiveSources, options = {}) {
  const onSourceDone = options.onSourceDone ?? `break`;
  const finalValue = options.finalValue ?? `undefined`;
  const maximumWait = intervalToMs(options.maximumWait, 2e3);
  let watchdog;
  const data = [];
  const states = reactiveSources.map((source) => ({
    finalData: void 0,
    done: false,
    source: resolveSource(source),
    unsub: () => {
    }
  }));
  const unsubscribe = () => {
    for (const s3 of states) {
      s3.unsub();
      s3.unsub = () => {
      };
    }
  };
  const isDataSetComplete = () => {
    for (let index = 0; index < data.length; index++) {
      if (onSourceDone === `allow` && states[index].done) continue;
      if (data[index] === void 0) return false;
    }
    return true;
  };
  const hasIncompleteSource = () => states.some((s3) => !s3.done);
  const resetDataSet = () => {
    for (let index = 0; index < data.length; index++) {
      if (finalValue === `last` && states[index].done) continue;
      data[index] = void 0;
    }
  };
  const onWatchdog = () => {
    done(`Sync timeout exceeded (${maximumWait.toString()})`);
  };
  const done = (reason) => {
    if (watchdog) clearTimeout(watchdog);
    unsubscribe();
    event2.dispose(reason);
  };
  const init5 = () => {
    watchdog = setTimeout(onWatchdog, maximumWait);
    for (const [index, state] of states.entries()) {
      data[index] = void 0;
      state.unsub = state.source.on((valueChanged) => {
        if (messageIsSignal(valueChanged)) {
          if (valueChanged.signal === `done`) {
            state.finalData = data[index];
            state.unsub();
            state.done = true;
            state.unsub = () => {
            };
            if (finalValue === `undefined`) data[index] = void 0;
            if (onSourceDone === `break`) {
              done(`Source '${index.toString()}' done, and onSourceDone:'break' is set`);
              return;
            }
            if (!hasIncompleteSource()) {
              done(`All sources done`);
              return;
            }
          }
          return;
        }
        data[index] = valueChanged.value;
        if (isDataSetComplete()) {
          event2.set([...data]);
          resetDataSet();
          if (watchdog) clearTimeout(watchdog);
          watchdog = setTimeout(onWatchdog, maximumWait);
        }
      });
    }
  };
  const event2 = initStream({
    onFirstSubscribe() {
      unsubscribe();
      init5();
    },
    onNoSubscribers() {
      if (watchdog) clearTimeout(watchdog);
      unsubscribe();
    }
  });
  return {
    dispose: event2.dispose,
    isDisposed: event2.isDisposed,
    on: event2.on,
    onValue: event2.onValue
  };
}
function syncToObject(reactiveSources, options = {}) {
  const keys = Object.keys(reactiveSources);
  const values = Object.values(reactiveSources);
  const s3 = syncToArray(values, options);
  const st3 = transform(s3, (streamValues) => {
    return zipKeyValue(keys, streamValues);
  });
  return st3;
}
var Process_exports = {};
__export(Process_exports, {
  CancelError: () => CancelError,
  average: () => average,
  cancelIfUndefined: () => cancelIfUndefined,
  flow: () => flow,
  ifNotUndefined: () => ifNotUndefined,
  ifUndefined: () => ifUndefined,
  max: () => max22,
  min: () => min3,
  rank: () => rank,
  seenLastToUndefined: () => seenLastToUndefined,
  seenToUndefined: () => seenToUndefined,
  seenToUndefinedByKey: () => seenToUndefinedByKey,
  sum: () => sum,
  tally: () => tally
});
function flow(...processors) {
  return (value2) => {
    let v3 = value2;
    for (const p4 of processors) {
      try {
        v3 = p4(v3);
      } catch (err) {
        if (err instanceof CancelError) {
          break;
        } else {
          throw err;
        }
      }
    }
    return v3;
  };
}
function seenLastToUndefined(eq) {
  if (eq === void 0) eq = isEqualDefault;
  let lastValue;
  return (value2) => {
    if (value2 !== lastValue) {
      lastValue = value2;
      return value2;
    }
    return void 0;
  };
}
function seenToUndefined(eq) {
  let seen = [];
  if (eq === void 0) eq = isEqualDefault;
  return (value2) => {
    if (value2 === void 0) return;
    for (const s3 of seen) {
      if (eq(s3, value2)) return;
    }
    seen.push(value2);
    return value2;
  };
}
function seenToUndefinedByKey(toString6) {
  let seen = /* @__PURE__ */ new Set();
  if (toString6 === void 0) toString6 = toStringDefault;
  return (value2) => {
    if (value2 === void 0) return;
    const key = toString6(value2);
    if (seen.has(key)) return;
    seen.add(key);
    return value2;
  };
}
function ifNotUndefined(fn2) {
  return (value2) => {
    if (value2 === void 0) return value2;
    const v3 = fn2(value2);
    return v3;
  };
}
var CancelError = class extends Error {
  constructor(message) {
    super(message);
    this.name = `CancelError`;
  }
};
function cancelIfUndefined() {
  return (value2) => {
    if (value2 === void 0) throw new CancelError(`cancel`);
    return value2;
  };
}
function ifUndefined(fn2) {
  return (value2) => {
    if (value2 === void 0) return fn2();
    else return value2;
  };
}
function tapProcess(input, ...processors) {
  const inputStream = resolveSource(input);
  const chain2 = (void 0)(...processors);
  inputStream.onValue((value2) => {
    chain2(value2);
  });
  return inputStream;
}
function tapStream(input, diverged) {
  const inputStream = resolveSource(input);
  inputStream.onValue((value2) => {
    diverged.set(value2);
  });
  return inputStream;
}
var tapOps = (input, ...ops) => {
  for (const op of ops) {
    input = op(input);
  }
  return input;
};
function throttle2(throttleSource, options = {}) {
  const elapsed22 = intervalToMs(options.elapsed, 0);
  let lastFire = performance.now();
  let lastValue;
  const upstream = initUpstream(throttleSource, {
    ...options,
    onValue(value2) {
      lastValue = value2;
      trigger();
    }
  });
  const trigger = () => {
    const now = performance.now();
    if (elapsed22 > 0 && now - lastFire > elapsed22) {
      lastFire = now;
      if (lastValue !== void 0) {
        upstream.set(lastValue);
      }
    }
  };
  return toReadable(upstream);
}
function timeoutValue(source, options) {
  let timer;
  const immediate = options.immediate ?? true;
  const repeat22 = options.repeat ?? false;
  const timeoutMs = intervalToMs(options.interval, 1e3);
  if (!isTrigger(options)) {
    throw new Error(`Param 'options' does not contain trigger 'value' or 'fn' fields`);
  }
  const sendFallback = () => {
    const [value2, done] = resolveTriggerValue(options);
    if (done) {
      events.dispose(`Trigger completed`);
    } else {
      if (events.isDisposed()) return;
      events.set(value2);
      if (repeat22) {
        timer = setTimeout(sendFallback, timeoutMs);
      }
    }
  };
  const events = initUpstream(source, {
    disposeIfSourceDone: true,
    // Received a value from upstream source
    onValue(v3) {
      if (timer) clearTimeout(timer);
      timer = setTimeout(sendFallback, timeoutMs);
      events.set(v3);
    },
    onDispose() {
      if (timer) clearTimeout(timer);
    }
  });
  if (immediate && !timer) {
    timer = setTimeout(sendFallback, timeoutMs);
  }
  return events;
}
function timeoutPing(source, options) {
  let timer;
  const rx = resolveSource(source);
  const abort = options.abort;
  const timeoutMs = intervalToMs(options, 1e3);
  const sendPing = () => {
    if (abort?.aborted || rx.isDisposed()) {
      off();
      return;
    }
    if (isPingable(rx)) rx.ping();
    timer = setTimeout(sendPing, timeoutMs);
  };
  const cancel = () => {
    if (timer) clearTimeout(timer);
  };
  const off = rx.on((msg) => {
    if (messageHasValue(msg)) {
      cancel();
      timer = setTimeout(sendPing, timeoutMs);
    } else if (messageIsDoneSignal(msg)) {
      off();
      cancel();
    }
  });
  timer = setTimeout(sendPing, timeoutMs);
  return rx;
}
function valueToPing(source, target, options = {}) {
  const lazy = options.lazy ?? `initial`;
  const signal = options.signal;
  const sourceRx = resolveSource(source);
  const gate = options.gate ?? ((value2) => true);
  let upstreamOff;
  let downstreamOff;
  if (signal) {
    signal.addEventListener(`abort`, () => {
      done(`Abort signal ${signal.reason}`);
    }, { once: true });
  }
  const events = initStream({
    onFirstSubscribe() {
      if (lazy !== `never` && upstreamOff === void 0) start();
    },
    onNoSubscribers() {
      if (lazy === `very` && upstreamOff !== void 0) {
        upstreamOff();
        upstreamOff = void 0;
      }
    }
  });
  const start = () => {
    upstreamOff = sourceRx.on((message) => {
      if (messageIsDoneSignal(message)) {
        done(`Upstream closed`);
      } else if (messageIsSignal(message)) {
        events.signal(message.signal);
      } else if (messageHasValue(message)) {
        if (gate(message.value)) {
          target.ping();
        }
      }
    });
    downstreamOff = target.on((message) => {
      if (messageIsDoneSignal(message)) {
        done(`Downstream closed`);
      } else if (messageIsSignal(message)) {
        events.signal(message.signal, message.context);
      } else if (messageHasValue(message)) {
        events.set(message.value);
      }
    });
  };
  const done = (reason) => {
    events.dispose(reason);
    if (upstreamOff) upstreamOff();
    if (downstreamOff) downstreamOff();
  };
  if (lazy === `never`) start();
  return events;
}
function withValue(input, options) {
  let lastValue = options.initial;
  const upstream = initUpstream(input, {
    ...options,
    onValue(value2) {
      lastValue = value2;
      upstream.set(value2);
    }
  });
  const readable = toReadable(upstream);
  return {
    ...readable,
    // @ts-expect-error
    last() {
      return lastValue;
    }
  };
}
var DirectedGraph_exports = {};
__export(DirectedGraph_exports, {
  adjacentVertices: () => adjacentVertices,
  areAdjacent: () => areAdjacent,
  bfs: () => bfs,
  clone: () => clone2,
  connect: () => connect,
  connectTo: () => connectTo,
  connectWithEdges: () => connectWithEdges,
  createVertex: () => createVertex,
  dfs: () => dfs,
  disconnect: () => disconnect,
  distance: () => distance2,
  distanceDefault: () => distanceDefault,
  dumpGraph: () => dumpGraph,
  edges: () => edges,
  get: () => get3,
  getCycles: () => getCycles,
  getOrCreate: () => getOrCreate,
  getOrFail: () => getOrFail,
  graph: () => graph,
  graphFromVertices: () => graphFromVertices,
  hasKey: () => hasKey,
  hasNoOuts: () => hasNoOuts,
  hasOnlyOuts: () => hasOnlyOuts,
  hasOut: () => hasOut,
  isAcyclic: () => isAcyclic,
  pathDijkstra: () => pathDijkstra,
  toAdjacencyMatrix: () => toAdjacencyMatrix,
  topologicalSort: () => topologicalSort,
  transitiveReduction: () => transitiveReduction,
  updateGraphVertex: () => updateGraphVertex,
  vertexHasOut: () => vertexHasOut,
  vertices: () => vertices
});
var PriorityMutable = class extends QueueMutable {
  constructor(opts = {}) {
    if (opts.eq === void 0) {
      opts = {
        ...opts,
        eq: (a4, b4) => {
          return isEqualDefault(a4.item, b4.item);
        }
      };
    }
    super(opts);
  }
  /**
   * Adds an item with a given priority
   * @param item Item
   * @param priority Priority (higher numeric value means higher priority)
   */
  enqueueWithPriority(item, priority2) {
    throwNumberTest(priority2, `positive`);
    super.enqueue({ item, priority: priority2 });
  }
  changePriority(item, priority2, addIfMissing = false, eq) {
    if (item === void 0) throw new Error(`Item cannot be undefined`);
    let toDelete;
    for (const d4 of this.data) {
      if (eq) {
        if (eq(d4.item, item)) {
          toDelete = d4;
          break;
        }
      } else {
        if (this.eq(d4, { item, priority: 0 })) {
          toDelete = d4;
          break;
        }
      }
    }
    if (toDelete === void 0 && !addIfMissing) throw new Error(`Item not found in priority queue. Item: ${JSON.stringify(item)}`);
    if (toDelete !== void 0) {
      this.removeWhere((item2) => toDelete === item2);
    }
    this.enqueueWithPriority(item, priority2);
  }
  dequeueMax() {
    const m5 = maxScore(this.data, (v3) => v3.priority);
    if (m5 === void 0) return;
    this.removeWhere((item) => item === m5);
    return m5.item;
  }
  dequeueMin() {
    const m5 = min2(this.data, (v3) => v3.priority);
    if (m5 === void 0) return;
    this.removeWhere((item) => item === m5);
    return m5.item;
  }
  peekMax() {
    const m5 = maxScore(this.data, (v3) => v3.priority);
    if (m5 === void 0) return;
    return m5.item;
  }
  peekMin() {
    const m5 = min2(this.data, (v3) => v3.priority);
    if (m5 === void 0) return;
    return m5.item;
  }
};
function priority(opts = {}) {
  return new PriorityMutable(opts);
}
var Table = class {
  constructor() {
    this.rows = [];
    this.rowLabels = [];
    this.colLabels = [];
  }
  labelColumns(...labels) {
    this.colLabels = labels;
  }
  labelColumn(columnNumber, label) {
    this.colLabels[columnNumber] = label;
  }
  getColumnLabelIndex(label) {
    for (const [index, l3] of this.colLabels.entries()) {
      if (l3 === label) return index;
    }
  }
  print() {
    console.table([...this.rowsWithLabelsObject()]);
  }
  *rowsWithLabelsArray() {
    for (let index = 0; index < this.rows.length; index++) {
      const labelledRow = this.getRowWithLabelsArray(index);
      yield labelledRow;
    }
  }
  /**
   * Return a copy of table as nested array
   * ```js
   * const t = new Table();
   * // add stuff
   * // ...
   * const m = t.asArray();
   * for (const row of m) {
   *  for (const colValue of row) {
   *    // iterate over all column values for this row
   *  }
   * }
   * ```
   * 
   * Alternative: get value at row Y and column X
   * ```js
   * const value = m[y][x];
   * ```
   * @returns 
   */
  asArray() {
    const r5 = [];
    for (const row of this.rows) {
      if (row === void 0) r5.push([]);
      else r5.push([...row]);
    }
    return r5;
  }
  /**
   * Return the number of rows
   */
  get rowCount() {
    return this.rows.length;
  }
  /**
   * Return the maximum number of columns in any row
   */
  get columnCount() {
    const lengths3 = this.rows.map((row) => row.length);
    return Math.max(...lengths3);
  }
  *rowsWithLabelsObject() {
    for (let index = 0; index < this.rows.length; index++) {
      const labelledRow = this.getRowWithLabelsObject(index);
      yield labelledRow;
    }
  }
  labelRows(...labels) {
    this.rowLabels = labels;
  }
  appendRow(...data) {
    this.rows.push(data);
  }
  getRowWithLabelsArray(rowNumber) {
    const row = this.rows.at(rowNumber);
    if (row === void 0) return void 0;
    return row.map((value2, index) => [this.colLabels.at(index), value2]);
  }
  /**
   * Return a row of objects. Keys use the column labels.
   * 
   * ```js
   * const row = table.getRowWithLabelsObject(10);
   * // eg:
   * // [{ colour: red, size: 10}, { colour: blue, size: 20 }]
   * ```
   * @param rowNumber 
   * @returns 
   */
  getRowWithLabelsObject(rowNumber) {
    const row = this.rows.at(rowNumber);
    if (row === void 0) return void 0;
    const object2 = {};
    for (let index = 0; index < this.colLabels.length; index++) {
      const label = this.colLabels.at(index) ?? index.toString();
      object2[label] = row[index];
    }
    return object2;
  }
  /**
   * Gets or creates a row at `rowNumber`.
   * @param rowNumber 
   * @returns 
   */
  getOrCreateRow(rowNumber) {
    let row = this.rows.at(rowNumber);
    if (row === void 0) {
      row = [];
      this.rows[rowNumber] = row;
    }
    return row;
  }
  /**
   * Gets the values at `rowNumber`
   * @param rowNumber 
   * @returns 
   */
  row(rowNumber) {
    return this.rows.at(rowNumber);
  }
  /**
   * Set the value of row,column to `value`
   * @param rowNumber 
   * @param columnNumber 
   * @param value 
   */
  set(rowNumber, columnNumber, value2) {
    const row = this.getOrCreateRow(rowNumber);
    row[columnNumber] = value2;
  }
  get(rowNumber, column) {
    const row = this.getOrCreateRow(rowNumber);
    const index = typeof column === `number` ? column : this.getColumnLabelIndex(column);
    if (index === void 0) throw new Error(`Column not found: ${column}`);
    return row[index];
  }
  /**
   * For a given row number, set all the columns to `value`.
   * `cols` gives the number of columns to set
   * @param rowNumber 
   * @param cols 
   * @param value 
   */
  setRow(rowNumber, cols, value2) {
    const row = this.getOrCreateRow(rowNumber);
    for (let columnNumber = 0; columnNumber < cols; columnNumber++) {
      row[columnNumber] = value2;
    }
  }
};
var createVertex = (id) => {
  return {
    id,
    out: []
  };
};
function hasKey(graph2, key) {
  throwGraphTest(graph2);
  return graph2.vertices.has(key);
}
function get3(graph2, key) {
  throwGraphTest(graph2);
  throwStringTest(key, `non-empty`, `key`);
  return graph2.vertices.get(key);
}
function toAdjacencyMatrix(graph2) {
  throwGraphTest(graph2);
  const v3 = [...graph2.vertices.values()];
  const table = new Table();
  table.labelColumns(...v3.map((vv) => vv.id));
  table.labelRows(...v3.map((vv) => vv.id));
  for (let i4 = 0; i4 < v3.length; i4++) {
    table.setRow(i4, v3.length, false);
    const ii3 = v3[i4];
    for (const [j3, jj] of v3.entries()) {
      if (ii3.out.some((o5) => o5.id === jj.id)) {
        table.set(i4, j3, true);
      }
    }
  }
  return table;
}
var dumpGraph = (graph2) => {
  const lines = debugGraphToArray(graph2);
  return lines.join(`
`);
};
var debugGraphToArray = (graph2) => {
  const r5 = [];
  const vertices2 = `vertices` in graph2 ? graph2.vertices.values() : graph2;
  for (const v3 of vertices2) {
    const str = debugDumpVertex(v3);
    r5.push(...str.map((line3) => ` ${line3}`));
  }
  return r5;
};
var distance2 = (graph2, edge) => {
  if (edge.weight !== void 0) return edge.weight;
  return 1;
};
function* edges(graph2) {
  throwGraphTest(graph2);
  const vertices2 = [...graph2.vertices.values()];
  for (const vertex of vertices2) {
    for (const edge of vertex.out) {
      yield edge;
    }
  }
}
function* vertices(graph2) {
  throwGraphTest(graph2);
  const vertices2 = [...graph2.vertices.values()];
  for (const vertex of vertices2) {
    yield vertex;
  }
}
function testGraph(g5, paramName = `graph`) {
  if (g5 === void 0) return [false, `Param '${paramName}' is undefined. Expected Graph`];
  if (g5 === null) return [false, `Param '${paramName}' is null. Expected Graph`];
  if (typeof g5 === `object`) {
    if (!(`vertices` in g5)) return [false, `Param '${paramName}.vertices' does not exist. Is it a Graph type?`];
  } else {
    return [false, `Param '${paramName} is type '${typeof g5}'. Expected an object Graph`];
  }
  return [true];
}
function throwGraphTest(g5, paramName = `graph`) {
  const r5 = testGraph(g5, paramName);
  if (r5[0]) return;
  throw new Error(r5[1]);
}
function* adjacentVertices(graph2, context) {
  throwGraphTest(graph2);
  if (context === void 0) return;
  const vertex = typeof context === `string` ? graph2.vertices.get(context) : context;
  if (vertex === void 0) throw new Error(`Vertex not found ${JSON.stringify(context)}`);
  for (const edge of vertex.out) {
    const edgeV = graph2.vertices.get(edge.id);
    if (edgeV === void 0) throw new Error(`Could not find vertex: ${edge.id}`);
    yield edgeV;
  }
}
var vertexHasOut = (vertex, outIdOrVertex) => {
  if (vertex === void 0) return false;
  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;
  return vertex.out.some((edge) => edge.id === outId);
};
var hasNoOuts = (graph2, vertex) => {
  throwGraphTest(graph2);
  const context = typeof vertex === `string` ? graph2.vertices.get(vertex) : vertex;
  if (context === void 0) return false;
  return context.out.length === 0;
};
var hasOnlyOuts = (graph2, vertex, ...outIdOrVertex) => {
  throwGraphTest(graph2);
  const context = resolveVertex(graph2, vertex);
  const outs = outIdOrVertex.map((o5) => resolveVertex(graph2, o5));
  if (outs.length !== context.out.length) {
    return false;
  }
  for (const out of outs) {
    if (!hasOut(graph2, context, out)) {
      return false;
    }
  }
  return true;
};
var hasOut = (graph2, vertex, outIdOrVertex) => {
  throwGraphTest(graph2);
  const context = resolveVertex(graph2, vertex);
  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;
  return context.out.some((edge) => edge.id === outId);
};
var getOrCreate = (graph2, id) => {
  throwGraphTest(graph2);
  const v3 = graph2.vertices.get(id);
  if (v3 !== void 0) return { graph: graph2, vertex: v3 };
  const vv = createVertex(id);
  const gg = updateGraphVertex(graph2, vv);
  return { graph: gg, vertex: vv };
};
var getOrFail = (graph2, id) => {
  throwGraphTest(graph2);
  const v3 = graph2.vertices.get(id);
  if (v3 === void 0) throw new Error(`Vertex '${id}' not found in graph`);
  return v3;
};
var updateGraphVertex = (graph2, vertex) => {
  throwGraphTest(graph2);
  const gr2 = {
    ...graph2,
    vertices: graph2.vertices.set(vertex.id, vertex)
  };
  return gr2;
};
var distanceDefault = (graph2, edge) => {
  if (edge.weight !== void 0) return edge.weight;
  return 1;
};
function disconnect(graph2, from2, to22) {
  throwGraphTest(graph2);
  const fromV = resolveVertex(graph2, from2);
  const toV = resolveVertex(graph2, to22);
  return hasOut(graph2, fromV, toV) ? updateGraphVertex(graph2, {
    ...fromV,
    out: fromV.out.filter((t6) => t6.id !== toV.id)
  }) : graph2;
}
function connectTo(graph2, from2, to22, weight) {
  throwGraphTest(graph2);
  const fromResult = getOrCreate(graph2, from2);
  graph2 = fromResult.graph;
  const toResult = getOrCreate(graph2, to22);
  graph2 = toResult.graph;
  const edge = {
    id: to22,
    weight
  };
  if (!hasOut(graph2, fromResult.vertex, toResult.vertex)) {
    graph2 = updateGraphVertex(graph2, {
      ...fromResult.vertex,
      // Add new edge to list of edges for this node
      out: [...fromResult.vertex.out, edge]
    });
  }
  return { graph: graph2, edge };
}
function connect(graph2, options) {
  const result = connectWithEdges(graph2, options);
  return result.graph;
}
function connectWithEdges(graph2, options) {
  throwGraphTest(graph2);
  const { to: to22, weight, from: from2 } = options;
  const bidi = options.bidi ?? false;
  const toList = Array.isArray(to22) ? to22 : [to22];
  let edges23 = [];
  for (const toSingle of toList) {
    const result = connectTo(graph2, from2, toSingle, weight);
    graph2 = result.graph;
    edges23.push(result.edge);
  }
  if (!bidi) return { graph: graph2, edges: edges23 };
  for (const toSingle of toList) {
    const result = connectTo(graph2, toSingle, from2, weight);
    graph2 = result.graph;
    edges23.push(result.edge);
  }
  return { graph: graph2, edges: edges23 };
}
var debugDumpVertex = (v3) => {
  const r5 = [
    v3.id
  ];
  const stringForEdge = (edge) => edge.weight === void 0 ? edge.id : `${edge.id} (${edge.weight})`;
  for (const edge of v3.out) {
    r5.push(` -> ${stringForEdge(edge)}`);
  }
  if (v3.out.length === 0) r5[0] += ` (terminal)`;
  return r5;
};
function areAdjacent(graph2, a4, b4) {
  throwGraphTest(graph2);
  if (hasOut(graph2, a4, b4.id)) return true;
  if (hasOut(graph2, b4, a4.id)) return true;
}
function resolveVertex(graph2, idOrVertex) {
  throwGraphTest(graph2);
  if (idOrVertex === void 0) throw new Error(`Param 'idOrVertex' is undefined. Expected string or Vertex`);
  const v3 = typeof idOrVertex === `string` ? graph2.vertices.get(idOrVertex) : idOrVertex;
  if (v3 === void 0) throw new Error(`Id not found ${idOrVertex}`);
  return v3;
}
function* bfs(graph2, startIdOrVertex, targetIdOrVertex) {
  throwGraphTest(graph2);
  const start = resolveVertex(graph2, startIdOrVertex);
  const target = targetIdOrVertex === void 0 ? void 0 : resolveVertex(graph2, targetIdOrVertex);
  const queue = new QueueMutable();
  const seen = /* @__PURE__ */ new Set();
  queue.enqueue(start);
  while (!queue.isEmpty) {
    const v3 = queue.dequeue();
    yield v3;
    if (target !== void 0 && target === v3) return;
    for (const edge of adjacentVertices(graph2, v3)) {
      if (!seen.has(edge.id)) {
        seen.add(edge.id);
        queue.enqueue(resolveVertex(graph2, edge.id));
      }
    }
  }
}
function* dfs(graph2, startIdOrVertex) {
  throwGraphTest(graph2);
  const source = resolveVertex(graph2, startIdOrVertex);
  const s3 = new StackMutable();
  const seen = /* @__PURE__ */ new Set();
  s3.push(source);
  while (!s3.isEmpty) {
    const v3 = s3.pop();
    if (v3 === void 0) continue;
    if (!seen.has(v3.id)) {
      seen.add(v3.id);
      yield v3;
      for (const edge of v3.out) {
        const destination = graph2.vertices.get(edge.id);
        if (destination) {
          s3.push(destination);
        }
      }
    }
  }
}
var pathDijkstra = (graph2, sourceOrId) => {
  throwGraphTest(graph2);
  const source = typeof sourceOrId === `string` ? graph2.vertices.get(sourceOrId) : sourceOrId;
  if (source === void 0) throw new Error(`source vertex not found`);
  const distances = /* @__PURE__ */ new Map();
  const previous = /* @__PURE__ */ new Map();
  distances.set(source.id, 0);
  const pq = new PriorityMutable();
  const vertices2 = [...graph2.vertices.values()];
  for (const v3 of vertices2) {
    if (v3.id !== source.id) {
      distances.set(v3.id, Number.MAX_SAFE_INTEGER);
      previous.set(v3.id, null);
    }
    pq.enqueueWithPriority(v3.id, Number.MAX_SAFE_INTEGER);
  }
  while (!pq.isEmpty) {
    const u3 = pq.dequeueMin();
    if (u3 === void 0) throw new Error(`Bug. Queue unexpectedly empty`);
    const vertexU = graph2.vertices.get(u3);
    for (const neighbour of vertexU.out) {
      const alt = distances.get(u3) + distance2(graph2, neighbour);
      if (alt < distances.get(neighbour.id)) {
        distances.set(neighbour.id, alt);
        previous.set(neighbour.id, vertexU);
        pq.changePriority(neighbour.id, alt, true);
      }
    }
  }
  const pathTo = (id) => {
    const path2 = [];
    while (true) {
      if (id === source.id) break;
      const v3 = previous.get(id);
      if (v3 === void 0 || v3 === null) throw new Error(`Id not present: ${id}`);
      path2.push({ id, weight: distances.get(id) });
      id = v3.id;
    }
    return path2;
  };
  return {
    distances,
    previous,
    pathTo
  };
};
var clone2 = (graph2) => {
  throwGraphTest(graph2);
  const g5 = {
    vertices: immutable([...graph2.vertices.entries()])
  };
  return g5;
};
var graph = (...initialConnections) => {
  let g5 = {
    vertices: immutable()
  };
  for (const ic2 of initialConnections) {
    g5 = connect(g5, ic2);
  }
  return g5;
};
function isAcyclic(graph2) {
  throwGraphTest(graph2);
  const cycles = getCycles(graph2);
  return cycles.length === 0;
}
function topologicalSort(graph2) {
  throwGraphTest(graph2);
  const indegrees = new NumberMap(0);
  for (const edge of edges(graph2)) {
    indegrees.add(edge.id, 1);
  }
  const queue = new QueueMutable();
  let vertexCount = 0;
  for (const vertex of vertices(graph2)) {
    if (indegrees.get(vertex.id) === 0) {
      queue.enqueue(vertex);
    }
    vertexCount++;
  }
  const topOrder = [];
  while (!queue.isEmpty) {
    const u3 = queue.dequeue();
    topOrder.push(u3);
    for (const neighbour of u3.out) {
      const result = indegrees.subtract(neighbour.id, 1);
      if (result === 0) {
        queue.enqueue(graph2.vertices.get(neighbour.id));
      }
    }
  }
  if (topOrder.length !== vertexCount) {
    throw new Error(`Graph contains cycles`);
  }
  return graphFromVertices(topOrder);
}
function graphFromVertices(vertices2) {
  const keyValues = map(vertices2, (f5) => {
    return [f5.id, f5];
  });
  const m5 = immutable([...keyValues]);
  return {
    vertices: m5
  };
}
function getCycles(graph2) {
  throwGraphTest(graph2);
  let index = 0;
  const stack = new StackMutable();
  const vertices2 = /* @__PURE__ */ new Map();
  const scc = [];
  for (const v3 of graph2.vertices.values()) {
    vertices2.set(v3.id, {
      ...v3,
      lowlink: Number.NaN,
      index: Number.NaN,
      onStack: false
    });
  }
  const strongConnect = (vertex) => {
    vertex.index = index;
    vertex.lowlink = index;
    index++;
    stack.push(vertex);
    vertex.onStack = true;
    for (const edge of vertex.out) {
      const edgeV = vertices2.get(edge.id);
      if (Number.isNaN(edgeV.index)) {
        strongConnect(edgeV);
        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);
      } else if (edgeV.onStack) {
        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);
      }
    }
    if (vertex.lowlink === vertex.index) {
      const stronglyConnected = [];
      let w3;
      while (vertex !== w3) {
        w3 = stack.pop();
        w3.onStack = false;
        stronglyConnected.push({ id: w3.id, out: w3.out });
      }
      if (stronglyConnected.length > 1)
        scc.push(stronglyConnected);
    }
  };
  for (const v3 of vertices2.values()) {
    if (Number.isNaN(v3.index)) {
      strongConnect(v3);
    }
  }
  return scc;
}
function transitiveReduction(graph2) {
  throwGraphTest(graph2);
  for (const u3 of vertices(graph2)) {
    for (const v3 of adjacentVertices(graph2, u3)) {
      for (const v1 of dfs(graph2, v3)) {
        if (v3.id === v1.id) continue;
        if (hasOut(graph2, u3, v1)) {
          const g5 = disconnect(graph2, u3, v1);
          return transitiveReduction(g5);
        }
      }
    }
  }
  return graph2;
}
function prepare(_rx) {
  let g5 = graph();
  const nodes = /* @__PURE__ */ new Map();
  const events = initStream();
  const process22 = (o5, path2) => {
    for (const [key, value2] of Object.entries(o5)) {
      const subPath = path2 + `.` + key;
      g5 = connect(g5, {
        from: path2,
        to: subPath
      });
      if (isReactive(value2)) {
        nodes.set(subPath, { value: value2, type: `rx` });
        value2.on((v3) => {
          console.log(`Rx.prepare value: ${JSON.stringify(v3)} path: ${subPath}`);
        });
      } else {
        const valueType = typeof value2;
        if (valueType === `bigint` || valueType === `boolean` || valueType === `number` || valueType === `string`) {
          nodes.set(subPath, { type: `primitive`, value: value2 });
        } else if (valueType === `object`) {
          process22(value2, subPath);
        } else if (valueType === `function`) {
          console.log(`Rx.process - not handling functions`);
        }
      }
    }
  };
  const returnValue = {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    dispose: events.dispose,
    // eslint-disable-next-line @typescript-eslint/unbound-method
    isDisposed: events.isDisposed,
    graph: g5,
    // eslint-disable-next-line @typescript-eslint/unbound-method
    on: events.on,
    // eslint-disable-next-line @typescript-eslint/unbound-method
    onValue: events.onValue
  };
  return returnValue;
}
var symbol = Symbol(`Rx`);
async function toArray22(source, options = {}) {
  const limit = options.limit ?? Number.MAX_SAFE_INTEGER;
  const maximumWait = intervalToMs(options.maximumWait, 10 * 1e3);
  const underThreshold = options.underThreshold ?? `partial`;
  const read = [];
  const rx = resolveSource(source);
  const promise = new Promise((resolve22, reject) => {
    const done = () => {
      clearTimeout(maxWait);
      unsub();
      if (read.length < limit && underThreshold === `throw`) {
        reject(new Error(`Threshold not reached. Wanted: ${limit} got: ${read.length}. Maximum wait: ${maximumWait}`));
        return;
      }
      if (read.length < limit && underThreshold === `fill`) {
        for (let index = 0; index < limit; index++) {
          if (read[index] === void 0) {
            read[index] = options.fillValue;
          }
        }
      }
      resolve22(read);
    };
    const maxWait = setTimeout(() => {
      done();
    }, maximumWait);
    const unsub = rx.on((message) => {
      if (messageIsDoneSignal(message)) {
        done();
      } else if (messageHasValue(message)) {
        read.push(message.value);
        if (read.length === limit) {
          done();
        }
      }
    });
  });
  return promise;
}
async function toArrayOrThrow(source, options = {}) {
  const limit = options.limit ?? Number.MAX_SAFE_INTEGER;
  const maximumWait = options.maximumWait ?? 5 * 1e3;
  const v3 = await toArray22(source, { limit, maximumWait, underThreshold: `partial` });
  if (options.limit && v3.length < options.limit) throw new Error(`Threshold not reached. Wanted: ${options.limit}, got ${v3.length}`);
  return v3;
}
async function* toGenerator(source) {
  const s3 = resolveSource(source);
  let promiseResolve = (_3) => {
  };
  let promiseReject = (_3) => {
  };
  const promiseInit = () => new Promise((resolve22, reject) => {
    promiseResolve = resolve22;
    promiseReject = reject;
  });
  let promise = promiseInit();
  let keepRunning = true;
  s3.on((message) => {
    if (messageHasValue(message)) {
      promiseResolve(message.value);
      promise = promiseInit();
    } else if (messageIsDoneSignal(message)) {
      keepRunning = false;
      promiseReject(`Source has completed`);
    }
  });
  while (keepRunning) {
    yield await promise;
  }
}
var mapObjectShallow = (object2, mapFunction) => {
  const entries2 = Object.entries(object2);
  const mapped = entries2.map(([sourceField, sourceFieldValue], index) => [
    sourceField,
    mapFunction({ value: sourceFieldValue, field: sourceField, index, path: sourceField })
  ]);
  return Object.fromEntries(mapped);
};
function wrap4(source) {
  return {
    source: resolveSource(source),
    enacts: {
      setHtmlText: (options) => {
        return setHtmlText(source, options);
      }
    },
    annotate: (transformer) => {
      const a4 = annotate(source, transformer);
      return wrap4(a4);
    },
    annotateWithOp: (op) => {
      const a4 = annotateWithOp(source, op);
      return wrap4(a4);
    },
    chunk: (options) => {
      const w3 = wrap4(chunk(source, options));
      return w3;
    },
    debounce: (options = {}) => {
      return wrap4(debounce2(source, options));
    },
    field: (fieldName, options = {}) => {
      const f5 = field(source, fieldName, options);
      return wrap4(f5);
    },
    filter: (predicate, options) => {
      return wrap4(filter22(source, predicate, options));
    },
    combineLatestToArray: (sources, options = {}) => {
      const srcs = [source, ...sources];
      return wrap4(combineLatestToArray(srcs, options));
    },
    combineLatestToObject: (sources, options) => {
      const name = options.name ?? `source`;
      const o5 = { ...sources };
      o5[name] = source;
      return wrap4(combineLatestToObject(o5, options));
    },
    min: (options = {}) => {
      return wrap4(min4(source, options));
    },
    max: (options = {}) => {
      return wrap4(max32(source, options));
    },
    average: (options = {}) => {
      return wrap4(average2(source, options));
    },
    sum: (options = {}) => {
      return wrap4(sum2(source, options));
    },
    tally: (options = {}) => {
      return wrap4(tally2(source, options));
    },
    split: (options = {}) => {
      const streams = split(source, options).map((v3) => wrap4(v3));
      return streams;
    },
    splitLabelled: (...labels) => {
      const l3 = splitLabelled(source, labels);
      const m5 = mapObjectShallow(l3, (args) => wrap4(args.value));
      return m5;
    },
    switcher: (cases, options = {}) => {
      const s3 = switcher(source, cases, options);
      const m5 = mapObjectShallow(s3, (args) => wrap4(args.value));
      return m5;
    },
    syncToArray: (additionalSources, options = {}) => {
      const unwrapped2 = [source, ...additionalSources].map((v3) => resolveSource(v3));
      const x3 = syncToArray(unwrapped2, options);
      return wrap4(x3);
    },
    syncToObject: (sources, options = {}) => {
      const name = options.name ?? `source`;
      const o5 = { ...sources };
      o5[name] = source;
      return wrap4(syncToObject(o5, options));
    },
    tapProcess: (...processors) => {
      tapProcess(source, ...processors);
      return wrap4(source);
    },
    tapStream: (divergedStream) => {
      tapStream(source, divergedStream);
      return wrap4(source);
    },
    tapOps: (source2, ...ops) => {
      tapOps(source2, ...ops);
      return wrap4(source2);
    },
    throttle: (options = {}) => {
      return wrap4(throttle2(source, options));
    },
    transform: (transformer, options = {}) => {
      return wrap4(transform(source, transformer, options));
    },
    timeoutValue: (options) => {
      return wrap4(timeoutValue(source, options));
    },
    timeoutPing: (options) => {
      return wrap4(timeoutPing(source, options));
    },
    toArray: (options) => {
      return toArray22(source, options);
    },
    toArrayOrThrow: (options) => {
      return toArrayOrThrow(source, options);
    },
    onValue: (callback) => {
      const s3 = resolveSource(source);
      s3.on((message) => {
        if (messageHasValue(message)) callback(message.value);
      });
    }
  };
}
function count2(options = {}) {
  const lazy = options.lazy ?? `initial`;
  const interval2 = intervalToMs(options.interval, 1e3);
  const amount = options.amount ?? 1;
  const offset2 = options.offset ?? 0;
  let produced = 0;
  let value2 = offset2;
  const done = (reason) => {
    events.dispose(reason);
  };
  const timer = continuously(() => {
    if (options.signal?.aborted) {
      done(`Aborted (${options.signal.reason})`);
      return false;
    }
    events.set(value2);
    value2 += 1;
    produced++;
    if (produced >= amount) {
      done(`Limit reached`);
      return false;
    }
  }, interval2);
  const events = initLazyStream({
    onStart() {
      timer.start();
    },
    onStop() {
      timer.cancel();
    },
    onDispose() {
      timer.cancel();
    },
    lazy
  });
  return events;
}
var Dom_exports = {};
__export(Dom_exports, {
  bind: () => bind,
  bindDiffUpdate: () => bindDiffUpdate,
  bindElement: () => bindElement,
  bindHtml: () => bindHtml,
  bindText: () => bindText,
  bindUpdate: () => bindUpdate,
  bindValueText: () => bindValueText,
  elements: () => elements,
  fromDomQuery: () => fromDomQuery,
  win: () => win
});
function* stringSegmentsWholeToEnd(source, delimiter = `.`) {
  while (source.length > 0) {
    yield source;
    const trimmed = afterMatch(source, delimiter);
    if (trimmed === source) {
      break;
    }
    source = trimmed;
  }
}
function* stringSegmentsWholeToFirst(source, delimiter = `.`) {
  while (source.length > 0) {
    yield source;
    const b4 = beforeMatch(source, delimiter, { ifNoMatch: `original`, fromEnd: true });
    if (b4 === source) break;
    source = b4;
  }
}
function fromDomQuery(query) {
  const elements2 = [...document.querySelectorAll(query)];
  return object(elements2);
}
var bindText = (source, elOrQuery, bindOpts = {}) => {
  return bindElement(source, elOrQuery, { ...bindOpts, elField: `textContent` });
};
var bindValueText = (source, elOrQuery, bindOpts = {}) => {
  return bindElement(source, elOrQuery, { ...bindOpts, elField: `value`, attribName: `value` });
};
var bindHtml = (source, elOrQuery, bindOpts = {}) => {
  return bindElement(source, elOrQuery, { ...bindOpts, elField: `innerHTML` });
};
var bindElement = (source, elOrQuery, ...binds) => {
  if (elOrQuery === null) throw new Error(`Param 'elOrQuery' is null`);
  if (elOrQuery === void 0) throw new Error(`Param 'elOrQuery' is undefined`);
  const el = resolveEl(elOrQuery);
  let b4 = [];
  if (binds.length === 0) {
    b4.push({ elField: `textContent` });
  } else {
    b4 = [...binds];
  }
  const bb = b4.map((bind2) => {
    if (`element` in bind2) return bind2;
    return { ...bind2, element: el };
  });
  return bind(source, ...bb);
};
var resolveBindUpdater = (bind2, element) => {
  const b4 = resolveBindUpdaterBase(bind2);
  return (value2) => {
    b4(value2, element);
  };
};
var resolveBindUpdaterBase = (bind2) => {
  if (bind2.elField !== void 0 || bind2.cssVariable === void 0 && bind2.attribName === void 0 && bind2.cssProperty === void 0 && bind2.textContent === void 0 && bind2.htmlContent === void 0) {
    const field2 = bind2.elField ?? `textContent`;
    return (v3, element) => {
      element[field2] = v3;
    };
  }
  if (bind2.attribName !== void 0) {
    const attrib = bind2.attribName;
    return (v3, element) => {
      element.setAttribute(attrib, v3);
    };
  }
  if (bind2.textContent) {
    return (v3, element) => {
      element.textContent = v3;
    };
  }
  if (bind2.htmlContent) {
    return (v3, element) => {
      element.innerHTML = v3;
    };
  }
  if (bind2.cssVariable !== void 0) {
    let css = bind2.cssVariable;
    if (!css.startsWith(`--`)) css = `--` + css;
    return (v3, element) => {
      element.style.setProperty(css, v3);
    };
  }
  if (bind2.cssProperty !== void 0) {
    return (v3, element) => {
      element.style[bind2.cssProperty] = v3;
    };
  }
  return (_3, _element) => {
  };
};
var resolveTransform = (bind2) => {
  if (!bind2.transform && !bind2.transformValue) return;
  if (bind2.transformValue) {
    if (bind2.sourceField === void 0) throw new Error(`Expects 'sourceField' to be set when 'transformValue' is set`);
    return (value2) => {
      const fieldValue = value2[bind2.sourceField];
      return bind2.transformValue(fieldValue);
    };
  } else if (bind2.transform) {
    if (bind2.sourceField !== void 0) throw new Error(`If 'transform' is set, 'sourceField' is ignored`);
    return (value2) => bind2.transform(value2);
  }
};
var bind = (source, ...bindsUnresolvedElements) => {
  const binds = bindsUnresolvedElements.map((bind2) => {
    if (bind2.element && bind2.element !== void 0) return bind2;
    if (bind2.query) return {
      ...bind2,
      element: resolveEl(bind2.query)
    };
    throw new Error(`Unable to resolve element. Missing 'element' or 'query' values on bind. ${JSON.stringify(bind2)}`);
  });
  const bindsResolved = binds.map((bind2) => ({
    update: resolveBindUpdater(bind2, bind2.element),
    transformer: resolveTransform(bind2),
    sourceField: bind2.sourceField
  }));
  const update = (value2) => {
    for (const bind2 of bindsResolved) {
      if (bind2.transformer) {
        bind2.update(bind2.transformer(value2));
      } else {
        const v3 = bind2.sourceField ? value2[bind2.sourceField] : value2;
        if (typeof v3 === `object`) {
          if (bind2.sourceField) {
            bind2.update(JSON.stringify(v3));
          } else {
            bind2.update(JSON.stringify(v3));
          }
        } else bind2.update(v3);
      }
    }
  };
  const unsub = source.on((message) => {
    if (messageHasValue(message)) {
      update(message.value);
    } else if (messageIsSignal(message)) {
      console.warn(message);
    }
  });
  if (hasLast(source)) {
    update(source.last());
  }
  return {
    remove: (removeElements) => {
      unsub();
      if (removeElements) {
        for (const bind2 of binds) {
          bind2.element.remove();
        }
      }
    }
  };
};
var bindUpdate = (source, elOrQuery, updater) => {
  const el = resolveEl(elOrQuery);
  const update = (value2) => {
    updater(value2, el);
  };
  const unsub = source.on((message) => {
    if (messageHasValue(message)) {
      console.log(message);
      update(message.value);
    } else {
      console.warn(message);
    }
  });
  if (hasLast(source)) {
    update(source.last());
  }
  return {
    remove: (removeElement) => {
      unsub();
      if (removeElement) {
        el.remove();
      }
    }
  };
};
var bindDiffUpdate = (source, elOrQuery, updater, opts = {}) => {
  if (elOrQuery === null) throw new Error(`Param 'elOrQuery' is null`);
  if (elOrQuery === void 0) throw new Error(`Param 'elOrQuery' is undefined`);
  const el = resolveEl(elOrQuery);
  const update = (value2) => {
    updater(value2, el);
  };
  const unsub = source.onDiff((value2) => {
    update(value2);
  });
  const init5 = () => {
    if (hasLast(source) && opts.initial) opts.initial(source.last(), el);
  };
  init5();
  return {
    refresh: () => {
      init5();
    },
    remove: (removeElement) => {
      unsub();
      if (removeElement) {
        el.remove();
      }
    }
  };
};
var elements = (source, options) => {
  const containerEl = options.container ? resolveEl(options.container) : document.body;
  const defaultTag = options.defaultTag ?? `div`;
  const elByField = /* @__PURE__ */ new Map();
  const binds = /* @__PURE__ */ new Map();
  for (const [key, value2] of Object.entries(options.binds ?? {})) {
    const tagName = value2.tagName ?? defaultTag;
    binds.set(key, {
      ...value2,
      update: resolveBindUpdaterBase(value2),
      transform: resolveTransform(value2),
      tagName,
      path: key
    });
  }
  const findBind = (path2) => {
    const bind2 = getFromKeys(binds, stringSegmentsWholeToEnd(path2));
    if (bind2 !== void 0) return bind2;
    if (!path2.includes(`.`)) return binds.get(`_root`);
  };
  function* ancestorBinds(path2) {
    for (const p4 of stringSegmentsWholeToFirst(path2)) {
      if (binds.has(p4)) {
        yield binds.get(p4);
      } else {
      }
    }
    if (binds.has(`_root`) && path2.includes(`.`)) yield binds.get(`_root`);
  }
  const create5 = (path2, value2) => {
    const rootedPath = getRootedPath(path2);
    console.log(`Rx.Dom.elements.create: ${path2} rooted: ${rootedPath} value: ${JSON.stringify(value2)}`);
    const bind2 = findBind(getRootedPath(path2));
    let tagName = defaultTag;
    if (bind2?.tagName) tagName = bind2.tagName;
    const el = document.createElement(tagName);
    el.setAttribute(`data-path`, path2);
    update(path2, el, value2);
    let parentForEl;
    for (const b4 of ancestorBinds(rootedPath)) {
      if (b4?.nestChildren) {
        const absoluteRoot = beforeMatch(path2, `.`);
        const findBy = b4.path.replace(`_root`, absoluteRoot);
        parentForEl = elByField.get(findBy);
        if (parentForEl === void 0) {
        } else {
          break;
        }
      }
    }
    (parentForEl ?? containerEl).append(el);
    elByField.set(path2, el);
    console.log(`Added el: ${path2}`);
  };
  const update = (path2, el, value2) => {
    console.log(`Rx.dom.update path: ${path2} value:`, value2);
    const bind2 = findBind(getRootedPath(path2));
    if (bind2 === void 0) {
      if (typeof value2 === `object`) value2 = JSON.stringify(value2);
      el.textContent = value2;
    } else {
      if (bind2.transform) value2 = bind2.transform(value2);
      bind2.update(value2, el);
    }
  };
  const changes = (changes2) => {
    const queue = new QueueMutable({}, changes2);
    let d4 = queue.dequeue();
    const seenPaths = /* @__PURE__ */ new Set();
    while (d4 !== void 0) {
      const path2 = d4.path;
      if (!(`previous` in d4) || d4.previous === void 0) {
        console.log(`Rx.Dom.elements.changes no previous. path: ${path2}`);
        create5(path2, d4.value);
        const subdata = [...getPathsAndData(d4.value, false, Number.MAX_SAFE_INTEGER, path2)];
        console.log(subdata);
        for (const dd of subdata) {
          if (!seenPaths.has(dd.path)) {
            queue.enqueue(dd);
            seenPaths.add(dd.path);
          }
        }
      } else if (d4.value === void 0) {
        const el = elByField.get(path2);
        if (el === void 0) {
          console.warn(`No element to delete? ${path2} `);
        } else {
          console.log(`Rx.Dom.elements.changes delete ${path2}`);
          el.remove();
        }
      } else {
        const el = elByField.get(path2);
        if (el === void 0) {
          console.warn(`Rx.Dom.elements.changes No element to update ? ${path2} `);
          create5(path2, d4.value);
        } else {
          update(path2, el, d4.value);
        }
      }
      d4 = queue.dequeue();
    }
  };
  source.onDiff((value2) => {
    changes(value2);
  });
  if (hasLast(source)) {
    const last3 = source.last();
    changes([...getPathsAndData(last3, false, 1)]);
  }
};
var getRootedPath = (path2) => {
  const after = afterMatch(path2, `.`);
  return after === path2 ? `_root` : `_root.` + after;
};
function win() {
  const generateRect = () => ({ width: window.innerWidth, height: window.innerHeight });
  const size = sources_exports.event(window, `resize`, {
    lazy: `very`,
    transform: () => generateRect()
  });
  const pointer = sources_exports.event(window, `pointermove`, {
    lazy: `very`,
    transform: (args) => {
      if (args === void 0) return { x: 0, y: 0 };
      const pe2 = args;
      return { x: pe2.x, y: pe2.y };
    }
  });
  const dispose = (reason = `Reactive.win.dispose`) => {
    size.dispose(reason);
    pointer.dispose(reason);
  };
  return { dispose, size, pointer };
}
var sources_exports = {};
__export(sources_exports, {
  array: () => array,
  arrayObject: () => arrayObject,
  boolean: () => boolean,
  colour: () => colour,
  derived: () => derived,
  domHslInputValue: () => domHslInputValue,
  domInputValue: () => domInputValue,
  domNumberInputValue: () => domNumberInputValue,
  event: () => event,
  eventField: () => eventField,
  eventTrigger: () => eventTrigger,
  func: () => func,
  iterator: () => iterator,
  number: () => number,
  object: () => object,
  objectProxy: () => objectProxy,
  objectProxySymbol: () => objectProxySymbol,
  observable: () => observable,
  observableWritable: () => observableWritable,
  of: () => of,
  string: () => string2
});
var of = (source, options = {}) => {
  if (Array.isArray(source)) {
    return array(source, options);
  } else {
  }
};
var array = (sourceArray, options = {}) => {
  const lazy = options.lazy ?? `initial`;
  const signal = options.signal;
  const whenStopped = options.whenStopped ?? `continue`;
  const debugLifecycle = options.debugLifecycle ?? false;
  const array2 = [...sourceArray];
  if (lazy !== `very` && whenStopped === `reset`) throw new Error(`whenStopped:'reset' has no effect with 'lazy:${lazy}'. Use lazy:'very' instead.`);
  const intervalMs = intervalToMs(options.interval, 5);
  let index = 0;
  let lastValue = array2[0];
  const s3 = initLazyStream({
    ...options,
    lazy,
    onStart() {
      if (debugLifecycle) console.log(`Rx.readFromArray:onStart`);
      c6.start();
    },
    onStop() {
      if (debugLifecycle) console.log(`Rx.readFromArray:onStop. whenStopped: ${whenStopped} index: ${index}`);
      c6.cancel();
      if (whenStopped === `reset`) index = 0;
    }
    // onFirstSubscribe() {
    //   if (debugLifecycle) console.log(`Rx.readFromArray:onFirstSubscribe lazy: ${ lazy } runState: '${ c.runState }'`);
    //   // Start if in lazy mode and not running
    //   if (lazy !== `never` && c.runState === `idle`) c.start();
    // },
    // onNoSubscribers() {
    //   if (debugLifecycle) console.log(`Rx.readFromArray:onNoSubscribers lazy: ${ lazy } runState: '${ c.runState }' whenStopped: '${ whenStopped }'`);
    //   if (lazy === `very`) {
    //     c.cancel();
    //     if (whenStopped === `reset`) {
    //       index = 0;
    //     }
    //   }
    // }
  });
  const c6 = continuously(() => {
    if (signal?.aborted) {
      s3.dispose(`Signalled (${signal.reason})`);
      return false;
    }
    lastValue = array2[index];
    index++;
    s3.set(lastValue);
    if (index === array2.length) {
      s3.dispose(`Source array complete`);
      return false;
    }
  }, intervalMs);
  if (!lazy) c6.start();
  return {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    dispose: s3.dispose,
    // eslint-disable-next-line @typescript-eslint/unbound-method
    isDisposed: s3.isDisposed,
    isDone() {
      return index === array2.length;
    },
    last() {
      return lastValue;
    },
    // eslint-disable-next-line @typescript-eslint/unbound-method
    on: s3.on,
    // eslint-disable-next-line @typescript-eslint/unbound-method
    onValue: s3.onValue
  };
};
function arrayObject(initialValue = [], options = {}) {
  const eq = options.eq ?? isEqualValueDefault;
  const setEvent = initStream();
  const arrayEvent = initStream();
  let value2 = initialValue;
  let disposed = false;
  const set3 = (replacement) => {
    const diff = compareArrays(value2, replacement, eq);
    value2 = replacement;
    setEvent.set([...replacement]);
  };
  const setAt = (index, v3) => {
    value2[index] = v3;
    setEvent.set([...value2]);
  };
  const push2 = (v3) => {
    value2 = [...value2, v3];
    setEvent.set([...value2]);
    const cr2 = [`add`, value2.length - 1, v3];
    arrayEvent.set([cr2]);
  };
  const deleteAt = (index) => {
    const valueChanged = remove2(value2, index);
    if (valueChanged.length === value2.length) return;
    const diff = compareArrays(value2, valueChanged, eq);
    value2 = valueChanged;
    setEvent.set([...value2]);
    arrayEvent.set(diff.summary);
  };
  const deleteWhere = (filter32) => {
    const valueChanged = value2.filter((v3) => !filter32(v3));
    const count22 = value2.length - valueChanged.length;
    const diff = compareArrays(value2, valueChanged, eq);
    value2 = valueChanged;
    setEvent.set([...value2]);
    arrayEvent.set(diff.summary);
    return count22;
  };
  const insertAt2 = (index, v3) => {
    const valueChanged = insertAt(value2, index, v3);
    const diff = compareArrays(value2, valueChanged, eq);
    value2 = valueChanged;
    setEvent.set([...value2]);
    arrayEvent.set(diff.summary);
  };
  const dispose = (reason) => {
    if (disposed) return;
    setEvent.dispose(reason);
    disposed = true;
  };
  const r5 = {
    dispose,
    isDisposed() {
      return disposed;
    },
    last: () => value2,
    on: setEvent.on,
    onArray: arrayEvent.on,
    onValue: setEvent.onValue,
    setAt,
    push: push2,
    deleteAt,
    deleteWhere,
    insertAt: insertAt2,
    /**
     * Set the whole object
     */
    set: set3
  };
  return r5;
}
function boolean(initialValue) {
  let value2 = initialValue;
  const events = initStream();
  const set3 = (v3) => {
    value2 = v3;
    events.set(v3);
  };
  return {
    dispose: events.dispose,
    isDisposed: events.isDisposed,
    last: () => value2,
    on: events.on,
    onValue: events.onValue,
    set: set3
  };
}
function colour(initialValue) {
  let value2 = initialValue;
  const events = initStream();
  const set3 = (v3) => {
    value2 = v3;
    events.set(v3);
  };
  return {
    dispose: events.dispose,
    isDisposed: events.isDisposed,
    last: () => value2,
    on: events.on,
    onValue: events.onValue,
    set: set3,
    setHsl: (hsl) => {
      set3(resolve2(hsl));
    }
  };
}
function derived(fn2, reactiveSources, options = {}) {
  const ignoreIdentical = options.ignoreIdentical ?? true;
  const eq = options.eq ?? isEqualValueDefault;
  const sources = combineLatestToObject(reactiveSources);
  const handle = (v3) => {
    const last3 = output.last();
    const vv = fn2(v3);
    if (vv !== void 0) {
      if (ignoreIdentical && last3 !== void 0) {
        if (eq(vv, last3)) return vv;
      }
      output.set(vv);
    }
    return vv;
  };
  const s3 = initUpstream(sources, {
    ...options,
    onValue(v3) {
      handle(v3);
    }
  });
  const output = cache(s3, fn2(sources.last()));
  return output;
}
function eventField(targetOrQuery, eventName, fieldName, initialValue, options = {}) {
  const initial = {};
  initial[fieldName] = initialValue;
  const rxField = field(
    event(targetOrQuery, eventName, initial, options),
    fieldName,
    options
  );
  return rxField;
}
function event(targetOrQuery, name, initialValue, options = {}) {
  let target;
  if (typeof targetOrQuery === `string`) {
    target = document.querySelector(targetOrQuery);
    if (target === null) throw new Error(`Target query did not resolve to an element. Query: '${targetOrQuery}'`);
  } else {
    target = targetOrQuery;
  }
  if (target === null) throw new Error(`Param 'targetOrQuery' is null`);
  const debugLifecycle = options.debugLifecycle ?? false;
  const debugFiring = options.debugFiring ?? false;
  const lazy = options.lazy ?? false;
  if (initialValue === void 0) initialValue = {};
  const rxObject = object(initialValue, { deepEntries: true });
  let eventAdded = false;
  let disposed = false;
  const callback = (args) => {
    if (debugFiring) console.log(`Reactive.event '${name}' firing '${JSON.stringify(args)}`);
    rxObject.set(args);
  };
  const remove22 = () => {
    if (!eventAdded) return;
    eventAdded = false;
    target.removeEventListener(name, callback);
    if (debugLifecycle) {
      console.log(`Rx.From.event remove '${name}'`);
    }
  };
  const add4 = () => {
    if (eventAdded) return;
    eventAdded = true;
    target.addEventListener(name, callback);
    if (debugLifecycle) {
      console.log(`Rx.From.event add '${name}'`);
    }
  };
  if (!lazy) add4();
  return {
    last: () => {
      if (lazy) add4();
      return rxObject.last();
    },
    dispose: (reason) => {
      if (disposed) return;
      disposed = true;
      remove22();
      rxObject.dispose(reason);
    },
    isDisposed() {
      return disposed;
    },
    on: (handler) => {
      if (lazy) add4();
      return rxObject.on(handler);
    },
    onValue: (handler) => {
      if (lazy) add4();
      return rxObject.onValue(handler);
    }
  };
}
function eventTrigger(targetOrQuery, name, options = {}) {
  let target;
  if (typeof targetOrQuery === `string`) {
    target = document.querySelector(targetOrQuery);
    if (target === null) throw new Error(`Target query did not resolve to an element. Query: '${targetOrQuery}'`);
  } else {
    target = targetOrQuery;
  }
  if (target === null) throw new Error(`Param 'targetOrQuery' is null`);
  const debugLifecycle = options.debugLifecycle ?? false;
  const debugFiring = options.debugFiring ?? false;
  const fireInitial = options.fireInitial ?? false;
  let count22 = 0;
  const elapsed22 = Stopwatch_exports.interval();
  const stream = initLazyStream({
    lazy: options.lazy ?? `very`,
    onStart() {
      target.addEventListener(name, callback);
      if (debugLifecycle) {
        console.log(`Rx.From.eventTrigger add '${name}'`);
      }
      if (fireInitial && count22 === 0) {
        if (debugLifecycle || debugFiring) console.log(`Rx.From.eventTrigger: firing initial`);
        callback();
      }
    },
    onStop() {
      target.removeEventListener(name, callback);
      if (debugLifecycle) {
        console.log(`Rx.From.eventTrigger remove '${name}'`);
      }
    }
  });
  const callback = (_args) => {
    if (debugFiring) console.log(`Rx.From.eventTrigger '${name}' triggered'`);
    stream.set({
      sinceLast: elapsed22(),
      total: ++count22
    });
  };
  return stream;
}
function domNumberInputValue(targetOrQuery, options = {}) {
  const input = domInputValue(targetOrQuery, options);
  const el = input.el;
  const relative2 = options.relative ?? false;
  const inverted = options.inverted ?? false;
  const rx = transform(input, (v3) => {
    return Number.parseFloat(v3);
  });
  if (relative2) {
    el.max = inverted ? "0" : "1";
    el.min = inverted ? "1" : "0";
    if (!el.hasAttribute(`step`)) {
      el.step = "0.1";
    }
  }
  if (el.getAttribute(`type`) === null) {
    el.type = `range`;
  }
  const set3 = (value2) => {
    input.set(value2.toString());
  };
  return {
    ...rx,
    last() {
      return Number.parseFloat(input.last());
    },
    set: set3
  };
}
function domHslInputValue(targetOrQuery, options = {}) {
  const input = domInputValue(targetOrQuery, {
    ...options,
    upstreamFilter(value2) {
      return typeof value2 === `object` ? toHex(value2) : value2;
    }
  });
  const rx = transform(input, (v3) => {
    return toHsl(v3, true);
  });
  return {
    ...rx,
    last() {
      return toHsl(input.last(), true);
    },
    set(value2) {
      input.set(toHex(value2));
    }
  };
}
function domInputValue(targetOrQuery, options = {}) {
  const target = typeof targetOrQuery === `string` ? document.querySelector(targetOrQuery) : targetOrQuery;
  if (target === null && typeof targetOrQuery === `string`) throw new Error(`Element query could not be resolved '${targetOrQuery}'`);
  if (target === null) throw new Error(`targetOrQuery is null`);
  const el = resolveEl(targetOrQuery);
  const when = options.when ?? `changed`;
  const eventName = when === `changed` ? `change` : `input`;
  const emitInitialValue = options.emitInitialValue ?? false;
  const fallbackValue = options.fallbackValue ?? ``;
  const upstreamSource = options.upstreamSource;
  let upstreamSourceUnsub = () => {
  };
  let attribName = options.attributeName;
  let fieldName = options.fieldName;
  if (fieldName === void 0 && attribName === void 0) {
    attribName = fieldName = `value`;
  }
  const readValue = () => {
    let value2;
    if (attribName) {
      value2 = el.getAttribute(attribName);
    }
    if (fieldName) {
      value2 = el[fieldName];
    }
    if (value2 === void 0 || value2 === null) value2 = fallbackValue;
    return value2;
  };
  const setValue = (value2) => {
    if (attribName) {
      el.setAttribute(attribName, value2);
    }
    if (fieldName) {
      el[fieldName] = value2;
    }
  };
  const setUpstream = (v3) => {
    v3 = options.upstreamFilter ? options.upstreamFilter(v3) : v3;
    setValue(v3);
  };
  if (upstreamSource) {
    upstreamSourceUnsub = upstreamSource.onValue(setUpstream);
    if (hasLast(upstreamSource)) {
      setUpstream(upstreamSource.last());
    }
  }
  const rxEvents = eventTrigger(el, eventName, {
    fireInitial: emitInitialValue,
    debugFiring: options.debugFiring ?? false,
    debugLifecycle: options.debugLifecycle ?? false
  });
  const rxValues = transform(rxEvents, (_trigger) => readValue());
  return {
    ...rxValues,
    el,
    last() {
      return readValue();
    },
    set(value2) {
      setValue(value2);
    },
    dispose(reason) {
      upstreamSourceUnsub();
      rxValues.dispose(reason);
      rxEvents.dispose(reason);
    }
  };
}
function number(initialValue) {
  let value2 = initialValue;
  const events = initStream();
  const set3 = (v3) => {
    value2 = v3;
    events.set(v3);
  };
  return {
    dispose: events.dispose,
    isDisposed: events.isDisposed,
    last: () => value2,
    on: events.on,
    onValue: events.onValue,
    set: set3
  };
}
var objectProxy = (target) => {
  const rx = object(target);
  const proxy = new Proxy(target, {
    set(target2, p4, newValue, _receiver) {
      const isArray = Array.isArray(target2);
      if (isArray && p4 === `length`) return true;
      if (typeof p4 === `string`) {
        rx.updateField(p4, newValue);
      }
      if (isArray && typeof p4 === `string`) {
        const pAsNumber = Number.parseInt(p4);
        if (!Number.isNaN(pAsNumber)) {
          target2[pAsNumber] = newValue;
          return true;
        }
      }
      target2[p4] = newValue;
      return true;
    }
  });
  return { proxy, rx };
};
var objectProxySymbol = (target) => {
  const { proxy, rx } = objectProxy(target);
  const p4 = proxy;
  p4[symbol] = rx;
  return p4;
};
function observable(init5) {
  const ow = observableWritable(init5);
  return {
    dispose: ow.dispose,
    isDisposed: ow.isDisposed,
    on: ow.on,
    onValue: ow.onValue
  };
}
function observableWritable(init5) {
  let onCleanup = () => {
  };
  const ow = manual({
    onFirstSubscribe() {
      onCleanup = init5(ow);
    },
    onNoSubscribers() {
      if (onCleanup) onCleanup();
    }
  });
  return {
    ...ow,
    onValue: (callback) => {
      return ow.on((message) => {
        if (messageHasValue(message)) {
          callback(message.value);
        }
      });
    }
  };
}
function string2(initialValue) {
  let value2 = initialValue;
  const events = initStream();
  const set3 = (v3) => {
    value2 = v3;
    events.set(v3);
  };
  return {
    dispose: events.dispose,
    isDisposed: events.isDisposed,
    last: () => value2,
    on: events.on,
    onValue: events.onValue,
    set: set3
  };
}
function run2(source, ...ops) {
  let s3 = resolveSource(source);
  for (const op of ops) {
    s3 = op(s3);
  }
  return s3;
}
function writable(source, ...ops) {
  let s3 = resolveSource(source);
  const head = s3;
  for (const op of ops) {
    s3 = op(s3);
  }
  let ss2 = s3;
  return {
    ...ss2,
    set(value2) {
      if (isWritable(head)) {
        head.set(value2);
      } else throw new Error(`Original source is not writable`);
    }
  };
}
function manual(options = {}) {
  const events = initStream(options);
  return {
    dispose: events.dispose,
    isDisposed: events.isDisposed,
    set(value2) {
      events.set(value2);
    },
    on: events.on,
    onValue: events.onValue
  };
}
var Sinks = {
  setHtmlText: (options) => {
    return (source) => {
      setHtmlText(source, options);
    };
  }
};
var Ops = {
  /**
  * Annotates values with the result of a function.
  * The input value needs to be an object.
  * 
  * For every value `input` emits, run it through `annotator`, which should
  * return the original value with additional fields.
  * 
  * Conceptually the same as `transform`, just with typing to enforce result
  * values are V & TAnnotation
  * @param annotator 
  * @returns 
  */
  annotate: (annotator) => opify(annotate, annotator),
  /**
   * Annotates the input stream using {@link ReactiveOp} as the source of annotations.
   * The output values will have the shape of `{ value: TIn, annotation: TAnnotation }`.
   * Meaning that the original value is stored under `.value`, and the annotation under `.annotation`.
   * 
   * ```js
   * // Emit values from an array
   * const r1 = Rx.run(
   *  Rx.From.array([ 1, 2, 3 ]),
   *  Rx.Ops.annotateWithOp(
   *    // Add the 'max' operator to emit the largest-seen value
   *    Rx.Ops.sum()
   *  )
   * );
   * const data = await Rx.toArray(r1);
   * // Data =  [ { value: 1, annotation: 1 }, { value: 2, annotation: 3 }, { value: 3, annotation: 6 } ]
   * ```
   * @param annotatorOp 
   * @returns 
   */
  annotateWithOp: (annotatorOp) => opify(annotateWithOp, annotatorOp),
  /**
   * Takes a stream of values and chunks them up (by quantity or time elapsed),
   * emitting them as an array.
   * @param options 
   * @returns 
   */
  chunk: (options) => {
    return (source) => {
      return chunk(source, options);
    };
  },
  cloneFromFields: () => {
    return (source) => {
      return cloneFromFields(source);
    };
  },
  /**
  * Merges values from several sources into a single source that emits values as an array.
  * @param options 
  * @returns 
  */
  combineLatestToArray: (options = {}) => {
    return (sources) => {
      return combineLatestToArray(sources, options);
    };
  },
  /**
   * Merges values from several sources into a single source that emits values as an object.
   * @param options
   * @returns 
   */
  combineLatestToObject: (options = {}) => {
    return (reactiveSources) => {
      return combineLatestToObject(reactiveSources, options);
    };
  },
  /**
  * Debounce values from the stream. It will wait until a certain time
  * has elapsed before emitting latest value.
  * 
  * Effect is that no values are emitted if input emits faster than the provided
  * timeout.
  * 
  * See also: throttle
  * @param options 
  * @returns 
  */
  debounce: (options) => {
    return (source) => {
      return debounce2(source, options);
    };
  },
  elapsed: () => opify(elapsed),
  /**
   * Yields the value of a field from an input stream of values.
   * Eg if the source reactive emits `{ colour: string, size: number }`,
   * we might use `field` to pluck out the `colour` field, thus returning
   * a stream of string values.
   * @param fieldName 
   * @param options 
   * @returns 
   */
  field: (fieldName, options) => {
    return (source) => {
      return field(source, fieldName, options);
    };
  },
  /**
   * Filters the input stream, only re-emitting values that pass the predicate
   * @param predicate 
   * @returns 
   */
  filter: (predicate) => opify(filter22, predicate),
  /**
   * Every upstream value is considered the target for interpolation.
   * Output value interpolates by a given amount toward the target.
   * @param options 
   * @returns 
   */
  interpolate: (options) => opify(interpolate22, options),
  /**
  * Outputs the minimum numerical value of the stream.
  * A value is only emitted when minimum decreases.
  * @returns 
  */
  min: (options) => opify(min4, options),
  /**
   * Outputs the maxium numerical value of the stream.
   * A value is only emitted when maximum increases.
   * @returns 
   */
  max: (options) => opify(max32, options),
  sum: (options) => opify(sum2, options),
  average: (options) => opify(average2, options),
  tally: (options) => opify(tally2, options),
  rank: (rank3, options) => opify(rank2, rank3, options),
  pipe: (...streams) => {
    return (source) => {
      const resolved = resolveSource(source);
      const s3 = [resolved, ...streams];
      return pipe(...s3);
    };
  },
  singleFromArray: (options = {}) => {
    return (source) => {
      return singleFromArray(source, options);
    };
  },
  split: (options = {}) => {
    return (source) => {
      return split(source, options);
    };
  },
  splitLabelled: (labels) => {
    return (source) => {
      return splitLabelled(source, labels);
    };
  },
  switcher: (cases, options = {}) => {
    return (source) => {
      return switcher(source, cases, options);
    };
  },
  syncToArray: (options = {}) => {
    return (reactiveSources) => {
      return syncToArray(reactiveSources, options);
    };
  },
  syncToObject: (options = {}) => {
    return (reactiveSources) => {
      return syncToObject(reactiveSources, options);
    };
  },
  tapProcess: (processor) => {
    return (source) => {
      return tapProcess(source, processor);
    };
  },
  tapStream: (divergedStream) => {
    return (source) => {
      return tapStream(source, divergedStream);
    };
  },
  tapOps: (...ops) => {
    return (source) => {
      return tapOps(source, ...ops);
    };
  },
  /**
  * Throttle values from the stream.
  * Only emits a value if some minimum time has elapsed.
  * @param options 
  * @returns 
  */
  throttle: (options) => opify(throttle2, options),
  /**
   * Trigger a value if 'source' does not emit a value within an interval.
   * Trigger value can be a fixed value, result of function, or step through an iterator.
   * @param options 
   * @returns 
   */
  timeoutValue: (options) => {
    return (source) => {
      return timeoutValue(source, options);
    };
  },
  timeoutPing: (options) => {
    return (source) => {
      return timeoutPing(source, options);
    };
  },
  transform: (transformer, options = {}) => {
    return (source) => {
      return transform(source, transformer, options);
    };
  },
  /**
  * Reactive where last (or a given initial) value is available to read
  * @param opts 
  * @returns 
  */
  withValue: (opts) => {
    return opify(withValue, opts);
  }
};
async function takeNextValue(source, maximumWait = 1e3) {
  const rx = resolveSource(source);
  let off = () => {
  };
  let watchdog;
  const p4 = new Promise((resolve22, reject) => {
    off = rx.on((message) => {
      if (watchdog) clearTimeout(watchdog);
      if (messageHasValue(message)) {
        off();
        resolve22(message.value);
      } else {
        if (messageIsDoneSignal(message)) {
          reject(new Error(`Source closed. ${message.context ?? ``}`));
          off();
        }
      }
    });
    watchdog = setTimeout(() => {
      watchdog = void 0;
      off();
      reject(new Error(`Timeout waiting for value (${JSON.stringify(maximumWait)})`));
    }, intervalToMs(maximumWait));
  });
  return p4;
}
var to4 = (a4, b4, transform2, closeBonA = false) => {
  const unsub = a4.on((message) => {
    if (messageHasValue(message)) {
      const value2 = transform2 ? transform2(message.value) : message.value;
      b4.set(value2);
    } else if (messageIsDoneSignal(message)) {
      unsub();
      if (closeBonA) {
        b4.dispose(`Source closed (${message.context ?? ``})`);
      }
    } else {
      console.warn(`Unsupported message: ${JSON.stringify(message)}`);
    }
  });
  return unsub;
};

// node_modules/ixfx/dist/chunk-GNUWD24I.js
var queue_exports = {};
__export(queue_exports, {
  PriorityMutable: () => PriorityMutable,
  asResponsive: () => asResponsive,
  immutable: () => immutable3,
  mutable: () => mutable2,
  priority: () => priority
});
var QueueImmutable = class _QueueImmutable {
  #data;
  /**
   * Creates an instance of Queue.
   * @param {QueueOpts} opts Options foor queue
   * @param {V[]} data Initial data. Index 0 is front of queue
   */
  constructor(opts = {}, data = []) {
    if (opts === void 0) throw new Error(`opts parameter undefined`);
    this.opts = opts;
    this.#data = data;
  }
  forEach(fn2) {
    for (let index = this.#data.length - 1; index >= 0; index--) {
      fn2(this.#data[index]);
    }
  }
  forEachFromFront(fn2) {
    this.#data.forEach((item) => {
      fn2(item);
    });
  }
  enqueue(...toAdd) {
    return new _QueueImmutable(
      this.opts,
      enqueue(this.opts, this.#data, ...toAdd)
    );
  }
  dequeue() {
    return new _QueueImmutable(this.opts, dequeue(this.opts, this.#data));
  }
  get isEmpty() {
    return isEmpty(this.opts, this.#data);
  }
  get isFull() {
    return isFull(this.opts, this.#data);
  }
  get length() {
    return this.#data.length;
  }
  get peek() {
    return peek(this.opts, this.#data);
  }
  toArray() {
    return [...this.#data];
  }
};
var immutable3 = (options = {}, ...startingItems) => {
  options = { ...options };
  return new QueueImmutable(options, [...startingItems]);
};
function asResponsive(queue) {
  const events = manual({
    onNoSubscribers() {
      queue.removeEventListener(`removed`, onRemoved);
      queue.removeEventListener(`enqueue`, onEnqueue);
    },
    onFirstSubscribe() {
      queue.addEventListener(`removed`, onRemoved);
      queue.addEventListener(`enqueue`, onEnqueue);
      events.set(queue.toArray());
    }
  });
  const onRemoved = (event2) => {
    events.set(event2.finalData);
  };
  const onEnqueue = (event2) => {
    events.set(event2.finalData);
  };
  const set3 = (data) => {
    queue.enqueue(...data);
  };
  return {
    ...events,
    set: set3
  };
}

// node_modules/ixfx/dist/chunk-WSRNZ4D4.js
var DomRx_exports = {};
__export(DomRx_exports, {
  resizeObservable: () => resizeObservable,
  themeChange: () => themeChange,
  windowResize: () => windowResize
});
var windowResize = (elapsed3) => Ops.debounce({ elapsed: elapsed3 ?? 100 })(sources_exports.event(window, `resize`, { innerWidth: 0, innerHeight: 0 }));
var themeChange = () => {
  const m5 = sources_exports.observable((stream) => {
    const ro2 = new MutationObserver((entries2) => {
      stream.set(entries2);
    });
    const opts = {
      attributeFilter: [`class`],
      attributes: true
    };
    ro2.observe(document.documentElement, opts);
    return () => {
      ro2.disconnect();
    };
  });
  return m5;
};
var resizeObservable = (elem, interval2) => {
  if (elem === null) {
    throw new Error(`elem parameter is null. Expected element to observe`);
  }
  if (elem === void 0) {
    throw new Error(`elem parameter is undefined. Expected element to observe`);
  }
  const m5 = sources_exports.observable((stream) => {
    const ro2 = new ResizeObserver((entries2) => {
      stream.set(entries2);
    });
    ro2.observe(elem);
    return () => {
      ro2.unobserve(elem);
    };
  });
  return Ops.debounce({ elapsed: interval2 ?? 100 })(m5);
};
var parentSizeCanvas = (domQueryOrEl, onResized, timeoutMs = 100) => {
  const el = resolveEl(domQueryOrEl);
  if (el.nodeName !== `CANVAS`) {
    throw new Error(
      `Expected HTML element with node name CANVAS, not ${el.nodeName}`
    );
  }
  const parent = el.parentElement;
  if (parent === null) throw new Error(`Element has no parent`);
  const ctx = el.getContext(`2d`);
  if (ctx === null) throw new Error(`Could not create drawing context`);
  el.style.width = `100%`;
  el.style.height = `100%`;
  const ro2 = resizeObservable(parent, timeoutMs).onValue(
    (entries2) => {
      const entry = entries2.find((v3) => v3.target === parent);
      if (entry === void 0) return;
      const width = entry.contentRect.width;
      const height4 = entry.contentRect.height;
      el.setAttribute(`width`, el.offsetWidth + `px`);
      el.setAttribute(`height`, el.offsetHeight + `px`);
      if (onResized !== void 0) {
        const bounds = {
          min: Math.min(width, height4),
          max: Math.max(width, height4),
          width,
          height: height4,
          center: { x: width / 2, y: height4 / 2 }
        };
        onResized({ ctx, el, bounds });
      }
    }
  );
  return ro2;
};

// node_modules/ixfx/dist/chunk-PZET2535.js
var isNull = (p4) => p4.x === null && p4.y === null;
var isNaN2 = (p4) => Number.isNaN(p4.x) || Number.isNaN(p4.y);
function guard(p4, name = `Point`) {
  if (p4 === void 0) {
    throw new Error(
      `'${name}' is undefined. Expected {x,y} got ${JSON.stringify(p4)}`
    );
  }
  if (p4 === null) {
    throw new Error(
      `'${name}' is null. Expected {x,y} got ${JSON.stringify(p4)}`
    );
  }
  if (p4.x === void 0) {
    throw new Error(
      `'${name}.x' is undefined. Expected {x,y} got ${JSON.stringify(p4)}`
    );
  }
  if (p4.y === void 0) {
    throw new Error(
      `'${name}.y' is undefined. Expected {x,y} got ${JSON.stringify(p4)}`
    );
  }
  if (typeof p4.x !== `number`) {
    throw new TypeError(`'${name}.x' must be a number. Got ${p4.x}`);
  }
  if (typeof p4.y !== `number`) {
    throw new TypeError(`'${name}.y' must be a number. Got ${p4.y}`);
  }
  if (p4.x === null) throw new Error(`'${name}.x' is null`);
  if (p4.y === null) throw new Error(`'${name}.y' is null`);
  if (Number.isNaN(p4.x)) throw new Error(`'${name}.x' is NaN`);
  if (Number.isNaN(p4.y)) throw new Error(`'${name}.y' is NaN`);
}
var guardNonZeroPoint = (pt2, name = `pt`) => {
  guard(pt2, name);
  throwNumberTest(pt2.x, `nonZero`, `${name}.x`);
  throwNumberTest(pt2.y, `nonZero`, `${name}.y`);
  if (typeof pt2.z !== `undefined`) {
    throwNumberTest(pt2.z, `nonZero`, `${name}.z`);
  }
  return true;
};
function isPoint(p4) {
  if (p4 === void 0) return false;
  if (p4 === null) return false;
  if (p4.x === void 0) return false;
  if (p4.y === void 0) return false;
  return true;
}
var isPoint3d = (p4) => {
  if (p4 === void 0) return false;
  if (p4 === null) return false;
  if (p4.x === void 0) return false;
  if (p4.y === void 0) return false;
  if (p4.z === void 0) return false;
  return true;
};
var isEmpty3 = (p4) => p4.x === 0 && p4.y === 0;
var isPlaceholder = (p4) => Number.isNaN(p4.x) && Number.isNaN(p4.y);
var fromPoints = (a4, b4) => {
  guard(a4, `a`);
  guard(b4, `b`);
  a4 = Object.freeze({ ...a4 });
  b4 = Object.freeze({ ...b4 });
  return Object.freeze({
    a: a4,
    b: b4
  });
};
var fromNumbers = (x1, y1, x22, y22) => {
  if (Number.isNaN(x1)) throw new Error(`x1 is NaN`);
  if (Number.isNaN(x22)) throw new Error(`x2 is NaN`);
  if (Number.isNaN(y1)) throw new Error(`y1 is NaN`);
  if (Number.isNaN(y22)) throw new Error(`y2 is NaN`);
  const a4 = { x: x1, y: y1 };
  const b4 = { x: x22, y: y22 };
  return fromPoints(a4, b4);
};

// node_modules/ixfx/dist/chunk-V7MA3QCK.js
var Svg_exports = {};
__export(Svg_exports, {
  Elements: () => SvgElements_exports,
  applyOpts: () => applyOpts,
  applyPathOpts: () => applyPathOpts,
  applyStrokeOpts: () => applyStrokeOpts,
  clear: () => clear,
  createEl: () => createEl,
  createOrResolve: () => createOrResolve,
  getBounds: () => getBounds,
  makeHelper: () => makeHelper,
  remove: () => remove3,
  setBounds: () => setBounds
});
var createMarker = (id, opts, childCreator) => {
  const m5 = createEl(`marker`, id);
  if (opts.markerWidth) {
    m5.setAttribute(`markerWidth`, opts.markerWidth?.toString());
  }
  if (opts.markerHeight) {
    m5.setAttribute(`markerHeight`, opts.markerHeight?.toString());
  }
  if (opts.orient) m5.setAttribute(`orient`, opts.orient.toString());
  else m5.setAttribute(`orient`, `auto-start-reverse`);
  if (opts.viewBox) m5.setAttribute(`viewBox`, opts.viewBox.toString());
  if (opts.refX) m5.setAttribute(`refX`, opts.refX.toString());
  if (opts.refY) m5.setAttribute(`refY`, opts.refY.toString());
  if (childCreator) {
    const c6 = childCreator();
    m5.appendChild(c6);
  }
  return m5;
};
var markerPrebuilt = (elem, opts, _context) => {
  if (elem === null) return `(elem null)`;
  const parent = elem.ownerSVGElement;
  if (parent === null) throw new Error(`parent for elem is null`);
  const defsEl = createOrResolve(parent, `defs`, `defs`);
  let defEl = defsEl.querySelector(`#${opts.id}`);
  if (defEl !== null) {
    return `url(#${opts.id})`;
  }
  if (opts.id === `triangle`) {
    opts = { ...opts, strokeStyle: `transparent` };
    if (!opts.markerHeight) opts = { ...opts, markerHeight: 6 };
    if (!opts.markerWidth) opts = { ...opts, markerWidth: 6 };
    if (!opts.refX) opts = { ...opts, refX: opts.markerWidth };
    if (!opts.refY) opts = { ...opts, refY: opts.markerHeight };
    if (!opts.fillStyle || opts.fillStyle === `none`) {
      opts = { ...opts, fillStyle: `black` };
    }
    if (!opts.viewBox) opts = { ...opts, viewBox: `0 0 10 10` };
    defEl = createMarker(opts.id, opts, () => {
      const tri = createEl(`path`);
      tri.setAttribute(`d`, `M 0 0 L 10 5 L 0 10 z`);
      if (opts) applyOpts(tri, opts);
      return tri;
    });
  } else throw new Error(`Do not know how to make ${opts.id}`);
  defEl.id = opts.id;
  defsEl.appendChild(defEl);
  return `url(#${opts.id})`;
};
var SvgElements_exports = {};
__export(SvgElements_exports, {
  circle: () => circle,
  circleUpdate: () => circleUpdate,
  grid: () => grid,
  group: () => group,
  groupUpdate: () => groupUpdate,
  line: () => line,
  lineUpdate: () => lineUpdate,
  path: () => path,
  pathUpdate: () => pathUpdate,
  text: () => text,
  textPath: () => textPath,
  textPathUpdate: () => textPathUpdate,
  textUpdate: () => textUpdate
});
var numberOrPercentage = (v3) => {
  if (v3 >= 0 && v3 <= 1) return `${v3 * 100}%`;
  return v3.toString();
};
var path = (svgOrArray, parent, opts, queryOrExisting) => {
  const elem = createOrResolve(
    parent,
    `path`,
    queryOrExisting
  );
  const svg = typeof svgOrArray === `string` ? svgOrArray : svgOrArray.join(`
`);
  elem.setAttributeNS(null, `d`, svg);
  parent.append(elem);
  return pathUpdate(elem, opts);
};
var pathUpdate = (elem, opts) => {
  if (opts) applyOpts(elem, opts);
  if (opts) applyStrokeOpts(elem, opts);
  return elem;
};
var circleUpdate = (elem, circle22, opts) => {
  elem.setAttributeNS(null, `cx`, circle22.x.toString());
  elem.setAttributeNS(null, `cy`, circle22.y.toString());
  elem.setAttributeNS(null, `r`, circle22.radius.toString());
  if (opts) applyOpts(elem, opts);
  if (opts) applyStrokeOpts(elem, opts);
  return elem;
};
var circle = (circle22, parent, opts, queryOrExisting) => {
  const p4 = createOrResolve(
    parent,
    `circle`,
    queryOrExisting
  );
  return circleUpdate(p4, circle22, opts);
};
var group = (children3, parent, queryOrExisting) => {
  const p4 = createOrResolve(parent, `g`, queryOrExisting);
  return groupUpdate(p4, children3);
};
var groupUpdate = (elem, children3) => {
  for (const c6 of children3) {
    if (c6.parentNode !== elem) {
      elem.append(c6);
    }
  }
  return elem;
};
var line = (line22, parent, opts, queryOrExisting) => {
  const lineEl = createOrResolve(
    parent,
    `line`,
    queryOrExisting
  );
  return lineUpdate(lineEl, line22, opts);
};
var lineUpdate = (lineEl, line22, opts) => {
  lineEl.setAttributeNS(null, `x1`, line22.a.x.toString());
  lineEl.setAttributeNS(null, `y1`, line22.a.y.toString());
  lineEl.setAttributeNS(null, `x2`, line22.b.x.toString());
  lineEl.setAttributeNS(null, `y2`, line22.b.y.toString());
  if (opts) applyOpts(lineEl, opts);
  if (opts) applyPathOpts(lineEl, opts);
  if (opts) applyStrokeOpts(lineEl, opts);
  return lineEl;
};
var textPathUpdate = (el, text2, opts) => {
  if (opts?.method) el.setAttributeNS(null, `method`, opts.method);
  if (opts?.side) el.setAttributeNS(null, `side`, opts.side);
  if (opts?.spacing) el.setAttributeNS(null, `spacing`, opts.spacing);
  if (opts?.startOffset) {
    el.setAttributeNS(null, `startOffset`, numberOrPercentage(opts.startOffset));
  }
  if (opts?.textLength) {
    el.setAttributeNS(null, `textLength`, numberOrPercentage(opts.textLength));
  }
  if (text2) {
    el.textContent = text2;
  }
  if (opts) applyOpts(el, opts);
  if (opts) applyStrokeOpts(el, opts);
  return el;
};
var textPath = (pathReference, text2, parent, opts, textQueryOrExisting, pathQueryOrExisting) => {
  const textEl = createOrResolve(
    parent,
    `text`,
    textQueryOrExisting,
    `-text`
  );
  textUpdate(textEl, void 0, void 0, opts);
  const p4 = createOrResolve(
    textEl,
    `textPath`,
    pathQueryOrExisting
  );
  p4.setAttributeNS(null, `href`, pathReference);
  return textPathUpdate(p4, text2, opts);
};
var textUpdate = (el, pos, text2, opts) => {
  if (pos) {
    el.setAttributeNS(null, `x`, pos.x.toString());
    el.setAttributeNS(null, `y`, pos.y.toString());
  }
  if (text2) {
    el.textContent = text2;
  }
  if (opts) {
    applyOpts(el, opts);
    if (opts) applyStrokeOpts(el, opts);
    if (opts.anchor) el.setAttributeNS(null, `text-anchor`, opts.anchor);
    if (opts.align) el.setAttributeNS(null, `alignment-baseline`, opts.align);
    const userSelect = opts.userSelect ?? true;
    if (!userSelect) {
      el.style.userSelect = `none`;
      el.style.webkitUserSelect = `none`;
    }
  }
  return el;
};
var text = (text2, parent, pos, opts, queryOrExisting) => {
  const p4 = createOrResolve(
    parent,
    `text`,
    queryOrExisting
  );
  return textUpdate(p4, pos, text2, opts);
};
var grid = (parent, center4, spacing, width, height4, opts = {}) => {
  if (!opts.strokeStyle) {
    opts = { ...opts, strokeStyle: getCssVariable(`bg-dim`, `silver`) };
  }
  if (!opts.strokeWidth) opts = { ...opts, strokeWidth: 1 };
  const g5 = createEl(`g`);
  applyOpts(g5, opts);
  applyPathOpts(g5, opts);
  applyStrokeOpts(g5, opts);
  let y3 = 0;
  while (y3 < height4) {
    const horiz = fromNumbers(0, y3, width, y3);
    line(horiz, g5);
    y3 += spacing;
  }
  let x3 = 0;
  while (x3 < width) {
    const vert = fromNumbers(x3, 0, x3, height4);
    line(vert, g5);
    x3 += spacing;
  }
  parent.append(g5);
  return g5;
};
var createOrResolve = (parent, type2, queryOrExisting, suffix) => {
  let existing = null;
  if (queryOrExisting !== void 0) {
    existing = typeof queryOrExisting === `string` ? parent.querySelector(queryOrExisting) : queryOrExisting;
  }
  if (existing === null) {
    const p4 = document.createElementNS(`http://www.w3.org/2000/svg`, type2);
    parent.append(p4);
    if (queryOrExisting && typeof queryOrExisting === `string` && queryOrExisting.startsWith(`#`)) {
      p4.id = suffix !== void 0 && !queryOrExisting.endsWith(suffix) ? queryOrExisting.slice(1) + suffix : queryOrExisting.slice(1);
    }
    return p4;
  }
  return existing;
};
var remove3 = (parent, queryOrExisting) => {
  if (typeof queryOrExisting === `string`) {
    const elem = parent.querySelector(queryOrExisting);
    if (elem === null) return;
    elem.remove();
  } else {
    queryOrExisting.remove();
  }
};
var clear = (parent) => {
  let c6 = parent.lastElementChild;
  while (c6) {
    c6.remove();
    c6 = parent.lastElementChild;
  }
};
var createEl = (type2, id) => {
  const m5 = document.createElementNS(`http://www.w3.org/2000/svg`, type2);
  if (id) {
    m5.id = id;
  }
  return m5;
};
var applyPathOpts = (elem, opts) => {
  if (opts.markerEnd) {
    elem.setAttribute(
      `marker-end`,
      markerPrebuilt(elem, opts.markerEnd, opts)
    );
  }
  if (opts.markerStart) {
    elem.setAttribute(
      `marker-start`,
      markerPrebuilt(elem, opts.markerStart, opts)
    );
  }
  if (opts.markerMid) {
    elem.setAttribute(
      `marker-mid`,
      markerPrebuilt(elem, opts.markerMid, opts)
    );
  }
};
var applyOpts = (elem, opts) => {
  if (opts.fillStyle) elem.setAttributeNS(null, `fill`, opts.fillStyle);
  if (opts.opacity) {
    elem.setAttributeNS(null, `opacity`, opts.opacity.toString());
  }
};
var applyStrokeOpts = (elem, opts) => {
  if (opts.strokeStyle) elem.setAttributeNS(null, `stroke`, opts.strokeStyle);
  if (opts.strokeWidth) {
    elem.setAttributeNS(null, `stroke-width`, opts.strokeWidth.toString());
  }
  if (opts.strokeDash) elem.setAttribute(`stroke-dasharray`, opts.strokeDash);
  if (opts.strokeLineCap) {
    elem.setAttribute(`stroke-linecap`, opts.strokeLineCap);
  }
};
var getBounds = (svg) => {
  const w3 = svg.getAttributeNS(null, `width`);
  const width = w3 === null ? 0 : Number.parseFloat(w3);
  const h5 = svg.getAttributeNS(null, `height`);
  const height4 = h5 === null ? 0 : Number.parseFloat(h5);
  return { width, height: height4 };
};
var setBounds = (svg, bounds) => {
  svg.setAttributeNS(null, `width`, bounds.width.toString());
  svg.setAttributeNS(null, `height`, bounds.height.toString());
};
var makeHelper = (parent, parentOpts) => {
  if (parentOpts) {
    applyOpts(parent, parentOpts);
    applyStrokeOpts(parent, parentOpts);
  }
  const o5 = {
    remove: (queryOrExisting) => {
      remove3(parent, queryOrExisting);
    },
    text: (text2, pos, opts, queryOrExisting) => text(text2, parent, pos, opts, queryOrExisting),
    textPath: (pathReference, text2, opts, textQueryOrExisting, pathQueryOrExisting) => textPath(pathReference, text2, parent, opts, textQueryOrExisting, pathQueryOrExisting),
    line: (line22, opts, queryOrExisting) => line(line22, parent, opts, queryOrExisting),
    circle: (circle22, opts, queryOrExisting) => circle(circle22, parent, opts, queryOrExisting),
    path: (svgString, opts, queryOrExisting) => path(svgString, parent, opts, queryOrExisting),
    grid: (center4, spacing, width, height4, opts) => grid(parent, center4, spacing, width, height4, opts),
    query: (selectors) => parent.querySelector(selectors),
    get width() {
      const w3 = parent.getAttributeNS(null, `width`);
      if (w3 === null) return 0;
      return Number.parseFloat(w3);
    },
    set width(width) {
      parent.setAttributeNS(null, `width`, width.toString());
    },
    get parent() {
      return parent;
    },
    get height() {
      const w3 = parent.getAttributeNS(null, `height`);
      if (w3 === null) return 0;
      return Number.parseFloat(w3);
    },
    set height(height4) {
      parent.setAttributeNS(null, `height`, height4.toString());
    },
    clear: () => {
      while (parent.firstChild) {
        parent.lastChild.remove();
      }
    }
  };
  return o5;
};

// node_modules/ixfx/dist/chunk-LOIP62EP.js
var quantiseEvery = (v3, every3, middleRoundsUp = true) => {
  const everyStr = every3.toString();
  const decimal = everyStr.indexOf(`.`);
  let multiplier = 1;
  if (decimal >= 0) {
    let d4 = everyStr.substring(decimal + 1).length;
    multiplier = 10 * d4;
    every3 = Math.floor(multiplier * every3);
    v3 = v3 * multiplier;
  }
  throwNumberTest(v3, ``, `v`);
  throwIntegerTest(every3, ``, `every`);
  let div = v3 / every3;
  const divModule = div % 1;
  div = Math.floor(div);
  if (divModule === 0.5 && middleRoundsUp || divModule > 0.5) div++;
  const vv = every3 * div / multiplier;
  return vv;
};
function* linearSpace(start, end, steps2, precision) {
  throwNumberTest(start, ``, `start`);
  throwNumberTest(end, ``, `end`);
  throwNumberTest(steps2, ``, `steps`);
  const r5 = precision ? round(precision) : (v3) => v3;
  const step = (end - start) / (steps2 - 1);
  throwNumberTest(step, ``, `step`);
  if (!Number.isFinite(step)) {
    throw new TypeError(`Calculated step value is infinite`);
  }
  for (let index = 0; index < steps2; index++) {
    const v3 = start + step * index;
    yield r5(v3);
  }
}

// node_modules/ixfx/dist/chunk-NGZXMICH.js
var dotProduct = (values) => {
  let r5 = 0;
  const length5 = values[0].length;
  for (let index = 0; index < length5; index++) {
    let t6 = 0;
    for (const [p4, value2] of values.entries()) {
      if (p4 === 0) t6 = value2[index];
      else {
        t6 *= value2[index];
      }
    }
    r5 += t6;
  }
  return r5;
};
var minIndex = (...data) => (
  // eslint-disable-next-line unicorn/no-array-reduce
  data.reduce(
    (bestIndex, value2, index, array2) => value2 < array2[bestIndex] ? index : bestIndex,
    0
  )
);
var minFast = (data) => {
  let m5 = Number.MIN_SAFE_INTEGER;
  for (const datum of data) {
    m5 = Math.min(m5, datum);
  }
  return m5;
};

// node_modules/ixfx/dist/chunk-UF3EQW5C.js
var set_exports = {};
__export(set_exports, {
  MassiveSet: () => MassiveSet,
  immutable: () => immutable4,
  mutable: () => mutable3
});
var mutable3 = (keyString) => new SetStringMutable(keyString);
var SetStringMutable = class extends SimpleEventEmitter {
  /**
   * Constructor
   * @param keyString Function which returns a string version of added items. If unspecified `JSON.stringify`
   */
  constructor(keyString) {
    super();
    this.store = /* @__PURE__ */ new Map();
    this.keyString = keyString ?? defaultKeyer;
  }
  /**
   * Number of items stored in set
   */
  get size() {
    return this.store.size;
  }
  /**
   * Adds one or more items to set. `add` event is fired for each item
   * @param values items to add
   */
  add(...values) {
    let somethingAdded = false;
    for (const value2 of values) {
      const isUpdated = this.has(value2);
      this.store.set(this.keyString(value2), value2);
      super.fireEvent(`add`, { value: value2, updated: isUpdated });
      if (!isUpdated) somethingAdded = true;
    }
    return somethingAdded;
  }
  /**
   * Returns values from set as an iterable
   * @returns
   */
  //eslint-disable-next-line functional/prefer-tacit
  values() {
    return this.store.values();
  }
  /**
   * Clear items from set
   */
  clear() {
    this.store.clear();
    super.fireEvent(`clear`, true);
  }
  /**
   * Delete value from set.
   * @param v Value to delete
   * @returns _True_ if item was found and removed
   */
  delete(v3) {
    const isDeleted = this.store.delete(this.keyString(v3));
    if (isDeleted) super.fireEvent(`delete`, v3);
    return isDeleted;
  }
  /**
   * Returns _true_ if item exists in set
   * @param v
   * @returns
   */
  has(v3) {
    return this.store.has(this.keyString(v3));
  }
  /**
   * Returns array copy of set
   * @returns Array copy of set
   */
  toArray() {
    return [...this.store.values()];
  }
};
var SetStringImmutable = class _SetStringImmutable {
  //eslint-disable-next-line functional/prefer-immutable-types
  constructor(keyString, map3) {
    this.store = map3 ?? /* @__PURE__ */ new Map();
    this.keyString = keyString ?? defaultKeyer;
  }
  get size() {
    return this.store.size;
  }
  add(...values) {
    const s3 = new Map(this.store);
    for (const v3 of values) {
      const key = this.keyString(v3);
      s3.set(key, v3);
    }
    return new _SetStringImmutable(this.keyString, s3);
  }
  delete(v3) {
    const s3 = new Map(this.store);
    const key = this.keyString(v3);
    if (s3.delete(key)) return new _SetStringImmutable(this.keyString, s3);
    return this;
  }
  has(v3) {
    const key = this.keyString(v3);
    return this.store.has(key);
  }
  toArray() {
    return [...this.store.values()];
  }
  *values() {
    yield* this.store.values();
  }
};
var immutable4 = (keyString = toStringDefault) => new SetStringImmutable(keyString);
var MassiveSet = class _MassiveSet {
  constructor(maxDepth = 1, depth = 0) {
    this.children = /* @__PURE__ */ new Map();
    this.values = [];
    this.#depth = depth;
    this.#maxDepth = maxDepth;
  }
  #depth;
  #maxDepth;
  /**
   * Returns the number of values stored in just this level of the set
   * @returns 
   */
  sizeLocal() {
    return this.values.length;
  }
  /**
   * Returns the number of branches at this node
   * Use {@link sizeChildrenDeep} to count all branches recursively
   * @returns 
   */
  sizeChildren() {
    return [...this.children.values()].length;
  }
  sizeChildrenDeep() {
    let t6 = this.sizeChildren();
    for (const c6 of this.children.values()) {
      t6 += c6.sizeChildrenDeep();
    }
    return t6;
  }
  /**
   * Returns the total number of values stored in the set
   */
  size() {
    let x3 = this.values.length;
    for (const set3 of this.children.values()) {
      x3 += set3.size();
    }
    return x3;
  }
  add(value2) {
    if (typeof value2 !== `string`) throw new Error(`Param 'value' must be a string. Got: ${typeof value2}`);
    if (value2.length === 0) throw new Error(`Param 'value' is empty`);
    const destination = this.#getChild(value2, true);
    if (destination === this) {
      if (!this.hasLocal(value2)) {
        this.values.push(value2);
      }
      return;
    }
    if (!destination) throw new Error(`Could not create child set for: ${value2}`);
    destination.add(value2);
  }
  remove(value2) {
    if (typeof value2 !== `string`) throw new Error(`Param 'value' must be a string. Got: ${typeof value2}`);
    if (value2.length === 0) throw new Error(`Param 'value' is empty`);
    const destination = this.#getChild(value2, false);
    if (destination === void 0) return false;
    if (destination === this) {
      if (this.hasLocal(value2)) {
        this.values = this.values.filter((v3) => v3 !== value2);
        return true;
      }
      return false;
    }
    return destination.remove(value2);
  }
  debugDump() {
    const r5 = this.#dumpToArray();
    for (const rr2 of r5) {
      console.log(rr2);
    }
  }
  #dumpToArray(depth = 0) {
    const r5 = [];
    r5.push(`Depth: ${this.#depth} Max: ${this.#maxDepth}`);
    for (const [key, value2] of this.children.entries()) {
      const dumped = value2.#dumpToArray(depth + 1);
      r5.push(` key: ${key}`);
      for (const d4 of dumped) {
        r5.push(` `.repeat(depth + 1) + d4);
      }
    }
    r5.push(`Values: (${this.values.length})`);
    for (const v3 of this.values) {
      r5.push(` ${v3}`);
    }
    return r5.map((line3) => ` `.repeat(depth) + line3);
  }
  #getChild(value2, create5) {
    if (value2 === void 0) throw new Error(`Param 'value' undefined`);
    if (this.#depth === this.#maxDepth) return this;
    if (value2.length <= this.#depth) return this;
    const k3 = value2[this.#depth];
    if (k3 === void 0) throw new Error(`Logic error. Depth: ${this.#depth} Len: ${value2.length}`);
    let child = this.children.get(k3);
    if (child === void 0 && create5) {
      child = new _MassiveSet(this.#maxDepth, this.#depth + 1);
      this.children.set(k3, child);
    }
    return child;
  }
  /**
   * Returns _true_ if `value` stored on this node
   * @param value 
   * @returns 
   */
  hasLocal(value2) {
    for (const v3 of this.values) {
      if (v3 === value2) return true;
    }
    return false;
  }
  has(value2) {
    if (typeof value2 !== `string`) return false;
    const destination = this.#getChild(value2, false);
    if (destination === void 0) return false;
    if (destination === this) return this.hasLocal(value2);
    return destination.has(value2);
  }
};

// node_modules/ixfx/dist/chunk-AGCCB7IA.js
var sortByNumericProperty = (data, propertyName) => [...data].sort((a4, b4) => {
  guardArray(data, `data`);
  const av = a4[propertyName];
  const bv = b4[propertyName];
  if (av < bv) return -1;
  if (av > bv) return 1;
  return 0;
});

// node_modules/ixfx/dist/chunk-H3AVG2VJ.js
var geometry_exports = {};
__export(geometry_exports, {
  Arcs: () => arc_exports,
  Beziers: () => bezier_exports,
  Circles: () => circle_exports,
  Compound: () => CompoundPath_exports,
  Convolve2d: () => Convolve2d_exports,
  CurveSimplification: () => CurveSimplification_exports,
  Ellipses: () => Ellipse_exports,
  Grids: () => Grid_exports,
  Layouts: () => Layout_exports,
  Lines: () => line_exports,
  Paths: () => path_exports,
  Points: () => point_exports,
  Polar: () => Polar_exports,
  QuadTree: () => QuadTree_exports,
  Rects: () => rect_exports,
  Scaler: () => Scaler_exports,
  Shapes: () => shape_exports,
  SurfacePoints: () => SurfacePoints_exports,
  Triangles: () => triangle_exports,
  Vectors: () => Vector_exports,
  Waypoints: () => Waypoint_exports,
  degreeToRadian: () => degreeToRadian,
  radianInvert: () => radianInvert,
  radianToDegree: () => radianToDegree,
  radiansFromAxisX: () => radiansFromAxisX
});
var Waypoint_exports = {};
__export(Waypoint_exports, {
  fromPoints: () => fromPoints2,
  init: () => init3
});
var joinPointsToLines = (...points) => {
  const lines = [];
  let start = points[0];
  for (let index = 1; index < points.length; index++) {
    lines.push(fromPoints(start, points[index]));
    start = points[index];
  }
  return lines;
};
var isLine = (p4) => {
  if (p4 === void 0) return false;
  if (p4.a === void 0) return false;
  if (p4.b === void 0) return false;
  if (!isPoint(p4.a)) return false;
  if (!isPoint(p4.b)) return false;
  return true;
};
var isPolyLine = (p4) => {
  if (!Array.isArray(p4)) return false;
  const valid = !p4.some((v3) => !isLine(v3));
  return valid;
};
var guard2 = (line3, name = `line`) => {
  if (line3 === void 0) throw new Error(`${name} undefined`);
  if (line3.a === void 0) throw new Error(`${name}.a undefined. Expected {a:Point, b:Point}. Got: ${JSON.stringify(line3)}`);
  if (line3.b === void 0) throw new Error(`${name}.b undefined. Expected {a:Point, b:Point} Got: ${JSON.stringify(line3)}`);
};
var getPointParameter = (aOrLine, b4) => {
  let a4;
  if (isLine(aOrLine)) {
    b4 = aOrLine.b;
    a4 = aOrLine.a;
  } else {
    a4 = aOrLine;
    if (b4 === void 0) throw new Error(`Since first parameter is not a line, two points are expected. Got a: ${JSON.stringify(a4)} b: ${JSON.stringify(b4)}`);
  }
  guard(a4, `a`);
  guard(a4, `b`);
  return [a4, b4];
};
function length2(aOrLine, pointB) {
  if (isPolyLine(aOrLine)) {
    const sum5 = aOrLine.reduce((accumulator, v3) => length2(v3) + accumulator, 0);
    return sum5;
  }
  if (aOrLine === void 0) throw new TypeError(`Parameter 'aOrLine' is undefined`);
  const [a4, b4] = getPointParameter(aOrLine, pointB);
  const x3 = b4.x - a4.x;
  const y3 = b4.y - a4.y;
  if (a4.z !== void 0 && b4.z !== void 0) {
    const z3 = b4.z - a4.z;
    return Math.hypot(x3, y3, z3);
  } else {
    return Math.hypot(x3, y3);
  }
}
function interpolate3(amount, aOrLine, pointBOrAllowOverflow, allowOverflow) {
  if (typeof pointBOrAllowOverflow === `boolean`) {
    allowOverflow = pointBOrAllowOverflow;
    pointBOrAllowOverflow = void 0;
  }
  if (!allowOverflow) throwPercentTest(amount, `amount`);
  else throwNumberTest(amount, ``, `amount`);
  const [a4, b4] = getPointParameter(aOrLine, pointBOrAllowOverflow);
  const d4 = length2(a4, b4);
  const d22 = d4 * (1 - amount);
  if (d4 === 0 && d22 === 0) return Object.freeze({ ...b4 });
  const x3 = b4.x - d22 * (b4.x - a4.x) / d4;
  const y3 = b4.y - d22 * (b4.y - a4.y) / d4;
  return Object.freeze({
    ...b4,
    x: x3,
    y: y3
  });
}
var directionVector = (line3) => ({
  x: line3.b.x - line3.a.x,
  y: line3.b.y - line3.a.y
});
var directionVectorNormalised = (line3) => {
  const l3 = length2(line3);
  const v3 = directionVector(line3);
  return {
    x: v3.x / l3,
    y: v3.y / l3
  };
};
var parallel = (line3, distance32) => {
  const dv = directionVector(line3);
  const dvn = directionVectorNormalised(line3);
  const a4 = {
    x: line3.a.x - dvn.y * distance32,
    y: line3.a.y + dvn.x * distance32
  };
  return {
    a: a4,
    b: {
      x: a4.x + dv.x,
      y: a4.y + dv.y
    }
  };
};
var perpendicularPoint = (line3, distance32, amount = 0) => {
  const origin = interpolate3(amount, line3);
  const dvn = directionVectorNormalised(line3);
  return {
    x: origin.x - dvn.y * distance32,
    y: origin.y + dvn.x * distance32
  };
};
var midpoint = (aOrLine, pointB) => {
  const [a4, b4] = getPointParameter(aOrLine, pointB);
  return interpolate3(0.5, a4, b4);
};
var line_exports = {};
__export(line_exports, {
  Empty: () => Empty2,
  Placeholder: () => Placeholder2,
  angleRadian: () => angleRadian2,
  apply: () => apply2,
  asPoints: () => asPoints,
  bbox: () => bbox2,
  distance: () => distance22,
  distanceSingleLine: () => distanceSingleLine,
  divide: () => divide2,
  extendFromA: () => extendFromA,
  fromFlatArray: () => fromFlatArray,
  fromNumbers: () => fromNumbers,
  fromPivot: () => fromPivot,
  fromPoints: () => fromPoints,
  fromPointsToPath: () => fromPointsToPath,
  getPointParameter: () => getPointParameter,
  guard: () => guard2,
  interpolate: () => interpolate3,
  isEmpty: () => isEmpty32,
  isEqual: () => isEqual2,
  isLine: () => isLine,
  isPlaceholder: () => isPlaceholder3,
  isPolyLine: () => isPolyLine,
  joinPointsToLines: () => joinPointsToLines,
  length: () => length2,
  midpoint: () => midpoint,
  multiply: () => multiply3,
  nearest: () => nearest,
  normaliseByRect: () => normaliseByRect2,
  parallel: () => parallel,
  perpendicularPoint: () => perpendicularPoint,
  pointAtX: () => pointAtX,
  pointsOf: () => pointsOf,
  relativePosition: () => relativePosition,
  rotate: () => rotate3,
  scaleFromMidpoint: () => scaleFromMidpoint,
  slope: () => slope,
  subtract: () => subtract2,
  sum: () => sum22,
  toFlatArray: () => toFlatArray,
  toPath: () => toPath,
  toString: () => toString32,
  toSvgString: () => toSvgString,
  withinRange: () => withinRange2
});
var guardDim = (d4, name = `Dimension`) => {
  if (d4 === void 0) throw new Error(`${name} is undefined`);
  if (Number.isNaN(d4)) throw new Error(`${name} is NaN`);
  if (d4 < 0) throw new Error(`${name} cannot be negative`);
};
var guard3 = (rect2, name = `rect`) => {
  if (rect2 === void 0) throw new Error(`{$name} undefined`);
  if (isPositioned(rect2)) guard(rect2, name);
  guardDim(rect2.width, name + `.width`);
  guardDim(rect2.height, name + `.height`);
};
var getRectPositioned = (rect2, origin) => {
  guard3(rect2);
  if (isPositioned(rect2) && origin === void 0) {
    return rect2;
  }
  if (origin === void 0) throw new Error(`Unpositioned rect needs origin parameter`);
  return Object.freeze({ ...rect2, ...origin });
};
var guardPositioned = (rect2, name = `rect`) => {
  if (!isPositioned(rect2)) throw new Error(`Expected ${name} to have x,y`);
  guard3(rect2, name);
};
var isEmpty22 = (rect2) => rect2.width === 0 && rect2.height === 0;
var isPlaceholder2 = (rect2) => Number.isNaN(rect2.width) && Number.isNaN(rect2.height);
var isPositioned = (rect2) => rect2.x !== void 0 && rect2.y !== void 0;
var isRect = (rect2) => {
  if (rect2 === void 0) return false;
  if (rect2.width === void 0) return false;
  if (rect2.height === void 0) return false;
  return true;
};
var isRectPositioned = (rect2) => isRect(rect2) && isPositioned(rect2);
function normaliseByRect(a4, b4, c6, d4) {
  if (isPoint(a4)) {
    if (typeof b4 === `number` && c6 !== void 0) {
      throwNumberTest(b4, `positive`, `width`);
      throwNumberTest(c6, `positive`, `height`);
    } else {
      if (!isRect(b4)) {
        throw new Error(`Expected second parameter to be a rect`);
      }
      c6 = b4.height;
      b4 = b4.width;
    }
    return Object.freeze({
      x: a4.x / b4,
      y: a4.y / c6
    });
  } else {
    throwNumberTest(a4, `positive`, `x`);
    if (typeof b4 !== `number`) {
      throw new TypeError(`Expecting second parameter to be a number (width)`);
    }
    if (typeof c6 !== `number`) {
      throw new TypeError(`Expecting third parameter to be a number (height)`);
    }
    throwNumberTest(b4, `positive`, `y`);
    throwNumberTest(c6, `positive`, `width`);
    if (d4 === void 0) throw new Error(`Expected height parameter`);
    throwNumberTest(d4, `positive`, `height`);
    return Object.freeze({
      x: a4 / c6,
      y: b4 / d4
    });
  }
}
function getPointParameter2(a4, b4, c6) {
  if (a4 === void 0) return { x: 0, y: 0 };
  if (Array.isArray(a4)) {
    if (a4.length === 0) return Object.freeze({ x: 0, y: 0 });
    if (a4.length === 1) return Object.freeze({ x: a4[0], y: 0 });
    if (a4.length === 2) return Object.freeze({ x: a4[0], y: a4[1] });
    if (a4.length === 3) return Object.freeze({ x: a4[0], y: a4[1], z: a4[2] });
    throw new Error(
      `Expected array to be 1-3 elements in length. Got ${a4.length}.`
    );
  }
  if (isPoint(a4)) {
    return a4;
  } else if (typeof a4 !== `number` || typeof b4 !== `number`) {
    throw new TypeError(
      `Expected point or x,y as parameters. Got: a: ${JSON.stringify(
        a4
      )} b: ${JSON.stringify(b4)}`
    );
  }
  if (typeof c6 === `number`) {
    return Object.freeze({ x: a4, y: b4, z: c6 });
  }
  return Object.freeze({ x: a4, y: b4 });
}
function distance3(a4, xOrB, y3, z3) {
  const pt2 = getPointParameter2(xOrB, y3, z3);
  guard(pt2, `b`);
  guard(a4, `a`);
  return isPoint3d(pt2) && isPoint3d(a4) ? Math.hypot(pt2.x - a4.x, pt2.y - a4.y, pt2.z - a4.z) : Math.hypot(pt2.x - a4.x, pt2.y - a4.y);
}
var nearest = (line3, point2) => {
  const n7 = (line22) => {
    const { a: a4, b: b4 } = line22;
    const atob2 = { x: b4.x - a4.x, y: b4.y - a4.y };
    const atop = { x: point2.x - a4.x, y: point2.y - a4.y };
    const length5 = atob2.x * atob2.x + atob2.y * atob2.y;
    let dot2 = atop.x * atob2.x + atop.y * atob2.y;
    const t22 = Math.min(1, Math.max(0, dot2 / length5));
    dot2 = (b4.x - a4.x) * (point2.y - a4.y) - (b4.y - a4.y) * (point2.x - a4.x);
    return { x: a4.x + atob2.x * t22, y: a4.y + atob2.y * t22 };
  };
  if (Array.isArray(line3)) {
    const pts = line3.map((l3) => n7(l3));
    const dists = pts.map((p4) => distance3(p4, point2));
    return Object.freeze(pts[minIndex(...dists)]);
  } else {
    return Object.freeze(n7(line3));
  }
};
var distanceSingleLine = (line3, point2) => {
  guard2(line3, `line`);
  guard(point2, `point`);
  if (length2(line3) === 0) {
    return length2(line3.a, point2);
  }
  const near = nearest(line3, point2);
  return length2(near, point2);
};
var findMinimum = (comparer, ...points) => {
  if (points.length === 0) throw new Error(`No points provided`);
  let min23 = points[0];
  for (const p4 of points) {
    min23 = comparer(min23, p4);
  }
  return min23;
};
var maxFromCorners = (topLeft, topRight, bottomRight, bottomLeft) => {
  if (topLeft.y > bottomRight.y) {
    throw new Error(`topLeft.y greater than bottomRight.y`);
  }
  if (topLeft.y > bottomLeft.y) {
    throw new Error(`topLeft.y greater than bottomLeft.y`);
  }
  const w1 = topRight.x - topLeft.x;
  const w22 = bottomRight.x - bottomLeft.x;
  const h1 = Math.abs(bottomLeft.y - topLeft.y);
  const h22 = Math.abs(bottomRight.y - topRight.y);
  return {
    x: Math.min(topLeft.x, bottomLeft.x),
    y: Math.min(topRight.y, topLeft.y),
    width: Math.max(w1, w22),
    height: Math.max(h1, h22)
  };
};
var bbox = (...points) => {
  const leftMost = findMinimum((a4, b4) => {
    return a4.x < b4.x ? a4 : b4;
  }, ...points);
  const rightMost = findMinimum((a4, b4) => {
    return a4.x > b4.x ? a4 : b4;
  }, ...points);
  const topMost = findMinimum((a4, b4) => {
    return a4.y < b4.y ? a4 : b4;
  }, ...points);
  const bottomMost = findMinimum((a4, b4) => {
    return a4.y > b4.y ? a4 : b4;
  }, ...points);
  const topLeft = { x: leftMost.x, y: topMost.y };
  const topRight = { x: rightMost.x, y: topMost.y };
  const bottomRight = { x: rightMost.x, y: bottomMost.y };
  const bottomLeft = { x: leftMost.x, y: bottomMost.y };
  return maxFromCorners(topLeft, topRight, bottomRight, bottomLeft);
};
var bbox2 = (line3) => bbox(line3.a, line3.b);
function divide(a4, b4, c6, d4) {
  if (isPoint(a4)) {
    guard(a4, `a`);
    if (isPoint(b4)) {
      return Object.freeze({
        x: a4.x / b4.x,
        y: a4.y / b4.y
      });
    } else if (isRect(b4)) {
      guard3(b4, `rect`);
      return Object.freeze({
        x: a4.x / b4.width,
        y: a4.y / b4.height
      });
    } else {
      if (c6 === void 0) c6 = b4;
      guard(a4);
      throwNumberTest(b4, `nonZero`, `x`);
      throwNumberTest(c6, `nonZero`, `y`);
      return Object.freeze({
        x: a4.x / b4,
        y: a4.y / c6
      });
    }
  } else {
    if (typeof b4 !== `number`) {
      throw new TypeError(`expected second parameter to be y1 coord`);
    }
    throwNumberTest(a4, `positive`, `x1`);
    throwNumberTest(b4, `positive`, `y1`);
    if (c6 === void 0) c6 = 1;
    if (d4 === void 0) d4 = c6;
    throwNumberTest(c6, `nonZero`, `x2`);
    throwNumberTest(d4, `nonZero`, `y2`);
    return Object.freeze({
      x: a4 / c6,
      y: b4 / d4
    });
  }
}
function divider(a4, b4, c6) {
  const divisor = getPointParameter2(a4, b4, c6);
  guardNonZeroPoint(divisor, `divisor`);
  return (aa2, bb, cc) => {
    const dividend = getPointParameter2(aa2, bb, cc);
    return typeof dividend.z === `undefined` ? Object.freeze({
      x: dividend.x / divisor.x,
      y: dividend.y / divisor.y
    }) : Object.freeze({
      x: dividend.x / divisor.x,
      y: dividend.y / divisor.y,
      z: dividend.z / (divisor.z ?? 1)
    });
  };
}
var divide2 = (line3, point2) => Object.freeze({
  ...line3,
  a: divide(line3.a, point2),
  b: divide(line3.b, point2)
});
var fromFlatArray = (array2) => {
  if (!Array.isArray(array2)) throw new Error(`arr parameter is not an array`);
  if (array2.length !== 4) throw new Error(`array is expected to have length four`);
  return fromNumbers(array2[0], array2[1], array2[2], array2[3]);
};
var Polar_exports = {};
__export(Polar_exports, {
  clampMagnitude: () => clampMagnitude,
  divide: () => divide3,
  dotProduct: () => dotProduct2,
  fromCartesian: () => fromCartesian,
  guard: () => guard4,
  invert: () => invert,
  isAntiParallel: () => isAntiParallel,
  isOpposite: () => isOpposite,
  isParallel: () => isParallel,
  isPolarCoord: () => isPolarCoord,
  multiply: () => multiply,
  normalise: () => normalise,
  rotate: () => rotate,
  rotateDegrees: () => rotateDegrees,
  spiral: () => spiral,
  spiralRaw: () => spiralRaw,
  toCartesian: () => toCartesian,
  toPoint: () => toPoint,
  toString: () => toString3
});
function degreeToRadian(angleInDegrees) {
  return Array.isArray(angleInDegrees) ? angleInDegrees.map((v3) => v3 * (Math.PI / 180)) : angleInDegrees * (Math.PI / 180);
}
function radianInvert(angleInRadians) {
  return (angleInRadians + Math.PI) % (2 * Math.PI);
}
function radianToDegree(angleInRadians) {
  return Array.isArray(angleInRadians) ? angleInRadians.map((v3) => v3 * 180 / Math.PI) : angleInRadians * 180 / Math.PI;
}
var radiansFromAxisX = (point2) => Math.atan2(point2.x, point2.y);
function subtract(a4, b4, c6, d4) {
  if (isPoint(a4)) {
    guard(a4, `a`);
    if (isPoint(b4)) {
      guard(b4, `b`);
      return Object.freeze({
        ...a4,
        x: a4.x - b4.x,
        y: a4.y - b4.y
      });
    } else {
      if (c6 === void 0) c6 = b4;
      return Object.freeze({
        ...a4,
        x: a4.x - b4,
        y: a4.y - c6
      });
    }
  } else {
    throwNumberTest(a4, ``, `a`);
    if (typeof b4 !== `number`) {
      throw new TypeError(`Second parameter is expected to by y value`);
    }
    throwNumberTest(b4, ``, `b`);
    if (Number.isNaN(c6)) throw new Error(`Third parameter is NaN`);
    if (Number.isNaN(d4)) throw new Error(`Fourth parameter is NaN`);
    if (c6 === void 0) c6 = 0;
    if (d4 === void 0) d4 = 0;
    return Object.freeze({
      x: a4 - c6,
      y: b4 - d4
    });
  }
}
var Empty = { x: 0, y: 0 };
var EmptyCartesian = Object.freeze({ x: 0, y: 0 });
var isPolarCoord = (p4) => {
  if (p4.distance === void 0) return false;
  if (p4.angleRadian === void 0) return false;
  return true;
};
var fromCartesian = (point2, origin) => {
  point2 = subtract(point2, origin);
  const angle = Math.atan2(point2.y, point2.x);
  return Object.freeze({
    ...point2,
    angleRadian: angle,
    distance: Math.hypot(point2.x, point2.y)
  });
};
var toCartesian = (a4, b4, c6) => {
  if (isPolarCoord(a4)) {
    if (b4 === void 0) b4 = Empty;
    if (isPoint(b4)) {
      return polarToCartesian(a4.distance, a4.angleRadian, b4);
    }
    throw new Error(
      `Expecting (Coord, Point). Second parameter is not a point`
    );
  } else if (typeof a4 === `object`) {
    throw new TypeError(
      `First param is an object, but not a Coord: ${JSON.stringify(a4)}`
    );
  } else {
    if (typeof a4 === `number` && typeof b4 === `number`) {
      if (c6 === void 0) c6 = Empty;
      if (!isPoint(c6)) {
        throw new Error(
          `Expecting (number, number, Point). Point param wrong type`
        );
      }
      return polarToCartesian(a4, b4, c6);
    } else {
      throw new TypeError(
        `Expecting parameters of (number, number). Got: (${typeof a4}, ${typeof b4}, ${typeof c6}). a: ${JSON.stringify(
          a4
        )}`
      );
    }
  }
};
function* spiral(smoothness, zoom) {
  let step = 0;
  while (true) {
    const a4 = smoothness * step++;
    yield {
      distance: zoom * a4,
      angleRadian: a4,
      step
    };
  }
}
var rotate = (c6, amountRadian) => Object.freeze({
  ...c6,
  angleRadian: c6.angleRadian + amountRadian
});
var normalise = (c6) => {
  if (c6.distance === 0) throw new Error(`Cannot normalise vector of length 0`);
  return Object.freeze({
    ...c6,
    distance: 1
  });
};
var guard4 = (p4, name = `Point`) => {
  if (p4 === void 0) {
    throw new Error(
      `'${name}' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(
        p4
      )}`
    );
  }
  if (p4 === null) {
    throw new Error(
      `'${name}' is null. Expected {distance, angleRadian} got ${JSON.stringify(
        p4
      )}`
    );
  }
  if (p4.angleRadian === void 0) {
    throw new Error(
      `'${name}.angleRadian' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(
        p4
      )}`
    );
  }
  if (p4.distance === void 0) {
    throw new Error(
      `'${name}.distance' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(
        p4
      )}`
    );
  }
  if (typeof p4.angleRadian !== `number`) {
    throw new TypeError(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `'${name}.angleRadian' must be a number. Got ${p4.angleRadian}`
    );
  }
  if (typeof p4.distance !== `number`) {
    throw new TypeError(`'${name}.distance' must be a number. Got ${p4.distance}`);
  }
  if (p4.angleRadian === null) throw new Error(`'${name}.angleRadian' is null`);
  if (p4.distance === null) throw new Error(`'${name}.distance' is null`);
  if (Number.isNaN(p4.angleRadian)) {
    throw new TypeError(`'${name}.angleRadian' is NaN`);
  }
  if (Number.isNaN(p4.distance)) throw new Error(`'${name}.distance' is NaN`);
};
var dotProduct2 = (a4, b4) => {
  guard4(a4, `a`);
  guard4(b4, `b`);
  return a4.distance * b4.distance * Math.cos(b4.angleRadian - a4.angleRadian);
};
var invert = (p4) => {
  guard4(p4, `c`);
  return Object.freeze({
    ...p4,
    angleRadian: p4.angleRadian - Math.PI
  });
};
var isOpposite = (a4, b4) => {
  guard4(a4, `a`);
  guard4(b4, `b`);
  if (a4.distance !== b4.distance) return false;
  return a4.angleRadian === -b4.angleRadian;
};
var isParallel = (a4, b4) => {
  guard4(a4, `a`);
  guard4(b4, `b`);
  return a4.angleRadian === b4.angleRadian;
};
var isAntiParallel = (a4, b4) => {
  guard4(a4, `a`);
  guard4(b4, `b`);
  return a4.angleRadian === -b4.angleRadian;
};
var rotateDegrees = (c6, amountDeg) => Object.freeze({
  ...c6,
  angleRadian: c6.angleRadian + degreeToRadian(amountDeg)
});
var spiralRaw = (step, smoothness, zoom) => {
  const a4 = smoothness * step;
  return Object.freeze({
    distance: zoom * a4,
    angleRadian: a4
  });
};
var multiply = (v3, amt) => {
  guard4(v3);
  throwNumberTest(amt, ``, `amt`);
  return Object.freeze({
    ...v3,
    distance: v3.distance * amt
  });
};
var divide3 = (v3, amt) => {
  guard4(v3);
  throwNumberTest(amt, ``, `amt`);
  return Object.freeze({
    ...v3,
    distance: v3.distance / amt
  });
};
var clampMagnitude = (v3, max23 = 1, min23 = 0) => {
  let mag = v3.distance;
  if (mag > max23) mag = max23;
  if (mag < min23) mag = min23;
  return Object.freeze({
    ...v3,
    distance: mag
  });
};
var polarToCartesian = (distance32, angleRadians, origin = Empty) => {
  guard(origin);
  return Object.freeze({
    x: origin.x + distance32 * Math.cos(angleRadians),
    y: origin.y + distance32 * Math.sin(angleRadians)
  });
};
var toString3 = (p4, digits) => {
  if (p4 === void 0) return `(undefined)`;
  if (p4 === null) return `(null)`;
  const angleDeg = radianToDegree(p4.angleRadian);
  const d4 = digits ? p4.distance.toFixed(digits) : p4.distance;
  const a4 = digits ? angleDeg.toFixed(digits) : angleDeg;
  return `(${d4},${a4})`;
};
var toPoint = (v3, origin = EmptyCartesian) => {
  guard4(v3, `v`);
  return Object.freeze({
    x: origin.x + v3.distance * Math.cos(v3.angleRadian),
    y: origin.y + v3.distance * Math.sin(v3.angleRadian)
  });
};
var fromPivot = (origin = { x: 0.5, y: 0.5 }, length5 = 1, angleRadian3 = 0, balance = 0.5) => {
  const left = length5 * balance;
  const right = length5 * (1 - balance);
  const a4 = toCartesian(left, radianInvert(angleRadian3), origin);
  const b4 = toCartesian(right, angleRadian3, origin);
  return Object.freeze({
    a: a4,
    b: b4
  });
};
var fromPointsToPath = (a4, b4) => toPath(fromPoints(a4, b4));
var isEqual = (...p4) => {
  if (p4 === void 0) throw new Error(`parameter 'p' is undefined`);
  if (p4.length < 2) return true;
  for (let index = 1; index < p4.length; index++) {
    if (p4[index].x !== p4[0].x) return false;
    if (p4[index].y !== p4[0].y) return false;
  }
  return true;
};
var isEqual2 = (a4, b4) => isEqual(a4.a, b4.a) && isEqual(a4.b, b4.b);
var point_exports = {};
__export(point_exports, {
  Empty: () => Empty,
  Placeholder: () => Placeholder,
  abs: () => abs,
  angleRadian: () => angleRadian,
  apply: () => apply,
  bbox: () => bbox,
  centroid: () => centroid,
  clamp: () => clamp23,
  clampMagnitude: () => clampMagnitude2,
  compare: () => compare3,
  compareByX: () => compareByX,
  compareByY: () => compareByY,
  convexHull: () => convexHull,
  distance: () => distance3,
  distanceToCenter: () => distanceToCenter,
  distanceToExterior: () => distanceToExterior,
  divide: () => divide,
  divider: () => divider,
  dotProduct: () => dotProduct3,
  findMinimum: () => findMinimum,
  from: () => from,
  fromNumbers: () => fromNumbers2,
  getPointParameter: () => getPointParameter2,
  guard: () => guard,
  guardNonZeroPoint: () => guardNonZeroPoint,
  interpolate: () => interpolate23,
  invert: () => invert2,
  isEmpty: () => isEmpty3,
  isEqual: () => isEqual,
  isNaN: () => isNaN2,
  isNull: () => isNull,
  isPlaceholder: () => isPlaceholder,
  isPoint: () => isPoint,
  isPoint3d: () => isPoint3d,
  leftmost: () => leftmost,
  multiply: () => multiply2,
  multiplyScalar: () => multiplyScalar,
  normalise: () => normalise2,
  normaliseByRect: () => normaliseByRect,
  pipeline: () => pipeline,
  pipelineApply: () => pipelineApply,
  progressBetween: () => progressBetween,
  project: () => project,
  quantiseEvery: () => quantiseEvery2,
  random: () => random2,
  reduce: () => reduce3,
  relation: () => relation,
  rightmost: () => rightmost,
  rotate: () => rotate2,
  rotatePointArray: () => rotatePointArray,
  round: () => round2,
  subtract: () => subtract,
  sum: () => sum3,
  toArray: () => toArray4,
  toIntegerValues: () => toIntegerValues,
  toString: () => toString22,
  withinRange: () => withinRange,
  wrap: () => wrap22
});
var abs = (pt2) => ({
  ...pt2,
  x: Math.abs(pt2.x),
  y: Math.abs(pt2.y)
});
var angleRadian = (a4, b4, c6) => {
  guard(a4, `a`);
  if (b4 === void 0) {
    return Math.atan2(a4.y, a4.x);
  }
  guard(b4, `b`);
  if (c6 === void 0) {
    return Math.atan2(b4.y - a4.y, b4.x - a4.x);
  }
  guard(c6, `c`);
  return Math.atan2(b4.y - a4.y, b4.x - a4.x) - Math.atan2(c6.y - a4.y, c6.x - a4.x);
};
var apply = (pt2, fn2) => {
  guard(pt2, `pt`);
  return Object.freeze({
    ...pt2,
    x: fn2(pt2.x, `x`),
    y: fn2(pt2.y, `y`)
  });
};
var centroid = (...points) => {
  if (!Array.isArray(points)) throw new Error(`Expected list of points`);
  const sum5 = points.reduce(
    (previous, p4) => {
      if (p4 === void 0) return previous;
      if (Array.isArray(p4)) {
        throw new TypeError(
          `'points' list contains an array. Did you mean: centroid(...myPoints)?`
        );
      }
      if (!isPoint(p4)) {
        throw new Error(
          `'points' contains something which is not a point: ${JSON.stringify(
            p4
          )}`
        );
      }
      return {
        x: previous.x + p4.x,
        y: previous.y + p4.y
      };
    },
    { x: 0, y: 0 }
  );
  return Object.freeze({
    x: sum5.x / points.length,
    y: sum5.y / points.length
  });
};
function clamp23(a4, b4, c6, d4) {
  if (isPoint(a4)) {
    if (b4 === void 0) b4 = 0;
    if (c6 === void 0) c6 = 1;
    throwNumberTest(b4, ``, `min`);
    throwNumberTest(c6, ``, `max`);
    return Object.freeze({
      x: clamp(a4.x, b4, c6),
      y: clamp(a4.y, b4, c6)
    });
  } else {
    if (b4 === void 0) throw new Error(`Expected y coordinate`);
    if (c6 === void 0) c6 = 0;
    if (d4 === void 0) d4 = 1;
    throwNumberTest(a4, ``, `x`);
    throwNumberTest(b4, ``, `y`);
    throwNumberTest(c6, ``, `min`);
    throwNumberTest(d4, ``, `max`);
    return Object.freeze({
      x: clamp(a4, c6, d4),
      y: clamp(b4, c6, d4)
    });
  }
}
var compare3 = (a4, b4) => {
  if (a4.x < b4.x && a4.y < b4.y) return -2;
  if (a4.x > b4.x && a4.y > b4.y) return 2;
  if (a4.x < b4.x || a4.y < b4.y) return -1;
  if (a4.x > b4.x || a4.y > b4.y) return 1;
  if (a4.x === b4.x && a4.x === b4.y) return 0;
  return Number.NaN;
};
var compareByX = (a4, b4) => {
  if (a4.x === b4.x) return 0;
  if (a4.x < b4.x) return -1;
  return 1;
};
var compareByY = (a4, b4) => {
  if (a4.y === b4.y) return 0;
  if (a4.y < b4.y) return -1;
  return 1;
};
var convexHull = (...pts) => {
  const sorted = [...pts].sort(compareByX);
  if (sorted.length === 1) return sorted;
  const x3 = (points) => {
    const v3 = [];
    for (const p4 of points) {
      while (v3.length >= 2) {
        const q3 = v3.at(-1);
        const r5 = v3.at(-2);
        if ((q3.x - r5.x) * (p4.y - r5.y) >= (q3.y - r5.y) * (p4.x - r5.x)) {
          v3.pop();
        } else break;
      }
      v3.push(p4);
    }
    v3.pop();
    return v3;
  };
  const upper = x3(sorted);
  const lower = x3(sorted.reverse());
  if (upper.length === 1 && lower.length === 1 && isEqual(lower[0], upper[0])) {
    return upper;
  }
  return [...upper, ...lower];
};
var guard5 = (circle3, parameterName = `circle`) => {
  if (isCirclePositioned(circle3)) {
    guard(circle3, `circle`);
  }
  if (Number.isNaN(circle3.radius)) throw new Error(`${parameterName}.radius is NaN`);
  if (circle3.radius <= 0) throw new Error(`${parameterName}.radius must be greater than zero`);
};
var guardPositioned2 = (circle3, parameterName = `circle`) => {
  if (!isCirclePositioned(circle3)) throw new Error(`Expected a positioned circle with x,y`);
  guard5(circle3, parameterName);
};
var isNaN22 = (a4) => {
  if (Number.isNaN(a4.radius)) return true;
  if (isCirclePositioned(a4)) {
    if (Number.isNaN(a4.x)) return true;
    if (Number.isNaN(a4.y)) return true;
  }
  return false;
};
var isPositioned2 = (p4) => p4.x !== void 0 && p4.y !== void 0;
var isCircle = (p4) => p4.radius !== void 0;
var isCirclePositioned = (p4) => isCircle(p4) && isPositioned2(p4);
var distanceCenter = (a4, b4) => {
  guardPositioned2(a4, `a`);
  if (isCirclePositioned(b4)) {
    guardPositioned2(b4, `b`);
  }
  return distance3(a4, b4);
};
var distanceFromExterior = (a4, b4) => {
  guardPositioned2(a4, `a`);
  if (isCirclePositioned(b4)) {
    return Math.max(0, distanceCenter(a4, b4) - a4.radius - b4.radius);
  } else if (isPoint(b4)) {
    const distribution = distance3(a4, b4);
    if (distribution < a4.radius) return 0;
    return distribution;
  } else throw new Error(`Second parameter invalid type`);
};
var isEqual3 = (a4, b4) => {
  if (a4.radius !== b4.radius) return false;
  if (isCirclePositioned(a4) && isCirclePositioned(b4)) {
    if (a4.x !== b4.x) return false;
    if (a4.y !== b4.y) return false;
    if (a4.z !== b4.z) return false;
    return true;
  } else if (!isCirclePositioned(a4) && !isCirclePositioned(b4)) {
  } else return false;
  return false;
};
var sum3 = function(a4, b4, c6, d4) {
  if (a4 === void 0) throw new TypeError(`a missing`);
  let ptA;
  let ptB;
  if (isPoint(a4)) {
    ptA = a4;
    if (b4 === void 0) b4 = Empty;
    if (isPoint(b4)) {
      ptB = b4;
    } else {
      if (b4 === void 0) throw new Error(`Expects x coordinate`);
      ptB = { x: b4, y: c6 ?? b4 };
    }
  } else if (!isPoint(b4)) {
    if (b4 === void 0) throw new Error(`Expected number as second param`);
    ptA = { x: a4, y: b4 };
    if (c6 === void 0) throw new Error(`Expects x coordiante`);
    ptB = { x: c6, y: d4 ?? 0 };
  }
  if (ptA === void 0) throw new Error(`ptA missing. a: ${JSON.stringify(a4)}`);
  if (ptB === void 0) throw new Error(`ptB missing. b: ${JSON.stringify(b4)}`);
  guard(ptA, `a`);
  guard(ptB, `b`);
  return Object.freeze({
    x: ptA.x + ptB.x,
    y: ptA.y + ptB.y
  });
};
var intersectionLine = (circle3, line3) => {
  const v1 = {
    x: line3.b.x - line3.a.x,
    y: line3.b.y - line3.a.y
  };
  const v22 = {
    x: line3.a.x - circle3.x,
    y: line3.a.y - circle3.y
  };
  const b4 = (v1.x * v22.x + v1.y * v22.y) * -2;
  const c6 = 2 * (v1.x * v1.x + v1.y * v1.y);
  const d4 = Math.sqrt(b4 * b4 - 2 * c6 * (v22.x * v22.x + v22.y * v22.y - circle3.radius * circle3.radius));
  if (Number.isNaN(d4)) return [];
  const u1 = (b4 - d4) / c6;
  const u22 = (b4 + d4) / c6;
  const returnValue = [];
  if (u1 <= 1 && u1 >= 0) {
    returnValue.push({
      x: line3.a.x + v1.x * u1,
      y: line3.a.y + v1.y * u1
    });
  }
  if (u22 <= 1 && u22 >= 0) {
    returnValue.push({
      x: line3.a.x + v1.x * u22,
      y: line3.a.y + v1.y * u22
    });
  }
  return returnValue;
};
var intersections = (a4, b4) => {
  const vector = subtract(b4, a4);
  const centerD = Math.hypot(vector.y, vector.x);
  if (centerD > a4.radius + b4.radius) return [];
  if (centerD < Math.abs(a4.radius - b4.radius)) return [];
  if (isEqual3(a4, b4)) return [];
  const centroidD = (a4.radius * a4.radius - b4.radius * b4.radius + centerD * centerD) / (2 * centerD);
  const centroid3 = {
    x: a4.x + vector.x * centroidD / centerD,
    y: a4.y + vector.y * centroidD / centerD
  };
  const centroidIntersectionD = Math.sqrt(a4.radius * a4.radius - centroidD * centroidD);
  const intersection = {
    x: -vector.y * (centroidIntersectionD / centerD),
    y: vector.x * (centroidIntersectionD / centerD)
  };
  return [
    sum3(centroid3, intersection),
    subtract(centroid3, intersection)
  ];
};
var circleRect = (a4, b4) => {
  const deltaX = a4.x - Math.max(b4.x, Math.min(a4.x, b4.x + b4.width));
  const deltaY = a4.y - Math.max(b4.y, Math.min(a4.y, b4.y + b4.height));
  return deltaX * deltaX + deltaY * deltaY < a4.radius * a4.radius;
};
var circleCircle = (a4, b4) => intersections(a4, b4).length === 2;
function intersectsPoint(rect2, a4, b4) {
  guard3(rect2, `rect`);
  let x3 = 0;
  let y3 = 0;
  if (typeof a4 === `number`) {
    if (b4 === void 0) throw new Error(`x and y coordinate needed`);
    x3 = a4;
    y3 = b4;
  } else {
    x3 = a4.x;
    y3 = a4.y;
  }
  if (isPositioned(rect2)) {
    if (x3 - rect2.x > rect2.width || x3 < rect2.x) return false;
    if (y3 - rect2.y > rect2.height || y3 < rect2.y) return false;
  } else {
    if (x3 > rect2.width || x3 < 0) return false;
    if (y3 > rect2.height || y3 < 0) return false;
  }
  return true;
}
var isIntersecting = (a4, b4) => {
  if (!isRectPositioned(a4)) {
    throw new Error(`a parameter should be RectPositioned`);
  }
  if (isCirclePositioned(b4)) {
    return circleRect(b4, a4);
  } else if (isPoint(b4)) {
    return intersectsPoint(a4, b4);
  }
  throw new Error(`Unknown shape for b: ${JSON.stringify(b4)}`);
};
var center = (rect2, origin) => {
  guard3(rect2);
  if (origin === void 0 && isPoint(rect2)) origin = rect2;
  else if (origin === void 0) origin = { x: 0, y: 0 };
  const r5 = getRectPositioned(rect2, origin);
  return Object.freeze({
    x: origin.x + rect2.width / 2,
    y: origin.y + rect2.height / 2
  });
};
var Placeholder = Object.freeze({ x: Number.NaN, y: Number.NaN });
var distanceFromExterior2 = (rect2, pt2) => {
  guardPositioned(rect2, `rect`);
  guard(pt2, `pt`);
  if (intersectsPoint(rect2, pt2)) return 0;
  const dx = Math.max(rect2.x - pt2.x, 0, pt2.x - rect2.x + rect2.width);
  const dy = Math.max(rect2.y - pt2.y, 0, pt2.y - rect2.y + rect2.height);
  return Math.hypot(dx, dy);
};
var distanceFromCenter = (rect2, pt2) => distance3(center(rect2), pt2);
var distanceToCenter = (a4, shape) => {
  if (isRectPositioned(shape)) {
    return distanceFromExterior2(shape, a4);
  }
  if (isCirclePositioned(shape)) {
    return distanceFromExterior(shape, a4);
  }
  if (isPoint(shape)) return distance3(a4, shape);
  throw new Error(`Unknown shape`);
};
var distanceToExterior = (a4, shape) => {
  if (isRectPositioned(shape)) {
    return distanceFromExterior2(shape, a4);
  }
  if (isCirclePositioned(shape)) {
    return distanceFromExterior(shape, a4);
  }
  if (isPoint(shape)) return distance3(a4, shape);
  throw new Error(`Unknown shape`);
};
var toArray4 = (p4) => [p4.x, p4.y];
var dotProduct3 = (...pts) => {
  const a4 = pts.map((p4) => toArray4(p4));
  return dotProduct(a4);
};
var from = (xOrArray, y3) => {
  if (Array.isArray(xOrArray)) {
    if (xOrArray.length !== 2) {
      throw new Error(`Expected array of length two, got ${xOrArray.length}`);
    }
    return Object.freeze({
      x: xOrArray[0],
      y: xOrArray[1]
    });
  } else {
    if (xOrArray === void 0) xOrArray = 0;
    else if (Number.isNaN(xOrArray)) throw new Error(`x is NaN`);
    if (y3 === void 0) y3 = 0;
    else if (Number.isNaN(y3)) throw new Error(`y is NaN`);
    return Object.freeze({ x: xOrArray, y: y3 });
  }
};
var fromNumbers2 = (...coords) => {
  const pts = [];
  if (Array.isArray(coords[0])) {
    for (const coord of coords) {
      if (!(coord.length % 2 === 0)) {
        throw new Error(`coords array should be even-numbered`);
      }
      pts.push(Object.freeze({ x: coord[0], y: coord[1] }));
    }
  } else {
    if (coords.length % 2 !== 0) {
      throw new Error(`Expected even number of elements: [x,y,x,y...]`);
    }
    for (let index = 0; index < coords.length; index += 2) {
      pts.push(
        Object.freeze({ x: coords[index], y: coords[index + 1] })
      );
    }
  }
  return pts;
};
var interpolate23 = (amount, a4, b4, allowOverflow = false) => interpolate3(amount, a4, b4, allowOverflow);
var invert2 = (pt2, what = `both`) => {
  switch (what) {
    case `both`: {
      return isPoint3d(pt2) ? Object.freeze({
        ...pt2,
        x: pt2.x * -1,
        y: pt2.y * -1,
        z: pt2.z * -1
      }) : Object.freeze({
        ...pt2,
        x: pt2.x * -1,
        y: pt2.y * -1
      });
    }
    case `x`: {
      return Object.freeze({
        ...pt2,
        x: pt2.x * -1
      });
    }
    case `y`: {
      return Object.freeze({
        ...pt2,
        y: pt2.y * -1
      });
    }
    case `z`: {
      if (isPoint3d(pt2)) {
        return Object.freeze({
          ...pt2,
          z: pt2.z * -1
        });
      } else throw new Error(`pt parameter is missing z`);
    }
    default: {
      throw new Error(`Unknown what parameter. Expecting 'both', 'x' or 'y'`);
    }
  }
};
function multiply2(a4, bOrX, y3) {
  guard(a4, `a`);
  if (typeof bOrX === `number`) {
    if (typeof y3 === `undefined`) y3 = bOrX;
    throwNumberTest(y3, ``, `y`);
    throwNumberTest(bOrX, ``, `x`);
    return Object.freeze({ x: a4.x * bOrX, y: a4.y * y3 });
  } else if (isPoint(bOrX)) {
    guard(bOrX, `b`);
    return Object.freeze({
      x: a4.x * bOrX.x,
      y: a4.y * bOrX.y
    });
  } else if (isRect(bOrX)) {
    guard3(bOrX, `rect`);
    return Object.freeze({
      x: a4.x * bOrX.width,
      y: a4.y * bOrX.height
    });
  } else {
    throw new Error(
      `Invalid arguments. a: ${JSON.stringify(a4)} b: ${JSON.stringify(bOrX)}`
    );
  }
}
var multiplyScalar = (pt2, v3) => {
  return isPoint3d(pt2) ? Object.freeze({
    ...pt2,
    x: pt2.x * v3,
    y: pt2.y * v3,
    z: pt2.z * v3
  }) : Object.freeze({
    ...pt2,
    x: pt2.x * v3,
    y: pt2.y * v3
  });
};
var clampMagnitude2 = (pt2, max23 = 1, min23 = 0) => {
  const length5 = distance3(pt2);
  let ratio = 1;
  if (length5 > max23) {
    ratio = max23 / length5;
  } else if (length5 < min23) {
    ratio = min23 / length5;
  }
  return ratio === 1 ? pt2 : multiply2(pt2, ratio, ratio);
};
var leftmost = (...points) => findMinimum((a4, b4) => a4.x <= b4.x ? a4 : b4, ...points);
var rightmost = (...points) => findMinimum((a4, b4) => a4.x >= b4.x ? a4 : b4, ...points);
var length22 = (ptOrX, y3) => {
  if (isPoint(ptOrX)) {
    y3 = ptOrX.y;
    ptOrX = ptOrX.x;
  }
  if (y3 === void 0) throw new Error(`Expected y`);
  return Math.hypot(ptOrX, y3);
};
var normalise2 = (ptOrX, y3) => {
  const pt2 = getPointParameter2(ptOrX, y3);
  const l3 = length22(pt2);
  if (l3 === 0) return Empty;
  return Object.freeze({
    ...pt2,
    x: pt2.x / l3,
    y: pt2.y / l3
  });
};
var pipelineApply = (point2, ...pipelineFns) => pipeline(...pipelineFns)(point2);
var pipeline = (...pipeline2) => (pt2) => (
  // eslint-disable-next-line unicorn/no-array-reduce
  pipeline2.reduce((previous, current) => current(previous), pt2)
);
var progressBetween = (position, waypointA, waypointB) => {
  const a4 = subtract(position, waypointA);
  const b4 = subtract(waypointB, waypointA);
  return isPoint3d(a4) && isPoint3d(b4) ? (a4.x * b4.x + a4.y * b4.y + a4.z * b4.z) / (b4.x * b4.x + b4.y * b4.y + b4.z * b4.z) : (a4.x * b4.x + a4.y * b4.y) / (b4.x * b4.x + b4.y * b4.y);
};
var project = (origin, distance32, angle) => {
  const x3 = Math.cos(angle) * distance32 + origin.x;
  const y3 = Math.sin(angle) * distance32 + origin.y;
  return { x: x3, y: y3 };
};
var quantiseEvery2 = (pt2, snap, middleRoundsUp = true) => {
  guard(pt2, `pt`);
  guard(snap, `snap`);
  return Object.freeze({
    x: quantiseEvery(pt2.x, snap.x, middleRoundsUp),
    y: quantiseEvery(pt2.y, snap.y, middleRoundsUp)
  });
};
var random2 = (rando) => {
  if (rando === void 0) rando = defaultRandom;
  return Object.freeze({
    x: rando(),
    y: rando()
  });
};
var reduce3 = (pts, fn2, initial) => {
  if (initial === void 0) initial = { x: 0, y: 0 };
  let accumulator = initial;
  for (const p4 of pts) {
    accumulator = fn2(p4, accumulator);
  }
  ;
  return accumulator;
};
var relation = (a4, b4) => {
  const start = getPointParameter2(a4, b4);
  let totalX = 0;
  let totalY = 0;
  let count3 = 0;
  let lastUpdate = performance.now();
  let lastPoint = start;
  const update = (aa2, bb) => {
    const p4 = getPointParameter2(aa2, bb);
    totalX += p4.x;
    totalY += p4.y;
    count3++;
    const distanceFromStart = distance3(p4, start);
    const distanceFromLast = distance3(p4, lastPoint);
    const now = performance.now();
    const speed = distanceFromLast / (now - lastUpdate);
    lastUpdate = now;
    lastPoint = p4;
    return Object.freeze({
      angle: angleRadian(p4, start),
      distanceFromStart,
      distanceFromLast,
      speed,
      centroid: centroid(p4, start),
      average: {
        x: totalX / count3,
        y: totalY / count3
      }
    });
  };
  return update;
};
function rotate2(pt2, amountRadian, origin) {
  if (origin === void 0) origin = { x: 0, y: 0 };
  guard(origin, `origin`);
  throwNumberTest(amountRadian, ``, `amountRadian`);
  const arrayInput = Array.isArray(pt2);
  if (amountRadian === 0) return pt2;
  if (!arrayInput) {
    pt2 = [pt2];
  }
  const ptAr = pt2;
  for (const [index, p4] of ptAr.entries()) guard(p4, `pt[${index}]`);
  const asPolar = ptAr.map((p4) => fromCartesian(p4, origin));
  const rotated = asPolar.map((p4) => rotate(p4, amountRadian));
  const asCartesisan = rotated.map((p4) => toCartesian(p4, origin));
  return arrayInput ? asCartesisan : asCartesisan[0];
}
var rotatePointArray = (v3, amountRadian) => {
  const mat = [
    [Math.cos(amountRadian), -Math.sin(amountRadian)],
    [Math.sin(amountRadian), Math.cos(amountRadian)]
  ];
  const result = [];
  for (const [index, element] of v3.entries()) {
    result[index] = [
      mat[0][0] * element[0] + mat[0][1] * element[1],
      mat[1][0] * element[0] + mat[1][1] * element[1]
    ];
  }
  return result;
};
var round2 = (ptOrX, yOrDigits, digits) => {
  const pt2 = getPointParameter2(ptOrX, yOrDigits);
  digits = digits ?? yOrDigits;
  digits = digits ?? 2;
  return Object.freeze({
    ...pt2,
    x: round(digits, pt2.x),
    y: round(digits, pt2.y)
  });
};
var toIntegerValues = (pt2, rounder = Math.round) => {
  guard(pt2, `pt`);
  return Object.freeze({
    x: rounder(pt2.x),
    y: rounder(pt2.y)
  });
};
function toString22(p4, digits) {
  if (p4 === void 0) return `(undefined)`;
  if (p4 === null) return `(null)`;
  guard(p4, `pt`);
  const x3 = digits ? p4.x.toFixed(digits) : p4.x;
  const y3 = digits ? p4.y.toFixed(digits) : p4.y;
  if (p4.z === void 0) {
    return `(${x3},${y3})`;
  } else {
    const z3 = digits ? p4.z.toFixed(digits) : p4.z;
    return `(${x3},${y3},${z3})`;
  }
}
var withinRange = (a4, b4, maxRange) => {
  guard(a4, `a`);
  guard(b4, `b`);
  if (typeof maxRange === `number`) {
    throwNumberTest(maxRange, `positive`, `maxRange`);
    maxRange = { x: maxRange, y: maxRange };
  } else {
    guard(maxRange, `maxRange`);
  }
  const x3 = Math.abs(b4.x - a4.x);
  const y3 = Math.abs(b4.y - a4.y);
  return x3 <= maxRange.x && y3 <= maxRange.y;
};
var wrap22 = (pt2, ptMax, ptMin) => {
  if (ptMax === void 0) ptMax = { x: 1, y: 1 };
  if (ptMin === void 0) ptMin = { x: 0, y: 0 };
  guard(pt2, `pt`);
  guard(ptMax, `ptMax`);
  guard(ptMin, `ptMin`);
  return Object.freeze({
    x: wrap2(pt2.x, ptMin.x, ptMax.x),
    y: wrap2(pt2.y, ptMin.y, ptMax.y)
  });
};
var multiply3 = (line3, point2) => Object.freeze({
  ...line3,
  a: multiply2(line3.a, point2),
  b: multiply2(line3.b, point2)
});
var relativePosition = (line3, pt2) => {
  const fromStart = distance3(line3.a, pt2);
  const total = length2(line3);
  return fromStart / total;
};
var rotate3 = (line3, amountRadian, origin) => {
  if (amountRadian === void 0 || amountRadian === 0) return line3;
  if (origin === void 0) origin = 0.5;
  if (typeof origin === `number`) {
    origin = interpolate3(origin, line3.a, line3.b);
  }
  return Object.freeze({
    ...line3,
    a: rotate2(line3.a, amountRadian, origin),
    b: rotate2(line3.b, amountRadian, origin)
  });
};
var subtract2 = (line3, point2) => Object.freeze({
  ...line3,
  a: subtract(line3.a, point2),
  b: subtract(line3.b, point2)
});
var sum22 = (line3, point2) => Object.freeze({
  ...line3,
  a: sum3(line3.a, point2),
  b: sum3(line3.b, point2)
});
function toString32(a4, b4) {
  if (isLine(a4)) {
    guard2(a4, `a`);
    b4 = a4.b;
    a4 = a4.a;
  } else if (b4 === void 0) throw new Error(`Expect second point if first is a point`);
  return toString22(a4) + `-` + toString22(b4);
}
var Empty2 = Object.freeze({
  a: Object.freeze({ x: 0, y: 0 }),
  b: Object.freeze({ x: 0, y: 0 })
});
var Placeholder2 = Object.freeze({
  a: Object.freeze({ x: Number.NaN, y: Number.NaN }),
  b: Object.freeze({ x: Number.NaN, y: Number.NaN })
});
var isEmpty32 = (l3) => isEmpty3(l3.a) && isEmpty3(l3.b);
var isPlaceholder3 = (l3) => isPlaceholder(l3.a) && isPlaceholder(l3.b);
var apply2 = (line3, fn2) => Object.freeze(
  {
    ...line3,
    a: fn2(line3.a),
    b: fn2(line3.b)
  }
);
var angleRadian2 = (lineOrPoint, b4) => {
  let a4;
  if (isLine(lineOrPoint)) {
    a4 = lineOrPoint.a;
    b4 = lineOrPoint.b;
  } else {
    a4 = lineOrPoint;
    if (b4 === void 0) throw new Error(`b point must be provided`);
  }
  return Math.atan2(b4.y - a4.y, b4.x - a4.x);
};
var normaliseByRect2 = (line3, width, height4) => Object.freeze({
  ...line3,
  a: normaliseByRect(line3.a, width, height4),
  b: normaliseByRect(line3.b, width, height4)
});
var withinRange2 = (line3, point2, maxRange) => {
  const calculatedDistance = distance22(line3, point2);
  return calculatedDistance <= maxRange;
};
var slope = (lineOrPoint, b4) => {
  let a4;
  if (isLine(lineOrPoint)) {
    a4 = lineOrPoint.a;
    b4 = lineOrPoint.b;
  } else {
    a4 = lineOrPoint;
    if (b4 === void 0) throw new Error(`b parameter required`);
  }
  if (b4 === void 0) {
    throw new TypeError(`Second point missing`);
  } else {
    return (b4.y - a4.y) / (b4.x - a4.x);
  }
};
var scaleFromMidpoint = (line3, factor) => {
  const a4 = interpolate3(factor / 2, line3);
  const b4 = interpolate3(0.5 + factor / 2, line3);
  return { a: a4, b: b4 };
};
var pointAtX = (line3, x3) => {
  const y3 = line3.a.y + (x3 - line3.a.x) * slope(line3);
  return Object.freeze({ x: x3, y: y3 });
};
var extendFromA = (line3, distance32) => {
  const calculatedLength = length2(line3);
  return Object.freeze({
    ...line3,
    a: line3.a,
    b: Object.freeze({
      x: line3.b.x + (line3.b.x - line3.a.x) / calculatedLength * distance32,
      y: line3.b.y + (line3.b.y - line3.a.y) / calculatedLength * distance32
    })
  });
};
function* pointsOf(line3) {
  const { a: a4, b: b4 } = line3;
  let x0 = Math.floor(a4.x);
  let y0 = Math.floor(a4.y);
  const x1 = Math.floor(b4.x);
  const y1 = Math.floor(b4.y);
  const dx = Math.abs(x1 - x0);
  const dy = -Math.abs(y1 - y0);
  const sx = x0 < x1 ? 1 : -1;
  const sy = y0 < y1 ? 1 : -1;
  let err = dx + dy;
  while (true) {
    yield { x: x0, y: y0 };
    if (x0 === x1 && y0 === y1) break;
    const e22 = 2 * err;
    if (e22 >= dy) {
      err += dy;
      x0 += sx;
    }
    if (e22 <= dx) {
      err += dx;
      y0 += sy;
    }
  }
}
var distance22 = (line3, point2) => {
  if (Array.isArray(line3)) {
    const distances = line3.map((l3) => distanceSingleLine(l3, point2));
    return minFast(distances);
  } else {
    return distanceSingleLine(line3, point2);
  }
};
var toFlatArray = (a4, b4) => {
  if (isLine(a4)) {
    return [a4.a.x, a4.a.y, a4.b.x, a4.b.y];
  } else if (isPoint(a4) && isPoint(b4)) {
    return [a4.x, a4.y, b4.x, b4.y];
  } else {
    throw new Error(`Expected single line parameter, or a and b points`);
  }
};
function* asPoints(lines) {
  for (const l3 of lines) {
    yield l3.a;
    yield l3.b;
  }
}
var toSvgString = (a4, b4) => [`M${a4.x} ${a4.y} L ${b4.x} ${b4.y}`];
var toPath = (line3) => {
  const { a: a4, b: b4 } = line3;
  return Object.freeze({
    ...line3,
    length: () => length2(a4, b4),
    interpolate: (amount) => interpolate3(amount, a4, b4),
    relativePosition: (point2) => relativePosition(line3, point2),
    bbox: () => bbox2(line3),
    toString: () => toString32(a4, b4),
    toFlatArray: () => toFlatArray(a4, b4),
    toSvgString: () => toSvgString(a4, b4),
    toPoints: () => [a4, b4],
    rotate: (amountRadian, origin) => toPath(rotate3(line3, amountRadian, origin)),
    nearest: (point2) => nearest(line3, point2),
    sum: (point2) => toPath(sum22(line3, point2)),
    divide: (point2) => toPath(divide2(line3, point2)),
    multiply: (point2) => toPath(multiply3(line3, point2)),
    subtract: (point2) => toPath(subtract2(line3, point2)),
    midpoint: () => midpoint(a4, b4),
    distanceToPoint: (point2) => distanceSingleLine(line3, point2),
    parallel: (distance32) => parallel(line3, distance32),
    perpendicularPoint: (distance32, amount) => perpendicularPoint(line3, distance32, amount),
    slope: () => slope(line3),
    withinRange: (point2, maxRange) => withinRange2(line3, point2, maxRange),
    isEqual: (otherLine) => isEqual2(line3, otherLine),
    apply: (fn2) => toPath(apply2(line3, fn2)),
    kind: `line`
  });
};
var fromPoints2 = (waypoints, opts = {}) => {
  const lines = joinPointsToLines(...waypoints);
  return init3(
    lines.map((l3) => toPath(l3)),
    opts
  );
};
var init3 = (paths2, opts = {}) => {
  const maxDistanceFromLine = opts.maxDistanceFromLine ?? 0.1;
  const checkUnordered = (pt2) => {
    const results = paths2.map((p4, index) => {
      const nearest3 = p4.nearest(pt2);
      const distance32 = distance3(pt2, nearest3);
      const positionRelative = p4.relativePosition(nearest3, maxDistanceFromLine);
      ;
      return { positionRelative, path: p4, index, nearest: nearest3, distance: distance32, rank: Number.MAX_SAFE_INTEGER };
    });
    const filtered = results.filter((v3) => v3.distance <= maxDistanceFromLine);
    const sorted = sortByNumericProperty(filtered, `distance`);
    for (let rank3 = 0; rank3 < sorted.length; rank3++) {
      sorted[rank3].rank = rank3;
    }
    return sorted;
  };
  return checkUnordered;
};
var Layout_exports = {};
__export(Layout_exports, {
  CirclePacking: () => CirclePacking_exports
});
var CirclePacking_exports = {};
__export(CirclePacking_exports, {
  random: () => random3
});
var shape_exports = {};
__export(shape_exports, {
  arrow: () => arrow,
  center: () => center3,
  isIntersecting: () => isIntersecting3,
  randomPoint: () => randomPoint3,
  starburst: () => starburst
});
var corners = (rect2, origin) => {
  const r5 = getRectPositioned(rect2, origin);
  return [
    { x: r5.x, y: r5.y },
    { x: r5.x + r5.width, y: r5.y },
    { x: r5.x + r5.width, y: r5.y + r5.height },
    { x: r5.x, y: r5.y + r5.height }
  ];
};
var fromTopLeft = (origin, width, height4) => {
  guardDim(width, `width`);
  guardDim(height4, `height`);
  guard(origin, `origin`);
  return { x: origin.x, y: origin.y, width, height: height4 };
};
var isContainedBy = (a4, b4, c6) => {
  const d4 = distanceCenter(a4, b4);
  if (isCircle(b4)) {
    return d4 < Math.abs(a4.radius - b4.radius);
  } else if (isPoint(b4)) {
    if (c6 === void 0) {
      return d4 <= a4.radius;
    } else {
      return d4 < Math.abs(a4.radius - c6);
    }
  } else throw new Error(`b parameter is expected to be CirclePositioned or Point`);
};
var isIntersecting2 = (a4, b4, c6) => {
  if (isEqual(a4, b4)) return true;
  if (isContainedBy(a4, b4, c6)) return true;
  if (isCircle(b4)) {
    return circleCircle(a4, b4);
  } else if (isRectPositioned(b4)) {
    return circleRect(a4, b4);
  } else if (isPoint(b4) && c6 !== void 0) {
    return circleCircle(a4, { ...b4, radius: c6 });
  }
  return false;
};
var piPi2 = Math.PI * 2;
var randomPoint = (within, opts = {}) => {
  const offset2 = isCirclePositioned(within) ? within : { x: 0, y: 0 };
  const strategy = opts.strategy ?? `uniform`;
  const margin = opts.margin ?? 0;
  const radius = within.radius - margin;
  const rand = opts.randomSource ?? Math.random;
  switch (strategy) {
    case `naive`: {
      return sum3(offset2, toCartesian(rand() * radius, rand() * piPi2));
    }
    case `uniform`: {
      return sum3(offset2, toCartesian(Math.sqrt(rand()) * radius, rand() * piPi2));
    }
    default: {
      throw new Error(`Unknown strategy '${strategy}'. Expects 'uniform' or 'naive'`);
    }
  }
};
var center2 = (circle3) => {
  return isCirclePositioned(circle3) ? Object.freeze({ x: circle3.x, y: circle3.y }) : Object.freeze({ x: circle3.radius, y: circle3.radius });
};
var random22 = (rando) => {
  if (rando === void 0) rando = defaultRandom;
  return Object.freeze({
    x: rando(),
    y: rando(),
    width: rando(),
    height: rando()
  });
};
var randomPoint2 = (within, options = {}) => {
  const rand = options.randomSource ?? defaultRandom;
  const margin = options.margin ?? { x: 0, y: 0 };
  const x3 = rand() * (within.width - margin.x - margin.x);
  const y3 = rand() * (within.height - margin.y - margin.y);
  const pos = { x: x3 + margin.x, y: y3 + margin.y };
  return isPositioned(within) ? sum3(pos, within) : Object.freeze(pos);
};
var isIntersecting3 = (a4, b4) => {
  if (isCirclePositioned(a4)) {
    return isIntersecting2(a4, b4);
  } else if (isRectPositioned(a4)) {
    return isIntersecting(a4, b4);
  }
  throw new Error(
    `a or b are unknown shapes. a: ${JSON.stringify(a4)} b: ${JSON.stringify(b4)}`
  );
};
var randomPoint3 = (shape, opts = {}) => {
  if (isCirclePositioned(shape)) {
    return randomPoint(shape, opts);
  } else if (isRectPositioned(shape)) {
    return randomPoint2(shape, opts);
  }
  throw new Error(`Unknown shape. Only CirclePositioned and RectPositioned are supported.`);
};
var center3 = (shape) => {
  if (shape === void 0) {
    return Object.freeze({ x: 0.5, y: 0.5 });
  } else if (isRect(shape)) {
    return center(shape);
  } else if (triangle_exports.isTriangle(shape)) {
    return triangle_exports.centroid(shape);
  } else if (isCircle(shape)) {
    return center2(shape);
  } else {
    throw new Error(`Unknown shape: ${JSON.stringify(shape)}`);
  }
};
var starburst = (outerRadius, points = 5, innerRadius, origin = point_exports.Empty, opts) => {
  throwIntegerTest(points, `positive`, `points`);
  const angle = Math.PI * 2 / points;
  const angleHalf = angle / 2;
  const initialAngle = opts?.initialAngleRadian ?? -Math.PI / 2;
  if (innerRadius === void 0) innerRadius = outerRadius / 2;
  let a4 = initialAngle;
  const pts = [];
  for (let index = 0; index < points; index++) {
    const peak = toCartesian(outerRadius, a4, origin);
    const left = toCartesian(innerRadius, a4 - angleHalf, origin);
    const right = toCartesian(innerRadius, a4 + angleHalf, origin);
    pts.push(left, peak);
    if (index + 1 < points) pts.push(right);
    a4 += angle;
  }
  return pts;
};
var arrow = (origin, from2, opts = {}) => {
  const tailLength = opts.tailLength ?? 10;
  const tailThickness = opts.tailThickness ?? Math.max(tailLength / 5, 5);
  const angleRadian3 = opts.angleRadian ?? 0;
  const arrowSize = opts.arrowSize ?? Math.max(tailLength / 5, 15);
  const triAngle = Math.PI / 2;
  let tri;
  let tailPoints;
  if (from2 === `tip`) {
    tri = triangle_exports.equilateralFromVertex(origin, arrowSize, triAngle);
    tailPoints = corners(
      fromTopLeft(
        { x: tri.a.x - tailLength, y: origin.y - tailThickness / 2 },
        tailLength,
        tailThickness
      )
    );
  } else if (from2 === `middle`) {
    const midX = tailLength + arrowSize / 2;
    const midY = tailThickness / 2;
    tri = triangle_exports.equilateralFromVertex(
      {
        x: origin.x + arrowSize * 1.2,
        y: origin.y
      },
      arrowSize,
      triAngle
    );
    tailPoints = corners(
      fromTopLeft(
        { x: origin.x - midX, y: origin.y - midY },
        tailLength + arrowSize,
        tailThickness
      )
    );
  } else {
    tailPoints = corners(
      fromTopLeft(
        { x: origin.x, y: origin.y - tailThickness / 2 },
        tailLength,
        tailThickness
      )
    );
    tri = triangle_exports.equilateralFromVertex(
      { x: origin.x + tailLength + arrowSize * 0.7, y: origin.y },
      arrowSize,
      triAngle
    );
  }
  const arrow2 = point_exports.rotate(
    [
      tailPoints[0],
      tailPoints[1],
      tri.a,
      tri.b,
      tri.c,
      tailPoints[2],
      tailPoints[3]
    ],
    angleRadian3,
    origin
  );
  return arrow2;
};
var random3 = (circles, container, opts = {}) => {
  if (!Array.isArray(circles)) throw new Error(`Parameter 'circles' is not an array`);
  const attempts = opts.attempts ?? 2e3;
  const sorted = sortByNumericProperty(circles, `radius`);
  const positionedCircles = [];
  const willHit = (b4, radius) => positionedCircles.some((v3) => isIntersecting2(v3, b4, radius));
  while (sorted.length > 0) {
    const circle3 = sorted.pop();
    if (!circle3) break;
    const randomPointOpts = { ...opts, margin: { x: circle3.radius, y: circle3.radius } };
    for (let index = 0; index < attempts; index++) {
      const position = randomPoint3(container, randomPointOpts);
      if (!willHit(position, circle3.radius)) {
        positionedCircles.push(Object.freeze({ ...circle3, ...position }));
        break;
      }
    }
  }
  return positionedCircles;
};
var circle_exports = {};
__export(circle_exports, {
  area: () => area,
  bbox: () => bbox3,
  center: () => center2,
  circumference: () => circumference,
  distanceCenter: () => distanceCenter,
  distanceFromExterior: () => distanceFromExterior,
  exteriorIntegerPoints: () => exteriorIntegerPoints,
  guard: () => guard5,
  guardPositioned: () => guardPositioned2,
  interiorIntegerPoints: () => interiorIntegerPoints,
  interpolate: () => interpolate32,
  intersectionLine: () => intersectionLine,
  intersections: () => intersections,
  isCircle: () => isCircle,
  isCirclePositioned: () => isCirclePositioned,
  isContainedBy: () => isContainedBy,
  isEqual: () => isEqual3,
  isIntersecting: () => isIntersecting2,
  isNaN: () => isNaN22,
  isPositioned: () => isPositioned2,
  length: () => length3,
  multiplyScalar: () => multiplyScalar2,
  nearest: () => nearest2,
  pointOnPerimeter: () => pointOnPerimeter,
  randomPoint: () => randomPoint,
  toPath: () => toPath2,
  toPositioned: () => toPositioned,
  toSvg: () => toSvg
});
var area = (circle3) => {
  guard5(circle3);
  return Math.PI * circle3.radius * circle3.radius;
};
var fromCenter = (origin, width, height4) => {
  guard(origin, `origin`);
  guardDim(width, `width`);
  guardDim(height4, `height`);
  const halfW = width / 2;
  const halfH = height4 / 2;
  return {
    x: origin.x - halfW,
    y: origin.y - halfH,
    width,
    height: height4
  };
};
var bbox3 = (circle3) => {
  return isCirclePositioned(circle3) ? fromCenter(circle3, circle3.radius * 2, circle3.radius * 2) : { width: circle3.radius * 2, height: circle3.radius * 2, x: 0, y: 0 };
};
function* exteriorIntegerPoints(circle3) {
  const { x: x3, y: y3, radius } = circle3;
  let xx = radius;
  let yy = 0;
  let radiusError = 1 - x3;
  while (xx >= yy) {
    yield { x: xx + x3, y: yy + y3 };
    yield { x: yy + x3, y: xx + y3 };
    yield { x: -xx + x3, y: yy + y3 };
    yield { x: -yy + x3, y: xx + y3 };
    yield { x: -xx + x3, y: -yy + y3 };
    yield { x: -yy + x3, y: -xx + y3 };
    yield { x: xx + x3, y: -yy + y3 };
    yield { x: yy + x3, y: -xx + y3 };
    yy++;
    if (radiusError < 0) {
      radiusError += 2 * yy + 1;
    } else {
      xx--;
      radiusError += 2 * (yy - xx + 1);
    }
  }
}
function* interiorIntegerPoints(circle3) {
  const xMin = circle3.x - circle3.radius;
  const xMax = circle3.x + circle3.radius;
  const yMin = circle3.y - circle3.radius;
  const yMax = circle3.y + circle3.radius;
  for (let x3 = xMin; x3 < xMax; x3++) {
    for (let y3 = yMin; y3 < yMax; y3++) {
      const r5 = Math.abs(distance3(circle3, x3, y3));
      if (r5 <= circle3.radius) yield { x: x3, y: y3 };
    }
  }
}
var piPi22 = Math.PI * 2;
var nearest2 = (circle3, point2) => {
  const n7 = (a4) => {
    const l3 = Math.sqrt(Math.pow(point2.x - a4.x, 2) + Math.pow(point2.y - a4.y, 2));
    const x3 = a4.x + a4.radius * ((point2.x - a4.x) / l3);
    const y3 = a4.y + a4.radius * ((point2.y - a4.y) / l3);
    return { x: x3, y: y3 };
  };
  if (Array.isArray(circle3)) {
    const pts = circle3.map((l3) => n7(l3));
    const dists = pts.map((p4) => distance3(p4, point2));
    return Object.freeze(pts[minIndex(...dists)]);
  } else {
    return Object.freeze(n7(circle3));
  }
};
var pointOnPerimeter = (circle3, angleRadian3, origin) => {
  if (origin === void 0) {
    origin = isCirclePositioned(circle3) ? circle3 : { x: 0, y: 0 };
  }
  return {
    x: Math.cos(-angleRadian3) * circle3.radius + origin.x,
    y: Math.sin(-angleRadian3) * circle3.radius + origin.y
  };
};
var circumference = (circle3) => {
  guard5(circle3);
  return piPi22 * circle3.radius;
};
var length3 = (circle3) => circumference(circle3);
var piPi3 = Math.PI * 2;
var interpolate32 = (circle3, t22) => pointOnPerimeter(circle3, t22 * piPi3);
function multiplyScalar2(a4, value2) {
  if (isCirclePositioned(a4)) {
    const pt2 = multiplyScalar(a4, value2);
    return Object.freeze({
      ...a4,
      ...pt2,
      radius: a4.radius * value2
    });
  } else {
    return Object.freeze({
      ...a4,
      radius: a4.radius * value2
    });
  }
}
var toSvg = (a4, sweep, origin) => {
  if (isCircle(a4)) {
    if (origin !== void 0) {
      return toSvgFull(a4.radius, origin, sweep);
    }
    if (isCirclePositioned(a4)) {
      return toSvgFull(a4.radius, a4, sweep);
    } else throw new Error(`origin parameter needed for non-positioned circle`);
  } else {
    if (origin === void 0) {
      throw new Error(`origin parameter needed`);
    } else {
      return toSvgFull(a4, origin, sweep);
    }
  }
};
var toSvgFull = (radius, origin, sweep) => {
  const { x: x3, y: y3 } = origin;
  const s3 = sweep ? `1` : `0`;
  return `
    M ${x3}, ${y3}
    m -${radius}, 0
    a ${radius},${radius} 0 1,${s3} ${radius * 2},0
    a ${radius},${radius} 0 1,${s3} -${radius * 2},0
  `.split(`
`);
};
var toPath2 = (circle3) => {
  guard5(circle3);
  return {
    ...circle3,
    nearest: (point2) => nearest2(circle3, point2),
    /**
     * Returns a relative (0.0-1.0) point on a circle. 0=3 o'clock, 0.25=6 o'clock, 0.5=9 o'clock, 0.75=12 o'clock etc.
     * @param {t} Relative (0.0-1.0) point
     * @returns {Point} X,y
     */
    interpolate: (t22) => interpolate32(circle3, t22),
    bbox: () => bbox3(circle3),
    length: () => circumference(circle3),
    toSvgString: (sweep = true) => toSvg(circle3, sweep),
    relativePosition: (_point, _intersectionThreshold) => {
      throw new Error(`Not implemented`);
    },
    distanceToPoint: (_point) => {
      throw new Error(`Not implemented`);
    },
    kind: `circular`
  };
};
var toPositioned = (circle3, defaultPositionOrX, y3) => {
  if (isCirclePositioned(circle3)) return circle3;
  const pt2 = getPointParameter2(defaultPositionOrX, y3);
  return Object.freeze({
    ...circle3,
    ...pt2
  });
};
var rect_exports = {};
__export(rect_exports, {
  Empty: () => Empty3,
  EmptyPositioned: () => EmptyPositioned,
  apply: () => apply3,
  applyDim: () => applyDim,
  applyScalar: () => applyScalar,
  area: () => area2,
  cardinal: () => cardinal,
  center: () => center,
  corners: () => corners,
  distanceFromCenter: () => distanceFromCenter,
  distanceFromExterior: () => distanceFromExterior2,
  divide: () => divide4,
  divideDim: () => divideDim,
  divideScalar: () => divideScalar,
  edges: () => edges2,
  fromCenter: () => fromCenter,
  fromElement: () => fromElement,
  fromNumbers: () => fromNumbers3,
  fromTopLeft: () => fromTopLeft,
  getEdgeX: () => getEdgeX,
  getEdgeY: () => getEdgeY,
  getRectPositioned: () => getRectPositioned,
  getRectPositionedParameter: () => getRectPositionedParameter,
  guard: () => guard3,
  guardDim: () => guardDim,
  guardPositioned: () => guardPositioned,
  intersectsPoint: () => intersectsPoint,
  isEmpty: () => isEmpty22,
  isEqual: () => isEqual4,
  isEqualSize: () => isEqualSize,
  isIntersecting: () => isIntersecting,
  isPlaceholder: () => isPlaceholder2,
  isPositioned: () => isPositioned,
  isRect: () => isRect,
  isRectPositioned: () => isRectPositioned,
  lengths: () => lengths,
  maxFromCorners: () => maxFromCorners,
  multiply: () => multiply4,
  multiplyDim: () => multiplyDim,
  multiplyScalar: () => multiplyScalar3,
  random: () => random22,
  randomPoint: () => randomPoint2,
  subtract: () => subtract3,
  subtractOffset: () => subtractOffset,
  sum: () => sum32,
  sumOffset: () => sumOffset,
  toArray: () => toArray23
});
var area2 = (rect2) => {
  guard3(rect2);
  return rect2.height * rect2.width;
};
function apply3(op, a4, b4, c6) {
  guard3(a4, `a`);
  if (isRect(b4)) {
    return isRectPositioned(a4) ? Object.freeze({
      ...a4,
      x: op(a4.x, b4.width),
      y: op(a4.y, b4.height),
      width: op(a4.width, b4.width),
      height: op(a4.height, b4.height)
    }) : Object.freeze({
      ...a4,
      width: op(a4.width, b4.width),
      height: op(a4.height, b4.height)
    });
  } else {
    if (typeof b4 !== `number`) {
      throw new TypeError(
        `Expected second parameter of type Rect or number. Got ${JSON.stringify(
          b4
        )}`
      );
    }
    if (typeof c6 !== `number`) throw new Error(`Expected third param as height. Got ${JSON.stringify(c6)}`);
    return isRectPositioned(a4) ? Object.freeze({
      ...a4,
      x: op(a4.x, b4),
      y: op(a4.y, c6),
      width: op(a4.width, b4),
      height: op(a4.height, c6)
    }) : Object.freeze({
      ...a4,
      width: op(a4.width, b4),
      height: op(a4.height, c6)
    });
  }
}
function applyScalar(op, rect2, param) {
  return isPositioned(rect2) ? Object.freeze({
    ...rect2,
    x: op(rect2.x, param),
    y: op(rect2.y, param),
    width: op(rect2.width, param),
    height: op(rect2.height, param)
  }) : Object.freeze({
    ...rect2,
    width: op(rect2.width, param),
    height: op(rect2.height, param)
  });
}
function applyDim(op, rect2, param) {
  return Object.freeze({
    ...rect2,
    width: op(rect2.width, param),
    height: op(rect2.height, param)
  });
}
var cardinal = (rect2, card) => {
  const { x: x3, y: y3, width, height: height4 } = rect2;
  switch (card) {
    case `nw`: {
      return Object.freeze({ x: x3, y: y3 });
    }
    case `n`: {
      return Object.freeze({
        x: x3 + width / 2,
        y: y3
      });
    }
    case `ne`: {
      return Object.freeze({
        x: x3 + width,
        y: y3
      });
    }
    case `sw`: {
      return Object.freeze({ x: x3, y: y3 + height4 });
    }
    case `s`: {
      return Object.freeze({
        x: x3 + width / 2,
        y: y3 + height4
      });
    }
    case `se`: {
      return Object.freeze({
        x: x3 + width,
        y: y3 + height4
      });
    }
    case `w`: {
      return Object.freeze({ x: x3, y: y3 + height4 / 2 });
    }
    case `e`: {
      return Object.freeze({ x: x3 + width, y: y3 + height4 / 2 });
    }
    case `center`: {
      return Object.freeze({
        x: x3 + width / 2,
        y: y3 + height4 / 2
      });
    }
    default: {
      throw new Error(`Unknown direction: ${card}`);
    }
  }
};
var edges2 = (rect2, origin) => {
  const c6 = corners(rect2, origin);
  return joinPointsToLines(...c6, c6[0]);
};
var getEdgeX = (rect2, edge) => {
  guard3(rect2);
  switch (edge) {
    case `top`: {
      return isPoint(rect2) ? rect2.x : 0;
    }
    case `bottom`: {
      return isPoint(rect2) ? rect2.x : 0;
    }
    case `left`: {
      return isPoint(rect2) ? rect2.y : 0;
    }
    case `right`: {
      return isPoint(rect2) ? rect2.x + rect2.width : rect2.width;
    }
  }
};
var getEdgeY = (rect2, edge) => {
  guard3(rect2);
  switch (edge) {
    case `top`: {
      return isPoint(rect2) ? rect2.y : 0;
    }
    case `bottom`: {
      return isPoint(rect2) ? rect2.y + rect2.height : rect2.height;
    }
    case `left`: {
      return isPoint(rect2) ? rect2.y : 0;
    }
    case `right`: {
      return isPoint(rect2) ? rect2.y : 0;
    }
  }
};
var Empty3 = Object.freeze({ width: 0, height: 0 });
var EmptyPositioned = Object.freeze({
  x: 0,
  y: 0,
  width: 0,
  height: 0
});
var fromElement = (el) => ({
  width: el.clientWidth,
  height: el.clientHeight
});
function fromNumbers3(xOrWidth, yOrHeight, width, height4) {
  if (width === void 0 || height4 === void 0) {
    if (typeof xOrWidth !== `number`) throw new Error(`width is not an number`);
    if (typeof yOrHeight !== `number`) {
      throw new TypeError(`height is not an number`);
    }
    return Object.freeze({ width: xOrWidth, height: yOrHeight });
  }
  if (typeof xOrWidth !== `number`) throw new Error(`x is not an number`);
  if (typeof yOrHeight !== `number`) throw new Error(`y is not an number`);
  if (typeof width !== `number`) throw new Error(`width is not an number`);
  if (typeof height4 !== `number`) throw new Error(`height is not an number`);
  return Object.freeze({ x: xOrWidth, y: yOrHeight, width, height: height4 });
}
function getRectPositionedParameter(a4, b4, c6, d4) {
  if (typeof a4 === `number`) {
    if (typeof b4 === `number`) {
      if (typeof c6 === `number` && typeof d4 === `number`) {
        return { x: a4, y: b4, width: c6, height: d4 };
      } else if (isRect(c6)) {
        return { x: a4, y: b4, width: c6.width, height: c6.height };
      } else {
        throw new TypeError(`If params 'a' & 'b' are numbers, expect following parameters to be x,y or Rect`);
      }
    } else {
      throw new TypeError(`If parameter 'a' is a number, expect following parameters to be: y,w,h`);
    }
  } else if (isRectPositioned(a4)) {
    return a4;
  } else if (isRect(a4)) {
    if (typeof b4 === `number` && typeof c6 === `number`) {
      return { width: a4.width, height: a4.height, x: b4, y: c6 };
    } else if (isPoint(b4)) {
      return { width: a4.width, height: a4.height, x: b4.x, y: b4.y };
    } else {
      throw new TypeError(`If param 'a' is a Rect, expects following parameters to be x,y`);
    }
  } else if (isPoint(a4)) {
    if (typeof b4 === `number` && typeof c6 === `number`) {
      return { x: a4.x, y: a4.y, width: b4, height: c6 };
    } else if (isRect(b4)) {
      return { x: a4.x, y: a4.y, width: b4.width, height: b4.height };
    } else {
      throw new TypeError(`If parameter 'a' is a Point, expect following params to be: Rect or width,height`);
    }
  }
  throw new TypeError(`Expect a first parameter to be x,RectPositioned,Rect or Point`);
}
var isEqualSize = (a4, b4) => {
  if (a4 === void 0) throw new Error(`a undefined`);
  if (b4 === void 0) throw new Error(`b undefined`);
  return a4.width === b4.width && a4.height === b4.height;
};
var isEqual4 = (a4, b4) => {
  if (isPositioned(a4) && isPositioned(b4)) {
    if (!isEqual(a4, b4)) return false;
    return a4.width === b4.width && a4.height === b4.height;
  } else if (!isPositioned(a4) && !isPositioned(b4)) {
    return a4.width === b4.width && a4.height === b4.height;
  } else {
    return false;
  }
};
var lengths = (rect2) => {
  guardPositioned(rect2, `rect`);
  return edges2(rect2).map((l3) => length2(l3));
};
var multiplyOp = (a4, b4) => a4 * b4;
function multiply4(a4, b4, c6) {
  return apply3(multiplyOp, a4, b4, c6);
}
function multiplyScalar3(rect2, amount) {
  return applyScalar(multiplyOp, rect2, amount);
}
function multiplyDim(rect2, amount) {
  return applyDim(multiplyOp, rect2, amount);
}
var divideOp = (a4, b4) => a4 / b4;
function divide4(a4, b4, c6) {
  return apply3(divideOp, a4, b4, c6);
}
function divideScalar(rect2, amount) {
  return applyScalar(divideOp, rect2, amount);
}
function divideDim(rect2, amount) {
  return applyDim(divideOp, rect2, amount);
}
var subtractOp = (a4, b4) => a4 - b4;
function subtract3(a4, b4, c6) {
  return apply3(subtractOp, a4, b4, c6);
}
function subtractOffset(a4, b4) {
  let x3 = 0;
  let y3 = 0;
  if (isPositioned(a4)) {
    x3 = a4.x;
    y3 = a4.y;
  }
  let xB = 0;
  let yB = 0;
  if (isPositioned(b4)) {
    xB = b4.x;
    yB = b4.y;
  }
  return Object.freeze({
    ...a4,
    x: x3 - xB,
    y: y3 - yB,
    width: a4.width - b4.width,
    height: a4.height - b4.height
  });
}
var sumOp = (a4, b4) => a4 + b4;
function sum32(a4, b4, c6) {
  return apply3(sumOp, a4, b4, c6);
}
function sumOffset(a4, b4) {
  let x3 = 0;
  let y3 = 0;
  if (isPositioned(a4)) {
    x3 = a4.x;
    y3 = a4.y;
  }
  let xB = 0;
  let yB = 0;
  if (isPositioned(b4)) {
    xB = b4.x;
    yB = b4.y;
  }
  return Object.freeze({
    ...a4,
    x: x3 + xB,
    y: y3 + yB,
    width: a4.width + b4.width,
    height: a4.height + b4.height
  });
}
function toArray23(rect2) {
  if (isPositioned(rect2)) {
    return [rect2.x, rect2.y, rect2.width, rect2.height];
  } else if (isRect(rect2)) {
    return [rect2.width, rect2.height];
  } else {
    throw new Error(
      `Param 'rect' is not a rectangle. Got: ${JSON.stringify(rect2)}`
    );
  }
}
var path_exports = {};
__export(path_exports, {
  getEnd: () => getEnd,
  getStart: () => getStart
});
var isQuadraticBezier = (path2) => path2.quadratic !== void 0;
var isCubicBezier = (path2) => path2.cubic1 !== void 0 && path2.cubic2 !== void 0;
var getStart = function(path2) {
  if (isQuadraticBezier(path2)) return path2.a;
  else if (isLine(path2)) return path2.a;
  else throw new Error(`Unknown path type ${JSON.stringify(path2)}`);
};
var getEnd = function(path2) {
  if (isQuadraticBezier(path2)) return path2.b;
  else if (isLine(path2)) return path2.b;
  else throw new Error(`Unknown path type ${JSON.stringify(path2)}`);
};
var Grid_exports = {};
__export(Grid_exports, {
  access1dArray: () => access1dArray,
  allDirections: () => allDirections,
  array2dUpdater: () => array2dUpdater,
  asRectangles: () => asRectangles,
  cellAtPoint: () => cellAtPoint,
  cellEquals: () => cellEquals,
  cellFromIndex: () => cellFromIndex,
  cellKeyString: () => cellKeyString,
  cellMiddle: () => cellMiddle,
  cells: () => cells,
  crossDirections: () => crossDirections,
  getLine: () => getLine,
  getVectorFromCardinal: () => getVectorFromCardinal,
  guardCell: () => guardCell,
  indexFromCell: () => indexFromCell,
  inside: () => inside,
  isEqual: () => isEqual5,
  neighbours: () => neighbours,
  offset: () => offset,
  offsetCardinals: () => offsetCardinals,
  rectangleForCell: () => rectangleForCell,
  rows: () => rows,
  simpleLine: () => simpleLine,
  toArray: () => toArray32,
  visitArray: () => visitArray,
  visitFor: () => visitFor,
  visitNeigbours: () => visitNeigbours,
  visitor: () => visitor,
  visitorBreadth: () => visitorBreadth,
  visitorColumn: () => visitorColumn,
  visitorDepth: () => visitorDepth,
  visitorRandom: () => visitorRandom,
  visitorRandomContiguous: () => visitorRandomContiguous,
  visitorRow: () => visitorRow
});
var isCell = (cell) => {
  if (cell === void 0) return false;
  return `x` in cell && `y` in cell;
};
var isNeighbour = (n7) => {
  if (n7 === void 0) return false;
  if (n7[1] === void 0) return false;
  return true;
};
var isEqual5 = (a4, b4) => {
  if (b4 === void 0) return false;
  if (a4 === void 0) return false;
  if (`rows` in a4 && `cols` in a4) {
    if (`rows` in b4 && `cols` in b4) {
      if (a4.rows !== b4.rows || a4.cols !== b4.cols) return false;
    } else return false;
  }
  if (`size` in a4) {
    if (`size` in b4) {
      if (a4.size !== b4.size) return false;
    } else return false;
  }
  return true;
};
var cellKeyString = (v3) => `Cell{${v3.x},${v3.y}}`;
var cellEquals = (a4, b4) => {
  if (b4 === void 0) return false;
  if (a4 === void 0) return false;
  return a4.x === b4.x && a4.y === b4.y;
};
var guardCell = (cell, parameterName = `Param`, grid2) => {
  if (cell === void 0) {
    throw new Error(parameterName + ` is undefined. Expecting {x,y}`);
  }
  if (cell.x === void 0) throw new Error(parameterName + `.x is undefined`);
  if (cell.y === void 0) throw new Error(parameterName + `.y is undefined`);
  if (Number.isNaN(cell.x)) throw new Error(parameterName + `.x is NaN`);
  if (Number.isNaN(cell.y)) throw new Error(parameterName + `.y is NaN`);
  if (!Number.isInteger(cell.x)) {
    throw new TypeError(parameterName + `.x is non-integer`);
  }
  if (!Number.isInteger(cell.y)) {
    throw new TypeError(parameterName + `.y is non-integer`);
  }
  if (grid2 !== void 0 && !inside(grid2, cell)) {
    throw new Error(
      `${parameterName} is outside of grid. Cell: ${cell.x},${cell.y} Grid: ${grid2.cols}, ${grid2.rows}`
    );
  }
};
var guardGrid = (grid2, parameterName = `Param`) => {
  if (grid2 === void 0) {
    throw new Error(`${parameterName} is undefined. Expecting grid.`);
  }
  if (!(`rows` in grid2)) throw new Error(`${parameterName}.rows is undefined`);
  if (!(`cols` in grid2)) throw new Error(`${parameterName}.cols is undefined`);
  if (!Number.isInteger(grid2.rows)) {
    throw new TypeError(`${parameterName}.rows is not an integer`);
  }
  if (!Number.isInteger(grid2.cols)) {
    throw new TypeError(`${parameterName}.cols is not an integer`);
  }
};
var inside = (grid2, cell) => {
  if (cell.x < 0 || cell.y < 0) return false;
  if (cell.x >= grid2.cols || cell.y >= grid2.rows) return false;
  return true;
};
var rectangleForCell = (grid2, cell) => {
  guardCell(cell);
  const size = grid2.size;
  const x3 = cell.x * size;
  const y3 = cell.y * size;
  const r5 = fromTopLeft({ x: x3, y: y3 }, size, size);
  return r5;
};
function* asRectangles(grid2) {
  for (const c6 of cells(grid2)) {
    yield rectangleForCell(grid2, c6);
  }
}
var toArray32 = (grid2, initialValue) => {
  const returnValue = [];
  for (let row = 0; row < grid2.rows; row++) {
    returnValue[row] = Array.from({ length: grid2.cols });
    if (initialValue) {
      for (let col = 0; col < grid2.cols; col++) {
        returnValue[row][col] = initialValue;
      }
    }
  }
  return returnValue;
};
var cellAtPoint = (grid2, position) => {
  const size = grid2.size;
  throwNumberTest(size, `positive`, `grid.size`);
  if (position.x < 0 || position.y < 0) return;
  const x3 = Math.floor(position.x / size);
  const y3 = Math.floor(position.y / size);
  if (x3 >= grid2.cols) return;
  if (y3 >= grid2.rows) return;
  return { x: x3, y: y3 };
};
var allDirections = Object.freeze([
  `n`,
  `ne`,
  `nw`,
  `e`,
  `s`,
  `se`,
  `sw`,
  `w`
]);
var crossDirections = Object.freeze([
  `n`,
  `e`,
  `s`,
  `w`
]);
var neighbours = (grid2, cell, bounds = `undefined`, directions) => {
  const directories = directions ?? allDirections;
  const points = directories.map(
    (c6) => offset(grid2, cell, getVectorFromCardinal(c6), bounds)
  );
  return zipKeyValue(directories, points);
};
function* visitNeigbours(grid2, cell, bounds = `undefined`, directions) {
  const directories = directions ?? allDirections;
  const points = directories.map(
    (c6) => offset(grid2, cell, getVectorFromCardinal(c6), bounds)
  );
  for (const pt2 of points) {
    if (pt2 !== void 0) yield pt2;
  }
}
var cellMiddle = (grid2, cell) => {
  guardCell(cell);
  const size = grid2.size;
  const x3 = cell.x * size;
  const y3 = cell.y * size;
  return Object.freeze({ x: x3 + size / 2, y: y3 + size / 2 });
};
var getLine = (start, end) => {
  guardCell(start);
  guardCell(end);
  let startX = start.x;
  let startY = start.y;
  const dx = Math.abs(end.x - startX);
  const dy = Math.abs(end.y - startY);
  const sx = startX < end.x ? 1 : -1;
  const sy = startY < end.y ? 1 : -1;
  let error = dx - dy;
  const cells2 = [];
  while (true) {
    cells2.push(Object.freeze({ x: startX, y: startY }));
    if (startX === end.x && startY === end.y) break;
    const error2 = 2 * error;
    if (error2 > -dy) {
      error -= dy;
      startX += sx;
    }
    if (error2 < dx) {
      error += dx;
      startY += sy;
    }
  }
  return cells2;
};
var offsetCardinals = (grid2, start, steps2, bounds = `stop`) => {
  guardGrid(grid2, `grid`);
  guardCell(start, `start`);
  throwIntegerTest(steps2, `aboveZero`, `steps`);
  const directions = allDirections;
  const vectors = directions.map((d4) => getVectorFromCardinal(d4, steps2));
  const cells2 = directions.map(
    (d4, index) => offset(grid2, start, vectors[index], bounds)
  );
  return zipKeyValue(directions, cells2);
};
var getVectorFromCardinal = (cardinal2, multiplier = 1) => {
  let v3;
  switch (cardinal2) {
    case `n`: {
      v3 = { x: 0, y: -1 * multiplier };
      break;
    }
    case `ne`: {
      v3 = { x: 1 * multiplier, y: -1 * multiplier };
      break;
    }
    case `e`: {
      v3 = { x: 1 * multiplier, y: 0 };
      break;
    }
    case `se`: {
      v3 = { x: 1 * multiplier, y: 1 * multiplier };
      break;
    }
    case `s`: {
      v3 = { x: 0, y: 1 * multiplier };
      break;
    }
    case `sw`: {
      v3 = { x: -1 * multiplier, y: 1 * multiplier };
      break;
    }
    case `w`: {
      v3 = { x: -1 * multiplier, y: 0 };
      break;
    }
    case `nw`: {
      v3 = { x: -1 * multiplier, y: -1 * multiplier };
      break;
    }
    default: {
      v3 = { x: 0, y: 0 };
    }
  }
  return Object.freeze(v3);
};
var simpleLine = function(start, end, endInclusive = false) {
  const cells2 = [];
  if (start.x === end.x) {
    const lastY = endInclusive ? end.y + 1 : end.y;
    for (let y3 = start.y; y3 < lastY; y3++) {
      cells2.push({ x: start.x, y: y3 });
    }
  } else if (start.y === end.y) {
    const lastX = endInclusive ? end.x + 1 : end.x;
    for (let x3 = start.x; x3 < lastX; x3++) {
      cells2.push({ x: x3, y: start.y });
    }
  } else {
    throw new Error(
      `Only does vertical and horizontal: ${start.x},${start.y} - ${end.x},${end.y}`
    );
  }
  return cells2;
};
var offset = function(grid2, start, vector, bounds = `undefined`) {
  guardCell(start, `start`, grid2);
  guardCell(vector);
  guardGrid(grid2, `grid`);
  let x3 = start.x;
  let y3 = start.y;
  switch (bounds) {
    case `wrap`: {
      x3 += vector.x % grid2.cols;
      y3 += vector.y % grid2.rows;
      if (x3 < 0) x3 = grid2.cols + x3;
      else if (x3 >= grid2.cols) {
        x3 -= grid2.cols;
      }
      if (y3 < 0) y3 = grid2.rows + y3;
      else if (y3 >= grid2.rows) {
        y3 -= grid2.rows;
      }
      break;
    }
    case `stop`: {
      x3 += vector.x;
      y3 += vector.y;
      x3 = clampIndex(x3, grid2.cols);
      y3 = clampIndex(y3, grid2.rows);
      break;
    }
    case `undefined`: {
      x3 += vector.x;
      y3 += vector.y;
      if (x3 < 0 || y3 < 0) return;
      if (x3 >= grid2.cols || y3 >= grid2.rows) return;
      break;
    }
    case `unbounded`: {
      x3 += vector.x;
      y3 += vector.y;
      break;
    }
    default: {
      throw new Error(`Unknown BoundsLogic case ${bounds}`);
    }
  }
  return Object.freeze({ x: x3, y: y3 });
};
var neighbourList = (grid2, cell, directions, bounds) => {
  const cellNeighbours = neighbours(grid2, cell, bounds, directions);
  const entries2 = Object.entries(cellNeighbours);
  return entries2.filter((n7) => isNeighbour(n7));
};
var visitor = function* (logic, grid2, start, opts = {}) {
  guardGrid(grid2, `grid`);
  guardCell(start, `start`, grid2);
  const v3 = opts.visited ?? mutable3(cellKeyString);
  const possibleNeighbours = logic.options ?? ((g5, c6) => neighbourList(g5, c6, crossDirections, `undefined`));
  if (!isCell(start)) {
    throw new Error(`'start' parameter is undefined or not a cell`);
  }
  let cellQueue = [start];
  let moveQueue = [];
  let current = void 0;
  while (cellQueue.length > 0) {
    if (current === void 0) {
      const nv = cellQueue.pop();
      if (nv === void 0) {
        break;
      }
      current = nv;
    }
    if (!v3.has(current)) {
      v3.add(current);
      yield current;
      const nextSteps = possibleNeighbours(grid2, current).filter(
        (step) => {
          if (step[1] === void 0) return false;
          return !v3.has(step[1]);
        }
      );
      if (nextSteps.length === 0) {
        if (current !== void 0) {
          cellQueue = cellQueue.filter((cq) => cellEquals(cq, current));
        }
      } else {
        for (const n7 of nextSteps) {
          if (n7 === void 0) continue;
          if (n7[1] === void 0) continue;
          moveQueue.push(n7);
        }
      }
    }
    moveQueue = moveQueue.filter((step) => !v3.has(step[1]));
    if (moveQueue.length === 0) {
      current = void 0;
    } else {
      const potential = logic.select(moveQueue);
      if (potential !== void 0) {
        cellQueue.push(potential[1]);
        current = potential[1];
      }
    }
  }
};
var visitorDepth = (grid2, start, opts = {}) => visitor(
  {
    select: (nbos) => nbos.at(-1)
  },
  grid2,
  start,
  opts
);
var visitorBreadth = (grid2, start, opts = {}) => visitor(
  {
    select: (nbos) => nbos[0]
  },
  grid2,
  start,
  opts
);
var randomNeighbour = (nbos) => randomElement(nbos);
var visitorRandomContiguous = (grid2, start, opts = {}) => visitor(
  {
    select: randomNeighbour
  },
  grid2,
  start,
  opts
);
var visitorRandom = (grid2, start, opts = {}) => visitor(
  {
    options: (grid22, cell) => {
      const t22 = [];
      for (const c6 of cells(grid22, cell)) {
        t22.push([`n`, c6]);
      }
      return t22;
    },
    select: randomNeighbour
  },
  grid2,
  start,
  opts
);
var visitorRow = (grid2, start, opts = {}) => {
  if (!start) start = { x: 0, y: 0 };
  const { reversed = false } = opts;
  const neighbourSelect = (nbos) => nbos.find((n7) => n7[0] === (reversed ? `w` : `e`));
  const possibleNeighbours = (grid22, cell) => {
    if (reversed) {
      if (cell.x > 0) {
        cell = { x: cell.x - 1, y: cell.y };
      } else {
        if (cell.y > 0) {
          cell = { x: grid22.cols - 1, y: cell.y - 1 };
        } else {
          cell = { x: grid22.cols - 1, y: grid22.rows - 1 };
        }
      }
    } else {
      if (cell.x < grid22.rows - 1) {
        cell = { x: cell.x + 1, y: cell.y };
      } else {
        if (cell.y < grid22.rows - 1) {
          cell = { x: 0, y: cell.y + 1 };
        } else {
          cell = { x: 0, y: 0 };
        }
      }
    }
    return [[reversed ? `w` : `e`, cell]];
  };
  const logic = {
    select: neighbourSelect,
    options: possibleNeighbours
  };
  return visitor(logic, grid2, start, opts);
};
var visitFor = (grid2, start, steps2, visitor2) => {
  throwIntegerTest(steps2, ``, `steps`);
  const opts = {
    reversed: steps2 < 0
  };
  steps2 = Math.abs(steps2);
  let c6 = start;
  let v3 = visitor2(grid2, start, opts);
  v3.next();
  let stepsMade = 0;
  while (stepsMade < steps2) {
    stepsMade++;
    const { value: value2 } = v3.next();
    if (value2) {
      c6 = value2;
      if (opts.debug) {
        console.log(
          `stepsMade: ${stepsMade} cell: ${c6.x}, ${c6.y} reverse: ${opts.reversed}`
        );
      }
    } else {
      if (steps2 >= grid2.cols * grid2.rows) {
        steps2 -= grid2.cols * grid2.rows;
        stepsMade = 0;
        v3 = visitor2(grid2, start, opts);
        v3.next();
        c6 = start;
        if (opts.debug) console.log(`resetting visitor to ${steps2}`);
      } else throw new Error(`Value not received by visitor`);
    }
  }
  return c6;
};
var visitorColumn = (grid2, start, opts = {}) => {
  const { reversed = false } = opts;
  const logic = {
    select: (nbos) => nbos.find((n7) => n7[0] === (reversed ? `n` : `s`)),
    options: (grid22, cell) => {
      if (reversed) {
        if (cell.y > 0) {
          cell = { x: cell.x, y: cell.y - 1 };
        } else {
          if (cell.x === 0) {
            cell = { x: grid22.cols - 1, y: grid22.rows - 1 };
          } else {
            cell = { x: cell.x - 1, y: grid22.rows - 1 };
          }
        }
      } else {
        if (cell.y < grid22.rows - 1) {
          cell = { x: cell.x, y: cell.y + 1 };
        } else {
          if (cell.x < grid22.cols - 1) {
            cell = { x: cell.x + 1, y: 0 };
          } else {
            cell = { x: 0, y: 0 };
          }
        }
      }
      return [[reversed ? `n` : `s`, cell]];
    }
  };
  return visitor(logic, grid2, start, opts);
};
var rows = function* (grid2, start) {
  if (!start) start = { x: 0, y: 0 };
  let row = start.y;
  let rowCells = [];
  for (const c6 of cells(grid2, start)) {
    if (c6.y === row) {
      rowCells.push(c6);
    } else {
      yield rowCells;
      rowCells = [c6];
      row = c6.y;
    }
  }
  if (rowCells.length > 0) yield rowCells;
};
var cells = function* (grid2, start) {
  if (!start) start = { x: 0, y: 0 };
  guardGrid(grid2, `grid`);
  guardCell(start, `start`, grid2);
  let { x: x3, y: y3 } = start;
  let canMove = true;
  do {
    yield { x: x3, y: y3 };
    x3++;
    if (x3 === grid2.cols) {
      y3++;
      x3 = 0;
    }
    if (y3 === grid2.rows) {
      y3 = 0;
      x3 = 0;
    }
    if (x3 === start.x && y3 === start.y) canMove = false;
  } while (canMove);
};
var access1dArray = (array2, cols) => {
  const grid2 = { cols, rows: Math.ceil(array2.length / cols) };
  const fn2 = (cell, wrap32) => {
    const index = indexFromCell(grid2, cell, wrap32);
    if (index === void 0) return void 0;
    return array2[index];
  };
  return fn2;
};
var array2dUpdater = (grid2, array2) => {
  const fn2 = (v3, position) => {
    const pos = cellAtPoint(grid2, position);
    if (pos === void 0) {
      throw new Error(
        `Position does not exist. Pos: ${JSON.stringify(
          position
        )} Grid: ${JSON.stringify(grid2)}`
      );
    }
    array2[pos.y][pos.x] = v3;
  };
  return fn2;
};
function* visitArray(array2, cols, iteratorFunction, opts) {
  if (typeof array2 === `undefined`) {
    throw new TypeError(`First parameter is undefined, expected an array`);
  }
  if (array2 === null) throw new Error(`First parameter is null, expected an array`);
  if (!Array.isArray(array2)) throw new Error(`First parameter should be an array`);
  throwIntegerTest(cols, `aboveZero`, `cols`);
  if (array2.length === 0) return;
  const wrap32 = opts?.boundsWrap ?? `stop`;
  const rows2 = Math.ceil(array2.length / cols);
  const grid2 = {
    cols,
    rows: rows2
  };
  if (iteratorFunction === void 0) iteratorFunction = cells;
  const iter = iteratorFunction(grid2, { x: 0, y: 0 }, opts);
  for (const cell of iter) {
    const index = indexFromCell(grid2, cell, wrap32);
    if (index === void 0) return void 0;
    yield [array2[index], index];
  }
}
var indexFromCell = (grid2, cell, wrap32) => {
  guardGrid(grid2, `grid`);
  if (cell.x < 0) {
    switch (wrap32) {
      case `stop`: {
        cell = { ...cell, x: 0 };
        break;
      }
      case `unbounded`: {
        throw new Error(`unbounded not supported`);
      }
      case `undefined`: {
        return void 0;
      }
      case `wrap`: {
        cell = offset(grid2, { x: 0, y: cell.y }, { x: cell.x, y: 0 }, `wrap`);
        break;
      }
    }
  }
  if (cell.y < 0) {
    switch (wrap32) {
      case `stop`: {
        cell = { ...cell, y: 0 };
        break;
      }
      case `unbounded`: {
        throw new Error(`unbounded not supported`);
      }
      case `undefined`: {
        return void 0;
      }
      case `wrap`: {
        cell = { ...cell, y: grid2.rows + cell.y };
        break;
      }
    }
  }
  if (cell.x >= grid2.cols) {
    switch (wrap32) {
      case `stop`: {
        cell = { ...cell, x: grid2.cols - 1 };
        break;
      }
      case `unbounded`: {
        throw new Error(`unbounded not supported`);
      }
      case `undefined`: {
        return void 0;
      }
      case `wrap`: {
        cell = { ...cell, x: cell.x % grid2.cols };
        break;
      }
    }
  }
  if (cell.y >= grid2.rows) {
    switch (wrap32) {
      case `stop`: {
        cell = { ...cell, y: grid2.rows - 1 };
        break;
      }
      case `unbounded`: {
        throw new Error(`unbounded not supported`);
      }
      case `undefined`: {
        return void 0;
      }
      case `wrap`: {
        cell = { ...cell, y: cell.y % grid2.rows };
        break;
      }
    }
  }
  const index = cell.y * grid2.cols + cell.x;
  return index;
};
var cellFromIndex = (colsOrGrid, index) => {
  let cols = 0;
  cols = typeof colsOrGrid === `number` ? colsOrGrid : colsOrGrid.cols;
  throwIntegerTest(cols, `aboveZero`, `colsOrGrid`);
  return {
    x: index % cols,
    y: Math.floor(index / cols)
  };
};
var bezier_exports = {};
__export(bezier_exports, {
  computeQuadraticSimple: () => computeQuadraticSimple,
  cubic: () => cubic,
  isCubicBezier: () => isCubicBezier,
  isQuadraticBezier: () => isQuadraticBezier,
  quadratic: () => quadratic,
  quadraticBend: () => quadraticBend,
  quadraticSimple: () => quadraticSimple,
  quadraticToSvgString: () => quadraticToSvgString,
  toPath: () => toPath3
});
var { abs: abs2, cos: cos2, sin: sin2, acos, atan2, sqrt: sqrt2, pow: pow3 } = Math;
function crt(v3) {
  return v3 < 0 ? -pow3(-v3, 1 / 3) : pow3(v3, 1 / 3);
}
var pi3 = Math.PI;
var tau2 = 2 * pi3;
var quart = pi3 / 2;
var epsilon = 1e-6;
var nMax = Number.MAX_SAFE_INTEGER || 9007199254740991;
var nMin = Number.MIN_SAFE_INTEGER || -9007199254740991;
var ZERO = { x: 0, y: 0, z: 0 };
var utils = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(t22, derivativeFn) {
    const d4 = derivativeFn(t22);
    let l3 = d4.x * d4.x + d4.y * d4.y;
    if (typeof d4.z !== "undefined") {
      l3 += d4.z * d4.z;
    }
    return sqrt2(l3);
  },
  compute: function(t22, points, _3d) {
    if (t22 === 0) {
      points[0].t = 0;
      return points[0];
    }
    const order = points.length - 1;
    if (t22 === 1) {
      points[order].t = 1;
      return points[order];
    }
    const mt3 = 1 - t22;
    let p4 = points;
    if (order === 0) {
      points[0].t = t22;
      return points[0];
    }
    if (order === 1) {
      const ret = {
        x: mt3 * p4[0].x + t22 * p4[1].x,
        y: mt3 * p4[0].y + t22 * p4[1].y,
        t: t22
      };
      if (_3d) {
        ret.z = mt3 * p4[0].z + t22 * p4[1].z;
      }
      return ret;
    }
    if (order < 4) {
      let mt22 = mt3 * mt3, t222 = t22 * t22, a4, b4, c6, d4 = 0;
      if (order === 2) {
        p4 = [p4[0], p4[1], p4[2], ZERO];
        a4 = mt22;
        b4 = mt3 * t22 * 2;
        c6 = t222;
      } else if (order === 3) {
        a4 = mt22 * mt3;
        b4 = mt22 * t22 * 3;
        c6 = mt3 * t222 * 3;
        d4 = t22 * t222;
      }
      const ret = {
        x: a4 * p4[0].x + b4 * p4[1].x + c6 * p4[2].x + d4 * p4[3].x,
        y: a4 * p4[0].y + b4 * p4[1].y + c6 * p4[2].y + d4 * p4[3].y,
        t: t22
      };
      if (_3d) {
        ret.z = a4 * p4[0].z + b4 * p4[1].z + c6 * p4[2].z + d4 * p4[3].z;
      }
      return ret;
    }
    const dCpts = JSON.parse(JSON.stringify(points));
    while (dCpts.length > 1) {
      for (let i4 = 0; i4 < dCpts.length - 1; i4++) {
        dCpts[i4] = {
          x: dCpts[i4].x + (dCpts[i4 + 1].x - dCpts[i4].x) * t22,
          y: dCpts[i4].y + (dCpts[i4 + 1].y - dCpts[i4].y) * t22
        };
        if (typeof dCpts[i4].z !== "undefined") {
          dCpts[i4].z = dCpts[i4].z + (dCpts[i4 + 1].z - dCpts[i4].z) * t22;
        }
      }
      dCpts.splice(dCpts.length - 1, 1);
    }
    dCpts[0].t = t22;
    return dCpts[0];
  },
  computeWithRatios: function(t22, points, ratios, _3d) {
    const mt3 = 1 - t22, r5 = ratios, p4 = points;
    let f1 = r5[0], f22 = r5[1], f32 = r5[2], f42 = r5[3], d4;
    f1 *= mt3;
    f22 *= t22;
    if (p4.length === 2) {
      d4 = f1 + f22;
      return {
        x: (f1 * p4[0].x + f22 * p4[1].x) / d4,
        y: (f1 * p4[0].y + f22 * p4[1].y) / d4,
        z: !_3d ? false : (f1 * p4[0].z + f22 * p4[1].z) / d4,
        t: t22
      };
    }
    f1 *= mt3;
    f22 *= 2 * mt3;
    f32 *= t22 * t22;
    if (p4.length === 3) {
      d4 = f1 + f22 + f32;
      return {
        x: (f1 * p4[0].x + f22 * p4[1].x + f32 * p4[2].x) / d4,
        y: (f1 * p4[0].y + f22 * p4[1].y + f32 * p4[2].y) / d4,
        z: !_3d ? false : (f1 * p4[0].z + f22 * p4[1].z + f32 * p4[2].z) / d4,
        t: t22
      };
    }
    f1 *= mt3;
    f22 *= 1.5 * mt3;
    f32 *= 3 * mt3;
    f42 *= t22 * t22 * t22;
    if (p4.length === 4) {
      d4 = f1 + f22 + f32 + f42;
      return {
        x: (f1 * p4[0].x + f22 * p4[1].x + f32 * p4[2].x + f42 * p4[3].x) / d4,
        y: (f1 * p4[0].y + f22 * p4[1].y + f32 * p4[2].y + f42 * p4[3].y) / d4,
        z: !_3d ? false : (f1 * p4[0].z + f22 * p4[1].z + f32 * p4[2].z + f42 * p4[3].z) / d4,
        t: t22
      };
    }
  },
  derive: function(points, _3d) {
    const dpoints = [];
    for (let p4 = points, d4 = p4.length, c6 = d4 - 1; d4 > 1; d4--, c6--) {
      const list = [];
      for (let j3 = 0, dpt; j3 < c6; j3++) {
        dpt = {
          x: c6 * (p4[j3 + 1].x - p4[j3].x),
          y: c6 * (p4[j3 + 1].y - p4[j3].y)
        };
        if (_3d) {
          dpt.z = c6 * (p4[j3 + 1].z - p4[j3].z);
        }
        list.push(dpt);
      }
      dpoints.push(list);
      p4 = list;
    }
    return dpoints;
  },
  between: function(v3, m5, M3) {
    return m5 <= v3 && v3 <= M3 || utils.approximately(v3, m5) || utils.approximately(v3, M3);
  },
  approximately: function(a4, b4, precision) {
    return abs2(a4 - b4) <= (precision || epsilon);
  },
  length: function(derivativeFn) {
    const z3 = 0.5, len = utils.Tvalues.length;
    let sum5 = 0;
    for (let i4 = 0, t22; i4 < len; i4++) {
      t22 = z3 * utils.Tvalues[i4] + z3;
      sum5 += utils.Cvalues[i4] * utils.arcfn(t22, derivativeFn);
    }
    return z3 * sum5;
  },
  map: function(v3, ds2, de2, ts2, te2) {
    const d1 = de2 - ds2, d22 = te2 - ts2, v22 = v3 - ds2, r5 = v22 / d1;
    return ts2 + d22 * r5;
  },
  lerp: function(r5, v1, v22) {
    const ret = {
      x: v1.x + r5 * (v22.x - v1.x),
      y: v1.y + r5 * (v22.y - v1.y)
    };
    if (v1.z !== void 0 && v22.z !== void 0) {
      ret.z = v1.z + r5 * (v22.z - v1.z);
    }
    return ret;
  },
  pointToString: function(p4) {
    let s3 = p4.x + "/" + p4.y;
    if (typeof p4.z !== "undefined") {
      s3 += "/" + p4.z;
    }
    return s3;
  },
  pointsToString: function(points) {
    return "[" + points.map(utils.pointToString).join(", ") + "]";
  },
  copy: function(obj) {
    return JSON.parse(JSON.stringify(obj));
  },
  angle: function(o5, v1, v22) {
    const dx1 = v1.x - o5.x, dy1 = v1.y - o5.y, dx2 = v22.x - o5.x, dy2 = v22.y - o5.y, cross = dx1 * dy2 - dy1 * dx2, dot2 = dx1 * dx2 + dy1 * dy2;
    return atan2(cross, dot2);
  },
  // round as string, to avoid rounding errors
  round: function(v3, d4) {
    const s3 = "" + v3;
    const pos = s3.indexOf(".");
    return parseFloat(s3.substring(0, pos + 1 + d4));
  },
  dist: function(p1, p22) {
    const dx = p1.x - p22.x, dy = p1.y - p22.y;
    return sqrt2(dx * dx + dy * dy);
  },
  closest: function(LUT, point2) {
    let mdist = pow3(2, 63), mpos, d4;
    LUT.forEach(function(p4, idx) {
      d4 = utils.dist(point2, p4);
      if (d4 < mdist) {
        mdist = d4;
        mpos = idx;
      }
    });
    return { mdist, mpos };
  },
  abcratio: function(t22, n7) {
    if (n7 !== 2 && n7 !== 3) {
      return false;
    }
    if (typeof t22 === "undefined") {
      t22 = 0.5;
    } else if (t22 === 0 || t22 === 1) {
      return t22;
    }
    const bottom = pow3(t22, n7) + pow3(1 - t22, n7), top = bottom - 1;
    return abs2(top / bottom);
  },
  projectionratio: function(t22, n7) {
    if (n7 !== 2 && n7 !== 3) {
      return false;
    }
    if (typeof t22 === "undefined") {
      t22 = 0.5;
    } else if (t22 === 0 || t22 === 1) {
      return t22;
    }
    const top = pow3(1 - t22, n7), bottom = pow3(t22, n7) + top;
    return top / bottom;
  },
  lli8: function(x1, y1, x22, y22, x3, y3, x4, y4) {
    const nx = (x1 * y22 - y1 * x22) * (x3 - x4) - (x1 - x22) * (x3 * y4 - y3 * x4), ny = (x1 * y22 - y1 * x22) * (y3 - y4) - (y1 - y22) * (x3 * y4 - y3 * x4), d4 = (x1 - x22) * (y3 - y4) - (y1 - y22) * (x3 - x4);
    if (d4 == 0) {
      return false;
    }
    return { x: nx / d4, y: ny / d4 };
  },
  lli4: function(p1, p22, p32, p4) {
    const x1 = p1.x, y1 = p1.y, x22 = p22.x, y22 = p22.y, x3 = p32.x, y3 = p32.y, x4 = p4.x, y4 = p4.y;
    return utils.lli8(x1, y1, x22, y22, x3, y3, x4, y4);
  },
  lli: function(v1, v22) {
    return utils.lli4(v1, v1.c, v22, v22.c);
  },
  makeline: function(p1, p22) {
    return new Bezier(
      p1.x,
      p1.y,
      (p1.x + p22.x) / 2,
      (p1.y + p22.y) / 2,
      p22.x,
      p22.y
    );
  },
  findbbox: function(sections) {
    let mx = nMax, my = nMax, MX = nMin, MY = nMin;
    sections.forEach(function(s3) {
      const bbox7 = s3.bbox();
      if (mx > bbox7.x.min) mx = bbox7.x.min;
      if (my > bbox7.y.min) my = bbox7.y.min;
      if (MX < bbox7.x.max) MX = bbox7.x.max;
      if (MY < bbox7.y.max) MY = bbox7.y.max;
    });
    return {
      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },
      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my }
    };
  },
  shapeintersections: function(s1, bbox1, s22, bbox22, curveIntersectionThreshold) {
    if (!utils.bboxoverlap(bbox1, bbox22)) return [];
    const intersections2 = [];
    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];
    const a22 = [s22.startcap, s22.forward, s22.back, s22.endcap];
    a1.forEach(function(l1) {
      if (l1.virtual) return;
      a22.forEach(function(l22) {
        if (l22.virtual) return;
        const iss = l1.intersects(l22, curveIntersectionThreshold);
        if (iss.length > 0) {
          iss.c1 = l1;
          iss.c2 = l22;
          iss.s1 = s1;
          iss.s2 = s22;
          intersections2.push(iss);
        }
      });
    });
    return intersections2;
  },
  makeshape: function(forward, back, curveIntersectionThreshold) {
    const bpl = back.points.length;
    const fpl = forward.points.length;
    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);
    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);
    const shape = {
      startcap: start,
      forward,
      back,
      endcap: end,
      bbox: utils.findbbox([start, forward, back, end])
    };
    shape.intersections = function(s22) {
      return utils.shapeintersections(
        shape,
        shape.bbox,
        s22,
        s22.bbox,
        curveIntersectionThreshold
      );
    };
    return shape;
  },
  getminmax: function(curve, d4, list) {
    if (!list) return { min: 0, max: 0 };
    let min23 = nMax, max23 = nMin, t22, c6;
    if (list.indexOf(0) === -1) {
      list = [0].concat(list);
    }
    if (list.indexOf(1) === -1) {
      list.push(1);
    }
    for (let i4 = 0, len = list.length; i4 < len; i4++) {
      t22 = list[i4];
      c6 = curve.get(t22);
      if (c6[d4] < min23) {
        min23 = c6[d4];
      }
      if (c6[d4] > max23) {
        max23 = c6[d4];
      }
    }
    return { min: min23, mid: (min23 + max23) / 2, max: max23, size: max23 - min23 };
  },
  align: function(points, line3) {
    const tx = line3.p1.x, ty = line3.p1.y, a4 = -atan2(line3.p2.y - ty, line3.p2.x - tx), d4 = function(v3) {
      return {
        x: (v3.x - tx) * cos2(a4) - (v3.y - ty) * sin2(a4),
        y: (v3.x - tx) * sin2(a4) + (v3.y - ty) * cos2(a4)
      };
    };
    return points.map(d4);
  },
  roots: function(points, line3) {
    line3 = line3 || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const order = points.length - 1;
    const aligned = utils.align(points, line3);
    const reduce22 = function(t22) {
      return 0 <= t22 && t22 <= 1;
    };
    if (order === 2) {
      const a22 = aligned[0].y, b22 = aligned[1].y, c23 = aligned[2].y, d22 = a22 - 2 * b22 + c23;
      if (d22 !== 0) {
        const m12 = -sqrt2(b22 * b22 - a22 * c23), m23 = -a22 + b22, v12 = -(m12 + m23) / d22, v22 = -(-m12 + m23) / d22;
        return [v12, v22].filter(reduce22);
      } else if (b22 !== c23 && d22 === 0) {
        return [(2 * b22 - c23) / (2 * b22 - 2 * c23)].filter(reduce22);
      }
      return [];
    }
    const pa2 = aligned[0].y, pb = aligned[1].y, pc = aligned[2].y, pd = aligned[3].y;
    let d4 = -pa2 + 3 * pb - 3 * pc + pd, a4 = 3 * pa2 - 6 * pb + 3 * pc, b4 = -3 * pa2 + 3 * pb, c6 = pa2;
    if (utils.approximately(d4, 0)) {
      if (utils.approximately(a4, 0)) {
        if (utils.approximately(b4, 0)) {
          return [];
        }
        return [-c6 / b4].filter(reduce22);
      }
      const q32 = sqrt2(b4 * b4 - 4 * a4 * c6), a22 = 2 * a4;
      return [(q32 - b4) / a22, (-b4 - q32) / a22].filter(reduce22);
    }
    a4 /= d4;
    b4 /= d4;
    c6 /= d4;
    const p4 = (3 * b4 - a4 * a4) / 3, p32 = p4 / 3, q3 = (2 * a4 * a4 * a4 - 9 * a4 * b4 + 27 * c6) / 27, q22 = q3 / 2, discriminant = q22 * q22 + p32 * p32 * p32;
    let u1, v1, x1, x22, x3;
    if (discriminant < 0) {
      const mp3 = -p4 / 3, mp33 = mp3 * mp3 * mp3, r5 = sqrt2(mp33), t22 = -q3 / (2 * r5), cosphi = t22 < -1 ? -1 : t22 > 1 ? 1 : t22, phi2 = acos(cosphi), crtr = crt(r5), t1 = 2 * crtr;
      x1 = t1 * cos2(phi2 / 3) - a4 / 3;
      x22 = t1 * cos2((phi2 + tau2) / 3) - a4 / 3;
      x3 = t1 * cos2((phi2 + 2 * tau2) / 3) - a4 / 3;
      return [x1, x22, x3].filter(reduce22);
    } else if (discriminant === 0) {
      u1 = q22 < 0 ? crt(-q22) : -crt(q22);
      x1 = 2 * u1 - a4 / 3;
      x22 = -u1 - a4 / 3;
      return [x1, x22].filter(reduce22);
    } else {
      const sd = sqrt2(discriminant);
      u1 = crt(-q22 + sd);
      v1 = crt(q22 + sd);
      return [u1 - v1 - a4 / 3].filter(reduce22);
    }
  },
  droots: function(p4) {
    if (p4.length === 3) {
      const a4 = p4[0], b4 = p4[1], c6 = p4[2], d4 = a4 - 2 * b4 + c6;
      if (d4 !== 0) {
        const m12 = -sqrt2(b4 * b4 - a4 * c6), m23 = -a4 + b4, v1 = -(m12 + m23) / d4, v22 = -(-m12 + m23) / d4;
        return [v1, v22];
      } else if (b4 !== c6 && d4 === 0) {
        return [(2 * b4 - c6) / (2 * (b4 - c6))];
      }
      return [];
    }
    if (p4.length === 2) {
      const a4 = p4[0], b4 = p4[1];
      if (a4 !== b4) {
        return [a4 / (a4 - b4)];
      }
      return [];
    }
    return [];
  },
  curvature: function(t22, d1, d22, _3d, kOnly) {
    let num, dnm, adk, dk, k3 = 0, r5 = 0;
    const d4 = utils.compute(t22, d1);
    const dd = utils.compute(t22, d22);
    const qdsum = d4.x * d4.x + d4.y * d4.y;
    if (_3d) {
      num = sqrt2(
        pow3(d4.y * dd.z - dd.y * d4.z, 2) + pow3(d4.z * dd.x - dd.z * d4.x, 2) + pow3(d4.x * dd.y - dd.x * d4.y, 2)
      );
      dnm = pow3(qdsum + d4.z * d4.z, 3 / 2);
    } else {
      num = d4.x * dd.y - d4.y * dd.x;
      dnm = pow3(qdsum, 3 / 2);
    }
    if (num === 0 || dnm === 0) {
      return { k: 0, r: 0 };
    }
    k3 = num / dnm;
    r5 = dnm / num;
    if (!kOnly) {
      const pk = utils.curvature(t22 - 1e-3, d1, d22, _3d, true).k;
      const nk = utils.curvature(t22 + 1e-3, d1, d22, _3d, true).k;
      dk = (nk - k3 + (k3 - pk)) / 2;
      adk = (abs2(nk - k3) + abs2(k3 - pk)) / 2;
    }
    return { k: k3, r: r5, dk, adk };
  },
  inflections: function(points) {
    if (points.length < 4) return [];
    const p4 = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }), a4 = p4[2].x * p4[1].y, b4 = p4[3].x * p4[1].y, c6 = p4[1].x * p4[2].y, d4 = p4[3].x * p4[2].y, v1 = 18 * (-3 * a4 + 2 * b4 + 3 * c6 - d4), v22 = 18 * (3 * a4 - b4 - 3 * c6), v3 = 18 * (c6 - a4);
    if (utils.approximately(v1, 0)) {
      if (!utils.approximately(v22, 0)) {
        let t22 = -v3 / v22;
        if (0 <= t22 && t22 <= 1) return [t22];
      }
      return [];
    }
    const d22 = 2 * v1;
    if (utils.approximately(d22, 0)) return [];
    const trm = v22 * v22 - 4 * v1 * v3;
    if (trm < 0) return [];
    const sq = Math.sqrt(trm);
    return [(sq - v22) / d22, -(v22 + sq) / d22].filter(function(r5) {
      return 0 <= r5 && r5 <= 1;
    });
  },
  bboxoverlap: function(b1, b22) {
    const dims = ["x", "y"], len = dims.length;
    for (let i4 = 0, dim, l3, t22, d4; i4 < len; i4++) {
      dim = dims[i4];
      l3 = b1[dim].mid;
      t22 = b22[dim].mid;
      d4 = (b1[dim].size + b22[dim].size) / 2;
      if (abs2(l3 - t22) >= d4) return false;
    }
    return true;
  },
  expandbox: function(bbox7, _bbox) {
    if (_bbox.x.min < bbox7.x.min) {
      bbox7.x.min = _bbox.x.min;
    }
    if (_bbox.y.min < bbox7.y.min) {
      bbox7.y.min = _bbox.y.min;
    }
    if (_bbox.z && _bbox.z.min < bbox7.z.min) {
      bbox7.z.min = _bbox.z.min;
    }
    if (_bbox.x.max > bbox7.x.max) {
      bbox7.x.max = _bbox.x.max;
    }
    if (_bbox.y.max > bbox7.y.max) {
      bbox7.y.max = _bbox.y.max;
    }
    if (_bbox.z && _bbox.z.max > bbox7.z.max) {
      bbox7.z.max = _bbox.z.max;
    }
    bbox7.x.mid = (bbox7.x.min + bbox7.x.max) / 2;
    bbox7.y.mid = (bbox7.y.min + bbox7.y.max) / 2;
    if (bbox7.z) {
      bbox7.z.mid = (bbox7.z.min + bbox7.z.max) / 2;
    }
    bbox7.x.size = bbox7.x.max - bbox7.x.min;
    bbox7.y.size = bbox7.y.max - bbox7.y.min;
    if (bbox7.z) {
      bbox7.z.size = bbox7.z.max - bbox7.z.min;
    }
  },
  pairiteration: function(c12, c23, curveIntersectionThreshold) {
    const c1b = c12.bbox(), c2b = c23.bbox(), r5 = 1e5, threshold = curveIntersectionThreshold || 0.5;
    if (c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold) {
      return [
        (r5 * (c12._t1 + c12._t2) / 2 | 0) / r5 + "/" + (r5 * (c23._t1 + c23._t2) / 2 | 0) / r5
      ];
    }
    let cc1 = c12.split(0.5), cc2 = c23.split(0.5), pairs = [
      { left: cc1.left, right: cc2.left },
      { left: cc1.left, right: cc2.right },
      { left: cc1.right, right: cc2.right },
      { left: cc1.right, right: cc2.left }
    ];
    pairs = pairs.filter(function(pair) {
      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());
    });
    let results = [];
    if (pairs.length === 0) return results;
    pairs.forEach(function(pair) {
      results = results.concat(
        utils.pairiteration(pair.left, pair.right, threshold)
      );
    });
    results = results.filter(function(v3, i4) {
      return results.indexOf(v3) === i4;
    });
    return results;
  },
  getccenter: function(p1, p22, p32) {
    const dx1 = p22.x - p1.x, dy1 = p22.y - p1.y, dx2 = p32.x - p22.x, dy2 = p32.y - p22.y, dx1p = dx1 * cos2(quart) - dy1 * sin2(quart), dy1p = dx1 * sin2(quart) + dy1 * cos2(quart), dx2p = dx2 * cos2(quart) - dy2 * sin2(quart), dy2p = dx2 * sin2(quart) + dy2 * cos2(quart), mx1 = (p1.x + p22.x) / 2, my1 = (p1.y + p22.y) / 2, mx2 = (p22.x + p32.x) / 2, my2 = (p22.y + p32.y) / 2, mx1n = mx1 + dx1p, my1n = my1 + dy1p, mx2n = mx2 + dx2p, my2n = my2 + dy2p, arc2 = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n), r5 = utils.dist(arc2, p1);
    let s3 = atan2(p1.y - arc2.y, p1.x - arc2.x), m5 = atan2(p22.y - arc2.y, p22.x - arc2.x), e5 = atan2(p32.y - arc2.y, p32.x - arc2.x), _3;
    if (s3 < e5) {
      if (s3 > m5 || m5 > e5) {
        s3 += tau2;
      }
      if (s3 > e5) {
        _3 = e5;
        e5 = s3;
        s3 = _3;
      }
    } else {
      if (e5 < m5 && m5 < s3) {
        _3 = e5;
        e5 = s3;
        s3 = _3;
      } else {
        e5 += tau2;
      }
    }
    arc2.s = s3;
    arc2.e = e5;
    arc2.r = r5;
    return arc2;
  },
  numberSort: function(a4, b4) {
    return a4 - b4;
  }
};
var PolyBezier = class _PolyBezier {
  constructor(curves) {
    this.curves = [];
    this._3d = false;
    if (!!curves) {
      this.curves = curves;
      this._3d = this.curves[0]._3d;
    }
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(curve) {
      return utils.pointsToString(curve.points);
    }).join(", ") + "]";
  }
  addCurve(curve) {
    this.curves.push(curve);
    this._3d = this._3d || curve._3d;
  }
  length() {
    return this.curves.map(function(v3) {
      return v3.length();
    }).reduce(function(a4, b4) {
      return a4 + b4;
    });
  }
  curve(idx) {
    return this.curves[idx];
  }
  bbox() {
    const c6 = this.curves;
    var bbox7 = c6[0].bbox();
    for (var i4 = 1; i4 < c6.length; i4++) {
      utils.expandbox(bbox7, c6[i4].bbox());
    }
    return bbox7;
  }
  offset(d4) {
    const offset2 = [];
    this.curves.forEach(function(v3) {
      offset2.push(...v3.offset(d4));
    });
    return new _PolyBezier(offset2);
  }
};
var { abs: abs3, min: min5, max: max4, cos: cos22, sin: sin22, acos: acos2, sqrt: sqrt22 } = Math;
var pi22 = Math.PI;
var Bezier = class _Bezier {
  constructor(coords) {
    let args = coords && coords.forEach ? coords : Array.from(arguments).slice();
    let coordlen = false;
    if (typeof args[0] === "object") {
      coordlen = args.length;
      const newargs = [];
      args.forEach(function(point3) {
        ["x", "y", "z"].forEach(function(d4) {
          if (typeof point3[d4] !== "undefined") {
            newargs.push(point3[d4]);
          }
        });
      });
      args = newargs;
    }
    let higher = false;
    const len = args.length;
    if (coordlen) {
      if (coordlen > 4) {
        if (arguments.length !== 1) {
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        }
        higher = true;
      }
    } else {
      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {
        if (arguments.length !== 1) {
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        }
      }
    }
    const _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z !== "undefined";
    const points = this.points = [];
    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {
      var point2 = {
        x: args[idx],
        y: args[idx + 1]
      };
      if (_3d) {
        point2.z = args[idx + 2];
      }
      points.push(point2);
    }
    const order = this.order = points.length - 1;
    const dims = this.dims = ["x", "y"];
    if (_3d) dims.push("z");
    this.dimlen = dims.length;
    const aligned = utils.align(points, { p1: points[0], p2: points[order] });
    const baselength = utils.dist(points[0], points[order]);
    this._linear = aligned.reduce((t22, p4) => t22 + abs3(p4.y), 0) < baselength / 50;
    this._lut = [];
    this._t1 = 0;
    this._t2 = 1;
    this.update();
  }
  static quadraticFromPoints(p1, p22, p32, t22) {
    if (typeof t22 === "undefined") {
      t22 = 0.5;
    }
    if (t22 === 0) {
      return new _Bezier(p22, p22, p32);
    }
    if (t22 === 1) {
      return new _Bezier(p1, p22, p22);
    }
    const abc = _Bezier.getABC(2, p1, p22, p32, t22);
    return new _Bezier(p1, abc.A, p32);
  }
  static cubicFromPoints(S4, B3, E3, t22, d1) {
    if (typeof t22 === "undefined") {
      t22 = 0.5;
    }
    const abc = _Bezier.getABC(3, S4, B3, E3, t22);
    if (typeof d1 === "undefined") {
      d1 = utils.dist(B3, abc.C);
    }
    const d22 = d1 * (1 - t22) / t22;
    const selen = utils.dist(S4, E3), lx = (E3.x - S4.x) / selen, ly = (E3.y - S4.y) / selen, bx1 = d1 * lx, by1 = d1 * ly, bx2 = d22 * lx, by2 = d22 * ly;
    const e1 = { x: B3.x - bx1, y: B3.y - by1 }, e22 = { x: B3.x + bx2, y: B3.y + by2 }, A2 = abc.A, v1 = { x: A2.x + (e1.x - A2.x) / (1 - t22), y: A2.y + (e1.y - A2.y) / (1 - t22) }, v22 = { x: A2.x + (e22.x - A2.x) / t22, y: A2.y + (e22.y - A2.y) / t22 }, nc1 = { x: S4.x + (v1.x - S4.x) / t22, y: S4.y + (v1.y - S4.y) / t22 }, nc2 = {
      x: E3.x + (v22.x - E3.x) / (1 - t22),
      y: E3.y + (v22.y - E3.y) / (1 - t22)
    };
    return new _Bezier(S4, nc1, nc2, E3);
  }
  static getUtils() {
    return utils;
  }
  getUtils() {
    return _Bezier.getUtils();
  }
  static get PolyBezier() {
    return PolyBezier;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return utils.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return false;
    const p4 = this.points, x3 = p4[0].x, y3 = p4[0].y, s3 = ["M", x3, y3, this.order === 2 ? "Q" : "C"];
    for (let i4 = 1, last3 = p4.length; i4 < last3; i4++) {
      s3.push(p4[i4].x);
      s3.push(p4[i4].y);
    }
    return s3.join(" ");
  }
  setRatios(ratios) {
    if (ratios.length !== this.points.length) {
      throw new Error("incorrect number of ratio values");
    }
    this.ratios = ratios;
    this._lut = [];
  }
  verify() {
    const print = this.coordDigest();
    if (print !== this._print) {
      this._print = print;
      this.update();
    }
  }
  coordDigest() {
    return this.points.map(function(c6, pos) {
      return "" + pos + c6.x + c6.y + (c6.z ? c6.z : 0);
    }).join("");
  }
  update() {
    this._lut = [];
    this.dpoints = utils.derive(this.points, this._3d);
    this.computedirection();
  }
  computedirection() {
    const points = this.points;
    const angle = utils.angle(points[0], points[this.order], points[1]);
    this.clockwise = angle > 0;
  }
  length() {
    return utils.length(this.derivative.bind(this));
  }
  static getABC(order = 2, S4, B3, E3, t22 = 0.5) {
    const u3 = utils.projectionratio(t22, order), um = 1 - u3, C2 = {
      x: u3 * S4.x + um * E3.x,
      y: u3 * S4.y + um * E3.y
    }, s3 = utils.abcratio(t22, order), A2 = {
      x: B3.x + (B3.x - C2.x) / s3,
      y: B3.y + (B3.y - C2.y) / s3
    };
    return { A: A2, B: B3, C: C2, S: S4, E: E3 };
  }
  getABC(t22, B3) {
    B3 = B3 || this.get(t22);
    let S4 = this.points[0];
    let E3 = this.points[this.order];
    return _Bezier.getABC(this.order, S4, B3, E3, t22);
  }
  getLUT(steps2) {
    this.verify();
    steps2 = steps2 || 100;
    if (this._lut.length === steps2 + 1) {
      return this._lut;
    }
    this._lut = [];
    steps2++;
    this._lut = [];
    for (let i4 = 0, p4, t22; i4 < steps2; i4++) {
      t22 = i4 / (steps2 - 1);
      p4 = this.compute(t22);
      p4.t = t22;
      this._lut.push(p4);
    }
    return this._lut;
  }
  on(point2, error) {
    error = error || 5;
    const lut = this.getLUT(), hits = [];
    for (let i4 = 0, c6, t22 = 0; i4 < lut.length; i4++) {
      c6 = lut[i4];
      if (utils.dist(c6, point2) < error) {
        hits.push(c6);
        t22 += i4 / lut.length;
      }
    }
    if (!hits.length) return false;
    return t /= hits.length;
  }
  project(point2) {
    const LUT = this.getLUT(), l3 = LUT.length - 1, closest = utils.closest(LUT, point2), mpos = closest.mpos, t1 = (mpos - 1) / l3, t22 = (mpos + 1) / l3, step = 0.1 / l3;
    let mdist = closest.mdist, t32 = t1, ft2 = t32, p4;
    mdist += 1;
    for (let d4; t32 < t22 + step; t32 += step) {
      p4 = this.compute(t32);
      d4 = utils.dist(point2, p4);
      if (d4 < mdist) {
        mdist = d4;
        ft2 = t32;
      }
    }
    ft2 = ft2 < 0 ? 0 : ft2 > 1 ? 1 : ft2;
    p4 = this.compute(ft2);
    p4.t = ft2;
    p4.d = mdist;
    return p4;
  }
  get(t22) {
    return this.compute(t22);
  }
  point(idx) {
    return this.points[idx];
  }
  compute(t22) {
    if (this.ratios) {
      return utils.computeWithRatios(t22, this.points, this.ratios, this._3d);
    }
    return utils.compute(t22, this.points, this._3d, this.ratios);
  }
  raise() {
    const p4 = this.points, np = [p4[0]], k3 = p4.length;
    for (let i4 = 1, pi5, pim; i4 < k3; i4++) {
      pi5 = p4[i4];
      pim = p4[i4 - 1];
      np[i4] = {
        x: (k3 - i4) / k3 * pi5.x + i4 / k3 * pim.x,
        y: (k3 - i4) / k3 * pi5.y + i4 / k3 * pim.y
      };
    }
    np[k3] = p4[k3 - 1];
    return new _Bezier(np);
  }
  derivative(t22) {
    return utils.compute(t22, this.dpoints[0], this._3d);
  }
  dderivative(t22) {
    return utils.compute(t22, this.dpoints[1], this._3d);
  }
  align() {
    let p4 = this.points;
    return new _Bezier(utils.align(p4, { p1: p4[0], p2: p4[p4.length - 1] }));
  }
  curvature(t22) {
    return utils.curvature(t22, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return utils.inflections(this.points);
  }
  normal(t22) {
    return this._3d ? this.__normal3(t22) : this.__normal2(t22);
  }
  __normal2(t22) {
    const d4 = this.derivative(t22);
    const q3 = sqrt22(d4.x * d4.x + d4.y * d4.y);
    return { t: t22, x: -d4.y / q3, y: d4.x / q3 };
  }
  __normal3(t22) {
    const r1 = this.derivative(t22), r22 = this.derivative(t22 + 0.01), q1 = sqrt22(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z), q22 = sqrt22(r22.x * r22.x + r22.y * r22.y + r22.z * r22.z);
    r1.x /= q1;
    r1.y /= q1;
    r1.z /= q1;
    r22.x /= q22;
    r22.y /= q22;
    r22.z /= q22;
    const c6 = {
      x: r22.y * r1.z - r22.z * r1.y,
      y: r22.z * r1.x - r22.x * r1.z,
      z: r22.x * r1.y - r22.y * r1.x
    };
    const m5 = sqrt22(c6.x * c6.x + c6.y * c6.y + c6.z * c6.z);
    c6.x /= m5;
    c6.y /= m5;
    c6.z /= m5;
    const R3 = [
      c6.x * c6.x,
      c6.x * c6.y - c6.z,
      c6.x * c6.z + c6.y,
      c6.x * c6.y + c6.z,
      c6.y * c6.y,
      c6.y * c6.z - c6.x,
      c6.x * c6.z - c6.y,
      c6.y * c6.z + c6.x,
      c6.z * c6.z
    ];
    const n7 = {
      t: t22,
      x: R3[0] * r1.x + R3[1] * r1.y + R3[2] * r1.z,
      y: R3[3] * r1.x + R3[4] * r1.y + R3[5] * r1.z,
      z: R3[6] * r1.x + R3[7] * r1.y + R3[8] * r1.z
    };
    return n7;
  }
  hull(t22) {
    let p4 = this.points, _p = [], q3 = [], idx = 0;
    q3[idx++] = p4[0];
    q3[idx++] = p4[1];
    q3[idx++] = p4[2];
    if (this.order === 3) {
      q3[idx++] = p4[3];
    }
    while (p4.length > 1) {
      _p = [];
      for (let i4 = 0, pt2, l3 = p4.length - 1; i4 < l3; i4++) {
        pt2 = utils.lerp(t22, p4[i4], p4[i4 + 1]);
        q3[idx++] = pt2;
        _p.push(pt2);
      }
      p4 = _p;
    }
    return q3;
  }
  split(t1, t22) {
    if (t1 === 0 && !!t22) {
      return this.split(t22).left;
    }
    if (t22 === 1) {
      return this.split(t1).right;
    }
    const q3 = this.hull(t1);
    const result = {
      left: this.order === 2 ? new _Bezier([q3[0], q3[3], q3[5]]) : new _Bezier([q3[0], q3[4], q3[7], q3[9]]),
      right: this.order === 2 ? new _Bezier([q3[5], q3[4], q3[2]]) : new _Bezier([q3[9], q3[8], q3[6], q3[3]]),
      span: q3
    };
    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);
    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);
    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);
    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);
    if (!t22) {
      return result;
    }
    t22 = utils.map(t22, t1, 1, 0, 1);
    return result.right.split(t22).left;
  }
  extrema() {
    const result = {};
    let roots = [];
    this.dims.forEach(
      function(dim) {
        let mfn = function(v3) {
          return v3[dim];
        };
        let p4 = this.dpoints[0].map(mfn);
        result[dim] = utils.droots(p4);
        if (this.order === 3) {
          p4 = this.dpoints[1].map(mfn);
          result[dim] = result[dim].concat(utils.droots(p4));
        }
        result[dim] = result[dim].filter(function(t22) {
          return t22 >= 0 && t22 <= 1;
        });
        roots = roots.concat(result[dim].sort(utils.numberSort));
      }.bind(this)
    );
    result.values = roots.sort(utils.numberSort).filter(function(v3, idx) {
      return roots.indexOf(v3) === idx;
    });
    return result;
  }
  bbox() {
    const extrema = this.extrema(), result = {};
    this.dims.forEach(
      function(d4) {
        result[d4] = utils.getminmax(this, d4, extrema[d4]);
      }.bind(this)
    );
    return result;
  }
  overlaps(curve) {
    const lbbox = this.bbox(), tbbox = curve.bbox();
    return utils.bboxoverlap(lbbox, tbbox);
  }
  offset(t22, d4) {
    if (typeof d4 !== "undefined") {
      const c6 = this.get(t22), n7 = this.normal(t22);
      const ret = {
        c: c6,
        n: n7,
        x: c6.x + n7.x * d4,
        y: c6.y + n7.y * d4
      };
      if (this._3d) {
        ret.z = c6.z + n7.z * d4;
      }
      return ret;
    }
    if (this._linear) {
      const nv = this.normal(0), coords = this.points.map(function(p4) {
        const ret = {
          x: p4.x + t22 * nv.x,
          y: p4.y + t22 * nv.y
        };
        if (p4.z && nv.z) {
          ret.z = p4.z + t22 * nv.z;
        }
        return ret;
      });
      return [new _Bezier(coords)];
    }
    return this.reduce().map(function(s3) {
      if (s3._linear) {
        return s3.offset(t22)[0];
      }
      return s3.scale(t22);
    });
  }
  simple() {
    if (this.order === 3) {
      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);
      const a22 = utils.angle(this.points[0], this.points[3], this.points[2]);
      if (a1 > 0 && a22 < 0 || a1 < 0 && a22 > 0) return false;
    }
    const n1 = this.normal(0);
    const n22 = this.normal(1);
    let s3 = n1.x * n22.x + n1.y * n22.y;
    if (this._3d) {
      s3 += n1.z * n22.z;
    }
    return abs3(acos2(s3)) < pi22 / 3;
  }
  reduce() {
    let i4, t1 = 0, t22 = 0, step = 0.01, segment, pass1 = [], pass2 = [];
    let extrema = this.extrema().values;
    if (extrema.indexOf(0) === -1) {
      extrema = [0].concat(extrema);
    }
    if (extrema.indexOf(1) === -1) {
      extrema.push(1);
    }
    for (t1 = extrema[0], i4 = 1; i4 < extrema.length; i4++) {
      t22 = extrema[i4];
      segment = this.split(t1, t22);
      segment._t1 = t1;
      segment._t2 = t22;
      pass1.push(segment);
      t1 = t22;
    }
    pass1.forEach(function(p1) {
      t1 = 0;
      t22 = 0;
      while (t22 <= 1) {
        for (t22 = t1 + step; t22 <= 1 + step; t22 += step) {
          segment = p1.split(t1, t22);
          if (!segment.simple()) {
            t22 -= step;
            if (abs3(t1 - t22) < step) {
              return [];
            }
            segment = p1.split(t1, t22);
            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);
            segment._t2 = utils.map(t22, 0, 1, p1._t1, p1._t2);
            pass2.push(segment);
            t1 = t22;
            break;
          }
        }
      }
      if (t1 < 1) {
        segment = p1.split(t1, 1);
        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);
        segment._t2 = p1._t2;
        pass2.push(segment);
      }
    });
    return pass2;
  }
  translate(v3, d1, d22) {
    d22 = typeof d22 === "number" ? d22 : d1;
    const o5 = this.order;
    let d4 = this.points.map((_3, i4) => (1 - i4 / o5) * d1 + i4 / o5 * d22);
    return new _Bezier(
      this.points.map((p4, i4) => ({
        x: p4.x + v3.x * d4[i4],
        y: p4.y + v3.y * d4[i4]
      }))
    );
  }
  scale(d4) {
    const order = this.order;
    let distanceFn = false;
    if (typeof d4 === "function") {
      distanceFn = d4;
    }
    if (distanceFn && order === 2) {
      return this.raise().scale(distanceFn);
    }
    const clockwise = this.clockwise;
    const points = this.points;
    if (this._linear) {
      return this.translate(
        this.normal(0),
        distanceFn ? distanceFn(0) : d4,
        distanceFn ? distanceFn(1) : d4
      );
    }
    const r1 = distanceFn ? distanceFn(0) : d4;
    const r22 = distanceFn ? distanceFn(1) : d4;
    const v3 = [this.offset(0, 10), this.offset(1, 10)];
    const np = [];
    const o5 = utils.lli4(v3[0], v3[0].c, v3[1], v3[1].c);
    if (!o5) {
      throw new Error("cannot scale this curve. Try reducing it first.");
    }
    [0, 1].forEach(function(t22) {
      const p4 = np[t22 * order] = utils.copy(points[t22 * order]);
      p4.x += (t22 ? r22 : r1) * v3[t22].n.x;
      p4.y += (t22 ? r22 : r1) * v3[t22].n.y;
    });
    if (!distanceFn) {
      [0, 1].forEach((t22) => {
        if (order === 2 && !!t22) return;
        const p4 = np[t22 * order];
        const d22 = this.derivative(t22);
        const p22 = { x: p4.x + d22.x, y: p4.y + d22.y };
        np[t22 + 1] = utils.lli4(p4, p22, o5, points[t22 + 1]);
      });
      return new _Bezier(np);
    }
    [0, 1].forEach(function(t22) {
      if (order === 2 && !!t22) return;
      var p4 = points[t22 + 1];
      var ov = {
        x: p4.x - o5.x,
        y: p4.y - o5.y
      };
      var rc2 = distanceFn ? distanceFn((t22 + 1) / order) : d4;
      if (distanceFn && !clockwise) rc2 = -rc2;
      var m5 = sqrt22(ov.x * ov.x + ov.y * ov.y);
      ov.x /= m5;
      ov.y /= m5;
      np[t22 + 1] = {
        x: p4.x + rc2 * ov.x,
        y: p4.y + rc2 * ov.y
      };
    });
    return new _Bezier(np);
  }
  outline(d1, d22, d32, d4) {
    d22 = d22 === void 0 ? d1 : d22;
    if (this._linear) {
      const n7 = this.normal(0);
      const start = this.points[0];
      const end = this.points[this.points.length - 1];
      let s3, mid, e5;
      if (d32 === void 0) {
        d32 = d1;
        d4 = d22;
      }
      s3 = { x: start.x + n7.x * d1, y: start.y + n7.y * d1 };
      e5 = { x: end.x + n7.x * d32, y: end.y + n7.y * d32 };
      mid = { x: (s3.x + e5.x) / 2, y: (s3.y + e5.y) / 2 };
      const fline = [s3, mid, e5];
      s3 = { x: start.x - n7.x * d22, y: start.y - n7.y * d22 };
      e5 = { x: end.x - n7.x * d4, y: end.y - n7.y * d4 };
      mid = { x: (s3.x + e5.x) / 2, y: (s3.y + e5.y) / 2 };
      const bline = [e5, mid, s3];
      const ls22 = utils.makeline(bline[2], fline[0]);
      const le22 = utils.makeline(fline[2], bline[0]);
      const segments2 = [ls22, new _Bezier(fline), le22, new _Bezier(bline)];
      return new PolyBezier(segments2);
    }
    const reduced = this.reduce(), len = reduced.length, fcurves = [];
    let bcurves = [], p4, alen = 0, tlen = this.length();
    const graduated = typeof d32 !== "undefined" && typeof d4 !== "undefined";
    function linearDistanceFunction(s3, e5, tlen2, alen2, slen) {
      return function(v3) {
        const f1 = alen2 / tlen2, f22 = (alen2 + slen) / tlen2, d5 = e5 - s3;
        return utils.map(v3, 0, 1, s3 + f1 * d5, s3 + f22 * d5);
      };
    }
    reduced.forEach(function(segment) {
      const slen = segment.length();
      if (graduated) {
        fcurves.push(
          segment.scale(linearDistanceFunction(d1, d32, tlen, alen, slen))
        );
        bcurves.push(
          segment.scale(linearDistanceFunction(-d22, -d4, tlen, alen, slen))
        );
      } else {
        fcurves.push(segment.scale(d1));
        bcurves.push(segment.scale(-d22));
      }
      alen += slen;
    });
    bcurves = bcurves.map(function(s3) {
      p4 = s3.points;
      if (p4[3]) {
        s3.points = [p4[3], p4[2], p4[1], p4[0]];
      } else {
        s3.points = [p4[2], p4[1], p4[0]];
      }
      return s3;
    }).reverse();
    const fs2 = fcurves[0].points[0], fe2 = fcurves[len - 1].points[fcurves[len - 1].points.length - 1], bs2 = bcurves[len - 1].points[bcurves[len - 1].points.length - 1], be2 = bcurves[0].points[0], ls2 = utils.makeline(bs2, fs2), le2 = utils.makeline(fe2, be2), segments = [ls2].concat(fcurves).concat([le2]).concat(bcurves);
    return new PolyBezier(segments);
  }
  outlineshapes(d1, d22, curveIntersectionThreshold) {
    d22 = d22 || d1;
    const outline = this.outline(d1, d22).curves;
    const shapes = [];
    for (let i4 = 1, len = outline.length; i4 < len / 2; i4++) {
      const shape = utils.makeshape(
        outline[i4],
        outline[len - i4],
        curveIntersectionThreshold
      );
      shape.startcap.virtual = i4 > 1;
      shape.endcap.virtual = i4 < len / 2 - 1;
      shapes.push(shape);
    }
    return shapes;
  }
  intersects(curve, curveIntersectionThreshold) {
    if (!curve) return this.selfintersects(curveIntersectionThreshold);
    if (curve.p1 && curve.p2) {
      return this.lineIntersects(curve);
    }
    if (curve instanceof _Bezier) {
      curve = curve.reduce();
    }
    return this.curveintersects(
      this.reduce(),
      curve,
      curveIntersectionThreshold
    );
  }
  lineIntersects(line3) {
    const mx = min5(line3.p1.x, line3.p2.x), my = min5(line3.p1.y, line3.p2.y), MX = max4(line3.p1.x, line3.p2.x), MY = max4(line3.p1.y, line3.p2.y);
    return utils.roots(this.points, line3).filter((t22) => {
      var p4 = this.get(t22);
      return utils.between(p4.x, mx, MX) && utils.between(p4.y, my, MY);
    });
  }
  selfintersects(curveIntersectionThreshold) {
    const reduced = this.reduce(), len = reduced.length - 2, results = [];
    for (let i4 = 0, result, left, right; i4 < len; i4++) {
      left = reduced.slice(i4, i4 + 1);
      right = reduced.slice(i4 + 2);
      result = this.curveintersects(left, right, curveIntersectionThreshold);
      results.push(...result);
    }
    return results;
  }
  curveintersects(c12, c23, curveIntersectionThreshold) {
    const pairs = [];
    c12.forEach(function(l3) {
      c23.forEach(function(r5) {
        if (l3.overlaps(r5)) {
          pairs.push({ left: l3, right: r5 });
        }
      });
    });
    let intersections2 = [];
    pairs.forEach(function(pair) {
      const result = utils.pairiteration(
        pair.left,
        pair.right,
        curveIntersectionThreshold
      );
      if (result.length > 0) {
        intersections2 = intersections2.concat(result);
      }
    });
    return intersections2;
  }
  arcs(errorThreshold) {
    errorThreshold = errorThreshold || 0.5;
    return this._iterate(errorThreshold, []);
  }
  _error(pc, np1, s3, e5) {
    const q3 = (e5 - s3) / 4, c12 = this.get(s3 + q3), c23 = this.get(e5 - q3), ref = utils.dist(pc, np1), d1 = utils.dist(pc, c12), d22 = utils.dist(pc, c23);
    return abs3(d1 - ref) + abs3(d22 - ref);
  }
  _iterate(errorThreshold, circles) {
    let t_s = 0, t_e = 1, safety;
    do {
      safety = 0;
      t_e = 1;
      let np1 = this.get(t_s), np2, np3, arc2, prev_arc;
      let curr_good = false, prev_good = false, done;
      let t_m = t_e, prev_e = 1, step = 0;
      do {
        prev_good = curr_good;
        prev_arc = arc2;
        t_m = (t_s + t_e) / 2;
        step++;
        np2 = this.get(t_m);
        np3 = this.get(t_e);
        arc2 = utils.getccenter(np1, np2, np3);
        arc2.interval = {
          start: t_s,
          end: t_e
        };
        let error = this._error(arc2, np1, t_s, t_e);
        curr_good = error <= errorThreshold;
        done = prev_good && !curr_good;
        if (!done) prev_e = t_e;
        if (curr_good) {
          if (t_e >= 1) {
            arc2.interval.end = prev_e = 1;
            prev_arc = arc2;
            if (t_e > 1) {
              let d4 = {
                x: arc2.x + arc2.r * cos22(arc2.e),
                y: arc2.y + arc2.r * sin22(arc2.e)
              };
              arc2.e += utils.angle({ x: arc2.x, y: arc2.y }, d4, this.get(1));
            }
            break;
          }
          t_e = t_e + (t_e - t_s) / 2;
        } else {
          t_e = t_m;
        }
      } while (!done && safety++ < 100);
      if (safety >= 100) {
        break;
      }
      prev_arc = prev_arc ? prev_arc : arc2;
      circles.push(prev_arc);
      t_s = prev_e;
    } while (t_e < 1);
    return circles;
  }
};
var quadraticBend = (a4, b4, bend = 0) => quadraticSimple(a4, b4, bend);
var quadraticSimple = (start, end, bend = 0) => {
  if (Number.isNaN(bend)) throw new Error(`bend is NaN`);
  if (bend < -1 || bend > 1) throw new Error(`Expects bend range of -1 to 1`);
  const middle = interpolate3(0.5, start, end);
  let target = middle;
  if (end.y < start.y) {
    target = bend > 0 ? { x: Math.min(start.x, end.x), y: Math.min(start.y, end.y) } : { x: Math.max(start.x, end.x), y: Math.max(start.y, end.y) };
  } else {
    target = bend > 0 ? { x: Math.max(start.x, end.x), y: Math.min(start.y, end.y) } : { x: Math.min(start.x, end.x), y: Math.max(start.y, end.y) };
  }
  const handle = interpolate3(Math.abs(bend), middle, target);
  return quadratic(start, end, handle);
};
var computeQuadraticSimple = (start, end, bend, amt) => {
  const q3 = quadraticSimple(start, end, bend);
  const bzr = new Bezier(q3.a, q3.quadratic, q3.b);
  return bzr.compute(amt);
};
var quadraticToSvgString = (start, end, handle) => [`M ${start.x} ${start.y} Q ${handle.x} ${handle.y} ${end.x} ${end.y}`];
var toPath3 = (cubicOrQuadratic) => {
  if (isCubicBezier(cubicOrQuadratic)) {
    return cubicToPath(cubicOrQuadratic);
  } else if (isQuadraticBezier(cubicOrQuadratic)) {
    return quadratictoPath(cubicOrQuadratic);
  } else {
    throw new Error(`Unknown bezier type`);
  }
};
var cubic = (start, end, cubic1, cubic2) => ({
  a: Object.freeze(start),
  b: Object.freeze(end),
  cubic1: Object.freeze(cubic1),
  cubic2: Object.freeze(cubic2)
});
var cubicToPath = (cubic2) => {
  const { a: a4, cubic1, cubic2: cubic22, b: b4 } = cubic2;
  const bzr = new Bezier(a4, cubic1, cubic22, b4);
  return Object.freeze({
    ...cubic2,
    length: () => bzr.length(),
    interpolate: (t22) => bzr.compute(t22),
    nearest: (_3) => {
      throw new Error(`not implemented`);
    },
    bbox: () => {
      const { x: x3, y: y3 } = bzr.bbox();
      const xSize = x3.size;
      const ySize = y3.size;
      if (xSize === void 0) throw new Error(`x.size not present on calculated bbox`);
      if (ySize === void 0) throw new Error(`x.size not present on calculated bbox`);
      return fromTopLeft({ x: x3.min, y: y3.min }, xSize, ySize);
    },
    relativePosition: (_point, _intersectionThreshold) => {
      throw new Error(`Not implemented`);
    },
    distanceToPoint: (_point) => {
      throw new Error(`Not implemented`);
    },
    toSvgString: () => [`brrup`],
    kind: `bezier/cubic`
  });
};
var quadratic = (start, end, handle) => ({
  a: Object.freeze(start),
  b: Object.freeze(end),
  quadratic: Object.freeze(handle)
});
var quadratictoPath = (quadraticBezier2) => {
  const { a: a4, b: b4, quadratic: quadratic2 } = quadraticBezier2;
  const bzr = new Bezier(a4, quadratic2, b4);
  return Object.freeze({
    ...quadraticBezier2,
    length: () => bzr.length(),
    interpolate: (t22) => bzr.compute(t22),
    nearest: (_3) => {
      throw new Error(`not implemented`);
    },
    bbox: () => {
      const { x: x3, y: y3 } = bzr.bbox();
      const xSize = x3.size;
      const ySize = y3.size;
      if (xSize === void 0) throw new Error(`x.size not present on calculated bbox`);
      if (ySize === void 0) throw new Error(`x.size not present on calculated bbox`);
      return fromTopLeft({ x: x3.min, y: y3.min }, xSize, ySize);
    },
    distanceToPoint: (_point) => {
      throw new Error(`Not implemented`);
    },
    relativePosition: (_point, _intersectionThreshold) => {
      throw new Error(`Not implemented`);
    },
    toString: () => bzr.toString(),
    toSvgString: () => quadraticToSvgString(a4, b4, quadratic2),
    kind: `bezier/quadratic`
  });
};
var CompoundPath_exports = {};
__export(CompoundPath_exports, {
  bbox: () => bbox4,
  computeDimensions: () => computeDimensions,
  distanceToPoint: () => distanceToPoint,
  fromPaths: () => fromPaths,
  guardContinuous: () => guardContinuous,
  interpolate: () => interpolate4,
  relativePosition: () => relativePosition2,
  setSegment: () => setSegment,
  toString: () => toString4,
  toSvgString: () => toSvgString2
});
var setSegment = (compoundPath, index, path2) => {
  const existing = [...compoundPath.segments];
  existing[index] = path2;
  return fromPaths(...existing);
};
var interpolate4 = (paths2, t22, useWidth, dimensions) => {
  if (dimensions === void 0) {
    dimensions = computeDimensions(paths2);
  }
  const expected = t22 * (useWidth ? dimensions.totalWidth : dimensions.totalLength);
  let soFar = 0;
  const l3 = useWidth ? dimensions.widths : dimensions.lengths;
  for (const [index, element] of l3.entries()) {
    if (soFar + element >= expected) {
      const relative2 = expected - soFar;
      let amt = relative2 / element;
      if (amt > 1) amt = 1;
      return paths2[index].interpolate(amt);
    } else soFar += element;
  }
  return { x: 0, y: 0 };
};
var distanceToPoint = (paths2, point2) => {
  if (paths2.length === 0) return 0;
  let distances = paths2.map((p4, index) => ({ path: p4, index, distance: p4.distanceToPoint(point2) }));
  distances = sortByNumericProperty(distances, `distance`);
  if (distances.length === 0) throw new Error(`Could not look up distances`);
  return distances[0].distance;
};
var relativePosition2 = (paths2, point2, intersectionThreshold, dimensions) => {
  if (dimensions === void 0) {
    dimensions = computeDimensions(paths2);
  }
  let distances = paths2.map((p4, index) => ({ path: p4, index, distance: p4.distanceToPoint(point2) }));
  distances = sortByNumericProperty(distances, `distance`);
  if (distances.length < 0) throw new Error(`Point does not intersect with path`);
  const d4 = distances[0];
  if (d4.distance > intersectionThreshold) throw new Error(`Point does not intersect with path. Minimum distance: ${d4.distance}, threshold: ${intersectionThreshold}`);
  const relativePositionOnPath = d4.path.relativePosition(point2, intersectionThreshold);
  let accumulated = 0;
  for (let index = 0; index < d4.index; index++) {
    accumulated += dimensions.lengths[index];
  }
  accumulated += dimensions.lengths[d4.index] * relativePositionOnPath;
  const accumulatedRel = accumulated / dimensions.totalLength;
  console.log(`acc: ${accumulated} rel: ${accumulatedRel} on path: ${relativePositionOnPath} path: ${d4.index}`);
  return accumulatedRel;
};
var computeDimensions = (paths2) => {
  const widths = paths2.map((l3) => l3.bbox().width);
  const lengths3 = paths2.map((l3) => l3.length());
  let totalLength = 0;
  let totalWidth = 0;
  for (const length5 of lengths3) {
    totalLength += length5;
  }
  for (const width of widths) {
    totalWidth += width;
  }
  return { totalLength, totalWidth, widths, lengths: lengths3 };
};
var bbox4 = (paths2) => {
  const boxes = paths2.map((p4) => p4.bbox());
  const corners3 = boxes.flatMap((b4) => corners(b4));
  return bbox(...corners3);
};
var toString4 = (paths2) => paths2.map((p4) => p4.toString()).join(`, `);
var guardContinuous = (paths2) => {
  let lastPos = getEnd(paths2[0]);
  for (let index = 1; index < paths2.length; index++) {
    const start = getStart(paths2[index]);
    if (!isEqual(start, lastPos)) throw new Error(`Path index ${index} does not start at prior path end. Start: ${start.x},${start.y} expected: ${lastPos.x},${lastPos.y}`);
    lastPos = getEnd(paths2[index]);
  }
};
var toSvgString2 = (paths2) => paths2.flatMap((p4) => p4.toSvgString());
var fromPaths = (...paths2) => {
  guardContinuous(paths2);
  const dims = computeDimensions(paths2);
  return Object.freeze({
    segments: paths2,
    length: () => dims.totalLength,
    nearest: (_3) => {
      throw new Error(`not implemented`);
    },
    interpolate: (t22, useWidth = false) => interpolate4(paths2, t22, useWidth, dims),
    relativePosition: (point2, intersectionThreshold) => relativePosition2(paths2, point2, intersectionThreshold, dims),
    distanceToPoint: (point2) => distanceToPoint(paths2, point2),
    bbox: () => bbox4(paths2),
    toString: () => toString4(paths2),
    toSvgString: () => toSvgString2(paths2),
    kind: `compound`
  });
};
var Ellipse_exports = {};
__export(Ellipse_exports, {
  fromDegrees: () => fromDegrees
});
var fromDegrees = (radiusX, radiusY, rotationDeg = 0, startAngleDeg = 0, endAngleDeg = 360) => ({
  radiusX,
  radiusY,
  rotation: degreeToRadian(rotationDeg),
  startAngle: degreeToRadian(startAngleDeg),
  endAngle: degreeToRadian(endAngleDeg)
});
var CurveSimplification_exports = {};
__export(CurveSimplification_exports, {
  rdpPerpendicularDistance: () => rdpPerpendicularDistance,
  rdpShortestDistance: () => rdpShortestDistance
});
var rdpShortestDistance = (points, epsilon2 = 0.1) => {
  const firstPoint = points[0];
  const lastPoint = points.at(-1);
  if (points.length < 3) {
    return points;
  }
  let index = -1;
  let distribution = 0;
  for (let index_ = 1; index_ < points.length - 1; index_++) {
    const cDistribution = distanceFromPointToLine(points[index_], firstPoint, lastPoint);
    if (cDistribution > distribution) {
      distribution = cDistribution;
      index = index_;
    }
  }
  if (distribution > epsilon2) {
    const l1 = points.slice(0, index + 1);
    const l22 = points.slice(index);
    const r1 = rdpShortestDistance(l1, epsilon2);
    const r22 = rdpShortestDistance(l22, epsilon2);
    const rs2 = [...r1.slice(0, -1), ...r22];
    return rs2;
  } else {
    return [firstPoint, lastPoint];
  }
};
var rdpPerpendicularDistance = (points, epsilon2 = 0.1) => {
  const firstPoint = points[0];
  const lastPoint = points.at(-1);
  if (points.length < 3) {
    return points;
  }
  let index = -1;
  let distribution = 0;
  for (let index_ = 1; index_ < points.length - 1; index_++) {
    const cDistribution = findPerpendicularDistance(points[index_], firstPoint, lastPoint);
    if (cDistribution > distribution) {
      distribution = cDistribution;
      index = index_;
    }
  }
  if (distribution > epsilon2) {
    const l1 = points.slice(0, index + 1);
    const l22 = points.slice(index);
    const r1 = rdpPerpendicularDistance(l1, epsilon2);
    const r22 = rdpPerpendicularDistance(l22, epsilon2);
    const rs2 = [...r1.slice(0, -1), ...r22];
    return rs2;
  } else {
    return [firstPoint, lastPoint];
  }
};
function findPerpendicularDistance(p4, p1, p22) {
  let result;
  let slope2;
  let intercept;
  if (p1.x == p22.x) {
    result = Math.abs(p4.x - p1.x);
  } else {
    slope2 = (p22.y - p1.y) / (p22.x - p1.x);
    intercept = p1.y - slope2 * p1.x;
    result = Math.abs(slope2 * p4.x - p4.y + intercept) / Math.sqrt(Math.pow(slope2, 2) + 1);
  }
  return result;
}
var distanceFromPointToLine = (p4, index, index_) => {
  const lineLength = distance3(index, index_);
  if (lineLength == 0) {
    return distance3(p4, index);
  }
  const t22 = ((p4.x - index.x) * (index_.x - index.x) + (p4.y - index.y) * (index_.y - index.y)) / lineLength;
  if (t22 < 0) {
    return distance3(p4, index);
  }
  if (t22 > 1) {
    return distance3(p4, index_);
  }
  return distance3(p4, { x: index.x + t22 * (index_.x - index.x), y: index.y + t22 * (index_.y - index.y) });
};
var QuadTree_exports = {};
__export(QuadTree_exports, {
  Direction: () => Direction,
  QuadTreeNode: () => QuadTreeNode,
  quadTree: () => quadTree
});
var Direction = /* @__PURE__ */ ((Direction2) => {
  Direction2[Direction2["Nw"] = 0] = "Nw";
  Direction2[Direction2["Ne"] = 1] = "Ne";
  Direction2[Direction2["Sw"] = 2] = "Sw";
  Direction2[Direction2["Se"] = 3] = "Se";
  return Direction2;
})(Direction || {});
var quadTree = (bounds, initialData = [], opts = {}) => {
  const o5 = {
    maxItems: opts.maxItems ?? 4,
    maxLevels: opts.maxLevels ?? 4
  };
  const n7 = new QuadTreeNode(void 0, bounds, 0, o5);
  for (const d4 of initialData) {
    n7.add(d4);
  }
  return n7;
};
var QuadTreeNode = class _QuadTreeNode {
  /**
   * Constructor
   * @param boundary
   * @param level
   * @param opts
   */
  constructor(parent, boundary, level, opts) {
    this.boundary = boundary;
    this.level = level;
    this.opts = opts;
    this.#parent = parent;
  }
  #items = [];
  #children = [];
  #parent;
  getLengthChildren() {
    return this.#children.length;
  }
  *parents() {
    let n7 = this;
    while (n7.#parent !== void 0) {
      yield n7.#parent;
      n7 = n7.#parent;
    }
  }
  getParent() {
    return this.#parent;
  }
  /**
   * Iterates over immediate children
   */
  *children() {
    for (const c6 of this.#children) {
      yield c6;
    }
  }
  /**
   * Array of QuadTreeItem
   * @returns
   */
  getValue() {
    return this.#items;
  }
  getIdentity() {
    return this;
  }
  /**
   * Get a descendant node in a given direction
   * @param d
   * @returns
   */
  direction(d4) {
    return this.#children[d4];
  }
  /**
   * Add an item to the quadtree
   * @param p
   * @returns False if item is outside of boundary, True if item was added
   */
  add(p4) {
    if (!isIntersecting3(this.boundary, p4)) return false;
    if (this.#children.length > 0) {
      for (const d4 of this.#children) d4.add(p4);
      return true;
    }
    this.#items.push(p4);
    if (this.#items.length > this.opts.maxItems && this.level < this.opts.maxLevels) {
      if (this.#children.length === 0) {
        this.#subdivide();
      }
      for (const item of this.#items) {
        for (const d4 of this.#children) d4.add(item);
      }
      this.#items = [];
    }
    return true;
  }
  /**
   * Returns true if point is inside node's boundary
   * @param p
   * @returns
   */
  couldHold(p4) {
    return intersectsPoint(this.boundary, p4);
  }
  #subdivide() {
    const w3 = this.boundary.width / 2;
    const h5 = this.boundary.height / 2;
    const x3 = this.boundary.x;
    const y3 = this.boundary.y;
    const coords = fromNumbers2(x3 + w3, y3, x3, y3, x3, y3 + h5, x3 + w3, y3 + h5);
    const rects = coords.map((p4) => fromTopLeft(p4, w3, h5));
    this.#children = rects.map(
      (r5) => new _QuadTreeNode(this, r5, this.level + 1, this.opts)
    );
  }
};
var Scaler_exports = {};
__export(Scaler_exports, {
  scaler: () => scaler2
});
var Placeholder3 = Object.freeze({
  width: Number.NaN,
  height: Number.NaN
});
var PlaceholderPositioned = Object.freeze({
  x: Number.NaN,
  y: Number.NaN,
  width: Number.NaN,
  height: Number.NaN
});
var scaler2 = (scaleBy = `both`, defaultRect) => {
  const defaultBounds = defaultRect ?? Placeholder3;
  let sw = 1;
  let sh2 = 1;
  let s3 = { x: 1, y: 1 };
  const computeScale = () => {
    switch (scaleBy) {
      case `height`: {
        return { x: sh2, y: sh2 };
      }
      case `width`: {
        return { x: sw, y: sw };
      }
      case `min`: {
        return { x: Math.min(sw, sh2), y: Math.min(sw, sh2) };
      }
      case `max`: {
        return { x: Math.max(sw, sh2), y: Math.max(sw, sh2) };
      }
      default: {
        return { x: sw, y: sh2 };
      }
    }
  };
  const normalise4 = (a4, b4, c6, d4) => {
    let inX = Number.NaN;
    let inY = Number.NaN;
    let outW = defaultBounds.width;
    let outH = defaultBounds.height;
    if (typeof a4 === `number`) {
      inX = a4;
      if (typeof b4 === `number`) {
        inY = b4;
        if (c6 === void 0) return [inX, inY, outW, outH];
        if (isRect(c6)) {
          outW = c6.width;
          outH = c6.height;
        } else if (typeof c6 === `number`) {
          outW = c6;
          if (typeof d4 === `number`) {
            outH = d4;
          } else {
            throw new TypeError(`Missing final height value`);
          }
        } else throw new Error(`Missing valid output range`);
      } else if (isRect(b4)) {
        outW = b4.width;
        outH = b4.height;
      } else {
        throw new Error(
          `Expected input y or output Rect to follow first number parameter`
        );
      }
    } else if (isPoint(a4)) {
      inX = a4.x;
      inY = a4.y;
      if (b4 === void 0) return [inX, inY, outW, outH];
      if (isRect(b4)) {
        outW = b4.width;
        outH = b4.height;
      } else if (typeof b4 === `number`) {
        outW = b4;
        if (typeof c6 === `number`) {
          outH = c6;
        } else {
          throw new TypeError(
            `Expected height as third parameter after Point and output width`
          );
        }
      } else {
        throw new TypeError(
          `Expected Rect or width as second parameter when first parameter is a Point`
        );
      }
    } else {
      throw new Error(`Expected input Point or x value as first parameter`);
    }
    return [inX, inY, outW, outH];
  };
  const scaleAbs = (a4, b4, c6, d4) => {
    const n7 = normalise4(a4, b4, c6, d4);
    return scaleNormalised(true, ...n7);
  };
  const scaleRel = (a4, b4, c6, d4) => {
    const n7 = normalise4(a4, b4, c6, d4);
    return scaleNormalised(false, ...n7);
  };
  const scaleNormalised = (abs4, x3, y3, w3, h5) => {
    if (Number.isNaN(w3)) throw new Error(`Output width range missing`);
    if (Number.isNaN(h5)) throw new Error(`Output height range missing`);
    if (w3 !== sw || h5 !== sh2) {
      sw = w3;
      sh2 = h5;
      s3 = computeScale();
    }
    return abs4 ? {
      x: x3 * s3.x,
      y: y3 * s3.y
    } : {
      x: x3 / s3.x,
      y: y3 / s3.y
    };
  };
  return {
    computeScale,
    rel: scaleRel,
    abs: scaleAbs,
    width: defaultBounds.width,
    height: defaultBounds.height
  };
};
var Convolve2d_exports = {};
__export(Convolve2d_exports, {
  boxBlurKernel: () => boxBlurKernel,
  convolve: () => convolve,
  convolveCell: () => convolveCell,
  convolveImage: () => convolveImage,
  edgeDetectionKernel: () => edgeDetectionKernel,
  gaussianBlur3Kernel: () => gaussianBlur3Kernel,
  gaussianBlur5Kernel: () => gaussianBlur5Kernel,
  identityKernel: () => identityKernel,
  kernel2dToArray: () => kernel2dToArray,
  multiply: () => multiply5,
  rgbReducer: () => rgbReducer,
  sharpenKernel: () => sharpenKernel,
  unsharpMasking5Kernel: () => unsharpMasking5Kernel
});
var ImageDataGrid_exports = {};
__export(ImageDataGrid_exports, {
  accessor: () => accessor,
  byColumn: () => byColumn,
  byRow: () => byRow
});
var accessor = (image) => {
  const grid2 = { rows: image.width, cols: image.height };
  const data = image.data;
  const fn2 = (cell, bounds) => {
    const index = indexFromCell(grid2, cell, bounds);
    if (index === void 0) {
      return void 0;
    }
    const pxIndex = index * 4;
    return {
      r: data[pxIndex],
      g: data[pxIndex + 1],
      b: data[pxIndex + 2],
      opacity: data[pxIndex + 3],
      space: `srgb`
    };
  };
  return fn2;
};
function* byRow(image) {
  const a4 = accessor(image);
  const grid2 = { rows: image.width, cols: image.height };
  for (let y3 = 0; y3 < grid2.rows; y3++) {
    let row = [];
    for (let x3 = 0; x3 < grid2.cols; x3++) {
      const p4 = a4({ x: x3, y: y3 }, `undefined`);
      if (p4) row.push(p4);
    }
    yield row;
  }
}
function* byColumn(image) {
  const a4 = accessor(image);
  const grid2 = { rows: image.width, cols: image.height };
  for (let x3 = 0; x3 < grid2.cols; x3++) {
    let col = [];
    for (let y3 = 0; y3 < grid2.rows; y3++) {
      const p4 = a4({ x: x3, y: y3 }, `undefined`);
      if (p4) col.push(p4);
    }
    yield col;
  }
}
var multiply5 = (kernel, scalar) => {
  const rows2 = kernel.length;
  const cols = kernel[0].length;
  const copy = [];
  for (let row = 0; row < rows2; row++) {
    copy[row] = [];
    for (let col = 0; col < cols; col++) {
      copy[row][col] = kernel[row][col] * scalar;
    }
  }
  return copy;
};
function convolveCell(c6, kernel, source, access, reduce22) {
  const valuesAtKernelPos = kernel.map((o5) => {
    const pos = offset(source, c6, o5[0], `stop`);
    if (!pos) return [o5[1], void 0];
    return [o5[1], access(pos, `undefined`)];
  });
  return reduce22(valuesAtKernelPos);
}
function* convolveImage(kernel, image) {
  const grid2 = { rows: image.width, cols: image.height };
  const imageDataAsGrid = accessor(image);
  yield* convolve(kernel, grid2, imageDataAsGrid, cells(grid2), rgbReducer);
}
function* convolve(kernel, source, access, visitor2, reduce22, origin) {
  if (!origin) {
    const kernelRows = kernel.length;
    const kernelCols = kernel[0].length;
    origin = { x: Math.floor(kernelRows / 2), y: Math.floor(kernelCols / 2) };
  }
  const asArray = kernel2dToArray(kernel, origin);
  for (const c6 of visitor2) {
    const v3 = convolveCell(c6, asArray, source, access, reduce22);
    yield [c6, v3];
  }
}
var kernel2dToArray = (kernel, origin) => {
  const offsets = [];
  const rows2 = kernel.length;
  const cols = kernel[0].length;
  if (!origin) origin = { x: Math.floor(rows2 / 2), y: Math.floor(cols / 2) };
  for (let xx = 0; xx < rows2; xx++) {
    for (let yy = 0; yy < cols; yy++) {
      offsets.push([{ x: xx - origin.x, y: yy - origin.y }, kernel[xx][yy]]);
    }
  }
  return offsets;
};
var rgbReducer = (values) => {
  let r5 = 0;
  let g5 = 0;
  let b4 = 0;
  const opacity2 = 0;
  for (const value2 of values) {
    const rgb = value2[1];
    const scale23 = value2[0];
    if (rgb === void 0) continue;
    if (rgb.opacity === 0) continue;
    if (scale23 === 0) continue;
    r5 += rgb.r * scale23;
    g5 += rgb.g * scale23;
    b4 += rgb.b * scale23;
  }
  const result = {
    r: r5,
    g: g5,
    b: b4,
    opacity: 255,
    space: `srgb`
  };
  return result;
};
var identityKernel = [
  [0, 0, 0],
  [0, 1, 0],
  [0, 0, 0]
];
var edgeDetectionKernel = [
  [0, -1, 0],
  [-1, 4, -1],
  [0, -1, 0]
];
var sharpenKernel = [
  [0, -1, 0],
  [-1, 5, -1],
  [0, -1, 0]
];
var boxBlurKernel = multiply5([
  [1, 1, 1],
  [1, 1, 1],
  [1, 1, 1]
], 1 / 9);
var gaussianBlur3Kernel = multiply5([
  [1, 2, 1],
  [2, 4, 2],
  [1, 2, 1]
], 1 / 16);
var gaussianBlur5Kernel = multiply5([
  [1, 4, 6, 4, 1],
  [4, 16, 24, 16, 4],
  [6, 24, 36, 24, 6],
  [4, 16, 24, 16, 4],
  [1, 4, 6, 4, 1]
], 1 / 256);
var unsharpMasking5Kernel = multiply5([
  [1, 4, 6, 4, 1],
  [4, 16, 24, 16, 4],
  [6, 24, -476, 24, 6],
  [4, 16, 24, 16, 4],
  [1, 4, 6, 4, 1]
], -1 / 256);
var arc_exports = {};
__export(arc_exports, {
  bbox: () => bbox5,
  distanceCenter: () => distanceCenter2,
  fromDegrees: () => fromDegrees2,
  guard: () => guard6,
  interpolate: () => interpolate5,
  isArc: () => isArc,
  isEqual: () => isEqual6,
  isPositioned: () => isPositioned3,
  length: () => length4,
  point: () => point,
  toLine: () => toLine,
  toPath: () => toPath4,
  toSvg: () => toSvg2
});
var isArc = (p4) => p4.startRadian !== void 0 && p4.endRadian !== void 0;
var isPositioned3 = (p4) => p4.x !== void 0 && p4.y !== void 0;
var piPi4 = Math.PI * 2;
function fromDegrees2(radius, startDegrees, endDegrees, origin) {
  const a4 = {
    radius,
    startRadian: degreeToRadian(startDegrees),
    endRadian: degreeToRadian(endDegrees)
  };
  if (isPoint(origin)) {
    guard(origin);
    const ap = {
      ...a4,
      x: origin.x,
      y: origin.y
    };
    return Object.freeze(ap);
  } else {
    return Object.freeze(a4);
  }
}
var toLine = (arc2) => fromPoints(
  point(arc2, arc2.startRadian),
  point(arc2, arc2.endRadian)
);
var point = (arc2, angleRadian3, origin) => {
  if (angleRadian3 > arc2.endRadian) throw new Error(`angleRadian beyond end angle of arc`);
  if (angleRadian3 < arc2.startRadian) throw new Error(`angleRadian beyond start angle of arc`);
  if (origin === void 0) {
    origin = isPositioned3(arc2) ? arc2 : { x: 0, y: 0 };
  }
  return {
    x: Math.cos(angleRadian3) * arc2.radius + origin.x,
    y: Math.sin(angleRadian3) * arc2.radius + origin.y
  };
};
var guard6 = (arc2) => {
  if (arc2 === void 0) throw new Error(`Arc is undefined`);
  if (isPositioned3(arc2)) {
    guard(arc2, `arc`);
  }
  if (arc2.radius === void 0) throw new Error(`Arc radius is undefined (${JSON.stringify(arc2)})`);
  if (typeof arc2.radius !== `number`) throw new Error(`Radius must be a number`);
  if (Number.isNaN(arc2.radius)) throw new Error(`Radius is NaN`);
  if (arc2.radius <= 0) throw new Error(`Radius must be greater than zero`);
  if (arc2.startRadian === void 0) throw new Error(`Arc is missing 'startRadian' field`);
  if (arc2.endRadian === void 0) throw new Error(`Arc is missing 'startRadian' field`);
  if (Number.isNaN(arc2.endRadian)) throw new Error(`Arc endRadian is NaN`);
  if (Number.isNaN(arc2.startRadian)) throw new Error(`Arc endRadian is NaN`);
  if (arc2.startRadian >= arc2.endRadian) throw new Error(`startRadian is expected to be les than endRadian`);
};
var interpolate5 = (amount, arc2, origin) => {
  guard6(arc2);
  return point(arc2, arc2.startRadian + (arc2.endRadian - arc2.startRadian) * amount, origin);
};
var toPath4 = (arc2) => {
  guard6(arc2);
  return Object.freeze({
    ...arc2,
    nearest: (point2) => {
      throw new Error(`not implemented`);
    },
    interpolate: (amount) => interpolate5(amount, arc2),
    bbox: () => bbox5(arc2),
    length: () => length4(arc2),
    toSvgString: () => toSvg2(arc2),
    relativePosition: (_point, _intersectionThreshold) => {
      throw new Error(`Not implemented`);
    },
    distanceToPoint: (_point) => {
      throw new Error(`Not implemented`);
    },
    kind: `arc`
  });
};
var length4 = (arc2) => piPi4 * arc2.radius * ((arc2.startRadian - arc2.endRadian) / piPi4);
var bbox5 = (arc2) => {
  if (isPositioned3(arc2)) {
    const middle = interpolate5(0.5, arc2);
    const asLine = toLine(arc2);
    return bbox(middle, asLine.a, asLine.b);
  } else {
    return {
      width: arc2.radius * 2,
      height: arc2.radius * 2
    };
  }
};
var toSvg2 = (a4, b4, c6, d4, e5) => {
  if (isArc(a4)) {
    if (isPositioned3(a4)) {
      return toSvgFull2(a4, a4.radius, a4.startRadian, a4.endRadian, b4);
    } else {
      return isPoint(b4) ? toSvgFull2(b4, a4.radius, a4.startRadian, a4.endRadian, c6) : toSvgFull2({ x: 0, y: 0 }, a4.radius, a4.startRadian, a4.endRadian);
    }
  } else {
    if (c6 === void 0) throw new Error(`startAngle undefined`);
    if (d4 === void 0) throw new Error(`endAngle undefined`);
    if (isPoint(a4)) {
      if (typeof b4 === `number` && typeof c6 === `number` && typeof d4 === `number`) {
        return toSvgFull2(a4, b4, c6, d4, e5);
      } else {
        throw new TypeError(`Expected (point, number, number, number). Missing a number param.`);
      }
    } else {
      throw new Error(`Expected (point, number, number, number). Missing first point.`);
    }
  }
};
var toSvgFull2 = (origin, radius, startRadian, endRadian, opts) => {
  if (opts === void 0 || typeof opts !== `object`) opts = {};
  const isFullCircle = endRadian - startRadian === 360;
  const start = toCartesian(radius, endRadian - 0.01, origin);
  const end = toCartesian(radius, startRadian, origin);
  const { largeArc = false, sweep = false } = opts;
  const d4 = [`
    M ${start.x} ${start.y}
    A ${radius} ${radius} 0 ${largeArc ? `1` : `0`} ${sweep ? `1` : `0`} ${end.x} ${end.y},
  `];
  if (isFullCircle) d4.push(`z`);
  return d4;
};
var distanceCenter2 = (a4, b4) => distance3(a4, b4);
var isEqual6 = (a4, b4) => {
  if (a4.radius !== b4.radius) return false;
  if (isPositioned3(a4) && isPositioned3(b4)) {
    if (a4.x !== b4.x) return false;
    if (a4.y !== b4.y) return false;
    if (a4.z !== b4.z) return false;
    return true;
  } else if (!isPositioned3(a4) && !isPositioned3(b4)) {
  } else return false;
  if (a4.endRadian !== b4.endRadian) return false;
  if (a4.startRadian !== b4.startRadian) return false;
  return true;
};
var Vector_exports = {};
__export(Vector_exports, {
  clampMagnitude: () => clampMagnitude3,
  divide: () => divide5,
  dotProduct: () => dotProduct4,
  fromLineCartesian: () => fromLineCartesian,
  fromLinePolar: () => fromLinePolar,
  fromPointPolar: () => fromPointPolar,
  fromRadians: () => fromRadians,
  multiply: () => multiply6,
  normalise: () => normalise3,
  quadrantOffsetAngle: () => quadrantOffsetAngle,
  subtract: () => subtract4,
  sum: () => sum4,
  toCartesian: () => toCartesian2,
  toPolar: () => toPolar,
  toRadians: () => toRadians,
  toString: () => toString5
});
var EmptyCartesian2 = Object.freeze({ x: 0, y: 0 });
var piPi5 = Math.PI * 2;
var pi32 = Math.PI;
var fromRadians = (radians) => {
  return Object.freeze({
    x: Math.cos(radians),
    y: Math.sin(radians)
  });
};
var toRadians = (point2) => {
  return Math.atan2(point2.y, point2.x);
};
var fromPointPolar = (pt2, angleNormalisation = ``, origin = EmptyCartesian2) => {
  pt2 = subtract(pt2, origin);
  let direction = Math.atan2(pt2.y, pt2.x);
  if (angleNormalisation === `unipolar` && direction < 0) direction += piPi5;
  else if (angleNormalisation === `bipolar`) {
    if (direction > pi32) direction -= piPi5;
    else if (direction <= -pi32) direction += piPi5;
  }
  return Object.freeze({
    distance: distance3(pt2),
    angleRadian: direction
  });
};
var fromLineCartesian = (line3) => subtract(line3.b, line3.a);
var fromLinePolar = (line3) => {
  guard2(line3, `line`);
  const pt2 = subtract(line3.b, line3.a);
  return fromPointPolar(pt2);
};
var isPolar = (v3) => {
  if (isPolarCoord(v3)) return true;
  return false;
};
var isCartesian = (v3) => {
  if (isPoint(v3)) return true;
  return false;
};
var normalise3 = (v3) => {
  if (isPolar(v3)) {
    return normalise(v3);
  } else if (isCartesian(v3)) {
    return normalise2(v3);
  }
  throw new Error(`Expected polar/cartesian vector. Got: ${v3}`);
};
var quadrantOffsetAngle = (p4) => {
  if (p4.x >= 0 && p4.y >= 0) return 0;
  if (p4.x < 0 && p4.y >= 0) return pi32;
  if (p4.x < 0 && p4.y < 0) return pi32;
  return piPi5;
};
var toPolar = (v3, origin = Empty) => {
  if (isPolar(v3)) {
    return v3;
  } else if (isCartesian(v3)) {
    return fromCartesian(v3, origin);
  }
  throw new Error(`Expected polar/cartesian vector. Got: ${v3}`);
};
var toCartesian2 = (v3) => {
  if (isPolar(v3)) {
    return toPoint(v3);
  } else if (isCartesian(v3)) {
    return v3;
  }
  throw new Error(`Expected polar/cartesian vector. Got: ${v3}`);
};
var toString5 = (v3, digits) => {
  if (isPolar(v3)) {
    return toString3(v3, digits);
  } else if (isCartesian(v3)) {
    return toString22(v3, digits);
  }
  throw new Error(`Expected polar/cartesian vector. Got: ${v3}`);
};
var dotProduct4 = (a4, b4) => {
  if (isPolar(a4) && isPolar(b4)) {
    return dotProduct2(a4, b4);
  } else if (isCartesian(a4) && isCartesian(b4)) {
    return dotProduct3(a4, b4);
  }
  throw new Error(`Expected two polar/Cartesian vectors.`);
};
var clampMagnitude3 = (v3, max23 = 1, min23 = 0) => {
  if (isPolar(v3)) {
    return clampMagnitude(v3, max23, min23);
  } else if (isCartesian(v3)) {
    return clampMagnitude2(v3, max23, min23);
  }
  throw new Error(`Expected either polar or Cartesian vector`);
};
var sum4 = (a4, b4) => {
  const polar = isPolar(a4);
  a4 = toCartesian2(a4);
  b4 = toCartesian2(b4);
  const c6 = sum3(a4, b4);
  return polar ? toPolar(c6) : c6;
};
var subtract4 = (a4, b4) => {
  const polar = isPolar(a4);
  a4 = toCartesian2(a4);
  b4 = toCartesian2(b4);
  const c6 = subtract(a4, b4);
  return polar ? toPolar(c6) : c6;
};
var multiply6 = (a4, b4) => {
  const polar = isPolar(a4);
  a4 = toCartesian2(a4);
  b4 = toCartesian2(b4);
  const c6 = multiply2(a4, b4);
  return polar ? toPolar(c6) : c6;
};
var divide5 = (a4, b4) => {
  const polar = isPolar(a4);
  a4 = toCartesian2(a4);
  b4 = toCartesian2(b4);
  const c6 = divide(a4, b4);
  return polar ? toPolar(c6) : c6;
};
var SurfacePoints_exports = {};
__export(SurfacePoints_exports, {
  circleRings: () => circleRings,
  circleVogelSpiral: () => circleVogelSpiral,
  sphereFibonacci: () => sphereFibonacci
});
var cos3 = Math.cos;
var sin3 = Math.sin;
var asin = Math.asin;
var sqrt3 = Math.sqrt;
var pow22 = Math.pow;
var pi4 = Math.PI;
var piPi6 = Math.PI * 2;
var goldenAngle = pi4 * (3 - sqrt3(5));
var goldenSection = (1 + sqrt3(5)) / 2;
function* circleVogelSpiral(circle3, opts = {}) {
  const maxPoints = opts.maxPoints ?? 5e3;
  const density = opts.density ?? 0.95;
  const rotationOffset = opts.rotation ?? 0;
  const c6 = toPositioned(circle3 ?? { radius: 1, x: 0, y: 0 });
  const max23 = c6.radius;
  let spacing = c6.radius * scale(density, 0, 1, 0.3, 0.01);
  if (opts.spacing) spacing = opts.spacing;
  let radius = 0;
  let count3 = 0;
  let angle = 0;
  while (count3 < maxPoints && radius < max23) {
    radius = spacing * count3 ** 0.5;
    angle = rotationOffset + count3 * 2 * pi4 / goldenSection;
    yield Object.freeze({
      x: c6.x + radius * cos3(angle),
      y: c6.y + radius * sin3(angle)
    });
    count3++;
  }
}
function* circleRings(circle3, opts = {}) {
  const rings = opts.rings ?? 5;
  const c6 = toPositioned(circle3 ?? { radius: 1, x: 0, y: 0 });
  const ringR = 1 / rings;
  const rotationOffset = opts.rotation ?? 0;
  let ringCount = 1;
  yield Object.freeze({ x: c6.x, y: c6.y });
  for (let r5 = ringR; r5 <= 1; r5 += ringR) {
    const n7 = Math.round(pi4 / asin(1 / (2 * ringCount)));
    for (const theta of linearSpace(0, piPi6, n7 + 1)) {
      yield Object.freeze({
        x: c6.x + r5 * cos3(theta + rotationOffset) * c6.radius,
        y: c6.y + r5 * sin3(theta + rotationOffset) * c6.radius
      });
    }
    ringCount++;
  }
}
function* sphereFibonacci(samples = 100, rotationRadians = 0, sphere) {
  const offset2 = 2 / samples;
  const s3 = sphere ?? { x: 0, y: 0, z: 0, radius: 1 };
  for (let index = 0; index < samples; index++) {
    const y3 = index * offset2 - 1 + offset2 / 2;
    const r5 = sqrt3(1 - pow22(y3, 2));
    const a4 = (index + 1) % samples * goldenAngle + rotationRadians;
    const x3 = cos3(a4) * r5;
    const z3 = sin3(a4) * r5;
    yield Object.freeze({
      x: s3.x + x3 * s3.radius,
      y: s3.y + y3 * s3.radius,
      z: s3.z + z3 * s3.radius
    });
  }
}
var triangle_exports = {};
__export(triangle_exports, {
  Empty: () => Empty4,
  Equilateral: () => Equilateral_exports,
  Isosceles: () => Isosceles_exports,
  Placeholder: () => Placeholder4,
  Right: () => Right_exports,
  angles: () => angles,
  anglesDegrees: () => anglesDegrees,
  apply: () => apply4,
  area: () => area3,
  barycentricCoord: () => barycentricCoord,
  barycentricToCartestian: () => barycentricToCartestian,
  bbox: () => bbox6,
  centroid: () => centroid2,
  corners: () => corners2,
  edges: () => edges22,
  equilateralFromVertex: () => equilateralFromVertex,
  fromFlatArray: () => fromFlatArray2,
  fromPoints: () => fromPoints3,
  fromRadius: () => fromRadius,
  guard: () => guard7,
  innerCircle: () => innerCircle,
  intersectsPoint: () => intersectsPoint2,
  isAcute: () => isAcute,
  isEmpty: () => isEmpty4,
  isEqual: () => isEqual7,
  isEquilateral: () => isEquilateral,
  isIsosceles: () => isIsosceles,
  isOblique: () => isOblique,
  isObtuse: () => isObtuse,
  isPlaceholder: () => isPlaceholder4,
  isRightAngle: () => isRightAngle,
  isTriangle: () => isTriangle,
  lengths: () => lengths2,
  outerCircle: () => outerCircle,
  perimeter: () => perimeter,
  rotate: () => rotate4,
  rotateByVertex: () => rotateByVertex,
  toFlatArray: () => toFlatArray2
});
var guard7 = (t22, name = `t`) => {
  if (t22 === void 0) throw new Error(`{$name} undefined`);
  guard(t22.a, name + `.a`);
  guard(t22.b, name + `.b`);
  guard(t22.c, name + `.c`);
};
var edges22 = (t22) => {
  guard7(t22);
  return joinPointsToLines(t22.a, t22.b, t22.c, t22.a);
};
var area3 = (t22) => {
  guard7(t22, `t`);
  const lengths3 = edges22(t22).map((l3) => length2(l3));
  const p4 = (lengths3[0] + lengths3[1] + lengths3[2]) / 2;
  return Math.sqrt(p4 * (p4 - lengths3[0]) * (p4 - lengths3[1]) * (p4 - lengths3[2]));
};
var centroid2 = (t22) => {
  guard7(t22);
  const total = reduce3(
    [t22.a, t22.b, t22.c],
    (p4, accumulator) => ({
      x: p4.x + accumulator.x,
      y: p4.y + accumulator.y
    })
  );
  const div = {
    x: total.x / 3,
    y: total.y / 3
  };
  return div;
};
var perimeter = (t22) => {
  guard7(t22);
  return edges22(t22).reduce((accumulator, v3) => accumulator + length2(v3), 0);
};
var innerCircle = (t22) => {
  const c6 = centroid2(t22);
  const p4 = perimeter(t22) / 2;
  const a4 = area3(t22);
  const radius = a4 / p4;
  return { radius, ...c6 };
};
var outerCircle = (t22) => {
  const [a4, b4, c6] = edges22(t22).map((l3) => length2(l3));
  const cent = centroid2(t22);
  const radius = a4 * b4 * c6 / Math.sqrt((a4 + b4 + c6) * (-a4 + b4 + c6) * (a4 - b4 + c6) * (a4 + b4 - c6));
  return {
    radius,
    ...cent
  };
};
var rotate4 = (triangle2, amountRadian, origin) => {
  if (amountRadian === void 0 || amountRadian === 0) return triangle2;
  if (origin === void 0) origin = centroid2(triangle2);
  return Object.freeze({
    ...triangle2,
    a: rotate2(triangle2.a, amountRadian, origin),
    b: rotate2(triangle2.b, amountRadian, origin),
    c: rotate2(triangle2.c, amountRadian, origin)
  });
};
var Equilateral_exports = {};
__export(Equilateral_exports, {
  area: () => area4,
  centerFromA: () => centerFromA,
  centerFromB: () => centerFromB,
  centerFromC: () => centerFromC,
  circumcircle: () => circumcircle,
  fromCenter: () => fromCenter2,
  height: () => height,
  incircle: () => incircle,
  perimeter: () => perimeter2
});
var pi4over3 = Math.PI * 4 / 3;
var pi2over3 = Math.PI * 2 / 3;
var resolveLength = (t22) => {
  if (typeof t22 === `number`) return t22;
  return t22.length;
};
var fromCenter2 = (t22, origin, rotationRad) => {
  if (!origin) origin = Object.freeze({ x: 0, y: 0 });
  const r5 = resolveLength(t22) / Math.sqrt(3);
  const rot = rotationRad ?? Math.PI * 1.5;
  const b4 = {
    x: r5 * Math.cos(rot) + origin.x,
    y: r5 * Math.sin(rot) + origin.y
  };
  const a4 = {
    x: r5 * Math.cos(rot + pi4over3) + origin.x,
    y: r5 * Math.sin(rot + pi4over3) + origin.y
  };
  const c6 = {
    x: r5 * Math.cos(rot + pi2over3) + origin.x,
    y: r5 * Math.sin(rot + pi2over3) + origin.y
  };
  return Object.freeze({ a: a4, b: b4, c: c6 });
};
var centerFromA = (t22, ptA) => {
  if (!ptA) ptA = Object.freeze({ x: 0, y: 0 });
  const r5 = resolveLength(t22);
  const { radius } = incircle(t22);
  return {
    x: ptA.x + r5 / 2,
    y: ptA.y - radius
  };
};
var centerFromB = (t22, ptB) => {
  if (!ptB) ptB = Object.freeze({ x: 0, y: 0 });
  const { radius } = incircle(t22);
  return {
    x: ptB.x,
    y: ptB.y + radius * 2
  };
};
var centerFromC = (t22, ptC) => {
  if (!ptC) ptC = Object.freeze({ x: 0, y: 0 });
  const r5 = resolveLength(t22);
  const { radius } = incircle(t22);
  return {
    x: ptC.x - r5 / 2,
    y: ptC.y - radius
  };
};
var height = (t22) => Math.sqrt(3) / 2 * resolveLength(t22);
var perimeter2 = (t22) => resolveLength(t22) * 3;
var area4 = (t22) => Math.pow(resolveLength(t22), 2) * Math.sqrt(3) / 4;
var circumcircle = (t22) => ({
  radius: Math.sqrt(3) / 3 * resolveLength(t22)
});
var incircle = (t22) => ({
  radius: Math.sqrt(3) / 6 * resolveLength(t22)
});
var Right_exports = {};
__export(Right_exports, {
  adjacentFromHypotenuse: () => adjacentFromHypotenuse,
  adjacentFromOpposite: () => adjacentFromOpposite,
  angleAtPointA: () => angleAtPointA,
  angleAtPointB: () => angleAtPointB,
  area: () => area5,
  circumcircle: () => circumcircle2,
  fromA: () => fromA,
  fromB: () => fromB,
  fromC: () => fromC,
  height: () => height2,
  hypotenuseFromAdjacent: () => hypotenuseFromAdjacent,
  hypotenuseFromOpposite: () => hypotenuseFromOpposite,
  hypotenuseSegments: () => hypotenuseSegments,
  incircle: () => incircle2,
  medians: () => medians,
  oppositeFromAdjacent: () => oppositeFromAdjacent,
  oppositeFromHypotenuse: () => oppositeFromHypotenuse,
  perimeter: () => perimeter3,
  resolveLengths: () => resolveLengths
});
var fromA = (t22, origin) => {
  if (!origin) origin = Object.freeze({ x: 0, y: 0 });
  const tt2 = resolveLengths(t22);
  const seg = hypotenuseSegments(t22);
  const h5 = height2(t22);
  const a4 = { x: origin.x, y: origin.y };
  const b4 = { x: origin.x + tt2.hypotenuse, y: origin.y };
  const c6 = { x: origin.x + seg[1], y: origin.y - h5 };
  return { a: a4, b: b4, c: c6 };
};
var fromB = (t22, origin) => {
  if (!origin) origin = Object.freeze({ x: 0, y: 0 });
  const tt2 = resolveLengths(t22);
  const seg = hypotenuseSegments(t22);
  const h5 = height2(t22);
  const b4 = { x: origin.x, y: origin.y };
  const a4 = { x: origin.x - tt2.hypotenuse, y: origin.y };
  const c6 = { x: origin.x - seg[0], y: origin.y - h5 };
  return { a: a4, b: b4, c: c6 };
};
var fromC = (t22, origin) => {
  if (!origin) origin = Object.freeze({ x: 0, y: 0 });
  const seg = hypotenuseSegments(t22);
  const h5 = height2(t22);
  const c6 = { x: origin.x, y: origin.y };
  const a4 = { x: origin.x - seg[1], y: origin.y + h5 };
  const b4 = { x: origin.x + seg[0], y: origin.y + h5 };
  return { a: a4, b: b4, c: c6 };
};
var resolveLengths = (t22) => {
  const a4 = t22.adjacent;
  const o5 = t22.opposite;
  const h5 = t22.hypotenuse;
  if (a4 !== void 0 && o5 !== void 0) {
    return {
      ...t22,
      adjacent: a4,
      opposite: o5,
      hypotenuse: Math.hypot(a4, o5)
    };
  } else if (a4 && h5) {
    return {
      ...t22,
      adjacent: a4,
      hypotenuse: h5,
      opposite: h5 * h5 - a4 * a4
    };
  } else if (o5 && h5) {
    return {
      ...t22,
      hypotenuse: h5,
      opposite: o5,
      adjacent: h5 * h5 - o5 * o5
    };
  } else if (t22.opposite && t22.hypotenuse && t22.adjacent) {
    return t22;
  }
  throw new Error(`Missing at least two edges`);
};
var height2 = (t22) => {
  const tt2 = resolveLengths(t22);
  const p4 = tt2.opposite * tt2.opposite / tt2.hypotenuse;
  const q3 = tt2.adjacent * tt2.adjacent / tt2.hypotenuse;
  return Math.sqrt(p4 * q3);
};
var hypotenuseSegments = (t22) => {
  const tt2 = resolveLengths(t22);
  const p4 = tt2.opposite * tt2.opposite / tt2.hypotenuse;
  const q3 = tt2.adjacent * tt2.adjacent / tt2.hypotenuse;
  return [p4, q3];
};
var perimeter3 = (t22) => {
  const tt2 = resolveLengths(t22);
  return tt2.adjacent + tt2.hypotenuse + tt2.opposite;
};
var area5 = (t22) => {
  const tt2 = resolveLengths(t22);
  return tt2.opposite * tt2.adjacent / 2;
};
var angleAtPointA = (t22) => {
  const tt2 = resolveLengths(t22);
  return Math.acos(
    (tt2.adjacent * tt2.adjacent + tt2.hypotenuse * tt2.hypotenuse - tt2.opposite * tt2.opposite) / (2 * tt2.adjacent * tt2.hypotenuse)
  );
};
var angleAtPointB = (t22) => {
  const tt2 = resolveLengths(t22);
  return Math.acos(
    (tt2.opposite * tt2.opposite + tt2.hypotenuse * tt2.hypotenuse - tt2.adjacent * tt2.adjacent) / (2 * tt2.opposite * tt2.hypotenuse)
  );
};
var medians = (t22) => {
  const tt2 = resolveLengths(t22);
  const b4 = tt2.adjacent * tt2.adjacent;
  const c6 = tt2.hypotenuse * tt2.hypotenuse;
  const a4 = tt2.opposite * tt2.opposite;
  return [
    Math.sqrt(2 * (b4 + c6) - a4) / 2,
    Math.sqrt(2 * (c6 + a4) - b4) / 2,
    Math.sqrt(2 * (a4 + b4) - c6) / 2
  ];
};
var circumcircle2 = (t22) => {
  const tt2 = resolveLengths(t22);
  return { radius: tt2.hypotenuse / 2 };
};
var incircle2 = (t22) => {
  const tt2 = resolveLengths(t22);
  return {
    radius: (tt2.adjacent + tt2.opposite - tt2.hypotenuse) / 2
  };
};
var oppositeFromAdjacent = (angleRad, adjacent) => Math.tan(angleRad) * adjacent;
var oppositeFromHypotenuse = (angleRad, hypotenuse) => Math.sin(angleRad) * hypotenuse;
var adjacentFromHypotenuse = (angleRadian3, hypotenuse) => Math.cos(angleRadian3) * hypotenuse;
var adjacentFromOpposite = (angleRadian3, opposite) => opposite / Math.tan(angleRadian3);
var hypotenuseFromOpposite = (angleRadian3, opposite) => opposite / Math.sin(angleRadian3);
var hypotenuseFromAdjacent = (angleRadian3, adjacent) => adjacent / Math.cos(angleRadian3);
var Isosceles_exports = {};
__export(Isosceles_exports, {
  apexAngle: () => apexAngle,
  area: () => area6,
  baseAngle: () => baseAngle,
  circumcircle: () => circumcircle3,
  fromA: () => fromA2,
  fromB: () => fromB2,
  fromC: () => fromC2,
  fromCenter: () => fromCenter3,
  height: () => height3,
  incircle: () => incircle3,
  legHeights: () => legHeights,
  medians: () => medians2,
  perimeter: () => perimeter4
});
var baseAngle = (t22) => Math.acos(t22.base / (2 * t22.legs));
var apexAngle = (t22) => {
  const aa2 = t22.legs * t22.legs;
  const cc = t22.base * t22.base;
  return Math.acos((2 * aa2 - cc) / (2 * aa2));
};
var height3 = (t22) => {
  const aa2 = t22.legs * t22.legs;
  const cc = t22.base * t22.base;
  return Math.sqrt((4 * aa2 - cc) / 4);
};
var legHeights = (t22) => {
  const b4 = baseAngle(t22);
  return t22.base * Math.sin(b4);
};
var perimeter4 = (t22) => 2 * t22.legs + t22.base;
var area6 = (t22) => {
  const h5 = height3(t22);
  return h5 * t22.base / 2;
};
var circumcircle3 = (t22) => {
  const h5 = height3(t22);
  const hh2 = h5 * h5;
  const cc = t22.base * t22.base;
  return { radius: (4 * hh2 + cc) / (8 * h5) };
};
var incircle3 = (t22) => {
  const h5 = height3(t22);
  return { radius: t22.base * h5 / (2 * t22.legs + t22.base) };
};
var medians2 = (t22) => {
  const aa2 = t22.legs * t22.legs;
  const cc = t22.base * t22.base;
  const medianAB = Math.sqrt(aa2 + 2 * cc) / 2;
  const medianC = Math.sqrt(4 * aa2 - cc) / 2;
  return [medianAB, medianAB, medianC];
};
var fromCenter3 = (t22, origin) => {
  if (!origin) origin = Object.freeze({ x: 0, y: 0 });
  const h5 = height3(t22);
  const incircleR = incircle3(t22).radius;
  const verticalToApex = h5 - incircleR;
  const a4 = { x: origin.x - t22.base / 2, y: origin.y + incircleR };
  const b4 = { x: origin.x + t22.base / 2, y: origin.y + incircleR };
  const c6 = { x: origin.x, y: origin.y - verticalToApex };
  return { a: a4, b: b4, c: c6 };
};
var fromA2 = (t22, origin) => {
  if (!origin) origin = Object.freeze({ x: 0, y: 0 });
  const h5 = height3(t22);
  const a4 = { x: origin.x, y: origin.y };
  const b4 = { x: origin.x + t22.base, y: origin.y };
  const c6 = { x: origin.x + t22.base / 2, y: origin.y - h5 };
  return { a: a4, b: b4, c: c6 };
};
var fromB2 = (t22, origin) => {
  if (!origin) origin = Object.freeze({ x: 0, y: 0 });
  const h5 = height3(t22);
  const b4 = { x: origin.x, y: origin.y };
  const a4 = { x: origin.x - t22.base, y: origin.y };
  const c6 = { x: origin.x - t22.base / 2, y: origin.y - h5 };
  return { a: a4, b: b4, c: c6 };
};
var fromC2 = (t22, origin) => {
  if (!origin) origin = Object.freeze({ x: 0, y: 0 });
  const h5 = height3(t22);
  const c6 = { x: origin.x, y: origin.y };
  const a4 = { x: origin.x - t22.base / 2, y: origin.y + h5 };
  const b4 = { x: origin.x + t22.base / 2, y: origin.y + h5 };
  return { a: a4, b: b4, c: c6 };
};
var piPi7 = Math.PI * 2;
var Empty4 = Object.freeze({
  a: { x: 0, y: 0 },
  b: { x: 0, y: 0 },
  c: { x: 0, y: 0 }
});
var Placeholder4 = Object.freeze({
  a: { x: Number.NaN, y: Number.NaN },
  b: { x: Number.NaN, y: Number.NaN },
  c: { x: Number.NaN, y: Number.NaN }
});
var isEmpty4 = (t22) => isEmpty3(t22.a) && isEmpty3(t22.b) && isEmpty3(t22.c);
var isPlaceholder4 = (t22) => isPlaceholder(t22.a) && isPlaceholder(t22.b) && isPlaceholder(t22.c);
var apply4 = (t22, fn2) => Object.freeze({
  ...t22,
  a: fn2(t22.a, `a`),
  b: fn2(t22.b, `b`),
  c: fn2(t22.c, `c`)
});
var isTriangle = (p4) => {
  if (p4 === void 0) return false;
  const tri = p4;
  if (!isPoint(tri.a)) return false;
  if (!isPoint(tri.b)) return false;
  if (!isPoint(tri.c)) return false;
  return true;
};
var isEqual7 = (a4, b4) => isEqual(a4.a, b4.a) && isEqual(a4.b, b4.b) && isEqual(a4.c, b4.c);
var corners2 = (t22) => {
  guard7(t22);
  return [t22.a, t22.b, t22.c];
};
var lengths2 = (t22) => {
  guard7(t22);
  return [
    distance3(t22.a, t22.b),
    distance3(t22.b, t22.c),
    distance3(t22.c, t22.a)
  ];
};
var angles = (t22) => {
  guard7(t22);
  return [
    angleRadian(t22.a, t22.b),
    angleRadian(t22.b, t22.c),
    angleRadian(t22.c, t22.a)
  ];
};
var anglesDegrees = (t22) => {
  guard7(t22);
  return radianToDegree(angles(t22));
};
var isEquilateral = (t22) => {
  guard7(t22);
  const [a4, b4, c6] = lengths2(t22);
  return a4 === b4 && b4 === c6;
};
var isIsosceles = (t22) => {
  const [a4, b4, c6] = lengths2(t22);
  if (a4 === b4) return true;
  if (b4 === c6) return true;
  if (c6 === a4) return true;
  return false;
};
var isRightAngle = (t22) => angles(t22).includes(Math.PI / 2);
var isOblique = (t22) => !isRightAngle(t22);
var isAcute = (t22) => !angles(t22).some((v3) => v3 >= Math.PI / 2);
var isObtuse = (t22) => angles(t22).some((v3) => v3 > Math.PI / 2);
var fromRadius = (origin, radius, opts = {}) => {
  throwNumberTest(radius, `positive`, `radius`);
  guard(origin, `origin`);
  const initialAngleRadian = opts.initialAngleRadian ?? 0;
  const angles2 = [
    initialAngleRadian,
    initialAngleRadian + piPi7 * 1 / 3,
    initialAngleRadian + piPi7 * 2 / 3
  ];
  const points = angles2.map((a4) => toCartesian(radius, a4, origin));
  return fromPoints3(points);
};
var rotateByVertex = (triangle2, amountRadian, vertex = `b`) => {
  const origin = vertex === `a` ? triangle2.a : vertex === `b` ? triangle2.b : triangle2.c;
  return Object.freeze({
    a: rotate2(triangle2.a, amountRadian, origin),
    b: rotate2(triangle2.b, amountRadian, origin),
    c: rotate2(triangle2.c, amountRadian, origin)
  });
};
var equilateralFromVertex = (origin, length5 = 10, angleRadian3 = Math.PI / 2) => {
  if (!origin) origin = Object.freeze({ x: 0, y: 0 });
  const a4 = project(origin, length5, Math.PI - -angleRadian3 / 2);
  const c6 = project(origin, length5, Math.PI - angleRadian3 / 2);
  return { a: a4, b: origin, c: c6 };
};
var toFlatArray2 = (t22) => {
  guard7(t22);
  return [t22.a.x, t22.a.y, t22.b.x, t22.b.y, t22.c.x, t22.c.y];
};
var fromFlatArray2 = (coords) => {
  if (!Array.isArray(coords)) throw new Error(`coords expected as array`);
  if (coords.length !== 6) {
    throw new Error(
      `coords array expected with 6 elements. Got ${coords.length}`
    );
  }
  return fromPoints3(fromNumbers2(...coords));
};
var fromPoints3 = (points) => {
  if (!Array.isArray(points)) throw new Error(`points expected as array`);
  if (points.length !== 3) {
    throw new Error(
      `points array expected with 3 elements. Got ${points.length}`
    );
  }
  const t22 = {
    a: points[0],
    b: points[1],
    c: points[2]
  };
  return t22;
};
var bbox6 = (t22, inflation = 0) => {
  const { a: a4, b: b4, c: c6 } = t22;
  const xMin = Math.min(a4.x, b4.x, c6.x) - inflation;
  const xMax = Math.max(a4.x, b4.x, c6.x) + inflation;
  const yMin = Math.min(a4.y, b4.y, c6.y) - inflation;
  const yMax = Math.max(a4.y, b4.y, c6.y) + inflation;
  const r5 = {
    x: xMin,
    y: yMin,
    width: xMax - xMin,
    height: yMax - yMin
  };
  return r5;
};
var barycentricCoord = (t22, a4, b4) => {
  const pt2 = getPointParameter2(a4, b4);
  const ab = (x3, y3, pa2, pb) => (pa2.y - pb.y) * x3 + (pb.x - pa2.x) * y3 + pa2.x * pb.y - pb.x * pa2.y;
  const alpha = ab(pt2.x, pt2.y, t22.b, t22.c) / ab(t22.a.x, t22.a.y, t22.b, t22.c);
  const theta = ab(pt2.x, pt2.y, t22.c, t22.a) / ab(t22.b.x, t22.b.y, t22.c, t22.a);
  const gamma = ab(pt2.x, pt2.y, t22.a, t22.b) / ab(t22.c.x, t22.c.y, t22.a, t22.b);
  return {
    a: alpha,
    b: theta,
    c: gamma
  };
};
var barycentricToCartestian = (t22, bc) => {
  guard7(t22);
  const { a: a4, b: b4, c: c6 } = t22;
  const x3 = a4.x * bc.a + b4.x * bc.b + c6.x * bc.c;
  const y3 = a4.y * bc.a + b4.y * bc.b + c6.y * bc.c;
  if (a4.z && b4.z && c6.z) {
    const z3 = a4.z * bc.a + b4.z * bc.b + c6.z * bc.c;
    return Object.freeze({ x: x3, y: y3, z: z3 });
  } else {
    return Object.freeze({ x: x3, y: y3 });
  }
};
var intersectsPoint2 = (t22, a4, b4) => {
  const box = bbox6(t22);
  const pt2 = getPointParameter2(a4, b4);
  if (!intersectsPoint(box, pt2)) return false;
  const bc = barycentricCoord(t22, pt2);
  return 0 <= bc.a && bc.a <= 1 && 0 <= bc.b && bc.b <= 1 && 0 <= bc.c && bc.c <= 1;
};

// node_modules/ixfx/dist/chunk-IVYKFPJL.js
var visual_exports = {};
__export(visual_exports, {
  BipolarView: () => BipolarView_exports,
  Colour: () => Colour_exports,
  Drawing: () => Drawing_exports,
  ImageDataGrid: () => ImageDataGrid_exports,
  Palette: () => Palette_exports,
  Plot2: () => Plot2_exports,
  PlotOld: () => PlotOld_exports,
  SceneGraph: () => SceneGraph_exports,
  Svg: () => Svg_exports,
  Video: () => Video_exports,
  scaleCanvas: () => scaleCanvas
});
var Drawing_exports = {};
__export(Drawing_exports, {
  arc: () => arc,
  bezier: () => bezier,
  circle: () => circle2,
  connectedPoints: () => connectedPoints,
  copyToImg: () => copyToImg,
  dot: () => dot,
  drawingStack: () => drawingStack,
  ellipse: () => ellipse,
  getContext: () => getContext,
  line: () => line2,
  lineThroughPoints: () => lineThroughPoints,
  makeHelper: () => makeHelper2,
  paths: () => paths,
  pointLabels: () => pointLabels,
  rect: () => rect,
  textBlock: () => textBlock,
  textBlockAligned: () => textBlockAligned,
  textHeight: () => textHeight,
  textRect: () => textRect,
  textWidth: () => textWidth,
  translatePoint: () => translatePoint,
  triangle: () => triangle
});
var PIPI = Math.PI * 2;
var getContext = (canvasElementContextOrQuery) => {
  if (canvasElementContextOrQuery === null) {
    throw new Error(
      `canvasElCtxOrQuery null. Must be a 2d drawing context or Canvas element`
    );
  }
  if (canvasElementContextOrQuery === void 0) {
    throw new Error(
      `canvasElCtxOrQuery undefined. Must be a 2d drawing context or Canvas element`
    );
  }
  const ctx = canvasElementContextOrQuery instanceof CanvasRenderingContext2D ? canvasElementContextOrQuery : canvasElementContextOrQuery instanceof HTMLCanvasElement ? canvasElementContextOrQuery.getContext(`2d`) : typeof canvasElementContextOrQuery === `string` ? resolveEl(canvasElementContextOrQuery).getContext(`2d`) : canvasElementContextOrQuery;
  if (ctx === null) throw new Error(`Could not create 2d context for canvas`);
  return ctx;
};
var makeHelper2 = (ctxOrCanvasEl, canvasBounds) => {
  const ctx = getContext(ctxOrCanvasEl);
  return {
    ctx,
    paths(pathsToDraw, opts) {
      paths(ctx, pathsToDraw, opts);
    },
    line(lineToDraw, opts) {
      line2(ctx, lineToDraw, opts);
    },
    rect(rectsToDraw, opts) {
      rect(ctx, rectsToDraw, opts);
    },
    bezier(bezierToDraw, opts) {
      bezier(ctx, bezierToDraw, opts);
    },
    connectedPoints(pointsToDraw, opts) {
      connectedPoints(ctx, pointsToDraw, opts);
    },
    pointLabels(pointsToDraw, opts) {
      pointLabels(ctx, pointsToDraw, opts);
    },
    dot(dotPosition, opts) {
      dot(ctx, dotPosition, opts);
    },
    circle(circlesToDraw, opts) {
      circle2(ctx, circlesToDraw, opts);
    },
    arc(arcsToDraw, opts) {
      arc(ctx, arcsToDraw, opts);
    },
    textBlock(lines, opts) {
      if (opts.bounds === void 0 && canvasBounds !== void 0) {
        opts = { ...opts, bounds: { ...canvasBounds, x: 0, y: 0 } };
      }
      textBlock(ctx, lines, opts);
    }
  };
};
var optsOp = (opts) => coloringOp(opts.strokeStyle, opts.fillStyle);
var applyOpts2 = (ctx, opts = {}, ...additionalOps) => {
  if (ctx === void 0) throw new Error(`ctx undefined`);
  const stack = drawingStack(ctx).push(optsOp(opts), ...additionalOps);
  stack.apply();
  return stack;
};
var arc = (ctx, arcs, opts = {}) => {
  applyOpts2(ctx, opts);
  const draw2 = (arc2) => {
    ctx.beginPath();
    ctx.arc(arc2.x, arc2.y, arc2.radius, arc2.startRadian, arc2.endRadian);
    ctx.stroke();
  };
  const arcsArray = Array.isArray(arcs) ? arcs : [arcs];
  for (const arc2 of arcsArray) {
    draw2(arc2);
  }
};
var coloringOp = (strokeStyle, fillStyle) => {
  const apply5 = (ctx) => {
    if (fillStyle) ctx.fillStyle = fillStyle;
    if (strokeStyle) ctx.strokeStyle = strokeStyle;
  };
  return apply5;
};
var lineOp = (lineWidth, lineJoin, lineCap) => {
  const apply5 = (ctx) => {
    if (lineWidth) ctx.lineWidth = lineWidth;
    if (lineJoin) ctx.lineJoin = lineJoin;
    if (lineCap) ctx.lineCap = lineCap;
  };
  return apply5;
};
var drawingStack = (ctx, stk) => {
  if (stk === void 0) stk = new StackImmutable();
  const push2 = (...ops) => {
    if (stk === void 0) stk = new StackImmutable();
    const s3 = stk.push(...ops);
    for (const o5 of ops) o5(ctx);
    return drawingStack(ctx, s3);
  };
  const pop2 = () => {
    const s3 = stk?.pop();
    return drawingStack(ctx, s3);
  };
  const apply5 = () => {
    if (stk === void 0) return drawingStack(ctx);
    for (const op of stk.data) op(ctx);
    return drawingStack(ctx, stk);
  };
  return { push: push2, pop: pop2, apply: apply5 };
};
var lineThroughPoints = (ctx, points, opts) => {
  applyOpts2(ctx, opts);
  ctx.moveTo(points[0].x, points[0].y);
  for (const [index, p4] of points.entries()) {
    if (index + 2 >= points.length) continue;
    const pNext = points[index + 1];
    const mid = {
      x: (p4.x + pNext.x) / 2,
      y: (p4.y + pNext.y) / 2
    };
    const cpX1 = (mid.x + p4.x) / 2;
    const cpX2 = (mid.x + pNext.x) / 2;
    ctx.quadraticCurveTo(cpX1, pNext.y, mid.x, mid.y);
    ctx.quadraticCurveTo(cpX2, pNext.y, pNext.x, pNext.y);
  }
};
var circle2 = (ctx, circlesToDraw, opts = {}) => {
  applyOpts2(ctx, opts);
  const draw2 = (c6) => {
    ctx.beginPath();
    ctx.arc(c6.x, c6.y, c6.radius, 0, PIPI);
    if (opts.strokeStyle) ctx.stroke();
    if (opts.fillStyle) ctx.fill();
  };
  if (Array.isArray(circlesToDraw)) {
    for (const c6 of circlesToDraw) draw2(c6);
  } else {
    draw2(circlesToDraw);
  }
};
var ellipse = (ctx, ellipsesToDraw, opts = {}) => {
  applyOpts2(ctx, opts);
  const draw2 = (ellipse2) => {
    ctx.beginPath();
    const rotation = ellipse2.rotation ?? 0;
    const startAngle = ellipse2.startAngle ?? 0;
    const endAngle = ellipse2.endAngle ?? PIPI;
    ctx.ellipse(ellipse2.x, ellipse2.y, ellipse2.radiusX, ellipse2.radiusY, rotation, startAngle, endAngle);
    if (opts.strokeStyle) ctx.stroke();
    if (opts.fillStyle) ctx.fill();
  };
  const ellipsesArray = Array.isArray(ellipsesToDraw) ? ellipsesToDraw : [ellipsesToDraw];
  for (const ellipse2 of ellipsesArray) {
    draw2(ellipse2);
  }
};
var paths = (ctx, pathsToDraw, opts = {}) => {
  applyOpts2(ctx, opts);
  const draw2 = (path2) => {
    if (isQuadraticBezier(path2)) quadraticBezier(ctx, path2, opts);
    else if (isLine(path2)) line2(ctx, path2, opts);
    else throw new Error(`Unknown path type ${JSON.stringify(path2)}`);
  };
  if (Array.isArray(pathsToDraw)) {
    for (const p4 of pathsToDraw) draw2(p4);
  } else {
    draw2(pathsToDraw);
  }
};
var connectedPoints = (ctx, pts, opts = {}) => {
  const shouldLoop = opts.loop ?? false;
  throwArrayTest(pts);
  if (pts.length === 0) return;
  for (const [index, pt2] of pts.entries()) guard(pt2, `Index ${index}`);
  applyOpts2(ctx, opts);
  if (opts.lineWidth) ctx.lineWidth = opts.lineWidth;
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for (const pt2 of pts) ctx.lineTo(pt2.x, pt2.y);
  if (shouldLoop) ctx.lineTo(pts[0].x, pts[0].y);
  if (opts.strokeStyle || opts.strokeStyle === void 0 && opts.fillStyle === void 0) {
    ctx.stroke();
  }
  if (opts.fillStyle) {
    ctx.fill();
  }
};
var pointLabels = (ctx, pts, opts = {}, labels) => {
  if (pts.length === 0) return;
  for (const [index, pt2] of pts.entries()) guard(pt2, `Index ${index}`);
  applyOpts2(ctx, opts);
  for (const [index, pt2] of pts.entries()) {
    const label = labels !== void 0 && index < labels.length ? labels[index] : index.toString();
    ctx.fillText(label.toString(), pt2.x, pt2.y);
  }
};
var translatePoint = (ctx, point2) => {
  const m5 = ctx.getTransform();
  return {
    x: point2.x * m5.a + point2.y * m5.c + m5.e,
    y: point2.x * m5.b + point2.y * m5.d + m5.f
  };
};
var copyToImg = (canvasEl) => {
  const img = document.createElement(`img`);
  img.src = canvasEl.toDataURL(`image/jpeg`);
  return img;
};
var dot = (ctx, pos, opts) => {
  if (opts === void 0) opts = {};
  const radius = opts.radius ?? 10;
  const positions = Array.isArray(pos) ? pos : [pos];
  let stroke = opts.stroke ? opts.stroke : opts.strokeStyle !== void 0;
  let filled = opts.filled ? opts.filled : opts.fillStyle !== void 0;
  if (!stroke && !filled) filled = true;
  applyOpts2(ctx, opts);
  for (const pos2 of positions) {
    ctx.beginPath();
    if (`radius` in pos2) {
      ctx.arc(pos2.x, pos2.y, pos2.radius, 0, 2 * Math.PI);
    } else {
      ctx.arc(pos2.x, pos2.y, radius, 0, 2 * Math.PI);
    }
    if (filled) {
      ctx.fill();
    }
    if (stroke) {
      ctx.stroke();
    }
  }
};
var bezier = (ctx, bezierToDraw, opts) => {
  if (isQuadraticBezier(bezierToDraw)) {
    quadraticBezier(ctx, bezierToDraw, opts);
  } else if (isCubicBezier(bezierToDraw)) {
    cubicBezier(ctx, bezierToDraw, opts);
  }
};
var cubicBezier = (ctx, bezierToDraw, opts = {}) => {
  let stack = applyOpts2(ctx, opts);
  const { a: a4, b: b4, cubic1, cubic2 } = bezierToDraw;
  const isDebug = opts.debug ?? false;
  if (isDebug) {
  }
  ctx.beginPath();
  ctx.moveTo(a4.x, a4.y);
  ctx.bezierCurveTo(cubic1.x, cubic1.y, cubic2.x, cubic2.y, b4.x, b4.y);
  ctx.stroke();
  if (isDebug) {
    stack = stack.push(
      optsOp({
        ...opts,
        strokeStyle: opacity(opts.strokeStyle ?? `silver`, 0.6),
        fillStyle: opacity(opts.fillStyle ?? `yellow`, 0.4)
      })
    );
    stack.apply();
    ctx.moveTo(a4.x, a4.y);
    ctx.lineTo(cubic1.x, cubic1.y);
    ctx.stroke();
    ctx.moveTo(b4.x, b4.y);
    ctx.lineTo(cubic2.x, cubic2.y);
    ctx.stroke();
    ctx.fillText(`a`, a4.x + 5, a4.y);
    ctx.fillText(`b`, b4.x + 5, b4.y);
    ctx.fillText(`c1`, cubic1.x + 5, cubic1.y);
    ctx.fillText(`c2`, cubic2.x + 5, cubic2.y);
    dot(ctx, cubic1, { radius: 3 });
    dot(ctx, cubic2, { radius: 3 });
    dot(ctx, a4, { radius: 3 });
    dot(ctx, b4, { radius: 3 });
    stack = stack.pop();
    stack.apply();
  }
};
var quadraticBezier = (ctx, bezierToDraw, opts = {}) => {
  const { a: a4, b: b4, quadratic: quadratic2 } = bezierToDraw;
  const isDebug = opts.debug ?? false;
  let stack = applyOpts2(ctx, opts);
  ctx.beginPath();
  ctx.moveTo(a4.x, a4.y);
  ctx.quadraticCurveTo(quadratic2.x, quadratic2.y, b4.x, b4.y);
  ctx.stroke();
  if (isDebug) {
    stack = stack.push(
      optsOp({
        ...opts,
        strokeStyle: opacity(opts.strokeStyle ?? `silver`, 0.6),
        fillStyle: opacity(opts.fillStyle ?? `yellow`, 0.4)
      })
    );
    connectedPoints(ctx, [a4, quadratic2, b4]);
    ctx.fillText(`a`, a4.x + 5, a4.y);
    ctx.fillText(`b`, b4.x + 5, b4.y);
    ctx.fillText(`h`, quadratic2.x + 5, quadratic2.y);
    dot(ctx, quadratic2, { radius: 3 });
    dot(ctx, a4, { radius: 3 });
    dot(ctx, b4, { radius: 3 });
    stack = stack.pop();
    stack.apply();
  }
};
var line2 = (ctx, toDraw, opts = {}) => {
  const isDebug = opts.debug ?? false;
  const o5 = lineOp(opts.lineWidth, opts.lineJoin, opts.lineCap);
  applyOpts2(ctx, opts, o5);
  const draw2 = (d4) => {
    const { a: a4, b: b4 } = d4;
    ctx.beginPath();
    ctx.moveTo(a4.x, a4.y);
    ctx.lineTo(b4.x, b4.y);
    if (isDebug) {
      ctx.fillText(`a`, a4.x, a4.y);
      ctx.fillText(`b`, b4.x, b4.y);
      dot(ctx, a4, { radius: 5, strokeStyle: `black` });
      dot(ctx, b4, { radius: 5, strokeStyle: `black` });
    }
    ctx.stroke();
  };
  if (Array.isArray(toDraw)) {
    for (const t6 of toDraw) draw2(t6);
  } else {
    draw2(toDraw);
  }
};
var triangle = (ctx, toDraw, opts = {}) => {
  applyOpts2(ctx, opts);
  const draw2 = (t6) => {
    connectedPoints(ctx, corners2(t6), { ...opts, loop: true });
    if (opts.debug) {
      pointLabels(ctx, corners2(t6), void 0, [`a`, `b`, `c`]);
    }
  };
  if (Array.isArray(toDraw)) {
    for (const t6 of toDraw) {
      draw2(t6);
    }
  } else {
    draw2(toDraw);
  }
};
var rect = (ctx, toDraw, opts = {}) => {
  applyOpts2(ctx, opts);
  const filled = opts.filled ?? (opts.fillStyle === void 0 ? false : true);
  const stroke = opts.stroke ?? (opts.strokeStyle === void 0 ? false : true);
  const draw2 = (d4) => {
    const x3 = `x` in d4 ? d4.x : 0;
    const y3 = `y` in d4 ? d4.y : 0;
    if (filled) ctx.fillRect(x3, y3, d4.width, d4.height);
    if (stroke) {
      if (opts.strokeWidth) ctx.lineWidth = opts.strokeWidth;
      ctx.strokeRect(x3, y3, d4.width, d4.height);
    }
    if (opts.debug) {
      pointLabels(ctx, corners(d4), void 0, [`NW`, `NE`, `SE`, `SW`]);
    }
  };
  if (Array.isArray(toDraw)) {
    for (const t6 of toDraw) {
      draw2(t6);
    }
  } else {
    draw2(toDraw);
  }
};
var textWidth = (ctx, text2, padding = 0, widthMultiple) => {
  const rect2 = textRect(ctx, text2, padding, widthMultiple);
  return rect2.width;
};
var textRect = (ctx, text2, padding = 0, widthMultiple) => {
  if (text2 === void 0 || text2 === null || text2.length === 0) return Empty3;
  const m5 = ctx.measureText(text2);
  const width = widthMultiple ? quantiseEvery(m5.width, widthMultiple) + padding : m5.width + padding;
  return {
    width,
    height: m5.actualBoundingBoxAscent + m5.actualBoundingBoxDescent + padding + padding
  };
};
var textHeight = (ctx, text2, padding = 0) => {
  const rect2 = textRect(ctx, text2, padding);
  return rect2.height;
};
var textBlock = (ctx, lines, opts) => {
  applyOpts2(ctx, opts);
  const anchorPadding = opts.anchorPadding ?? 0;
  const anchor = opts.anchor;
  const bounds = opts.bounds ?? { x: 0, y: 0, width: 1e6, height: 1e6 };
  const blocks = lines.map((l3) => ctx.measureText(l3));
  const widths = blocks.map((tm) => tm.width);
  const heights = blocks.map(
    (tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent
  );
  const maxWidth = Math.max(...widths);
  const totalHeight = heights.reduce((accumulator, value2) => accumulator + value2, 0);
  let { x: x3, y: y3 } = anchor;
  if (anchor.x + maxWidth > bounds.width) {
    x3 = bounds.width - (maxWidth + anchorPadding);
  } else x3 -= anchorPadding;
  if (x3 < bounds.x) x3 = bounds.x + anchorPadding;
  if (anchor.y + totalHeight > bounds.height) {
    y3 = bounds.height - (totalHeight + anchorPadding);
  } else y3 -= anchorPadding;
  if (y3 < bounds.y) y3 = bounds.y + anchorPadding;
  for (const [index, line22] of lines.entries()) {
    ctx.fillText(line22, x3, y3);
    y3 += heights[index];
  }
};
var textBlockAligned = (ctx, text2, opts) => {
  const { bounds } = opts;
  const { horiz = `left`, vert = `top` } = opts;
  const lines = typeof text2 === `string` ? [text2] : text2;
  applyOpts2(ctx, opts);
  ctx.save();
  ctx.translate(bounds.x, bounds.y);
  ctx.textAlign = `left`;
  ctx.textBaseline = `top`;
  const middleX = bounds.width / 2;
  const middleY = bounds.height / 2;
  const blocks = lines.map((l3) => ctx.measureText(l3));
  const heights = blocks.map(
    (tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent
  );
  const totalHeight = heights.reduce((accumulator, value2) => accumulator + value2, 0);
  let y3 = 0;
  if (vert === `center`) y3 = middleY - totalHeight / 2;
  else if (vert === `bottom`) {
    y3 = bounds.height - totalHeight;
  }
  for (const [index, line22] of lines.entries()) {
    let x3 = 0;
    if (horiz === `center`) x3 = middleX - blocks[index].width / 2;
    else if (horiz === `right`) x3 = bounds.width - blocks[index].width;
    ctx.fillText(line22, x3, y3);
    y3 += heights[index];
  }
  ctx.restore();
};
var Plot2_exports = {};
__export(Plot2_exports, {
  AxisX: () => AxisX,
  AxisY: () => AxisY,
  Legend: () => Legend,
  Plot: () => Plot,
  PlotArea: () => PlotArea,
  Series: () => Series
});
var SceneGraph_exports = {};
__export(SceneGraph_exports, {
  Box: () => Box,
  CanvasBox: () => CanvasBox,
  CanvasLayoutState: () => CanvasLayoutState,
  CanvasMeasureState: () => CanvasMeasureState,
  LayoutState: () => LayoutState,
  MeasureState: () => MeasureState,
  boxRectFromPx: () => boxRectFromPx,
  boxRectFromRectPx: () => boxRectFromRectPx,
  boxUnitFromPx: () => boxUnitFromPx
});
var clamp3 = (value2, maximum) => {
  return Object.freeze({
    ...value2,
    width: Math.min(value2.width, maximum.width),
    height: Math.min(value2.height, maximum.height)
  });
};
var boxUnitFromPx = (v3) => {
  return { type: `px`, value: v3 };
};
var boxRectFromPx = (x3, y3, width, height4) => {
  return {
    x: boxUnitFromPx(x3),
    y: boxUnitFromPx(y3),
    width: boxUnitFromPx(width),
    height: boxUnitFromPx(height4)
  };
};
var boxRectFromRectPx = (r5) => {
  return {
    x: boxUnitFromPx(r5.x),
    y: boxUnitFromPx(r5.y),
    width: boxUnitFromPx(r5.width),
    height: boxUnitFromPx(r5.height)
  };
};
var unitIsEqual = (a4, b4) => {
  if (a4.type === `px` && b4.type === `px`) {
    return a4.value === b4.value;
  }
  return false;
};
var boxRectIsEqual = (a4, b4) => {
  if (a4 === void 0 && b4 === void 0) return true;
  if (a4 === void 0) return false;
  if (b4 === void 0) return false;
  if (a4.x && b4.x && !unitIsEqual(a4.x, b4.x)) return false;
  if (a4.y && b4.y && !unitIsEqual(a4.y, b4.y)) return false;
  if (a4.width && b4.width && !unitIsEqual(a4.width, b4.width)) return false;
  if (a4.height && b4.height && !unitIsEqual(a4.height, b4.height)) return false;
  return true;
};
var BaseState = class {
  constructor(bounds) {
    this.bounds = bounds;
    this.pass = 0;
  }
  resolveToPx(u3, maxValue, defaultValue) {
    if (u3 === void 0 && defaultValue !== void 0) return defaultValue;
    if (u3 === void 0) return;
    if (u3.type === void 0) throw new TypeError(`Expected 'type' and 'value' fields. Type is missing`);
    if (u3.value === void 0) throw new TypeError(`Expected 'type' and 'value' fields. Value is missing`);
    if (u3.type === `px`) return u3.value;
    if (u3.type === `pc`) return u3.value * maxValue;
    throw new Error(`Unknown unit type: ${u3.type}`);
  }
  resolveBox(box) {
    if (box === void 0) return void 0;
    const x3 = this.resolveToPx(box.x, this.bounds.width);
    const y3 = this.resolveToPx(box.y, this.bounds.height);
    const width = this.resolveToPx(box.width, this.bounds.width);
    const height4 = this.resolveToPx(box.height, this.bounds.height);
    if (!width || !height4) throw new TypeError(`Expected width and height`);
    if (x3 === void 0 && y3 === void 0) {
      return Object.freeze({ width, height: height4 });
    } else {
      if (!x3 || !y3) throw new TypeError(`Expected x and y`);
      return Object.freeze({
        x: x3,
        y: y3,
        width,
        height: height4
      });
    }
  }
};
var MeasureState = class extends BaseState {
  constructor(bounds) {
    super(bounds);
    this.measurements = /* @__PURE__ */ new Map();
  }
  getActualSize(id) {
    const s3 = this.measurements.get(id);
    if (s3 === void 0) return;
    if (isPlaceholder2(s3.actual)) return;
    return s3.actual;
  }
  whatIsMeasured() {
    return [...this.measurements.keys()];
  }
};
var LayoutState = class extends BaseState {
  constructor(bounds) {
    super(bounds);
    this.layouts = /* @__PURE__ */ new Map();
  }
};
var Box = class {
  /**
   * Constructor.
   * 
   * If `parent` is provided, `parent.onChildAdded(this)` is called.
   * @param parent parent box 
   * @param id id of this box
   */
  constructor(parent, id) {
    this.canvasRegion = PlaceholderPositioned;
    this.children = [];
    this._idMap = /* @__PURE__ */ new Map();
    this.debugLayout = false;
    this._visible = true;
    this._ready = true;
    this.takesSpaceWhenInvisible = false;
    this._needsMeasuring = true;
    this._needsLayoutX = true;
    this._needsDrawing = true;
    this.debugHue = randomHue();
    this.id = id;
    this._parent = parent;
    parent?.onChildAdded(this);
  }
  /**
   * Returns _true_ if `box` is a child
   * @param box 
   * @returns 
   */
  hasChild(box) {
    const byReference = this.children.find((c6) => c6 === box);
    const byId = this.children.find((c6) => c6.id === box.id);
    return byReference !== void 0 || byId !== void 0;
  }
  /**
   * Sends a message to all child boxes.
   * 
   * This first calls `onNotify` on this instance,
   * before calling `notify()` on each child.
   * @param message 
   * @param source 
   */
  notify(message, source) {
    this.onNotify(message, source);
    for (const c6 of this.children) c6.notify(message, source);
  }
  *getChildren() {
    return this.children.entries();
  }
  /**
   * Handles a received message
   * @param _message 
   * @param _source 
   */
  onNotify(_message, _source) {
  }
  /**
   * Notification a child box has been added
   * 
   * Throws if
   * - child has parent as its own child
   * - child is same as this
   * - child is already child of this
   * @param child 
   */
  onChildAdded(child) {
    if (child.hasChild(this)) throw new Error(`Recursive`);
    if (child === this) throw new Error(`Cannot add self as child`);
    if (this.hasChild(child)) throw new Error(`Child already present`);
    this.children.push(child);
    this._idMap.set(child.id, child);
    this.layoutInvalidated(`Box.onChildAdded`);
  }
  /**
   * Sets `_ready` to `ready`. If `includeChildren` is _true_,
   * `setReady` is called on each child
   * @param ready 
   * @param includeChildren 
   */
  setReady(ready, includeChildren = false) {
    this._ready = ready;
    if (includeChildren) {
      for (const c6 of this.children) c6.setReady(ready, includeChildren);
    }
  }
  /**
   * Gets visible state
   */
  get visible() {
    return this._visible;
  }
  /**
   * Sets visible state
   */
  set visible(v3) {
    if (this._visible === v3) return;
    this._visible = v3;
    this.layoutInvalidated(`Box.set visible`);
  }
  /**
   * Gets the box's desired region, or _undefined_
   */
  get desiredRegion() {
    return this._desiredRect;
  }
  /**
   * Sets the box's desired region.
   * Calls `onLayoutNeeded()`
   */
  set desiredRegion(v3) {
    if (boxRectIsEqual(v3, this._desiredRect)) return;
    this._desiredRect = v3;
    this.layoutInvalidated(`set desiredRegion`);
  }
  /**
   * Calls `notifyChildLayoutNeeded`
   */
  layoutInvalidated(reason) {
    if (reason === void 0) debugger;
    this.debugLog(`layoutInvalidated ${reason}`);
    this._needsMeasuring = true;
    this._needsLayoutX = true;
    this._needsDrawing = true;
    this.notifyChildLayoutNeeded();
  }
  drawingInvalidated(_reason) {
    this._needsDrawing = true;
  }
  /**
   * Called from a child, notifying us that
   * its layout has changed
   * @returns 
   */
  notifyChildLayoutNeeded() {
    this._needsDrawing = true;
    this._needsLayoutX = true;
    this._needsMeasuring = true;
    if (this._parent === void 0) return;
    this._parent.notifyChildLayoutNeeded();
  }
  /**
   * Returns the root box
   */
  get root() {
    if (this._parent === void 0) return this;
    return this._parent.root;
  }
  /**
   * Prepare for measuring
   */
  measurePreflight() {
  }
  /**
   * Applies actual size, returning _true_ if size is different than before
   * 
   * 1. Sets `_needsLayout` to _false_.
   * 2. Sets `visual` to `m`
   * 3. Calls `measureApply` on each child
   * 4. If there's a change or `force`, sets `needsDrawing` to _true_, and notifies root of `measureApplied`
   * @param m Measurement for box
   * @returns 
   */
  measureApply(m5) {
    this._needsMeasuring = false;
    const different = this._measuredSize === void 0 ? true : !isEqualSize(m5.actual, this._measuredSize);
    if (different) {
      this._needsLayoutX = true;
    }
    this._measuredSize = { width: m5.actual.width, height: m5.actual.height };
    for (const c6 of m5.children) {
      if (c6 !== void 0) c6.ref.measureApply(c6);
    }
    if (different) {
      this.root.notify(`measureApplied`, this);
    }
    return different;
  }
  layoutApply(l3) {
    this._needsLayoutX = false;
    const different = this._layoutPosition === void 0 ? true : !isEqual(l3.actual, this._layoutPosition);
    this._layoutPosition = { x: l3.actual.x, y: l3.actual.y };
    for (const c6 of l3.children) {
      if (c6 !== void 0) c6.ref.layoutApply(c6);
    }
    if (different) {
      this.root.notify(`layoutApplied`, this);
    }
    return different;
  }
  /**
   * Debug log from this box context
   * @param m 
   */
  debugLog(m5) {
    if (!this.debugLayout) return;
    console.log(`SceneGraph[${this.id}]`, m5);
  }
  layoutStart(measureState, layoutState, force, parent) {
    const m5 = {
      ref: this,
      actual: Empty,
      children: []
    };
    layoutState.layouts.set(this.id, m5);
    const currentPosition = this.layoutSelf(measureState, layoutState, parent);
    this.root.notify(`laidout`, this);
    if (currentPosition === void 0) return;
    m5.actual = currentPosition;
    m5.children = this.children.map((c6) => c6.layoutStart(measureState, layoutState, force, m5));
    if (withoutUndefined(m5.children).length < this.children.length) {
      return void 0;
    }
    return m5;
  }
  layoutSelf(measureState, layoutState, _parent) {
    const box = layoutState.resolveBox(this._desiredRect);
    const x3 = box === void 0 ? 0 : `x` in box ? box.x : 0;
    const y3 = box === void 0 ? 0 : `y` in box ? box.y : 0;
    if (x3 === void 0) debugger;
    if (y3 === void 0) debugger;
    return { x: x3, y: y3 };
  }
  /**
   * Start of measuring
   * 1. Keeps track of measurements in `opts.measurements`
   * 2. If this box takes space
   * 2.1. Measure itself if needed
   * 2.2. Use size
   * 2. Calls `measureStart` on each child
   * @param opts Options
   * @param force Force measurement
   * @param parent Parent's measurement 
   * @returns Measurement
   */
  measureStart(opts, force, parent) {
    this.measurePreflight();
    const m5 = {
      ref: this,
      // So far no known measurement
      actual: Placeholder3,
      children: []
    };
    opts.measurements.set(this.id, m5);
    if (!this._visible && !this.takesSpaceWhenInvisible) {
      m5.actual = EmptyPositioned;
    } else {
      let currentMeasurement = this._measuredSize;
      if (this._needsMeasuring || this._measuredSize === void 0) {
        currentMeasurement = this.measureSelf(opts, parent);
        this.root.notify(`measured`, this);
      }
      if (typeof currentMeasurement === `string`) {
        return;
      } else if (currentMeasurement === void 0) {
        return;
      }
      m5.actual = currentMeasurement;
    }
    m5.children = this.children.map((c6) => c6.measureStart(opts, force, m5));
    if (withoutUndefined(m5.children).length < this.children.length) {
      return void 0;
    }
    return m5;
  }
  /**
   * Measure the box
   * 1. Uses desired rectangle, if possible
   * 2. Otherwise uses parent's size
   * @param opts Measure state
   * @param parent Parent size
   * @returns 
   */
  measureSelf(opts, parent) {
    let size = Placeholder3;
    const context = parent ? parent.actual : opts.bounds;
    const desired = opts.resolveBox(this._desiredRect);
    size = desired ? clamp3(desired, context) : context;
    if (isPlaceholder2(size)) {
      return `Box.measureSelf - No size for box?`;
    }
    return size;
  }
  // protected updateDone(state: MeasureState, force: boolean): void {
  //   this.onUpdateDone(state, force);
  //   for (const c of this.children) c.updateDone(state, force);
  // }
  /**
   * Update has completed
   * @param state 
   * @param force 
   */
  //abstract onUpdateDone(state: MeasureState, force: boolean): void;
  /**
   * Update
   * 1. Calls `this.updateBegin()` to initialise measurement state
   * 2. In a loop, run `measureStart()` and then `measureApply` if possible
   * 3. Call `updateDone` when finished
   * @param force Force update
   * @returns 
   */
  update(context, force = false) {
    if (context === void 0) throw new Error(`context is undefined`);
    if (!this._needsMeasuring && !this._needsLayoutX && !force) return;
    const [measureState, layoutState] = this.updateBegin(context);
    let attempts = 5;
    let measureApplied = false;
    let layoutApplied = false;
    if (this._needsMeasuring || force) {
      while (attempts--) {
        const m5 = this.measureStart(measureState, force);
        if (m5 !== void 0) {
          this.measureApply(m5);
          if (!this._ready) return;
          measureApplied = true;
        }
      }
      if (!measureApplied) this.debugLog(`Ran out of measurement attempts`);
    }
    if (this._needsLayoutX || force) {
      const p4 = this.layoutStart(measureState, layoutState, force);
      if (p4 === void 0) {
        this.debugLog(`Warning: could not layout`);
      } else {
        this.layoutApply(p4);
        layoutApplied = true;
      }
    }
    this.updateComplete(measureApplied, layoutApplied);
  }
};
var CanvasMeasureState = class extends MeasureState {
  constructor(bounds, ctx) {
    super(bounds);
    this.ctx = ctx;
    if (ctx === void 0) throw new Error(`ctx is undefined`);
  }
};
var CanvasLayoutState = class extends LayoutState {
  constructor(bounds, ctx) {
    super(bounds);
    this.ctx = ctx;
    if (ctx === void 0) throw new Error(`ctx is undefined`);
  }
};
var CanvasBox = class _CanvasBox extends Box {
  constructor(parent, id, bounds) {
    super(parent, id);
    this.bounds = bounds;
    this.debugLog(`CanvasBox ctor bounds: ${JSON.stringify(bounds)}`);
  }
  static fromCanvas(canvasElement) {
    const box = new _CanvasBox(void 0, `canvas-box`, canvasElement.getBoundingClientRect());
    return box;
  }
  /**
   * Called if this is the parent Box
   */
  addEventHandlers(element) {
    element.addEventListener(`pointermove`, (event2) => {
      const p4 = { x: event2.offsetX, y: event2.offsetY };
      this.notifyPointerMove(p4);
    });
    element.addEventListener(`pointerleave`, (_event) => {
      this.notifyPointerLeave();
    });
    element.addEventListener(`click`, (event2) => {
      const p4 = { x: event2.offsetX, y: event2.offsetY };
      this.notifyClick(p4);
    });
  }
  onClick(_p) {
  }
  /**
   * Click event has happened on canvas
   * 1. If it's within our range, call `onClick` and pass to all children via `notifyClick`
   * @param p 
   * @returns 
   */
  notifyClick(p4) {
    if (isPlaceholder2(this.canvasRegion)) return;
    if (intersectsPoint(this.canvasRegion, p4)) {
      const pp = subtract(p4, this.canvasRegion.x, this.canvasRegion.y);
      this.onClick(pp);
      for (const c6 of this.children) c6.notifyClick(pp);
    }
  }
  /**
   * Pointer has left
   * 1. Pass notification to all children via `notifyPointerLeave`
   */
  notifyPointerLeave() {
    this.onPointerLeave();
    for (const c6 of this.children) c6.notifyPointerLeave();
  }
  /**
   * Pointer has moved
   * 1. If it's within range `onPointerMove` is called, and pass on to all children via `notifyPointerMove`
   * @param p 
   * @returns 
   */
  notifyPointerMove(p4) {
    if (isPlaceholder2(this.canvasRegion)) return;
    if (intersectsPoint(this.canvasRegion, p4)) {
      const pp = subtract(p4, this.canvasRegion.x, this.canvasRegion.y);
      this.onPointerMove(pp);
      for (const c6 of this.children) c6.notifyPointerMove(pp);
    }
  }
  /**
   * Handler when pointer has left
   */
  onPointerLeave() {
  }
  /**
   * Handler when pointer moves within our region
   * @param _p 
   */
  onPointerMove(_p) {
  }
  /**
   * Performs recalculations and drawing as necessary
   * If nothing needs to happen, function returns.
   * @param context 
   * @param force Force update
   */
  update(context, force = false) {
    super.update(context, force);
    this.draw(context, force);
  }
  getBounds() {
    return this.bounds === void 0 && this._parent ? this._parent.bounds : this.bounds;
  }
  unsetBounds() {
    this.bounds = void 0;
  }
  /**
   * Update begins.
   * @returns MeasureState
   */
  updateBegin(context) {
    if (context === void 0) throw new Error(`Context is undefined`);
    let bounds = this.getBounds();
    if (bounds === void 0) {
      this.debugLog(`No bounds for element or parent, using canvas bounds`);
      bounds = { x: 0, y: 0, width: context.canvas.width, height: context.canvas.height };
    }
    return [
      new CanvasMeasureState(bounds, context),
      new CanvasLayoutState(bounds, context)
    ];
  }
  updateComplete(_measureChanged, _layoutChanged) {
    this.canvasRegion = PlaceholderPositioned;
  }
  measureApply(m5) {
    const different = super.measureApply(m5);
    if (different) this.canvasRegion = PlaceholderPositioned;
    return different;
  }
  layoutApply(l3) {
    const different = super.layoutApply(l3);
    if (different) this.canvasRegion = PlaceholderPositioned;
    return different;
  }
  draw(ctx, force = false) {
    if (this._needsDrawing || force) {
      if (isPlaceholder2(this.canvasRegion)) {
        if (this._layoutPosition === void 0) return;
        if (this._measuredSize === void 0) return;
        this.canvasRegion = {
          x: this._layoutPosition.x,
          y: this._layoutPosition.y,
          width: this._measuredSize.width,
          height: this._measuredSize.height
        };
      }
      if (this._needsLayoutX || this._needsMeasuring) {
      }
      ctx.save();
      const v3 = this.canvasRegion;
      ctx.translate(v3.x, v3.y);
      ctx.beginPath();
      ctx.rect(0, 0, v3.width, v3.height);
      ctx.clip();
      if (this.debugLayout) {
        ctx.lineWidth = 1;
        ctx.strokeStyle = `hsl(${this.debugHue}, 100%, 50%)`;
        ctx.strokeRect(0, 0, v3.width, v3.height);
        ctx.fillStyle = ctx.strokeStyle;
        ctx.fillText(this.id, 10, 10, v3.width);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(v3.width, v3.height);
        ctx.stroke();
      }
      this.drawSelf(ctx);
      this._needsDrawing = false;
      ctx.restore();
    }
    for (const c6 of this.children) {
      c6.draw(ctx, force);
    }
  }
  /**
   * Draw this object
   * @param _ctx 
   */
  drawSelf(_ctx) {
  }
};
var scaleCanvas = (domQueryOrElement) => {
  const canvasElement = resolveEl(domQueryOrElement);
  const ratio = window.devicePixelRatio;
  canvasElement.style.width = canvasElement.width + `px`;
  canvasElement.style.height = canvasElement.height + `px`;
  canvasElement.width *= devicePixelRatio;
  canvasElement.height *= devicePixelRatio;
  const getContext2 = () => {
    const ctx = canvasElement.getContext(`2d`);
    if (ctx === null) throw new Error(`Could not get drawing context`);
    ctx.save();
    ctx.scale(ratio, ratio);
    return ctx;
  };
  return { ctx: getContext2(), element: canvasElement, bounds: canvasElement.getBoundingClientRect() };
};
var ArrayDataSource = class {
  constructor(series) {
    this.dirty = false;
    this.type = `array`;
    this.series = series;
    this.data = [];
    this.dirty = true;
  }
  clear() {
    this.set([]);
    this._range = void 0;
  }
  set(data) {
    this.data = data;
    this.dirty = true;
  }
  get length() {
    return this.data.length;
  }
  get range() {
    if (!this.dirty && this._range !== void 0) return this._range;
    this.dirty = false;
    const updatedRange = minMaxAvg(this.data);
    if (this._range === void 0 || updatedRange.max !== this._range.max || updatedRange.min !== this._range.min) {
      this._range = updatedRange;
      return { ...this._range, changed: true };
    } else {
      return { ...this._range, changed: false };
    }
  }
  add(value2) {
    this.data = [...this.data, value2];
    this.dirty = true;
  }
};
var StreamingDataSource = class extends ArrayDataSource {
  constructor() {
    super(...arguments);
    this.desiredDataPointMinWidth = 5;
  }
  add(value2) {
    const lastWidth = this.series.lastPxPerPt;
    if (lastWidth > -1 && lastWidth < this.desiredDataPointMinWidth) {
      const pts = Math.floor(this.desiredDataPointMinWidth / lastWidth);
      const d4 = [...this.data.slice(pts), value2];
      super.set(d4);
    } else super.add(value2);
  }
};
var Series = class {
  constructor(name, sourceType, plot2, opts) {
    this.plot = plot2;
    this.width = 3;
    this.lastPxPerPt = -1;
    this.name = name;
    this.drawingStyle = opts.drawingStyle ?? `line`;
    this.colour = opts.colour;
    this.width = opts.width ?? 3;
    this.axisRange = opts.axisRange ?? { min: Number.NaN, max: Number.NaN };
    this._visualRange = { ...this.axisRange };
    this._visualRangeStretch = opts.visualRangeStretch ?? true;
    this.formattedPrecision = opts.formattedPrecision ?? -1;
    if (sourceType === `array`) {
      this.source = new ArrayDataSource(this);
    } else if (sourceType === `stream`) {
      this.source = new StreamingDataSource(this);
    } else throw new Error(`Unknown sourceType. Expected array|stream`);
  }
  formatValue(v3) {
    if (this.formattedPrecision < 0) {
      if (Math.abs(v3) < 100) return v3.toFixed(2);
      return Math.floor(v3).toString();
    } else {
      return v3.toFixed(this.formattedPrecision);
    }
  }
  get visualFormatted() {
    const d4 = this.visualDataRange;
    const min6 = this.formatValue(d4.min);
    const max5 = this.formatValue(d4.max);
    const longest = min6.length > max5.length ? min6 : max5;
    return { min: min6, max: max5, longest };
  }
  get visualDataRange() {
    let vr2 = this._visualRange;
    const sourceRange = this.source.range;
    let changed = false;
    if (sourceRange.changed) {
      if (this._visualRangeStretch) {
        const rmin = Math.min(ifNaN(vr2.min, sourceRange.min), sourceRange.min);
        const rmax = Math.max(ifNaN(vr2.max, sourceRange.max), sourceRange.max);
        if (rmin !== vr2.min || rmax !== vr2.max) {
          vr2 = { min: rmin, max: rmax };
          changed = true;
        }
      } else {
        if (!isRangeEqual(sourceRange, vr2)) {
          vr2 = sourceRange;
          changed = true;
        }
      }
    }
    this._visualRange = vr2;
    return { ...vr2, changed };
  }
  scaleValue(value2) {
    if (this.source === void 0) return value2;
    const r5 = this.visualDataRange;
    if (r5.changed) {
      this.plot.notify(`range-change`, this.plot.plotArea);
    }
    if (r5.min == r5.max) {
      return 0.5;
    }
    return scale(value2, r5.min, r5.max);
  }
  add(value2) {
    throwNumberTest(value2, ``, `value`);
    this.source.add(value2);
    this.plot.plotArea.drawingInvalidated(`Series.add`);
  }
  /**
   * Clears the underlying source
   * and sets a flag that the plot area needs redrawing
   */
  clear() {
    this.source.clear();
    this._visualRange = { ...this.axisRange };
    this.plot.plotArea.layoutInvalidated(`Series.clear`);
  }
};
var PlotArea = class extends CanvasBox {
  constructor(plot2, region) {
    super(plot2, `PlotArea`, region);
    this.plot = plot2;
    this.paddingPx = 0;
    this.piPi = Math.PI * 2;
    this.pointerDistanceThreshold = 20;
    this.lastRangeChange = 0;
  }
  clear() {
    this.lastRangeChange = 0;
    this.pointer = void 0;
  }
  measureSelf(opts, _parent) {
    const axisY = opts.getActualSize(`AxisY`);
    const padding = this.paddingPx;
    const legend = opts.getActualSize(`Legend`);
    const legendHeight = legend?.height ?? 0;
    const axisX = opts.getActualSize(`AxisX`);
    const axisXHeight = axisX?.height ?? 0;
    if (!axisY) return `No AxisY. Measured: ${opts.whatIsMeasured().join(`, `)}`;
    if (!legend) return `No Legend`;
    if (!axisX) return `No AxisX`;
    return {
      width: opts.bounds.width - axisY.width - this.paddingPx,
      height: opts.bounds.height - legendHeight - axisXHeight - padding
    };
  }
  layoutSelf(measureState, _layoutState, _parent) {
    const axisY = measureState.getActualSize(`AxisY`);
    const padding = this.paddingPx;
    const axisYWidth = axisY?.width ?? 0;
    return {
      x: axisYWidth,
      y: padding
      // layoutState.bounds.height - height - axisXHeight - legendHeight
    };
  }
  onNotify(message, source) {
    if (message === `measureApplied` && source === this.plot.axisY)
      this.layoutInvalidated(`PlotArea.onNotify measureApplied to axisY`);
    if (message === `laidout` && source === this.plot.legend)
      this.layoutInvalidated(`PlotArea.onNotify laidout to legend`);
  }
  // protected onClick(p: Point): void {
  //   this.plot.frozen = !this.plot.frozen;
  // }
  onPointerLeave() {
    for (const series of this.plot.series.values()) {
      series.tooltip = void 0;
    }
    this.pointer = void 0;
    this.plot.legend.drawingInvalidated(`PlotArea.onPointerLeave`);
  }
  onPointerMove(p4) {
    this.pointer = p4;
    this.plot.legend.drawingInvalidated(`PlotArea.onPointerMove`);
  }
  measurePreflight() {
    this.updateTooltip();
  }
  updateTooltip() {
    const p4 = this.pointer;
    if (p4 === void 0) return;
    for (const series of this.plot.series.values()) {
      if (p4 === void 0) {
        series.tooltip = void 0;
        return;
      }
      if (series.dataHitPoint === void 0) return;
      const v3 = series.dataHitPoint(p4);
      if (v3[0] === void 0) return;
      if (v3[1] > this.pointerDistanceThreshold) return;
      series.tooltip = series.formatValue(v3[0].value);
    }
    this.plot.legend.drawingInvalidated(`PlotArea.updateTooltip`);
  }
  drawSelf(ctx) {
    if (this.plot.frozen) return;
    const seriesCopy = this.plot.seriesArray();
    ctx.clearRect(0, -1, this.canvasRegion.width, this.canvasRegion.height + 5);
    for (const series of seriesCopy) {
      if (series.source.type === `array` || series.source.type === `stream`) {
        const arraySeries = series.source;
        if (arraySeries.data === void 0) return;
        const d4 = [...arraySeries.data];
        this.drawDataSet(series, d4, ctx);
      } else console.warn(`Unknown data source type ${series.source.type}`);
    }
  }
  computeY(series, rawValue) {
    const s3 = series.scaleValue(rawValue);
    return flip(s3) * this.canvasRegion.height + this.paddingPx;
  }
  drawDataSet(series, d4, ctx) {
    const padding = this.paddingPx + series.width;
    const v3 = subtract3(this.canvasRegion, padding * 2, padding * 3.5);
    const pxPerPt = v3.width / d4.length;
    series.lastPxPerPt = pxPerPt;
    let x3 = padding;
    ctx.strokeStyle = series.colour;
    ctx.lineWidth = series.width;
    const shapes = [];
    series.dataHitPoint = (pt2) => {
      const distances = shapes.map((v22) => distanceToExterior(pt2, v22));
      const index = minIndex(...distances);
      const closest = shapes[index];
      if (closest === void 0) [void 0, 0];
      return [closest, distances[index]];
    };
    if (series.drawingStyle === `line`) {
      let y3 = 0;
      ctx.beginPath();
      for (let index = 0; index < d4.length; index++) {
        const scaled = clamp(series.scaleValue(d4[index]));
        y3 = padding + this.paddingPx + v3.height * flip(scaled);
        shapes.push({ x: x3, y: y3, index, value: d4[index] });
        if (index == 0) ctx.moveTo(x3 + pxPerPt / 2, y3);
        else ctx.lineTo(x3 + pxPerPt / 2, y3);
        if (y3 > this.canvasRegion.height)
          console.warn(`${y3} h: ${this.canvasRegion.height}`);
        x3 += pxPerPt;
      }
      ctx.strokeStyle = series.colour;
      ctx.stroke();
    } else if (series.drawingStyle === `dotted`) {
      let y3 = 0;
      ctx.fillStyle = series.colour;
      for (let index = 0; index < d4.length; index++) {
        const scaled = series.scaleValue(d4[index]);
        y3 = padding + v3.height * flip(scaled);
        ctx.beginPath();
        ctx.arc(x3 + pxPerPt / 2, y3, series.width, 0, this.piPi);
        ctx.fill();
        shapes.push({ radius: series.width, x: x3, y: y3, index, value: d4[index] });
        x3 += pxPerPt;
      }
    } else if (series.drawingStyle === `bar`) {
      ctx.fillStyle = series.colour;
      const interBarPadding = Math.ceil(pxPerPt * 0.1);
      for (let index = 0; index < d4.length; index++) {
        const scaled = series.scaleValue(d4[index]);
        const h5 = v3.height * scaled;
        const r5 = {
          x: x3 + interBarPadding,
          y: v3.height - h5 + padding,
          width: pxPerPt - interBarPadding,
          height: h5,
          index,
          value: d4[index]
        };
        ctx.fillRect(r5.x, r5.y, r5.width, r5.height);
        shapes.push(r5);
        x3 += pxPerPt;
      }
    }
  }
};
var Legend = class extends CanvasBox {
  constructor(plot2, region) {
    super(plot2, `Legend`, region);
    this.plot = plot2;
    this.sampleSize = { width: 10, height: 10 };
    this.padding = 3;
    this.widthSnapping = 20;
    this.labelMeasurements = /* @__PURE__ */ new Map();
  }
  clear() {
  }
  layoutSelf(measureState, layoutState, _parent) {
    const axisY = measureState.getActualSize(`AxisY`);
    const axisYWidth = axisY?.width ?? 0;
    const height4 = this._measuredSize?.height ?? 0;
    return {
      x: axisYWidth,
      y: layoutState.bounds.height - height4
    };
  }
  measureSelf(opts, _parent) {
    const series = this.plot.seriesArray();
    const sample = this.sampleSize;
    const padding = this.padding;
    const widthSnapping = this.widthSnapping;
    const ctx = opts.ctx;
    const yAxis = opts.measurements.get(`AxisY`);
    const yAxisWidth = yAxis?.actual.width ?? 0;
    let rowX = padding;
    let y3 = padding;
    const availableWidth = opts.bounds.width - yAxisWidth - padding;
    let rowHeight = 0;
    ctx.textBaseline = `middle`;
    for (const s3 of series) {
      let labelWidth = sample.width + padding;
      const text2 = textRect(ctx, s3.name, padding, widthSnapping);
      labelWidth += textWidth(ctx, s3.name, padding, widthSnapping);
      if (s3.tooltip) {
        labelWidth += textWidth(ctx, s3.tooltip, padding, widthSnapping);
      }
      rowHeight = Math.min(sample.height + padding + padding, text2.height + padding + padding);
      labelWidth += padding;
      if (rowX + labelWidth > availableWidth) {
        rowX = padding;
        y3 += rowHeight;
      }
      const r5 = { width: 10, height: 10, x: rowX, y: y3 };
      rowX = rowX + labelWidth;
      this.labelMeasurements.set(s3.name, r5);
    }
    return {
      width: availableWidth,
      height: y3 + rowHeight
    };
  }
  drawSelf(ctx) {
    const series = this.plot.seriesArray();
    const sample = this.sampleSize;
    const padding = this.padding;
    this.debugLog(`drawSelf`);
    ctx.clearRect(0, 0, this.canvasRegion.width, this.canvasRegion.height);
    for (const s3 of series) {
      const r5 = this.labelMeasurements.get(s3.name);
      if (r5 === void 0) continue;
      let x3 = r5.x;
      ctx.fillStyle = s3.colour;
      ctx.fillRect(x3, r5.y, sample.width, sample.height);
      x3 += sample.width + padding;
      ctx.textBaseline = `middle`;
      ctx.fillStyle = this.plot.legendTextColour;
      ctx.fillText(s3.name, x3, r5.y + sample.height / 2);
      if (s3.tooltip) {
        ctx.fillStyle = this.plot.legendTextColour;
        ctx.fillText(s3.tooltip, r5.x, r5.y + sample.height / 2);
      }
    }
  }
  onNotify(message, source) {
    this.debugLog(`onNotify ${message} source: ${source.id}`);
    if (message === `measureApplied` && source === this._parent.axisY) {
      this.layoutInvalidated(`Legend.onNotify measureApplied to axisY`);
    } else if (message == `range-change`) {
    }
  }
};
var AxisX = class extends CanvasBox {
  constructor(plot2, region) {
    super(plot2, `AxisX`, region);
    this.plot = plot2;
    this.paddingPx = 2;
  }
  clear() {
  }
  onNotify(message, source) {
    if (message === `measureApplied` && source === this.plot.axisY) {
      this.layoutInvalidated(`AxisX.onNotify measureApplied to axisY`);
    }
  }
  drawSelf(ctx) {
    const plot2 = this.plot;
    const v3 = this.canvasRegion;
    const strokeWidth = plot2.axisStrokeWidth;
    const colour2 = this.colour ?? plot2.axisStrokeColour;
    ctx.strokeStyle = colour2;
    ctx.clearRect(0, 0, v3.width, v3.height);
    ctx.beginPath();
    ctx.lineWidth = strokeWidth;
    ctx.moveTo(0, strokeWidth / 2);
    ctx.lineTo(v3.width, strokeWidth / 2);
    ctx.stroke();
  }
  measureSelf(opts, _parent) {
    const plot2 = this.plot;
    const padding = this.paddingPx;
    const yAxis = opts.measurements.get(`AxisY`);
    const yAxisWidth = yAxis?.actual.width ?? 0;
    const heightOfText = 0;
    const h5 = plot2.axisStrokeWidth + heightOfText + padding + padding;
    return {
      width: opts.bounds.width - yAxisWidth - padding,
      height: h5
    };
  }
  layoutSelf(measureState, _layoutState, _parent) {
    const yAxis = measureState.measurements.get(`AxisY`);
    const legend = measureState.getActualSize(`Legend`);
    const legendHeight = legend?.height ?? 0;
    const yAxisWidth = yAxis?.actual.width ?? 0;
    const height4 = this._measuredSize?.height ?? 0;
    return {
      x: yAxisWidth,
      y: measureState.bounds.height - height4 - legendHeight
    };
  }
};
var isRangeEqual = (a4, b4) => a4.max === b4.max && a4.min === b4.min;
var isRangeSinglePoint = (a4) => a4.max === a4.min;
var AxisY = class extends CanvasBox {
  constructor(plot2, region) {
    super(plot2, `AxisY`, region);
    this.plot = plot2;
    this._minCharLength = 3;
    this.paddingPx = 3;
    this.lastPlotAreaHeight = 0;
    this.lastRange = { min: 0, max: 0 };
    this.showDataLabels = true;
  }
  clear() {
    this.lastRange = { min: 0, max: 0 };
    this.lastPlotAreaHeight = 0;
  }
  measurePreflight() {
    this.debugLog(`measurePreflight`);
  }
  onNotify(message, source) {
    const pa2 = this.plot.plotArea;
    if (message === `range-change`) {
      this.drawingInvalidated(`range-change`);
      return;
    }
    if (message === `measureApplied` && source === pa2 && pa2.canvasRegion.height !== this.lastPlotAreaHeight) {
      this.lastPlotAreaHeight = pa2.canvasRegion.height;
      this.drawingInvalidated(`AxisY.onNotify height change`);
    }
  }
  measureSelf(copts) {
    this.debugLog(`measureSelf. needsLayout: ${this._needsLayoutX} needsDrawing: ${this._needsDrawing}`);
    if (copts.ctx === void 0) throw new Error(`opts.ctx is undefined`);
    switch (this.plot.scaling) {
      case `normalise`:
        return this.#measureNormalise(copts);
      default:
        return this.#measureIndependent(copts);
    }
  }
  #measureIndependent(copts) {
    const paddingPx = this.paddingPx;
    let width = this.plot.axisStrokeWidth + paddingPx;
    if (this.showDataLabels) {
      for (const s3 of this.plot.seriesArray()) {
        const r5 = s3.visualFormatted;
        let chars = Math.max(r5.longest.length, this._minCharLength);
        width += textWidth(copts.ctx, `9`.repeat(chars + 1), paddingPx);
      }
    }
    return {
      width,
      height: copts.bounds.height
    };
  }
  /**
   * Single data display
   * @param copts 
   * @returns 
   */
  #measureNormalise(copts) {
    const paddingPx = this.paddingPx;
    let width = this.plot.axisStrokeWidth + paddingPx;
    if (this.showDataLabels) {
      width += textWidth(copts.ctx, `100%`, paddingPx * 2);
    }
    const w3 = copts.resolveToPx(this.desiredRegion?.width, width, width);
    return {
      width: w3,
      height: copts.bounds.height
    };
  }
  layoutSelf(_measureState, _layoutState, _parent) {
    return { x: 0, y: 0 };
  }
  drawSelf(ctx) {
    switch (this.plot.scaling) {
      case `normalise`:
        this.#drawNormalised(ctx);
        break;
      default:
        this.#drawIndependent(ctx);
    }
  }
  // getSeries(): Series | undefined {
  //   return this.seriesToShow === undefined ?
  //     // Pick first series
  //     this.plot.seriesArray()[ 0 ] :
  //     // Try designated series name
  //     this.plot.series.get(this.seriesToShow);
  // }
  /**
  * Draw all the axis on a common scale
  * @param ctx 
  */
  #drawNormalised(ctx) {
    const plot2 = this.plot;
    const plotArea = plot2.plotArea;
    const v3 = this.canvasRegion;
    const paddingPx = this.paddingPx;
    const strokeWidth = plot2.axisStrokeWidth;
    const colour2 = this.colour ?? plot2.axisStrokeColour;
    ctx.strokeStyle = colour2;
    ctx.fillStyle = colour2;
    ctx.clearRect(0, 0, v3.width, v3.height);
    ctx.beginPath();
    ctx.lineWidth = strokeWidth;
    const lineX = v3.width - strokeWidth / 2;
    ctx.moveTo(lineX, plotArea.paddingPx + strokeWidth);
    ctx.lineTo(lineX, plotArea.canvasRegion.height + paddingPx);
    ctx.stroke();
    ctx.fillStyle = plot2.axisTextColour;
    ctx.textBaseline = `top`;
    const labelWidth = this.canvasRegion.width - strokeWidth - paddingPx;
    let m5 = ctx.measureText(`0%`);
    ctx.fillText(`0%`, labelWidth - m5.width, plotArea.canvasRegion.height - paddingPx);
    m5 = ctx.measureText(`100%`);
    ctx.fillText(`100%`, labelWidth - m5.width, plotArea.canvasRegion.y);
  }
  #drawIndependent(ctx) {
    const plot2 = this.plot;
    const plotArea = plot2.plotArea;
    const v3 = this.canvasRegion;
    const paddingPx = this.paddingPx;
    const strokeWidth = plot2.axisStrokeWidth;
    const colour2 = this.colour ?? plot2.axisStrokeColour;
    ctx.strokeStyle = colour2;
    ctx.fillStyle = colour2;
    ctx.clearRect(0, 0, v3.width, v3.height);
    ctx.beginPath();
    ctx.lineWidth = strokeWidth;
    const lineX = v3.width - strokeWidth / 2;
    ctx.moveTo(lineX, plotArea.paddingPx + strokeWidth);
    ctx.lineTo(lineX, plotArea.canvasRegion.height + paddingPx);
    ctx.stroke();
    const swatchSize = 10;
    let xOffset = paddingPx;
    const middleY = (plotArea.canvasRegion.height - paddingPx) / 2;
    for (const s3 of this.plot.seriesArray()) {
      ctx.textBaseline = `top`;
      const r5 = s3.visualFormatted;
      let actualWidth = 0;
      let xPre = xOffset;
      if (isRangeSinglePoint(s3.visualDataRange)) {
        ctx.fillStyle = plot2.axisTextColour;
        let m5 = ctx.measureText(r5.max);
        ctx.fillText(r5.max, xOffset, middleY + swatchSize);
        actualWidth = m5.width;
        xOffset += m5.width + paddingPx;
      } else {
        ctx.fillStyle = plot2.axisTextColour;
        let m12 = ctx.measureText(r5.min);
        ctx.fillText(r5.min, xOffset, plotArea.canvasRegion.height - paddingPx);
        let m23 = ctx.measureText(r5.max);
        ctx.fillText(r5.max, xOffset, plotArea.canvasRegion.y);
        actualWidth = Math.max(m12.width, m23.width);
        xOffset += actualWidth + paddingPx;
      }
      ctx.fillStyle = s3.colour;
      ctx.fillRect(xPre + (actualWidth / 2 - swatchSize / 2), middleY - swatchSize / 2, swatchSize, swatchSize);
    }
  }
  // seriesAxis(series: Series, ctx: CanvasRenderingContext2D) {
  //   const plot = this.plot;
  //   const plotArea = plot.plotArea;
  //   const v = this.canvasRegion;
  //   const paddingPx = this.paddingPx;
  //   const r = series.visualRange;
  //   const strokeWidth = plot.axisStrokeWidth;
  //   const colour = this.colour ?? plot.axisStrokeColour;
  //   ctx.strokeStyle = colour;
  //   ctx.fillStyle = colour;
  //   if (Number.isNaN(r.min) && Number.isNaN(r.max)) return; // Empty
  //   this.lastRange = r;
  //   ctx.clearRect(0, 0, v.width, v.height);
  //   // ctx.fillStyle = `yellow`;
  //   // ctx.fillRect(0, 0, this.canvasRegion.width, this.canvasRegion.height);
  //   ctx.beginPath();
  //   ctx.lineWidth = strokeWidth;
  //   const lineX = v.width - strokeWidth / 2;
  //   ctx.moveTo(lineX, plotArea.paddingPx + strokeWidth);
  //   ctx.lineTo(lineX, plotArea.canvasRegion.height + paddingPx);// + strokeWidth + strokeWidth);
  //   ctx.stroke();
  //   ctx.textBaseline = `top`;
  //   const fromRight = v.width - paddingPx * 4;
  //   ctx.fillStyle = plot.axisTextColour;
  //   if (isRangeSinglePoint(r)) {
  //     this.debugLog(`rangeSinglePoint`);
  //     drawText(ctx, series.formatValue(r.max), (size) => [
  //       fromRight - size.width,
  //       plotArea.computeY(series, r.max) - paddingPx * 4,
  //     ]);
  //   } else {
  //     // Draw min/max data labels
  //     drawText(ctx, series.formatValue(r.max), (size) => [
  //       fromRight - size.width,
  //       plotArea.computeY(series, r.max) + strokeWidth / 2,
  //     ]);
  //     drawText(ctx, series.formatValue(r.min), (size) => [
  //       fromRight - size.width,
  //       plotArea.computeY(series, r.min) - 5,
  //     ]);
  //   }
  // }
};
var Plot = class extends CanvasBox {
  constructor(canvasElementOrQuery, opts = {}) {
    const { ctx, element, bounds } = scaleCanvas(canvasElementOrQuery);
    super(void 0, `Plot`);
    this._frozen = false;
    this._canvasEl = element;
    this.bounds = bounds;
    this.scaling = opts.scaling ?? `normalise`;
    this._ctx = ctx;
    if (opts.autoSize) {
      parentSizeCanvas(element, (event2) => {
        this.bounds = element.getBoundingClientRect();
        this.plotArea.bounds = this.bounds;
        this.legend.bounds = this.bounds;
        this.axisX.bounds = this.bounds;
        this.axisY.bounds = this.bounds;
        ctx.clearRect(0, 0, this.bounds.width, this.bounds.height);
        this.drawingInvalidated(`resize`);
        this.layoutInvalidated(`resize`);
        this.update(event2.ctx, true);
      });
    }
    this.axisStrokeColour = opts.axisStrokeColour ?? `black`;
    this.axisTextColour = opts.axisTextColour ?? `black`;
    this.legendTextColour = opts.legendTextColour ?? `black`;
    this.axisStrokeWidth = opts.axisStrokeWidth ?? 3;
    this.series = /* @__PURE__ */ new Map();
    this.plotArea = new PlotArea(this, bounds);
    this.legend = new Legend(this, bounds);
    this.axisX = new AxisX(this, bounds);
    this.axisY = new AxisY(this, bounds);
  }
  update(ctx, force = false) {
    if (ctx === void 0) ctx = this._ctx;
    super.update(ctx, force);
  }
  /**
   * Calls 'clear()' on each of the series
   */
  clearSeries() {
    for (const series of this.series.values()) {
      series.clear();
    }
    this.update();
  }
  /**
   * Removes all series, plot, legend
   * and axis data.
   */
  clear() {
    this.series = /* @__PURE__ */ new Map();
    this.plotArea.clear();
    this.legend.clear();
    this.axisX.clear();
    this.axisY.clear();
    this.layoutInvalidated(`Plot.clear`);
    this.drawingInvalidated(`Plot.clear`);
    this.update();
  }
  get frozen() {
    return this._frozen;
  }
  set frozen(v3) {
    this._frozen = v3;
    if (v3) {
      this._canvasEl.classList.add(`frozen`);
      this._canvasEl.title = `Plot frozen. Tap to unfreeze`;
    } else {
      this._canvasEl.title = ``;
      this._canvasEl.classList.remove(`frozen`);
    }
  }
  seriesArray() {
    return [...this.series.values()];
  }
  get seriesLength() {
    return this.series.size;
  }
  /**
   * Plots a simple object, eg `{ x: 10, y: 20, z: 300 }`
   * Series are automatically created for each property of `o`
   *
   * Be sure to call `update()` to visually refresh.
   * @param o
   */
  plot(o5) {
    const paths2 = getPaths(o5, true);
    let seriesCreated = false;
    for (const p4 of paths2) {
      let s3 = this.series.get(p4);
      if (s3 === void 0) {
        s3 = this.createSeries(p4, `stream`);
        s3.drawingStyle = `line`;
        seriesCreated = true;
      }
      const f5 = getField(o5, p4);
      throwResult(f5);
      s3.add(f5.value);
    }
    if (seriesCreated) this.legend.layoutInvalidated(`new series`);
    this.update();
  }
  createSeriesFromObject(o5, prefix = ``) {
    const keys = Object.keys(o5);
    const create22 = (key) => {
      const v3 = o5[key];
      if (typeof v3 === `object`) {
        return this.createSeriesFromObject(v3, `${prefix}${key}.`);
      } else if (typeof v3 === `number`) {
        return [this.createSeries(key, `stream`)];
      } else {
        return [];
      }
    };
    return keys.flatMap((k3) => create22(k3));
  }
  createSeries(name, type2 = `array`, seriesOpts) {
    const seriesLength = this.seriesLength;
    if (name === void 0) name = `series-${seriesLength}`;
    if (this.series.has(name))
      throw new Error(`Series name '${name}' already in use`);
    let opts = {
      colour: `hsl(${seriesLength * 25 % 360}, 70%,50%)`,
      ...seriesOpts
    };
    if (this.defaultSeriesOpts) opts = { ...this.defaultSeriesOpts, ...opts };
    const s3 = new Series(name, type2, this, opts);
    this.series.set(name, s3);
    this.setReady(true, true);
    this.plotArea.drawingInvalidated(`Plot.createSeries`);
    return s3;
  }
};
var Palette_exports = {};
__export(Palette_exports, {
  create: () => create4
});
var create4 = (fallbacks) => new PaletteImpl(fallbacks);
var PaletteImpl = class {
  /* eslint-disable-next-line functional/prefer-readonly-type */
  #store = /* @__PURE__ */ new Map();
  /* eslint-disable-next-line functional/prefer-readonly-type */
  #aliases = /* @__PURE__ */ new Map();
  #lastFallback = 0;
  #elementBase;
  constructor(fallbacks) {
    if (fallbacks !== void 0) this.fallbacks = fallbacks;
    else this.fallbacks = [`red`, `blue`, `green`, `orange`];
    this.#elementBase = document.body;
  }
  setElementBase(el) {
    this.#elementBase = el;
  }
  add(key, colour2) {
    this.#store.set(key, colour2);
  }
  alias(from2, to5) {
    this.#aliases.set(from2, to5);
  }
  get(key, fallback) {
    const alias = this.#aliases.get(key);
    if (alias !== void 0) key = alias;
    const c6 = this.#store.get(key);
    if (c6 !== void 0) return c6;
    const varName = `--` + key;
    let fromCss = getComputedStyle(this.#elementBase).getPropertyValue(varName).trim();
    if (fromCss === void 0 || fromCss.length === 0) {
      if (fallback !== void 0) return fallback;
      fromCss = this.fallbacks[this.#lastFallback];
      this.#lastFallback++;
      if (this.#lastFallback === this.fallbacks.length) this.#lastFallback = 0;
    }
    return fromCss;
  }
  getOrAdd(key, fallback) {
    if (this.has(key)) return this.get(key);
    const c6 = this.get(key, fallback);
    this.add(key, c6);
    return c6;
  }
  has(key) {
    return this.#store.has(key);
  }
};
var BipolarView_exports = {};
__export(BipolarView_exports, {
  init: () => init4
});
function getNumericAttribute(el, name, defaultValue) {
  const a4 = el.getAttribute(name);
  if (a4 === null) return defaultValue;
  return Number.parseInt(a4);
}
var init4 = (elementQuery, options = {}) => {
  const element = document.querySelector(elementQuery);
  if (!element) throw new Error(`Element query could not be found (${elementQuery})`);
  const labels = options.labels ?? [`x`, `y`];
  const labelPrecision = options.labelPrecision ?? 2;
  const asPercentages = options.asPercentages ?? false;
  const displayLastValues = options.displayLastValues ?? 0;
  const showWhiskers = options.showWhiskers ?? true;
  const showDot = options.showDot ?? true;
  const showLabels = options.showLabels ?? true;
  const yAxisBottomNegative = options.yAxisBottomNegative ?? true;
  const axisColour = resolveToString(options.axisColour, `silver`);
  const bgColour = resolveToString(options.bgColour, `white`);
  const whiskerColour = resolveToString(options.whiskerColour, `black`);
  const dotColour = resolveToString(options.dotColour, options.whiskerColour, `black`);
  const labelColour = resolveToString(options.labelColour, options.axisColour, `silver`);
  const axisWidth = options.axisWidth ?? 1 * window.devicePixelRatio;
  const dotRadius = options.dotRadius ?? 5 * window.devicePixelRatio;
  const pad = options.padding ?? 10 * window.devicePixelRatio;
  const whiskerSize = options.whiskerSize ?? 5 * window.devicePixelRatio;
  const width = options.width ?? getNumericAttribute(element, `width`, 200) * window.devicePixelRatio;
  const height4 = options.height ?? getNumericAttribute(element, `height`, 200) * window.devicePixelRatio;
  let lastValues;
  if (displayLastValues > 0) {
    lastValues = immutable3({
      capacity: displayLastValues,
      discardPolicy: `older`
    });
  }
  element.width = width;
  element.height = height4;
  element.style.width = `${width / window.devicePixelRatio}px`;
  element.style.height = `${height4 / window.devicePixelRatio}px`;
  const midY = height4 / 2;
  const midX = width / 2;
  const ctx = element.getContext(`2d`);
  if (!ctx) throw new Error(`Could not create drawing context`);
  if (window.devicePixelRatio >= 2) {
    ctx.font = `20px sans-serif`;
  }
  const percentageFormat = (v3) => `${Math.round(v3 * 100)}%`;
  const fixedFormat = (v3) => v3.toFixed(labelPrecision);
  const valueFormat = asPercentages ? percentageFormat : fixedFormat;
  if (showLabels) {
    labels[0] = labels[0] + `:`;
    labels[1] = labels[1] + `:`;
  } else {
    labels[0] = ``;
    labels[1] = ``;
  }
  const renderBackground = options.renderBackground ?? ((ctx2, width2, height22) => {
    if (options.bgColour === `transparent`) {
      ctx2.clearRect(0, 0, width2, height22);
    } else {
      ctx2.fillStyle = bgColour;
      ctx2.fillRect(0, 0, width2, height22);
    }
  });
  return (x3, y3) => {
    x3 = clamp2(x3);
    y3 = clamp2(y3);
    renderBackground(ctx, width, height4);
    ctx.fillStyle = labelColour;
    ctx.textBaseline = `top`;
    ctx.save();
    ctx.translate(midX, midY);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText((labels[1] + ` ` + valueFormat(y3)).trim(), -midX + pad, 1);
    ctx.restore();
    ctx.fillText((labels[0] + ` ` + valueFormat(x3)).trim(), pad, midX + 2);
    if (!yAxisBottomNegative) y3 *= -1;
    ctx.strokeStyle = axisColour;
    ctx.lineWidth = axisWidth;
    ctx.beginPath();
    ctx.moveTo(pad, midY);
    ctx.lineTo(width - pad, midY);
    ctx.moveTo(midX, pad);
    ctx.lineTo(midX, height4 - pad);
    ctx.stroke();
    ctx.closePath();
    const yy = (height4 - pad - pad) / 2 * -y3;
    const xx = (width - pad - pad) / 2 * x3;
    const dotPos = { x: xx, y: yy, radius: dotRadius };
    if (lastValues) {
      lastValues = lastValues.enqueue(dotPos);
    }
    ctx.save();
    ctx.translate(midX, midY);
    if (showDot) {
      if (lastValues) {
        const opacityStep = 1 / lastValues.length;
        let opacity2 = 1;
        lastValues.forEach((d4) => {
          const colour2 = opacity(dotColour, opacity2);
          circle2(ctx, d4, { fillStyle: colour2 });
          opacity2 -= opacityStep;
        });
      } else {
        circle2(ctx, dotPos, { fillStyle: dotColour });
      }
    }
    if (showWhiskers) {
      ctx.strokeStyle = whiskerColour;
      ctx.beginPath();
      ctx.moveTo(0, yy - whiskerSize);
      ctx.lineTo(0, yy + whiskerSize);
      ctx.moveTo(xx - whiskerSize, 0);
      ctx.lineTo(xx + whiskerSize, 0);
      ctx.stroke();
      ctx.closePath();
    }
    ctx.restore();
  };
};
var PlotOld_exports = {};
__export(PlotOld_exports, {
  add: () => add3,
  calcScale: () => calcScale,
  defaultAxis: () => defaultAxis,
  draw: () => draw,
  drawValue: () => drawValue,
  plot: () => plot
});
var piPi8 = Math.PI * 2;
var defaultAxis = (name) => ({
  endWith: `none`,
  lineWidth: 1,
  namePosition: `none`,
  name,
  showLabels: name === `y`,
  showLine: true,
  // For y axis, it's the width, for x axis it's the text height
  textSize: name === `y` ? 20 : 10
});
var calcScale = (buffer, drawingOpts, seriesColours) => {
  const scales = [];
  for (const s3 of buffer.keys()) {
    const series = [...buffer.get(s3)];
    if (series.length === 0) break;
    let { min: min6, max: max5 } = minMaxAvg(series);
    let range2 = max5 - min6;
    let colour2;
    if (seriesColours !== void 0) {
      colour2 = seriesColours[s3];
    }
    if (colour2 == void 0) {
      colour2 = drawingOpts.defaultSeriesVariable ? getCssVariable(
        `accent`,
        drawingOpts.defaultSeriesColour
      ) : drawingOpts.defaultSeriesColour;
    }
    if (range2 === 0) {
      range2 = min6;
      min6 = min6 - range2 / 2;
      max5 = max5 + range2 / 2;
    }
    scales.push({
      min: min6,
      max: max5,
      range: range2,
      name: s3,
      colour: colour2
    });
  }
  return scales;
};
var add3 = (buffer, value2, series = ``) => {
  buffer.addKeyedValues(series, value2);
};
var drawValue = (index, buffer, drawing) => {
  const c6 = {
    ...drawing,
    translucentPlot: true,
    leadingEdgeDot: false
  };
  draw(buffer, c6);
  drawing = {
    ...drawing,
    highlightIndex: index,
    leadingEdgeDot: true,
    translucentPlot: false,
    style: `none`,
    clearCanvas: false
  };
  draw(buffer, drawing);
};
var scaleWithFixedRange = (buffer, range2, drawing) => calcScale(buffer, drawing, drawing.seriesColours).map((s3) => ({
  ...s3,
  range: range2[1] - range2[0],
  min: range2[0],
  max: range2[1]
}));
var draw = (buffer, drawing) => {
  const { x: xAxis, y: yAxis, ctx, canvasSize } = drawing;
  const margin = drawing.margin;
  const series = drawing.y.scaleRange ? scaleWithFixedRange(buffer, drawing.y.scaleRange, drawing) : calcScale(buffer, drawing, drawing.seriesColours);
  if (drawing.clearCanvas)
    ctx.clearRect(0, 0, canvasSize.width, canvasSize.height);
  if (drawing.debug) {
    ctx.strokeStyle = `orange`;
    ctx.strokeRect(0, 0, canvasSize.width, canvasSize.height);
  }
  ctx.translate(margin, margin);
  const plotSize = drawing.plotSize ?? plotSizeFromBounds(canvasSize, drawing);
  const axisSize = {
    height: plotSize.height + margin + margin,
    width: plotSize.width
  };
  if (yAxis.showLabels || yAxis.showLine) {
    for (const s3 of series) {
      if (yAxis.allowedSeries !== void 0 && !yAxis.allowedSeries.includes(s3.name)) continue;
      drawYSeriesScale(s3, axisSize, drawing);
    }
    if (series.length > 0 && yAxis.showLine)
      drawYLine(axisSize, series[0], drawing);
  }
  if ((xAxis.showLabels || xAxis.showLine) && series.length > 0) {
    const yPos = yAxis.labelRange ? yAxis.labelRange[0] : series[0].min;
    drawXAxis(
      plotSize.width,
      calcYForValue(yPos, series[0], plotSize.height) + margin + xAxis.lineWidth,
      drawing
    );
  }
  const plotDrawing = {
    ...drawing,
    plotSize
  };
  const ptr = translatePoint(ctx, drawing.pointer);
  for (const s3 of series) {
    const data = buffer.getSource(s3.name);
    if (data === void 0) continue;
    let leadingEdgeIndex = buffer.typeName === `circular` ? data.pointer - 1 : data.length - 1;
    if (drawing.highlightIndex !== void 0)
      leadingEdgeIndex = drawing.highlightIndex;
    ctx.save();
    ctx.translate(0, margin + margin);
    drawSeriesData(s3, data, plotSize, plotDrawing, leadingEdgeIndex);
    ctx.restore();
  }
  if (drawing.showLegend) {
    ctx.save();
    ctx.translate(0, plotSize.height + margin + margin + margin);
    const legendSize = {
      width: plotSize.width,
      height: drawing.x.textSize + margin + margin
    };
    drawLegend(series, drawing, legendSize);
    ctx.restore();
  }
  ctx.resetTransform();
};
var drawYSeriesScale = (series, plotSize, drawing) => {
  const { ctx, y: y3, digitsPrecision, margin } = drawing;
  const { height: height4 } = plotSize;
  if (drawing.debug) {
    ctx.strokeStyle = `purple`;
    ctx.strokeRect(0, 0, y3.textSize, height4 + margin);
  }
  ctx.fillStyle = series.colour.length > 0 ? series.colour : `white`;
  if (y3.colour) ctx.fillStyle = y3.colour;
  const min6 = y3.labelRange ? y3.labelRange[0] : series.min;
  const max5 = y3.labelRange ? y3.labelRange[1] : series.max;
  const range2 = y3.labelRange ? max5 - min6 : series.range;
  const mid = min6 + range2 / 2;
  const halfHeight = drawing.textHeight / 2;
  ctx.textBaseline = `top`;
  ctx.fillText(
    min6.toFixed(digitsPrecision),
    0,
    calcYForValue(min6, series, height4) - halfHeight
  );
  ctx.fillText(
    mid.toFixed(digitsPrecision),
    0,
    calcYForValue(mid, series, height4) - halfHeight
  );
  ctx.fillText(
    max5.toFixed(digitsPrecision),
    0,
    calcYForValue(max5, series, height4) - margin
  );
  ctx.translate(y3.textSize + margin, 0);
};
var drawYLine = (plotSize, series, drawing) => {
  if (series === void 0) throw new Error(`series undefined`);
  const { ctx, y: y3 } = drawing;
  const { height: height4 } = plotSize;
  const min6 = y3.labelRange ? y3.labelRange[0] : series.min;
  const max5 = y3.labelRange ? y3.labelRange[1] : series.max;
  const minPos = calcYForValue(min6, series, height4);
  const maxPos = calcYForValue(max5, series, height4);
  ctx.translate(y3.lineWidth, 0);
  ctx.lineWidth = y3.lineWidth;
  ctx.beginPath();
  ctx.moveTo(0, minPos);
  ctx.lineTo(0, maxPos);
  ctx.strokeStyle = series.colour;
  if (y3.colour) ctx.strokeStyle = y3.colour;
  ctx.stroke();
  ctx.translate(y3.lineWidth, 0);
};
var drawLegend = (series, drawing, size) => {
  const { ctx } = drawing;
  const lineSampleWidth = 10;
  let x3 = 0;
  const lineY = drawing.margin * 3;
  const textY = drawing.margin;
  ctx.lineWidth = drawing.lineWidth;
  for (const s3 of series) {
    ctx.moveTo(x3, lineY);
    ctx.strokeStyle = s3.colour;
    ctx.lineTo(x3 + lineSampleWidth, lineY);
    ctx.stroke();
    x3 += lineSampleWidth + drawing.margin;
    let label = s3.name;
    if (s3.lastValue)
      label += ` ` + s3.lastValue.toFixed(drawing.digitsPrecision);
    const labelSize = ctx.measureText(label);
    ctx.fillStyle = s3.colour;
    ctx.fillText(label, x3, textY);
    x3 += labelSize.width;
  }
};
var drawXAxis = (width, yPos, drawing) => {
  const { ctx, x: x3, y: y3 } = drawing;
  if (!x3.showLine) return;
  if (x3.colour) ctx.strokeStyle = x3.colour;
  ctx.lineWidth = x3.lineWidth;
  ctx.beginPath();
  ctx.moveTo(0, yPos);
  ctx.lineTo(width, yPos);
  ctx.stroke();
};
var drawSeriesData = (series, values, plotSize, drawing, leadingEdgeIndex) => {
  const { ctx, lineWidth, translucentPlot = false, margin, x: xAxis } = drawing;
  const style = drawing.style ?? `connected`;
  const height4 = plotSize.height - margin;
  let dataXScale = 1;
  if (xAxis.scaleRange) {
    const xAxisRange = xAxis.scaleRange[1] - xAxis.scaleRange[0];
    dataXScale = plotSize.width / xAxisRange;
  } else {
    dataXScale = drawing.capacity === 0 ? plotSize.width / values.length : plotSize.width / drawing.capacity;
  }
  const incrementBy = drawing.coalesce ? dataXScale < 0 ? Math.floor(1 / dataXScale) : 1 : 1;
  let x3 = 0;
  let leadingEdge;
  if (drawing.debug) {
    ctx.strokeStyle = `green`;
    ctx.strokeRect(0, 0, plotSize.width, plotSize.height);
  }
  const colourTransform = (c6) => {
    if (translucentPlot) return opacity(c6, 0.2);
    return c6;
  };
  if (style === `dots`) {
    ctx.fillStyle = colourTransform(series.colour);
  } else if (style === `none`) {
  } else {
    ctx.beginPath();
    ctx.lineWidth = lineWidth;
    ctx.strokeStyle = colourTransform(series.colour);
  }
  for (let index = 0; index < values.length; index += incrementBy) {
    const y3 = calcYForValue(values[index], series, height4) - 1;
    if (style === `dots`) {
      ctx.beginPath();
      ctx.arc(x3, y3, lineWidth, 0, piPi8);
      ctx.fill();
    } else if (style === `none`) {
    } else {
      if (index == 0) ctx.moveTo(x3, y3);
      ctx.lineTo(x3, y3);
    }
    if (index === leadingEdgeIndex) {
      leadingEdge = { x: x3, y: y3 };
      series.lastValue = values[index];
    }
    x3 += dataXScale;
  }
  if (style === `connected`) {
    ctx.stroke();
  }
  if (leadingEdge !== void 0 && drawing.leadingEdgeDot) {
    ctx.beginPath();
    ctx.fillStyle = colourTransform(series.colour);
    ctx.arc(leadingEdge.x, leadingEdge.y, 3, 0, 2 * Math.PI);
    ctx.fill();
  }
};
var calcYForValue = (v3, series, height4) => (1 - (v3 - series.min) / series.range) * height4;
var calcSizing = (margin, x3, y3, showLegend) => {
  let fromLeft = margin;
  if (y3.showLabels) fromLeft += y3.textSize;
  if (y3.showLine) fromLeft += y3.lineWidth;
  if (y3.showLabels || y3.showLine) fromLeft += margin + margin;
  const fromRight = margin;
  const fromTop = margin + margin;
  let fromBottom = margin + margin;
  fromBottom += x3.showLabels ? x3.textSize : margin;
  if (x3.showLine) fromBottom += x3.lineWidth;
  if (x3.showLabels || x3.showLine) fromBottom += margin;
  if (showLegend) fromBottom += x3.textSize;
  return {
    left: fromLeft,
    right: fromRight,
    top: fromTop,
    bottom: fromBottom
  };
};
var plotSizeFromBounds = (bounds, opts) => {
  const { width, height: height4 } = bounds;
  const sizing = calcSizing(opts.margin, opts.x, opts.y, opts.showLegend);
  return {
    width: width - sizing.left - sizing.right,
    height: height4 - sizing.top - sizing.bottom
  };
};
var canvasSizeFromPlot = (plot2, opts) => {
  const { width, height: height4 } = plot2;
  const sizing = calcSizing(opts.margin, opts.x, opts.y, opts.showLegend);
  return {
    width: width + sizing.left + sizing.right,
    height: height4 + sizing.top + sizing.bottom
  };
};
var plot = (parentElementOrQuery, opts) => {
  if (parentElementOrQuery === null)
    throw new Error(`parentElOrQuery is null. Expected string or element`);
  const parentEl = resolveEl(parentElementOrQuery);
  let canvasEl;
  let destroyCanvasEl = true;
  let plotSize = opts.plotSize;
  let canvasSize;
  if (parentEl.nodeName === `CANVAS`) {
    canvasEl = parentEl;
    destroyCanvasEl = false;
    canvasSize = { width: canvasEl.width, height: canvasEl.height };
  } else {
    canvasEl = document.createElement(`CANVAS`);
    parentEl.append(canvasEl);
    plotSize = opts.plotSize;
    canvasSize = { width: canvasEl.width, height: canvasEl.height };
  }
  const pointer = { x: 0, y: 0 };
  const onPointerMove = (event2) => {
    pointer.x = event2.offsetX;
    pointer.y = event2.offsetY;
  };
  canvasEl.addEventListener(`pointermove`, onPointerMove);
  const ctx = canvasEl.getContext(`2d`);
  const capacity = opts.capacity ?? 10;
  const buffer = capacity > 0 ? ofCircularMutable({ capacity }) : ofArrayMutable();
  const metrics = ctx.measureText(`Xy`);
  const coalesce = opts.coalesce ?? true;
  if (ctx === null) throw new Error(`Drawing context not available`);
  let xAxis = defaultAxis(`x`);
  if (opts.x) xAxis = { ...xAxis, ...opts.x };
  let yAxis = defaultAxis(`y`);
  if (opts.y) yAxis = { ...yAxis, ...opts.y };
  let drawingOpts = {
    ...opts,
    y: yAxis,
    x: xAxis,
    pointer,
    capacity,
    coalesce,
    plotSize,
    canvasSize,
    ctx,
    textHeight: opts.textHeight ?? metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent,
    style: opts.style ?? `connected`,
    defaultSeriesColour: opts.defaultSeriesColour ?? `yellow`,
    margin: 3,
    clearCanvas: true,
    leadingEdgeDot: true,
    debug: opts.debug ?? false,
    digitsPrecision: opts.digitsPrecision ?? 2,
    lineWidth: opts.lineWidth ?? 2,
    showLegend: opts.showLegend ?? false
  };
  if (plotSize) {
    const canvasSize2 = canvasSizeFromPlot(plotSize, drawingOpts);
    canvasEl.width = canvasSize2.width;
    canvasEl.height = canvasSize2.height;
    drawingOpts.canvasSize = canvasSize2;
  }
  if (opts.autoSizeCanvas) {
    parentSizeCanvas(canvasEl, (args) => {
      const bounds = args.bounds;
      drawingOpts = {
        ...drawingOpts,
        plotSize: plotSizeFromBounds(bounds, drawingOpts),
        canvasSize: bounds
      };
      draw(buffer, drawingOpts);
    });
  }
  return {
    drawValue: (index) => {
      drawValue(index, buffer, drawingOpts);
    },
    dispose: () => {
      canvasEl.removeEventListener(`pointermove`, onPointerMove);
      if (destroyCanvasEl) canvasEl.remove();
    },
    add: (value2, series = ``, skipDrawing = false) => {
      add3(buffer, value2, series);
      if (skipDrawing) return;
      draw(buffer, drawingOpts);
    },
    draw: () => {
      draw(buffer, drawingOpts);
    },
    clear: () => {
      buffer.clear();
    }
  };
};
try {
  if (typeof window !== `undefined`) {
    window.ixfx = {
      ...window.ixfx,
      Visuals: {
        SceneGraph: SceneGraph_exports,
        Plot2: Plot2_exports,
        Drawing: Drawing_exports,
        Svg: Svg_exports,
        Palette: Palette_exports,
        Colour: Colour_exports,
        Video: Video_exports
      }
    };
  }
} catch {
}

// node_modules/ixfx/dist/chunk-NRMCFXBX.js
var random_exports = {};
__export(random_exports, {
  arrayElement: () => randomElement,
  arrayIndex: () => randomIndex,
  calculateNonZero: () => calculateNonZero,
  chance: () => chance,
  float: () => float,
  floatSource: () => floatSource,
  gaussian: () => gaussian2,
  gaussianSource: () => gaussianSource,
  hue: () => randomHue,
  integer: () => integer,
  integerSource: () => integerSource,
  integerUniqueGen: () => integerUniqueGen,
  minutesMs: () => minutesMs,
  minutesMsSource: () => minutesMsSource,
  secondsMs: () => secondsMs,
  secondsMsSource: () => secondsMsSource,
  shortGuid: () => shortGuid,
  string: () => string,
  weighted: () => weighted,
  weightedIndex: () => weightedIndex,
  weightedInteger: () => weightedInteger,
  weightedIntegerSource: () => weightedIntegerSource,
  weightedSource: () => weightedSource
});
var chance = (p4, a4, b4, randomSource2) => {
  const source = randomSource2 ?? Math.random;
  const resolve3 = (x3) => {
    if (typeof x3 === `function`) return x3();
    return x3;
  };
  const pp = resolve3(p4);
  throwNumberTest(pp, `percentage`, `p`);
  if (source() <= pp) {
    return resolve3(b4);
  } else {
    return resolve3(a4);
  }
};
var calculateNonZero = (source = Math.random) => {
  let v3 = 0;
  while (v3 === 0) {
    v3 = source();
  }
  return v3;
};
var gaussian2 = (skew = 1) => gaussianSource(skew)();
var gaussianSource = (skew = 1) => {
  const min6 = 0;
  const max5 = 1;
  const compute = () => {
    const u3 = calculateNonZero();
    const v3 = calculateNonZero();
    let result = Math.sqrt(-2 * Math.log(u3)) * Math.cos(2 * Math.PI * v3);
    result = result / 10 + 0.5;
    if (result > 1 || result < 0) {
      result = compute();
    } else {
      result = Math.pow(result, skew);
      result *= max5 - min6;
      result += min6;
    }
    return result;
  };
  return compute;
};
var shortGuid = (options = {}) => {
  const source = options.source ?? Math.random;
  const firstPart = Math.trunc(source() * 46656);
  const secondPart = Math.trunc(source() * 46656);
  const firstPartString = `000${firstPart.toString(36)}`.slice(-3);
  const secondPartString = `000${secondPart.toString(36)}`.slice(-3);
  return firstPartString + secondPartString;
};
var integerSource = (maxOrOptions) => {
  if (typeof maxOrOptions === `undefined`) {
    throw new TypeError(`maxOrOptions is undefined`);
  }
  const options = typeof maxOrOptions === `number` ? { max: maxOrOptions } : maxOrOptions;
  let max5 = Math.floor(options.max);
  let min6 = Math.floor(options.min ?? 0);
  if (!options.min && max5 < 0) {
    max5 = 1;
    min6 = options.max;
  }
  const randomSource2 = options.source ?? Math.random;
  if (min6 > max5) {
    throw new Error(`Min value is greater than max (min: ${min6} max: ${max5})`);
  }
  throwFromResult(numberTest(min6, ``, `min`));
  throwFromResult(numberTest(max5, ``, `max`));
  if (max5 === min6) {
    throw new Error(`Max and min values cannot be the same (${max5})`);
  }
  const amt = Math.abs(max5 - min6);
  return () => Math.floor(randomSource2() * amt) + min6;
};
var integer = (maxOrOptions) => integerSource(maxOrOptions)();
function* integerUniqueGen(maxOrOptions) {
  const options = typeof maxOrOptions === `number` ? { max: maxOrOptions } : maxOrOptions;
  const min6 = options.min ?? 0;
  const max5 = options.max;
  const source = options.source ?? Math.random;
  const loop = options.loop ?? false;
  throwFromResult(integerTest(min6, ``, `min`));
  throwFromResult(integerTest(max5, ``, `max`));
  if (min6 > max5) {
    throw new Error(`Min value is greater than max. Min: ${min6} Max: ${max5}`);
  }
  const origRange = [...count(max5 - min6, min6)];
  let numberRange = shuffle(origRange);
  let index = 0;
  while (true) {
    if (index === numberRange.length) {
      if (loop) numberRange = shuffle(origRange, source);
      else return;
    }
    yield numberRange[index++];
  }
}
var minutesMsSource = (maxMinutesOrOptions) => {
  const options = typeof maxMinutesOrOptions === `number` ? { max: maxMinutesOrOptions } : maxMinutesOrOptions;
  const min6 = (options.min ?? 0) * 60 * 1e3;
  const max5 = options.max * 60 * 1e3;
  return integerSource({ ...options, max: max5, min: min6 });
};
var minutesMs = (maxMinutesOrOptions) => minutesMsSource(maxMinutesOrOptions)();
var secondsMsSource = (maxSecondsOrOptions) => {
  const options = typeof maxSecondsOrOptions === `number` ? { max: maxSecondsOrOptions } : maxSecondsOrOptions;
  const min6 = (options.min ?? 0) * 1e3;
  const max5 = options.max * 1e3;
  return () => integer({ ...options, max: max5, min: min6 });
};
var secondsMs = (maxSecondsOrOptions) => secondsMsSource(maxSecondsOrOptions)();
var weighted = (easingNameOrOptions = `quadIn`) => weightedSource(easingNameOrOptions)();
var weightedSource = (easingNameOrOptions = `quadIn`) => {
  const options = typeof easingNameOrOptions === `string` ? { easing: easingNameOrOptions } : easingNameOrOptions;
  const source = options.source ?? defaultRandom;
  const easingName = options.easing ?? `quadIn`;
  const easingFunction = get(easingName);
  if (easingFunction === void 0) {
    throw new Error(`Easing function '${easingName}' not found.`);
  }
  const compute = () => {
    const r5 = source();
    return easingFunction(r5);
  };
  return compute;
};
var weightedIntegerSource = (maxOrOptions) => {
  const options = typeof maxOrOptions === `number` ? { max: maxOrOptions } : maxOrOptions;
  const source = options.source ?? defaultRandom;
  const max5 = options.max;
  const min6 = options.min ?? 0;
  const easingName = options.easing ?? `quadIn`;
  if (typeof max5 === `undefined`) throw new Error(`max field is undefined`);
  if (typeof easingName !== `string`) {
    throw new TypeError(`easing field expected to be string`);
  }
  throwNumberTest(max5);
  const easingFunction = get(easingName);
  if (easingFunction === void 0) {
    throw new Error(`Easing '${easingName}' not found`);
  }
  throwNumberTest(min6);
  if (max5 <= min6) throw new Error(`Max should be greater than min`);
  const compute = () => {
    const r5 = clamp(easingFunction(source()));
    return Math.floor(r5 * (max5 - min6)) + min6;
  };
  return compute;
};
var weightedInteger = (maxOrOptions) => weightedIntegerSource(maxOrOptions)();

// src/components/pose-overlay.ts
var _colours;
var OverlayElement = class extends h3 {
  constructor() {
    super(...arguments);
    this.canvasEl = ii();
    __privateAdd(this, _colours, create({
      autoDeleteElapsedMs: 1e3,
      autoDeletePolicy: `get`
    }));
    this.lastHue = 100;
    this.labelPoints = true;
  }
  render() {
    return ke`
      <canvas ${Kt(this.canvasEl)}></canvas>
    `;
  }
  setSize(width, height4) {
    const el = this.canvasEl.value;
    if (!el) return;
    el.width = width;
    el.height = height4;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  draw(mode, data) {
    const el = this.canvasEl.value;
    if (!el) return;
    const wrap5 = wrap(el);
    wrap5.clear();
    if (!data) return;
    switch (mode) {
      case `hand`: {
        this.drawHands(wrap5, data);
        break;
      }
      case `objects`: {
        this.drawObjects(wrap5, data.detections);
        break;
      }
      case `pose`: {
        for (const d4 of data) {
          if (`poseid` in d4) {
            const pose = d4;
            this.drawPose(wrap5, pose);
          }
        }
        this.drawLandmarks(wrap5, data.landmarks);
        break;
      }
      case `face`: {
        this.drawFaces(wrap5, data.detections);
        break;
      }
    }
  }
  drawFaces(wrap5, d4) {
    for (let i4 = 0; i4 < d4.length; i4++) {
      const bbox7 = d4[i4].boundingBox;
      const colour2 = Colour_exports.goldenAngleColour(i4);
      for (let k3 = 0; k3 < d4[i4].keypoints.length; k3++) {
        const label = this.labelPoints ? k3.toString() : ``;
        wrap5.dot(d4[i4].keypoints[k3], 0.01, colour2, label);
      }
    }
  }
  drawHands(wrap5, results) {
    let index = 0;
    for (const hand of results.landmarks) {
      const colour2 = Colour_exports.goldenAngleColour(index);
      this.drawHand(wrap5, hand, colour2);
      this.drawOneSetOfLandmarks(wrap5, hand, 0.02, colour2);
      index++;
    }
  }
  drawHand(wrap5, p4, colour2) {
    const width = 0.01;
    wrap5.ctx.strokeStyle = colour2;
    wrap5.joinPoints(width, p4[0], p4[1], p4[2], p4[3], p4[4]);
    wrap5.joinPoints(width, p4[5], p4[6], p4[7], p4[8]);
    wrap5.joinPoints(width, p4[9], p4[10], p4[11], p4[12]);
    wrap5.joinPoints(width, p4[13], p4[14], p4[15], p4[16]);
    wrap5.joinPoints(width, p4[17], p4[18], p4[19], p4[20]);
    wrap5.joinPoints(width, p4[5], p4[9], p4[13], p4[17], p4[0], p4[5]);
  }
  drawObjects(wrap5, data) {
    const typewriter2 = typewriter(wrap5.ctx, 10, 100);
    let index = 0;
    for (const d4 of data) {
      const colour2 = Colour_exports.goldenAngleColour(index);
      this.drawDetectionBoundingBox(wrap5, d4, colour2, typewriter2);
      index++;
    }
  }
  drawDetectionBoundingBox(wrap5, det, colour2, typewriter2) {
    const ctx = wrap5.ctx;
    const bbox7 = det.boundingBox;
    if (bbox7) {
      this.drawBoundingBox(ctx, bbox7, colour2);
    }
    if (det.categories) {
      for (const c6 of det.categories) {
        typewriter2.line(`${c6.score.toPrecision(2)} - ${c6.categoryName}`, colour2);
      }
    }
  }
  drawBoundingBox(ctx, bbox7, colour2) {
    ctx.save();
    ctx.translate(bbox7.originX, bbox7.originY);
    ctx.rotate(bbox7.angle);
    ctx.lineWidth = 5;
    ctx.strokeStyle = colour2;
    ctx.strokeRect(0, 0, bbox7.width, bbox7.height);
    ctx.restore();
  }
  getColour(id) {
    let colour2 = __privateGet(this, _colours).get(id);
    __privateGet(this, _colours).touch(id);
    if (!colour2) {
      this.lastHue += 45 * Math.random();
      if (this.lastHue > 360) this.lastHue = this.lastHue % 360;
      colour2 = `hsl(${this.lastHue}deg, 50%, 50%)`;
      __privateGet(this, _colours).set(id, colour2);
    }
    return colour2;
  }
  drawLandmarks(wrap5, poses) {
    if (!poses) return;
    let index = 0;
    for (const p4 of poses) {
      this.drawOneSetOfLandmarks(wrap5, p4, 0.01, this.getColour(index.toString()));
      index++;
    }
  }
  drawOneSetOfLandmarks(wrap5, p4, maxRadius, colour2) {
    let index = 0;
    for (const l3 of p4) {
      let z3 = -1 * l3.z;
      const r5 = Math.min(maxRadius * 3, Math.max(1e-4, maxRadius + maxRadius * z3 * 3));
      const label = this.labelPoints ? index.toString() : ``;
      wrap5.dot(l3, r5, colour2, label);
      index++;
    }
  }
  drawPose(wrap5, pose) {
    const colour2 = this.getColour(pose.poseid);
    this.drawPoseLines(wrap5, pose.landmarks, colour2);
    if (this.labelPoints) {
      this.drawOneSetOfLandmarks(wrap5, pose.landmarks, 2e-3, colour2);
    }
  }
  drawPoseLines(wrap5, p4, colour2) {
    let index = 0;
    const width = 0.01;
    wrap5.ctx.strokeStyle = colour2;
    wrap5.joinPoints(width, p4[32], p4[30], p4[28], p4[26], p4[24], p4[12], p4[14], p4[16], p4[18], p4[20], p4[16], p4[22]);
    wrap5.joinPoints(width, p4[31], p4[29], p4[27], p4[25], p4[23], p4[11], p4[13], p4[15], p4[17], p4[19], p4[15], p4[21]);
    wrap5.joinPoints(width, p4[12], p4[11]);
    wrap5.joinPoints(width, p4[24], p4[23]);
    wrap5.joinPoints(width, p4[10], p4[9]);
    wrap5.joinPoints(width, p4[8], p4[6], p4[5], p4[4], p4[0], p4[1], p4[2], p4[3], p4[7]);
  }
};
_colours = new WeakMap();
OverlayElement.styles = i`
    :host {
      display: block;
      height: 100%;
      width: 100%;
    }
  `;
OverlayElement = __decorateClass([
  t3("overlay-element")
], OverlayElement);

// src/util/log.ts
var Log = class {
  constructor(prefix, verbosity) {
    if (typeof verbosity === `string`) {
      this.verbosity = verbosity;
    } else {
      this.verbosity = verbosity.verbosity;
    }
    this.prefix = prefix;
  }
  info(msg) {
    if (this.verbosity === `errors`) return;
    console.log(this.prefix, msg);
  }
  debug(msg) {
    if (this.verbosity !== `debug`) return;
    console.log(this.prefix, msg);
  }
};

// src/recorder.ts
var Recorder = class extends EventTarget {
  constructor(recordings, dispatcher) {
    super();
    this.recordings = recordings;
    this.dispatcher = dispatcher;
    this.#state = `idle`;
    this.buffer = [];
    this.computeFreqMs = 0;
    this.log = new Log(`Recorder`, `info`);
    this.onDataBound = this.onData.bind(this);
  }
  #state;
  #mode;
  start(computeFreqMs) {
    this.computeFreqMs = computeFreqMs;
    this.#setState(`recording`);
    this.dispatcher.addEventListener(`data`, this.onDataBound);
  }
  get length() {
    return this.buffer.length;
  }
  onData(event2) {
    const detail = event2.detail;
    const data = detail.data;
    const mode = detail.mode;
    this.#mode = mode;
    this.buffer.push(data);
    if (this.buffer.length % 5 === 0) {
      this.log.info(`Recorder: ${this.buffer.length} samples`);
    }
  }
  stop() {
    this.#setState(`complete`);
    this.dispatcher.removeEventListener(`data`, this.onDataBound);
    const name = this.recordings.promptName();
    if (name) {
      const rec = {
        rateMs: this.computeFreqMs,
        samples: this.buffer,
        mode: this.#mode,
        name
      };
      this.recordings.add(rec);
    }
    this.buffer = [];
  }
  #setState(state) {
    const prior = this.#state;
    if (state === prior) return;
    this.#state = state;
    if (state === `recording` && prior !== `idle`) throw new Error(`Cannot transition ${prior} - > ${state}`);
    if (state === `complete` && prior !== `recording`) throw new Error(`Cannot transition ${prior} - > ${state}`);
    this.log.debug(`${prior} -> ${state}`);
    this.dispatchEvent(new CustomEvent(`state-change`, {
      detail: {
        priorState: prior,
        newState: state
      }
    }));
  }
  get state() {
    return this.#state;
  }
};

// src/components/vision-element.ts
var _lastCameras, _lastRecordings, _lastSource, _lastOptions;
var VisionElement = class extends h3 {
  constructor() {
    super(...arguments);
    this.videoSelectorEl = ii();
    this.videoSourceEl = ii();
    this.overlayEl = ii();
    this.recPanelEl = ii();
    this.debug = true;
    __privateAdd(this, _lastCameras, []);
    __privateAdd(this, _lastRecordings, []);
    __privateAdd(this, _lastSource);
    __privateAdd(this, _lastOptions);
    this.uiSource = `video`;
    this.hideModelSelector = false;
  }
  render() {
    return ke`
      <div id="sources">
        <video-source id="video" ${Kt(this.videoSourceEl)} @sized=${this.onVideoSized}></video-source>
        <overlay-element @click=${this.onOverlayClick} id="overlay" ${Kt(this.overlayEl)} ></overlay-element>
      </div>
      <div id="controls">
        ${this.hideModelSelector ? ke`` : ke`<details><summary>Model</summary>
                  <model-element @request-mode=${this.onRequestMode}></model-element>
                </details>`}
        <details><summary>Source</summary>
          <fieldset @change=${this.onSelectSource}>
            <input type="radio" checked name="source" id="source-video" value="video"><label for="source-video">Video</label>
            <input type="radio" name="source" id="source-recording" value="recording"><label for="source-recording">Recording</label>
          </fieldset>
          <video-selector class=${this.uiSource === `video` ? `show` : `hidden`} 
            .source=${__privateGet(this, _lastSource)} 
            .cameras=${__privateGet(this, _lastCameras)} ${Kt(this.videoSelectorEl)} 
            @startstop=${this.onVideoStartStop}
            @change=${this.onVideoSelectorChange}>
          </video-selector>
          <rec-panel class=${this.uiSource === `recording` ? `show` : `hidden`} 
            .recordings=${__privateGet(this, _lastRecordings)} 
            @startstop=${this.onRecStartStop}
            @change=${this.onRecSelectorChange}
            @request-delete=${this.onRecRequestDelete}
            id="rec-panel" ${Kt(this.recPanelEl)}>
            </rec-panel>
        </details>
        <details><summary>Recording</summary>
        ${this.getRecordingUi()}
        </details>
      </div>
    `;
  }
  onRequestMode(event2) {
    this.dispatchEvent(new CustomEvent(`request-mode`, {
      detail: event2.detail
    }));
  }
  onRecRequestDelete(event2) {
    const detail = event2.detail;
    this.dispatchEvent(new CustomEvent(`request-source-delete`, { detail }));
  }
  onRecSelectorChange(event2) {
    const detail = event2.detail;
    this.dispatchEvent(new CustomEvent(`request-source`, { detail }));
  }
  /**
   * User has choosing a new camera
   * @param event 
   */
  onVideoSelectorChange(event2) {
    const detail = event2.detail;
    this.dispatchEvent(new CustomEvent(`request-source`, { detail }));
  }
  onRecStartStop(event2) {
    const detail = event2.detail;
    this.dispatchEvent(new CustomEvent(`source-startstop`, {
      detail
    }));
  }
  onVideoStartStop(event2) {
    const detail = event2.detail;
    this.dispatchEvent(new CustomEvent(`source-startstop`, {
      detail
    }));
  }
  getRecordingUi() {
    if (!this.recorder) return ke`<button @click=${this.onStartRecording}>Start recording</button>`;
    const r5 = this.recorder;
    switch (r5.state) {
      case "recording": {
        return ke`<button @click=${this.onStopRecording}>Stop recording</button>`;
      }
      case "complete": {
        return ke`<em>Complete</em>`;
      }
    }
  }
  onStopRecording() {
    const r5 = this.recorder;
    if (!r5) return;
    r5.stop();
    this.recorder = void 0;
  }
  onStartRecording() {
    this.dispatchEvent(new CustomEvent(`request-recorder`));
  }
  onOverlayClick() {
    this.videoSourceEl.value?.togglePreview();
  }
  setOptions(options) {
    __privateSet(this, _lastOptions, options);
  }
  /**
   * User swapped between camera/recording in UI
   * @param event 
   * @returns 
   */
  onSelectSource(event2) {
    const t6 = event2.target;
    if (!t6) return;
    if (t6.value === `video`) {
      this.uiSource = `video`;
    } else if (t6.value === `recording`) {
      this.uiSource = `recording`;
    }
  }
  /**
   * Notification that sources have been updated
   * @param sources 
   */
  onSourcesUpdated(cameras, recordings) {
    __privateSet(this, _lastCameras, cameras);
    __privateSet(this, _lastRecordings, recordings);
    const el = this.videoSelectorEl.value;
    if (el) {
      el.cameras = cameras;
    }
    const recPanel = this.recPanelEl.value;
    if (recPanel) {
      recPanel.recordings = __privateGet(this, _lastRecordings);
    } else {
      console.warn(`Not able to set recordings, element missing.`);
    }
  }
  connectedCallback() {
    super.connectedCallback();
    window.addEventListener(`resize`, () => {
      this.resizeElements();
    });
  }
  firstUpdated(_changedProperties) {
    const overlay = this.overlayEl.value;
    const opts = __privateGet(this, _lastOptions)?.overlay;
    if (overlay && opts) {
      overlay.labelPoints = opts.label;
    } else {
      console.warn(`Not able to set options for overlay, element missing.`);
    }
  }
  updateRecPanel() {
    const el = this.shadowRoot?.getElementById(`rec-panel`);
    const recPanel = this.recPanelEl.value || el;
    if (recPanel) {
      recPanel.recordings = __privateGet(this, _lastRecordings);
    } else {
      console.warn(`Not able to set recordings, element missing.`);
    }
  }
  /**
   * Notification that source has changed
   * @param source 
   */
  notifySourceChange(source) {
    __privateSet(this, _lastSource, source);
    let el = this.videoSelectorEl.value;
    if (el) {
      el.source = source;
    }
  }
  notifySourceState(state, source) {
    if (!source) {
      this.videoSelectorEl.value?.notifySourceState(state);
      this.recPanelEl.value?.notifySourceState(state);
    } else if (source.kind === `camera` || source.kind === `file`) {
      this.videoSelectorEl.value?.notifySourceState(state);
    } else if (source.kind === `recording`) {
      this.recPanelEl.value?.notifySourceState(state);
    }
  }
  onVideoSized() {
    this.resizeElements();
  }
  resizeElements() {
    const overlay = this.overlayEl.value;
    const v3 = this.videoSourceEl.value;
    if (!v3 || !overlay) return;
    const container = this.getBoundingClientRect();
    const videoSize = v3.getVideoSize();
    if (!videoSize) return;
    let w3 = videoSize?.width;
    let h5 = videoSize?.height;
    const isVideoLandscape = w3 >= h5;
    const videoRatioWoverH = w3 / h5;
    const videoRatioHoverW = h5 / w3;
    const isLandscape = w3 >= h5;
    let constrainedDimension = isVideoLandscape ? `width` : `height`;
    if (isLandscape) constrainedDimension = `height`;
    if (constrainedDimension === `width`) {
      w3 = container.width;
      h5 = w3 * videoRatioHoverW;
    } else {
      h5 = container.height;
      w3 = h5 * videoRatioWoverH;
    }
    const left = container.width / 2 - w3 / 2;
    const top = container.height / 2 - h5 / 2;
    v3.style.height = overlay.style.height = `${h5}px`;
    v3.style.width = overlay.style.width = `${w3}px`;
    v3.style.left = overlay.style.left = `${left}px`;
    v3.style.top = overlay.style.top = `${top}px`;
    overlay.setSize(w3, h5);
  }
  onSourceChange(event2) {
    const d4 = event2.detail;
    this.dispatchEvent(new CustomEvent(`change-source`, {
      detail: d4
    }));
  }
  onReceivedData(mode, data) {
    const el = this.overlayEl.value;
    if (!el) return;
    el.draw(mode, data);
  }
  getVideoSource() {
    return this.videoSourceEl.value;
  }
  getVideoElement() {
    const src = this.getVideoSource();
    if (!src) return;
    return src.getVideoElement();
  }
};
_lastCameras = new WeakMap();
_lastRecordings = new WeakMap();
_lastSource = new WeakMap();
_lastOptions = new WeakMap();
VisionElement.styles = i`
  :host {
    display: block;
    background-color: transparent;
    font-family: system-ui, sans-serif;
  }
  #controls {
    background: black;
    color: white;
    position: absolute;
    top: 0px;
    left: 0px;
    padding: 0.5rem;
  }
  #overlay,#video {
    position:absolute;
  }
  #sources {
    background:green;
  }
  fieldset {
    border: 0;
  }
  summary {
    user-select: none;
    pointer:default;
  }
  details {
    padding:0.3rem;
  }

  .hidden {
    display:none;
  }
  `;
__decorateClass([
  n4()
], VisionElement.prototype, "uiSource", 2);
__decorateClass([
  n4()
], VisionElement.prototype, "recorder", 2);
__decorateClass([
  n4()
], VisionElement.prototype, "hideModelSelector", 2);
VisionElement = __decorateClass([
  t3("vision-element")
], VisionElement);

// src/components/rec-panel.ts
var RecPanel = class extends h3 {
  constructor() {
    super(...arguments);
    this.recordings = [];
    this.playing = false;
    this.selectEl = ii();
  }
  render() {
    if (this.recordings.length === 0) {
      return ke`<em>No recordings</em>`;
    }
    let recs = [
      ...this.recordings
    ];
    return ke`
    <div id="contents">
      <div id="toolbar">
        <button @click=${this.onStartStopClick}>${this.playing ? `Stop` : `Play`}</button>
      </div>
      <select ${Kt(this.selectEl)} @change=${this.onSelectChange}>
        ${this.recordings.map((r5) => ke`<option .source=${r5}>${r5.label}</option>`)}
      </select>
      <button @click=${this.onDeleteClick}>Delete</button>
    </div>
    `;
  }
  onStartStopClick() {
    const rec = this.getSelected();
    if (!rec) {
      console.warn(`No recording selected?`);
      return;
    }
    this.dispatchEvent(new CustomEvent(`startstop`, { detail: rec }));
  }
  onSelectChange(event2) {
    const target = event2.target;
    if (!target) return;
    const item = target.item(target.selectedIndex);
    if (!item) return;
    const recording = item.recording;
  }
  getSelected() {
    const el = this.selectEl.value;
    if (!el) return;
    const item = el.item(el.selectedIndex);
    if (!item) return;
    return item.source;
  }
  onDeleteClick() {
    const rec = this.getSelected();
    if (!rec) return;
    this.dispatchEvent(new CustomEvent(`request-delete`, { detail: rec }));
  }
  // #setState(state: RecPanelStates) {
  //   const prior = this.#state;
  //   if (state === prior) return;
  //   this.#state = state;
  //   this.#log(`state ${ prior } -> ${ state }`);
  //   this.dispatchEvent(new CustomEvent(`state`, {
  //     detail: {
  //       priorState: prior,
  //       newState: state
  //     }
  //   }));
  // }
  notifySourceState(state) {
    this.playing = state === `started`;
  }
  // onToggle() {
  //   this.expanded = !this.expanded;
  // }
};
RecPanel.styles = i`
    :host {
      display:block;
      background-color: hsla(0,0%,30%,0.5);
    }
    #contents {
      padding: 0.5rem;
    }
    #toolbar {
      margin-bottom: 0.5rem;
    }
  `;
__decorateClass([
  n4()
], RecPanel.prototype, "recordings", 2);
__decorateClass([
  n4()
], RecPanel.prototype, "playing", 2);
RecPanel = __decorateClass([
  t3("rec-panel")
], RecPanel);

// src/components/video-source.ts
var _state, _VideoSourceElement_instances, setState_fn;
var VideoSourceElement = class extends h3 {
  constructor() {
    super(...arguments);
    __privateAdd(this, _VideoSourceElement_instances);
    this.videoEl = ii();
    this.log = new Log(`VideoSourceElement`, `errors`);
    __privateAdd(this, _state, `stopped`);
    this.showPreview = true;
  }
  render() {
    return ke`
      <video class=${this.showPreview ? `show` : `hide`} @pause=${this.onPause} @loadedmetadata=${this.onLoadedMetadata} @playing=${this.onPlaying} @ended=${this.onEnded} loop autoplay muted playsInline webkitPlaysInline ${Kt(this.videoEl)}></video>
    `;
  }
  togglePreview() {
    this.showPreview = !this.showPreview;
  }
  getVideoElement() {
    return this.videoEl.value;
  }
  getVideoSize() {
    const el = this.videoEl.value;
    if (!el) return;
    return {
      width: el.videoWidth,
      height: el.videoHeight
    };
  }
  get isStarted() {
    return __privateGet(this, _state) === `started`;
  }
  start() {
    const el = this.videoEl.value;
    if (!el) {
      console.warn(`No video element`);
    } else {
      el.play();
    }
  }
  stop() {
    const el = this.videoEl.value;
    if (!el) {
      console.warn(`No video element`);
    } else {
      el.pause();
    }
  }
  onLoadedMetadata() {
    const el = this.videoEl.value;
    if (!el) return;
    this.dispatchEvent(new CustomEvent(
      `sized`,
      {
        detail: {
          width: el.videoWidth,
          height: el.videoHeight
        }
      }
    ));
  }
  /**
   * From video element - now playing
   */
  onPlaying() {
    __privateMethod(this, _VideoSourceElement_instances, setState_fn).call(this, `started`);
  }
  /**
   * From video element - now stopped
   */
  onPause() {
    __privateMethod(this, _VideoSourceElement_instances, setState_fn).call(this, `stopped`);
  }
  /**
   * From video element - now stopped
   */
  onEnded() {
    __privateMethod(this, _VideoSourceElement_instances, setState_fn).call(this, `stopped`);
  }
  setVideoSource(source) {
    const el = this.videoEl.value;
    if (el) {
      el.classList.remove(`hide`);
      if (typeof source === `string`) {
        el.srcObject = null;
        el.src = source;
      } else {
        if (!source) {
          el.pause();
          el.classList.add(`hide`);
        }
        el.srcObject = source ?? null;
      }
    } else {
      console.warn(`Video element unavailable`);
    }
    if (source && el?.paused) {
      el.play();
    }
  }
};
_state = new WeakMap();
_VideoSourceElement_instances = new WeakSet();
setState_fn = function(state) {
  const prior = __privateGet(this, _state);
  if (state === prior) return;
  __privateSet(this, _state, state);
  this.log.debug(`state ${prior} -> ${state}`);
  this.dispatchEvent(new CustomEvent(`state`, {
    detail: {
      priorState: prior,
      newState: state
    }
  }));
};
VideoSourceElement.styles = i`
    :host {
      display: block;
    }
    video {
      width: 100%;
      height: 100%;
      opacity: 0.5;
    }
    video.hide {
      display:none;
    }
  `;
__decorateClass([
  n4()
], VideoSourceElement.prototype, "source", 2);
__decorateClass([
  n4()
], VideoSourceElement.prototype, "showPreview", 2);
VideoSourceElement = __decorateClass([
  t3("video-source")
], VideoSourceElement);

// src/processor-modes.ts
var getProcessorModes = () => [`pose`, `objects`, `hand`, `face`];
var validateProcessorMode = (a4, fallback) => {
  if (typeof a4 === `string`) {
    if (a4 === `pose`) return `pose`;
    if (a4 === `hand`) return `hand`;
    if (a4 === `face`) return `face`;
    if (a4 === `objects`) return `objects`;
  }
  if (fallback) return fallback;
  throw new Error(`Invalid mode: ${a4}. Expected: ${getProcessorModes().join(`,`)}`);
};

// src/components/model-element.ts
var ModelElement = class extends h3 {
  render() {
    const modes = getProcessorModes();
    return ke`
      <select @change=${this.onSelectChange}>
      ${modes.map((m5) => ke`<option>${m5}</option>`)}
      </select>
    `;
  }
  onSelectChange(event2) {
    const value2 = event2.target.value;
    this.dispatchEvent(new CustomEvent(`request-mode`, {
      detail: {
        mode: validateProcessorMode(value2)
      }
    }));
  }
};
ModelElement.styles = i`
    :host {
      display: block;
    
    }
  `;
ModelElement = __decorateClass([
  t3("model-element")
], ModelElement);

// src/mediapipe/pose-matcher.ts
var TrackedPose = class {
  constructor() {
    this.centroid = point_exports.Empty;
    this.firstSeen = performance.now();
    this.lastSeen = performance.now();
    this.id = shortGuid();
  }
};
var getLowest = (data, fn2) => {
  const ranked = data.map((d4) => fn2(d4));
  let index = -1;
  let score = Number.MAX_SAFE_INTEGER;
  for (let i4 = 0; i4 < ranked.length; i4++) {
    if (ranked[i4] < score) {
      score = ranked[i4];
      index = i4;
    }
  }
  if (index === -1) return void 0;
  return { data: data[index], score };
};
var PoseMatcher = class {
  constructor(opts) {
    this.tracked = [];
    this.lastPrune = 0;
    this.distanceThreshold = opts.distanceThreshold;
    this.ageThreshold = opts.maxAgeMs;
    this.log = new Log(`PoseMatcher`, opts.verbosity);
  }
  *toPoses(poses) {
    for (let i4 = 0; i4 < poses.landmarks.length; i4++) {
      yield this.toPose(poses.landmarks[i4], poses.worldLandmarks[i4]);
    }
  }
  toPose(n7, l3) {
    const c6 = point_exports.centroid(n7[12], n7[11], n7[24], n7[23]);
    const now = performance.now();
    if (now - this.lastPrune > this.ageThreshold) {
      let pre = this.tracked.length;
      this.tracked = this.tracked.filter((d4) => {
        const age = now - d4.lastSeen;
        if (age > this.ageThreshold) return false;
        return true;
      });
      this.lastPrune = now;
      let post = this.tracked.length;
      if (post < pre) {
        this.log.debug(`Pruned: ${pre - post} expired pose(s)`);
      }
    }
    const closest = getLowest(this.tracked, (d4) => point_exports.distance(d4.centroid, c6));
    let target;
    if (!closest || closest.score > this.distanceThreshold) {
      if (closest) {
        this.log.info(`Closest match exceeds threshold. Score: ${closest?.score} Threshold: ${this.distanceThreshold}`);
      } else {
        this.log.info(`No poses`);
      }
      target = new TrackedPose();
      this.tracked.push(target);
    } else {
      target = closest.data;
    }
    target.lastSeen = now;
    target.centroid = c6;
    return {
      poseid: target.id,
      landmarks: n7,
      world: l3
    };
  }
};

// src/mediapipe/makeModelPath.ts
var makeModelPath = (basePath, provided) => {
  if (provided.startsWith(`http`)) return provided;
  return basePath + provided;
};

// src/mediapipe/pose-detector.ts
var PoseDetector = class _PoseDetector {
  constructor(p4, opts = {}) {
    this.p = p4;
    this.opts = {
      ..._PoseDetector.defaults(),
      ...opts
    };
    this.log = new Log(`PoseDetector`, this.opts.verbosity);
    this.matcher = new PoseMatcher(this.opts.matcher);
  }
  static defaults() {
    return {
      numPoses: 5,
      minPoseDetectionConfidence: 0.3,
      minPosePresenceConfidence: 0.3,
      minTrackingConfidence: 0.3,
      outputSegmentationMasks: false,
      modelPath: "pose_landmarker_full.task",
      verbosity: `errors`,
      matcher: {
        distanceThreshold: 0.1,
        maxAgeMs: 2e3,
        verbosity: `errors`
      }
    };
  }
  compute(v3, callback, timestamp) {
    this.lp?.detectForVideo(v3, timestamp, (poses) => {
      const matched = [...this.matcher.toPoses(poses)];
      callback(matched);
    });
  }
  async init() {
    const p4 = this.p;
    const v3 = await Xo.forVisionTasks(p4.wasmBase);
    const opts = this.opts;
    const mpOpts = {
      baseOptions: {
        modelAssetPath: makeModelPath(p4.modelsBase, opts.modelPath),
        delegate: `GPU`
      },
      runningMode: `VIDEO`,
      numPoses: opts.numPoses,
      minPoseDetectionConfidence: opts.minPoseDetectionConfidence,
      minPosePresenceConfidence: opts.minPosePresenceConfidence,
      minTrackingConfidence: opts.minTrackingConfidence,
      outputSegmentationMasks: opts.outputSegmentationMasks
    };
    this.log.info(mpOpts);
    this.lp = await hc.createFromOptions(v3, mpOpts);
    return true;
  }
  dispose() {
    this.lp?.close();
    this.lp = void 0;
  }
};

// src/mediapipe/object-detector.ts
var ObjectDetector = class _ObjectDetector {
  constructor(p4, options = {}) {
    this.p = p4;
    this.opts = {
      ..._ObjectDetector.defaults(),
      ...options
    };
    this.log = new Log(`ObjectDetector`, this.opts.verbosity);
  }
  static defaults() {
    return {
      verbosity: `errors`,
      modelPath: "efficientdet_lite0.tflite",
      scoreThreshold: 0.5
    };
  }
  compute(v3, callback, timestamp) {
    const results = this.od?.detectForVideo(v3, timestamp);
    callback(results);
  }
  dispose() {
    this.od?.close();
    this.od = void 0;
  }
  async init() {
    const p4 = this.p;
    const vision = await Xo.forVisionTasks(p4.wasmBase);
    const mpOpts = {
      baseOptions: {
        modelAssetPath: makeModelPath(p4.modelsBase, this.opts.modelPath)
      },
      scoreThreshold: 0.5,
      runningMode: `VIDEO`
    };
    this.od = await ic.createFromOptions(vision, mpOpts);
    this.log.info(mpOpts);
    return true;
  }
};

// src/mediapipe/face-detector.ts
var FaceDetector = class _FaceDetector {
  constructor(p4, options = {}) {
    this.p = p4;
    this.opts = {
      ..._FaceDetector.defaults(),
      ...options
    };
    this.log = new Log(`FaceDetector`, this.opts.verbosity);
  }
  static defaults() {
    return {
      verbosity: `errors`,
      modelPath: "blaze_face_short_range.tflite",
      minDetectionConfidence: 0.5,
      minSupressionThreshold: 0.3
    };
  }
  compute(v3, callback, timestamp) {
    const results = this.fd?.detectForVideo(v3, timestamp);
    callback(results);
  }
  dispose() {
    this.fd?.close();
    this.fd = void 0;
  }
  async init() {
    const opts = this.opts;
    const p4 = this.p;
    const vision = await Xo.forVisionTasks(p4.wasmBase);
    const mpOpts = {
      baseOptions: {
        modelAssetPath: makeModelPath(p4.modelsBase, this.opts.modelPath)
      },
      minDetectionConfidence: opts.minDetectionConfidence,
      minSuppressionThreshold: opts.minSupressionThreshold,
      runningMode: `VIDEO`
    };
    this.log.info(mpOpts);
    this.fd = await sh.createFromOptions(vision, mpOpts);
    return true;
  }
};

// src/mediapipe/hand-detector.ts
var HandDetector = class _HandDetector {
  constructor(p4, options = {}) {
    this.p = p4;
    this.opts = {
      ..._HandDetector.defaults(),
      ...options
    };
    this.log = new Log(`HandDetector`, this.opts.verbosity);
  }
  static defaults() {
    return {
      verbosity: `errors`,
      numHands: 2,
      modelPath: "hand_landmarker.task",
      minHandDetectionConfidence: 0.5,
      minHandPresenceConfidence: 0.5,
      minTrackingConfidence: 0.5
    };
  }
  compute(v3, callback, timestamp) {
    const results = this.hd?.detectForVideo(v3, timestamp);
    callback(results);
  }
  dispose() {
    this.hd?.close();
    this.hd = void 0;
  }
  async init() {
    const opts = this.opts;
    const p4 = this.p;
    const vision = await Xo.forVisionTasks(p4.wasmBase);
    const mpOpts = {
      baseOptions: {
        modelAssetPath: makeModelPath(p4.modelsBase, this.opts.modelPath)
      },
      minHandDetectionConfidence: opts.minHandDetectionConfidence,
      minHandPresenceConfidence: opts.minHandPresenceConfidence,
      minTrackingConfidence: opts.minTrackingConfidence,
      numHands: opts.numHands,
      runningMode: `VIDEO`
    };
    this.hd = await kh.createFromOptions(vision, mpOpts);
    this.log.info(mpOpts);
    return true;
  }
};

// src/processing.ts
var Processing = class extends EventTarget {
  constructor(mlv, opts) {
    super();
    this.mlv = mlv;
    this.#currentMode = opts.mode;
    this.wasmBase = opts.wasmBase;
    this.modelsBase = opts.modelsBase;
    this.log = new Log(`Processing`, opts.verbosity);
    this.dispatcher = mlv.dispatcher;
    this.dispatcherBound = this.dispatcher.receivedData.bind(this.dispatcher);
    this.computeFreqMs = opts.computeFreqMs;
    this.poseOptions = opts.pose ?? PoseDetector.defaults();
    this.objectDetectorOptions = opts.objects ?? ObjectDetector.defaults();
    this.faceDetectorOptions = opts.face ?? FaceDetector.defaults();
    this.handDetectorOptions = opts.hand ?? HandDetector.defaults();
  }
  #state = `stopped`;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  #updateTimer;
  #model;
  #currentMode = `face`;
  #videoEl;
  stop() {
    if (this.#state === `stopping` || this.#state === `stopped`) return;
    this.setState(`stopping`);
    this.#model?.dispose();
    this.#model = void 0;
    this.setState(`stopped`);
  }
  setMode(mode) {
    if (mode === this.currentMode) return;
    if (typeof mode !== `string`) throw new Error(`Expected string. Got: ${typeof mode}`);
    validateProcessorMode(mode);
    localStorage.setItem(`last-mode`, mode);
    const video = this.#videoEl;
    if (!video) return;
    this.stop();
    this.#currentMode = mode;
    this.start(video);
  }
  getModelOptions() {
    const modelOpts = {
      wasmBase: this.wasmBase,
      modelsBase: this.modelsBase
    };
    return modelOpts;
  }
  async start(video) {
    this.setState(`starting`);
    this.#videoEl = video;
    switch (this.#currentMode) {
      case `pose`: {
        this.log.info(this.poseOptions);
        this.#model = new PoseDetector(this.getModelOptions(), this.poseOptions);
        break;
      }
      case `objects`: {
        this.log.info(this.objectDetectorOptions);
        this.#model = new ObjectDetector(this.getModelOptions(), this.objectDetectorOptions);
        break;
      }
      case `face`: {
        this.log.info(this.faceDetectorOptions);
        this.#model = new FaceDetector(this.getModelOptions(), this.faceDetectorOptions);
        break;
      }
      case `hand`: {
        this.log.info(this.handDetectorOptions);
        this.#model = new HandDetector(this.getModelOptions(), this.handDetectorOptions);
        break;
      }
      default: {
        throw new Error(`Unsupported mode '${this.#currentMode}'. Expected: 'hand', 'pose', 'objects' or 'face'`);
      }
    }
    if (this.#model) {
      this.#model.init();
      this.setState(`started`);
    }
  }
  #run() {
    const v3 = this.#videoEl;
    if (!v3) {
      console.warn(`No video element`);
      return;
    }
    this.#model?.compute(v3, (data) => this.dispatcher.receivedData(this.#currentMode, data), performance.now());
    if (this.#state === `started`) {
      this.#updateTimer = setTimeout(() => this.#run(), this.computeFreqMs);
    }
  }
  setState(state) {
    if (this.#state === state) return;
    const prior = this.#state;
    if (state === `starting`) {
      if (prior !== `stopped` && prior !== `queued-start`) throw new Error(`Cannot start when in state: ${prior}`);
    }
    if (state === `started`) {
      if (prior !== `starting`) throw new Error(`Cannot go to 'started' when state is: ${prior}`);
    }
    this.#state = state;
    if (state === `started`) {
      this.#updateTimer = setTimeout(() => this.#run(), this.computeFreqMs);
    } else {
      if (this.#updateTimer) {
        clearTimeout(this.#updateTimer);
      }
      this.#updateTimer = 0;
    }
    this.log.debug(`State ${prior} -> ${state}`);
    this.dispatchEvent(new CustomEvent(`state`, {
      detail: {
        priorState: prior,
        newState: state
      }
    }));
  }
  get isStarted() {
    return this.#state === `started`;
  }
  get currentMode() {
    return this.#currentMode;
  }
};

// src/util/text.ts
var snipBefore = (input, match) => {
  const pos = input.indexOf(match);
  if (pos >= 0) {
    return input.substring(0, pos);
  }
  return input;
};

// src/sources/camera-sources.ts
var CameraSources = class {
  constructor(sources) {
    this.sources = sources;
  }
  #disabled = false;
  #cameras = [];
  init() {
    this.updateDevices();
  }
  async updateDevices() {
    if (this.#disabled) return;
    if (!(`mediaDevices` in navigator)) {
      console.warn(`navigator.mediaDevices is missing -- are you running over https:// or via localhost?`);
      this.#disabled = true;
      return;
    }
    if (!("getUserMedia" in navigator.mediaDevices)) {
      this.#disabled = true;
      console.warn(`navigator.getUserMedia is missing -- are you running over https:// or via localhost?`);
      return;
    }
    await navigator.mediaDevices.getUserMedia({ video: true });
    const devices = await navigator.mediaDevices.enumerateDevices();
    this.#cameras = devices.filter((d4) => d4.kind === `videoinput`).map((d4) => ({
      id: d4.deviceId,
      kind: `camera`,
      label: snipBefore(d4.label, "(").trim()
    }));
    this.sources.notifySourceUpdated(this);
  }
  get cameras() {
    return this.#cameras;
  }
};

// src/sources/record-player.ts
var RecordPlayer = class {
  constructor(data, dispatcher) {
    this.data = data;
    this.dispatcher = dispatcher;
  }
  #timer = 0;
  async start() {
    let pos = 0;
    const mode = this.data.mode;
    const samples = this.data.samples;
    this.#timer = setInterval(() => {
      this.dispatcher.receivedData(mode, samples[pos]);
      pos++;
      if (pos >= this.data.samples.length) pos = 0;
    }, this.data.rateMs * 2);
    return true;
  }
  stop() {
    clearInterval(this.#timer);
  }
};

// src/sources/recording-sources.ts
var Recordings = class {
  constructor(sources) {
    this.sources = sources;
  }
  #store = [];
  delete(source) {
    const filtered = this.#store.filter((rd) => rd.name !== source.id);
    if (filtered.length !== this.#store.length) {
      this.#store = filtered;
      this.save();
    }
  }
  getSources() {
    return this.#store.map((r5) => ({
      id: r5.name,
      kind: `recording`,
      label: r5.name
    }));
  }
  getRecording(name) {
    return this.#store.find((r5) => r5.name === name);
  }
  add(data) {
    this.#store.push(data);
    this.save();
  }
  save() {
    localStorage.setItem(`recordings`, JSON.stringify(this.#store));
    this.sources.notifySourceUpdated(this);
  }
  init() {
    const s3 = localStorage.getItem(`recordings`);
    if (!s3) return;
    try {
      const o5 = JSON.parse(s3);
      for (const d4 of o5) {
        this.#store.push(d4);
      }
      this.sources.notifySourceUpdated(this);
    } catch (error) {
      console.error(error);
    }
  }
  promptName() {
    const formatOpts = {
      dateStyle: `short`,
      timeStyle: `short`
    };
    const defaultName = new Intl.DateTimeFormat("se-SE", formatOpts).format(Date.now()) + " recording " + this.#store.length + 1;
    const name = window.prompt(`Name for recording`, defaultName);
    return name;
  }
};

// src/sources/video-element-source.ts
var VideoElementSource = class {
  constructor(src, data, camera) {
    this.src = src;
    this.data = data;
    this.camera = camera;
  }
  async start() {
    let stream = void 0;
    switch (this.data.kind) {
      case "camera": {
        stream = await this.getMediaStream();
        this.mediaStream = stream;
        break;
      }
      case "file": {
        stream = this.data.id;
        break;
      }
    }
    this.src.setVideoSource(stream);
    if (stream) {
      this.src.start();
      return true;
    } else {
      this.src.stop();
      return false;
    }
  }
  stop() {
    if (this.mediaStream) {
      for (const vt2 of this.mediaStream.getVideoTracks()) {
        vt2.stop();
      }
    }
    this.src.stop();
  }
  async getMediaStream() {
    if (this.data.id === `-`) return void 0;
    const c6 = getConstraints(this.data, this.camera);
    try {
      const stream = await navigator.mediaDevices.getUserMedia(c6);
      return stream;
    } catch (error) {
      if (typeof error === `object`) {
        const name = error.name ?? ``;
        if (name === `OverconstrainedError`) {
          console.error(`Overconstrained error: ${error.constraint}`);
          console.error(`Constraints: ${JSON.stringify(c6)}`);
        }
      }
      throw error;
    }
  }
};
var getConstraints = (source, options) => {
  const video = {};
  if (source.id.length > 0) {
    video.deviceId = { exact: source.id };
  }
  if (options.facingMode) {
    video.facingMode = options.facingMode;
  }
  if (options.height) {
    video.height = { ideal: options.height };
  }
  if (options.width) {
    video.width = { ideal: options.width };
  }
  const constraints = {
    video
  };
  return constraints;
};

// src/sources/index.ts
var Sources = class extends EventTarget {
  constructor(cameraOptions, mlv) {
    super();
    this.mlv = mlv;
    this.log = new Log(`Sources`, mlv.log);
    this.#cameraOpts = cameraOptions;
    this.#camera = new CameraSources(this);
    this.#recordings = new Recordings(this);
  }
  #camera;
  #recordings;
  #state = `stopped`;
  #current;
  #currentData;
  #videoEl;
  #cameraOpts;
  delete(source) {
    if (source.kind !== `recording`) throw new Error(`Cannot delete type: ${source.kind}`);
    this.#recordings.delete(source);
  }
  get isStarted() {
    return this.#state === `started`;
  }
  createRecorder() {
    return new Recorder(this.#recordings, this.mlv.dispatcher);
  }
  startStop() {
    if (this.#state === `stopped`) {
      this.start();
      return true;
    } else if (this.#state === `started`) {
      this.stop();
      return false;
    } else {
      console.warn(`Cannot start/stop in state: ${this.#state}`);
      return false;
    }
  }
  kindMatch(kind) {
    if (this.#currentData) {
      if (this.#currentData.kind === kind) return true;
    }
    return false;
  }
  async start() {
    this.#setState(`starting`);
    const sourceData = this.#currentData;
    if (!sourceData) throw new Error(`Cannot start, no source data available`);
    let source;
    let videoEl = this.#videoEl;
    if (!videoEl) {
      videoEl = this.#videoEl = this.mlv.el.getVideoSource();
    }
    switch (sourceData.kind) {
      case `camera`: {
        if (!videoEl) throw new Error(`No video element`);
        source = new VideoElementSource(videoEl, sourceData, this.#cameraOpts);
        break;
      }
      case `file`: {
        if (!videoEl) throw new Error(`No video element`);
        source = new VideoElementSource(videoEl, sourceData, this.#cameraOpts);
        break;
      }
      case `recording`: {
        const rec = this.#recordings.getRecording(sourceData.id);
        if (rec) {
          source = new RecordPlayer(rec, this.mlv.dispatcher);
        } else {
          console.warn(`Could not get recording: ${sourceData.id}`);
        }
      }
    }
    this.#current = source;
    if (await source?.start()) {
      this.#setState(`started`);
    } else {
      this.#setState(`stopped`);
    }
  }
  stop() {
    const current = this.#current;
    if (current) {
      try {
        current.stop();
        this.#current = void 0;
      } catch (error) {
        console.error(error);
      }
    }
    this.#setState(`stopped`);
  }
  get cameras() {
    return this.#camera.cameras;
  }
  get recordings() {
    return this.#recordings.getSources();
  }
  init() {
    this.#camera.init();
    this.#recordings.init();
  }
  setSource(sourceData) {
    this.log.debug(`setSource: ${JSON.stringify(sourceData)}`);
    this.#currentData = sourceData;
    this.dispatchEvent(new CustomEvent(`source-change`, { detail: sourceData }));
  }
  getCurrentId() {
    if (this.#currentData) return this.#currentData.id;
    return ``;
  }
  notifySourceUpdated(source) {
    this.dispatchEvent(new CustomEvent(`updated`, {
      detail: source
    }));
    if (source === this.#camera && !this.#current) {
      const c6 = this.#camera.cameras[0];
      if (c6) {
        this.setSource(c6);
        this.start();
      }
    }
  }
  #setState(state) {
    const prior = this.#state;
    if (prior === state) return;
    this.#state = state;
    if (state === `starting` && prior !== `stopped`) throw new Error(`Cannot transition ${prior} -> ${state}`);
    this.log.debug(`state ${prior} -> ${state} (current: ${JSON.stringify(this.#currentData)})`);
    const dict = {
      priorState: prior,
      newState: state
    };
    this.dispatchEvent(new CustomEvent(`state-change`, { detail: dict }));
  }
  get currentSourceData() {
    return this.#currentData;
  }
};

// node_modules/@clinth/remote/dist/Util.js
var shortUuid = () => {
  const firstPart = Math.random() * 46656 | 0;
  const secondPart = Math.random() * 46656 | 0;
  return ("000" + firstPart.toString(36)).slice(-3) + ("000" + secondPart.toString(36)).slice(-3);
};
var elapsed2 = (from2) => {
  let e5 = Date.now() - from2;
  if (e5 < 1e3)
    return `${e5}ms`;
  e5 /= 1e3;
  if (e5 < 1e3)
    return `${e5}s`;
  e5 /= 60;
  if (e5 < 60)
    return `${e5}mins`;
  e5 /= 60;
  return `${e5}hrs`;
};

// node_modules/@clinth/remote/dist/BroadcasterBase.js
var BroadcasterBase = class {
  constructor(_name, _broadcast, _log) {
    this._name = _name;
    this._broadcast = _broadcast;
    this._log = _log;
    this._state = `idle`;
  }
  setState(newState) {
    if (newState == this._state)
      return;
    const priorState = this._state;
    this._state = newState;
    this._log.verbose(priorState + " -> " + newState);
    this._broadcast.onBroadcasterState(priorState, newState, this);
  }
  get state() {
    return this._state;
  }
  get name() {
    return this._name;
  }
};

// node_modules/@clinth/remote/dist/util/Log.js
var Log2 = class _Log {
  constructor(_prefix, _level = `error`) {
    this._prefix = _prefix;
    this._level = _level;
  }
  static fromConfig(opts, category, prefix) {
    let l3 = opts[category];
    if (l3 === void 0) {
      const log = opts.log;
      if (log !== void 0)
        l3 = log[category];
    }
    if (l3 === `silent` || l3 === `verbose` || `error`)
      return new _Log(prefix, l3);
    return new _Log(prefix);
  }
  warn(msg) {
    if (this._level !== `verbose`)
      return;
    console.warn(this._prefix, msg);
  }
  verbose(msg) {
    if (this._level !== `verbose`)
      return;
    console.log(this._prefix, msg);
  }
  error(msg) {
    if (this._level === `silent`)
      return;
    console.error(this._prefix, msg);
  }
};

// node_modules/@clinth/remote/dist/BcBroadcast.js
var BcBroadcast = class extends BroadcasterBase {
  constructor(_broadcast) {
    super(`bc`, _broadcast, Log2.fromConfig(_broadcast._manager.opts, `bc`, `BcBroadcast`));
    this._bc = new BroadcastChannel(`remote`);
    this._bc.addEventListener(`message`, (evt) => {
      try {
        const msg = JSON.parse(evt.data);
        this._log.verbose(msg);
        this._broadcast.onMessage(msg, this);
      } catch (e5) {
        console.error(e5);
      }
    });
    setTimeout(() => {
      this.setState(`open`);
    }, 500);
  }
  static isSupported() {
    return `BroadcastChannel` in self;
  }
  toString() {
    return `BcBroadcast`;
  }
  maintain() {
  }
  send(payload) {
    payload = this._broadcast._manager.validateOutgoing(payload);
    payload._channel = `bc-bc`;
    this._bc.postMessage(JSON.stringify(payload));
    return true;
  }
};

// node_modules/@clinth/remote/dist/Broadcast.js
var Broadcast = class extends EventTarget {
  constructor(_manager) {
    super();
    this._manager = _manager;
    this._broadcast = [];
    this._peerId = _manager.peerId;
  }
  dumpToConsole() {
    console.group(`Broadcasters`);
    for (const b4 of this._broadcast) {
      console.log(b4.name + " (" + b4.state + ")");
    }
    console.groupEnd();
  }
  onBroadcasterState(priorState, newState, source) {
    this.dispatchEvent(new CustomEvent(`change`, {
      detail: { priorState, newState, source }
    }));
  }
  add(b4) {
    this._broadcast.push(b4);
  }
  send(payload) {
    payload = this._manager.validateOutgoing(payload);
    this._broadcast.forEach((b4) => b4.send(payload));
  }
  warn(msg) {
    console.log(`Broadcast`, msg);
  }
  onSessionMessageReceived(data, via, session) {
    if (typeof data === `string`)
      throw new Error(`Expected object`);
    const { _id, _kind, _from } = data;
    if (_from !== void 0)
      this._manager.peering.notifySeenPeer(_from, session);
    if (_id === void 0) {
      this.warn(`Session message received without an id. Dropping. ${JSON.stringify(data)}`);
      return;
    }
    if (!this._manager.validateIncoming(data))
      return;
    this._manager.onMessageReceived(data, via);
  }
  onMessage(data, via) {
    const { _id, _kind, _from } = data;
    if (_from !== void 0) {
      this._manager.peering.notifySeenPeer(_from, via);
    }
    if (_id === void 0) {
      this.warn(`Message received without an id. Dropping. ${JSON.stringify(data)}`);
      return;
    }
    if (!this._manager.validateIncoming(data))
      return;
    if (_kind === void 0) {
      this._manager.onBroadcastReceived(data, via);
      return;
    }
    switch (_kind) {
      case `peering-ad`:
        this._manager.peering.onAdvertReceived(data, via);
        break;
      case `peering-invite`:
        this._manager.peering.onInviteReceived(data, via);
        break;
      case `peering-reply`:
        this._manager.peering.onReply(data, via);
        break;
      default:
        this.log(`Unknown message kind: ${_kind}`);
    }
  }
  maintain() {
    const bcs = [...this._broadcast];
    bcs.forEach((b4) => b4.maintain());
  }
  log(msg) {
    console.log(`BroadcastMessageHandler`, msg);
  }
};

// node_modules/@clinth/remote/dist/LogicalNode.js
var LogicalNode = class {
  constructor(_id, _peering) {
    this._id = _id;
    this._peering = _peering;
    this._deadAfterIdleMs = 60 * 1e3;
    this._sessions = [];
    this._state = `idle`;
    this._idleSince = Date.now();
    this._log = new Log2(`LogicalNode[${_id}]`, _peering.manager.opts.defaultLog ?? `error`);
  }
  send(data) {
    if (this.isDead)
      throw new Error(`Cannot send while node is dead`);
    for (const s3 of this._sessions) {
      if (s3.state === `open`) {
        console.log(`Send via ${s3.channel.name}`);
        s3.send(data);
        return true;
      }
    }
    return false;
  }
  setState(newState) {
    if (newState == this._state)
      return;
    if (this.isDead)
      throw new Error(`Node is marked dead, cannot change state`);
    const priorState = this._state;
    this._state = newState;
    if (newState === `idle`)
      this._idleSince = Date.now();
    this._peering.onLogicalNodeState(priorState, newState, this);
  }
  hasChannel(channelName) {
    return this._sessions.some((c6) => c6.channel.name === channelName);
  }
  onSessionEstablished(s3) {
    if (this.isDead)
      throw new Error(`Node is marked dead, cannot establish session`);
    this._sessions.push(s3);
    this._log.verbose(`Session established. ch: ${s3.channel.name} id: ${s3.id}. ${this._sessions.length} sesion(s)`);
    this.setState(`open`);
  }
  dump() {
    let t6 = [`LogicalNode[${this._id}]`];
    this._sessions.forEach((s3) => {
      t6.push(` - ` + s3.statusString());
    });
    return t6.join("\n");
  }
  dumpSessions() {
    let t6 = "";
    this._sessions.forEach((s3) => {
      t6 += ` - ` + s3.state + " " + s3.channel.name + " elapsed: " + s3.elapsedString() + "\n";
    });
    return t6.trim();
  }
  maintain() {
    if (this.isDead)
      return;
    const sessions = [...this._sessions];
    for (const s3 of sessions) {
      s3.maintain();
    }
    const length5 = this._sessions.length;
    this._sessions = this._sessions.filter((s3) => s3.state === `open`);
    if (this._sessions.length !== length5) {
      this._log.verbose(`Removed ${length5 - this._sessions.length} session(s).`);
    }
    if (this.sessions.length === 0)
      this.setState(`idle`);
    if (this._state === `idle`) {
      const elapsed3 = Date.now() - this._idleSince;
      if (elapsed3 > this._deadAfterIdleMs)
        this.setState(`dead`);
    }
  }
  get id() {
    return this._id;
  }
  get sessions() {
    return [...this._sessions];
  }
  get isDead() {
    return this._state === `dead`;
  }
  get state() {
    return this._state;
  }
};

// node_modules/@clinth/remote/dist/PeeringSession.js
var PeeringSession = class _PeeringSession extends EventTarget {
  constructor(id, weInitiated, remotePeer, channel, bc, manager) {
    super();
    this.id = id;
    this.weInitiated = weInitiated;
    this.remotePeer = remotePeer;
    this.channel = channel;
    this.bc = bc;
    this.manager = manager;
    this._state = `idle`;
    this._createdAt = Date.now();
  }
  onMessageReceived(data, via) {
    this.manager.broadcast.onSessionMessageReceived(data, via, this);
  }
  send(data) {
    this.dispatchEvent(new CustomEvent(`send`, { detail: { ...data } }));
    return true;
  }
  get name() {
    return `peering-session`;
  }
  statusString() {
    return `${this.state} ${this.channel.name} id: ${this.id} ${this.weInitiated ? `local` : `remote`} elapsed: ${elapsed2(this._createdAt)}`;
  }
  elapsedString() {
    return elapsed2(this._createdAt);
  }
  setState(newState) {
    if (this._state === newState)
      return;
    const priorState = this._state;
    this._state = newState;
    this.dispatchEvent(new CustomEvent(`change`, { detail: { priorState, newState } }));
  }
  maintain() {
    if (this._state == `started` || this._state == `idle`) {
      if (Date.now() - this._createdAt > 10 * 1e3) {
        this.setState(`timeout`);
      }
    }
  }
  get state() {
    return this._state;
  }
  onClosed(reason) {
    this.dispose();
  }
  onOpened() {
    this.setState(`open`);
    this.manager.peering.onSessionEstablished(this);
  }
  dispose() {
    this.log(`dispose`);
    this.setState(`closed`);
    this.dispatchEvent(new Event(`disposing`));
  }
  static initiate(remotePeer, channel, bc, manager) {
    const id = shortUuid();
    return new _PeeringSession(id, true, remotePeer, channel, bc, manager);
  }
  static accept(sessionId, remotePeer, channel, bc, manager) {
    return new _PeeringSession(sessionId, false, remotePeer, channel, bc, manager);
  }
  start() {
    if (this.state !== `idle`)
      throw new Error(`Can only start while idle`);
    this.channel.initiatePeering(this.remotePeer, this);
  }
  log(msg) {
    console.log(`PeeringSession`, msg);
  }
  onReply(r5, bc) {
    this.dispatchEvent(new CustomEvent(`reply`, { detail: { reply: r5, bc } }));
  }
  broadcastReply(kind, data) {
    data = {
      ...data,
      _kind: kind
    };
    this.bc.send(data);
  }
};

// node_modules/@clinth/remote/dist/util/ExpiringMap.js
var ExpiringMultiMap = class {
  constructor(expiryMs) {
    this.expiryMs = expiryMs;
    this._store = /* @__PURE__ */ new Map();
    setTimeout(() => {
      this.maintain();
    }, Math.min(expiryMs, 30 * 1e3));
  }
  get lengthKeys() {
    const keys = [...this._store.keys()];
    return keys.length;
  }
  maintain() {
    const entries2 = [...this._store.entries()];
    const now = Date.now();
    entries2.forEach(([k3, arr]) => {
      arr = arr.filter((v3) => v3.expiresAt > now);
      if (arr.length == 0) {
        this._store.delete(k3);
      } else {
        this._store.set(k3, arr);
      }
    });
  }
  get(key) {
    const a4 = this._store.get(key);
    if (a4 === void 0)
      return [];
    return a4.map((v3) => v3.data);
  }
  *valuesForKey(key) {
    const a4 = this._store.get(key);
    if (a4 === void 0)
      return;
    for (let i4 = 0; i4 < a4.length; i4++) {
      yield a4[i4];
    }
  }
  *keys() {
    yield* this._store.keys();
  }
  *entriesRaw() {
    yield* this._store.entries();
  }
  *entries() {
    for (const e5 of this._store.entries()) {
      for (let i4 = 0; i4 < e5[1].length; i4++) {
        yield [e5[0], e5[1][i4].data];
      }
    }
  }
  dump() {
    const now = Date.now();
    const until3 = (v3) => {
      let e5 = v3 - now;
      if (e5 < 1e3)
        return `${e5}ms`;
      e5 /= 1e3;
      if (e5 < 1e3)
        return `${Math.round(e5)}s`;
      e5 /= 60;
      return `${Math.round(e5)}mins`;
    };
    let t6 = ``;
    for (const [k3, v3] of this._store.entries()) {
      t6 += `${k3} = `;
      for (let i4 = 0; i4 < v3.length; i4++) {
        t6 += v3[i4].data + " (expires in " + until3(v3[i4].expiresAt) + ") ";
      }
    }
    if (t6.length === 0)
      return `(empty)`;
    else
      return t6;
  }
  add(key, value2) {
    let a4 = this._store.get(key);
    if (a4 === void 0) {
      a4 = [];
      this._store.set(key, a4);
    }
    const existing = a4.find((v3) => v3.data === value2);
    if (existing === void 0) {
      a4.push({ data: value2, expiresAt: Date.now() + this.expiryMs });
    } else {
      existing.expiresAt = Date.now() + this.expiryMs;
    }
  }
};

// node_modules/@clinth/remote/dist/Peering.js
var Peering = class extends EventTarget {
  constructor(manager) {
    super();
    this.manager = manager;
    this._log = new Log2(`Peering`, manager.opts.defaultLog ?? `silent`);
    this._nodes = /* @__PURE__ */ new Map();
    this._inProgress = [];
    this._ephemeral = new ExpiringMultiMap(30 * 1e3);
  }
  getEphemeral(peerId) {
    return this._ephemeral.get(peerId);
  }
  getLogicalNode(peerId) {
    return this._nodes.get(peerId);
  }
  onLogicalNodeState(priorState, newState, node) {
    this.dispatchEvent(new CustomEvent(`logicalNodeState`, {
      detail: {
        newState,
        priorState,
        node
      }
    }));
  }
  hasChannel(channelName) {
    for (const n7 of this._nodes.values()) {
      if (n7.hasChannel(channelName))
        return true;
    }
  }
  dumpToConsole() {
    console.group(`Peering`);
    console.group(`LogicalNodes`);
    for (const n7 of this._nodes.values()) {
      let ln2 = n7.id + ` (${n7.state})
`;
      const sessions = n7.sessions;
      for (const s3 of sessions) {
        ln2 += " - " + s3.channel.name + " (" + s3.state + ") " + s3.id + "\n";
      }
      console.log(ln2);
    }
    console.groupEnd();
    if (this._inProgress.length > 0) {
      console.group("In progress");
      for (const s3 of this._inProgress) {
        console.log(s3.state + " " + s3.channel.name + " " + s3.id + " " + s3.elapsedString());
      }
      console.groupEnd();
    }
    if (this._ephemeral.lengthKeys > 0) {
      console.group("Ephemeral");
      console.log(this._ephemeral.dump());
      console.groupEnd();
    }
    console.groupEnd();
  }
  onSessionEstablished(s3) {
    const n7 = this.getOrCreate(s3.remotePeer);
    n7.onSessionEstablished(s3);
    this._inProgress = this._inProgress.filter((p4) => p4.id !== s3.id);
  }
  maintain() {
    const ip = [...this._inProgress];
    ip.forEach((i4) => {
      i4.maintain();
    });
    this._inProgress = this._inProgress.filter((i4) => i4.state === `idle` || i4.state == `open` || i4.state === `started`);
    const nodes = [...this._nodes.values()];
    nodes.forEach((n7) => {
      n7.maintain();
      if (this.manager._debugMaintain)
        console.log(n7.dump());
    });
    const dead = nodes.filter((n7) => n7.isDead);
    for (const d4 of dead) {
      this._log.verbose(`Removing dead node: ${d4.id}`);
      this.dispatchEvent(new CustomEvent(`logicalNodeRemoved`, {
        detail: {
          node: d4,
          type: `removed`
        }
      }));
      this._nodes.delete(d4.id);
    }
    if (this.manager._debugMaintain)
      console.log(this._ephemeral.dump());
  }
  getOrCreate(id) {
    let n7 = this._nodes.get(id);
    if (n7 === void 0) {
      n7 = new LogicalNode(id, this);
      this._nodes.set(id, n7);
      this.dispatchEvent(new CustomEvent(`logicalNodeAdded`, {
        detail: {
          node: n7,
          type: `added`
        }
      }));
    }
    return n7;
  }
  findPeeringSession(peerId, channel) {
    return this._inProgress.find((p4) => p4.remotePeer === peerId && p4.channel === channel);
  }
  findPeeringSessionById(session) {
    return this._inProgress.find((p4) => p4.id === session);
  }
  findPeeringSessionByRemote(remote) {
    return this._inProgress.find((p4) => p4.remotePeer === remote);
  }
  onInviteReceived(i4, bc) {
    try {
      const invitee = i4.invitee;
      if (invitee !== this.manager.peerId)
        return;
      if (this.findPeeringSessionByRemote(i4.inviter)) {
        this.warn(`Dropping invitation from a peer we have already invited: ${i4.inviter}. Our id: ${this.manager.peerId}`);
        return;
      }
      this.onAllowInvite(i4, bc);
    } catch (ex) {
      this.warn(ex);
    }
  }
  onReply(r5, bc) {
    const s3 = this.findPeeringSessionById(r5.peeringSessionId);
    if (s3 === void 0) {
      this._log.warn(`Received peering reply for unknown session  ${r5.peeringSessionId}`);
      this._log.warn(r5);
      this._log.warn(`Sessions: ` + this._inProgress.map((p4) => p4.id).join(", "));
      return;
    }
    s3.onReply(r5, bc);
  }
  onAllowInvite(i4, bc) {
    const payload = JSON.parse(i4.payload);
    const ch2 = this.manager.getChannelFactory(i4.channel);
    if (ch2 === void 0) {
      this.warn(`Received invitation for channel ${i4.channel}, but we do not support it`);
      return;
    }
    const s3 = PeeringSession.accept(i4.peeringSessionId, i4.inviter, ch2, bc, this.manager);
    this._inProgress.push(s3);
    ch2.acceptInvitation(i4, s3, bc);
  }
  warn(msg) {
    console.warn(`PeeringHandler`, msg);
  }
  notifySeenPeer(peer, bc) {
    this._ephemeral.add(peer, bc);
  }
  onAdvertReceived(pa2, bc) {
    const n7 = this.getOrCreate(pa2.peerId);
    const channels = pa2.channels.split(", ");
    this.notifySeenPeer(pa2.peerId, bc);
    channels.forEach((c6) => {
      if (c6.length === 0 || c6 === void 0)
        return;
      const ch2 = this.manager.getChannelFactory(c6);
      if (ch2 === void 0) {
        return;
      }
      if (!n7.hasChannel(c6)) {
        const inProgress = this.findPeeringSession(pa2.peerId, ch2);
        if (inProgress) {
        } else {
          const start = PeeringSession.initiate(pa2.peerId, ch2, bc, this.manager);
          this._inProgress.push(start);
          start.start();
        }
      }
    });
  }
  getLogicalNodes() {
    return [...this._nodes.values()];
  }
};

// node_modules/@clinth/remote/dist/RtcChannelFactory.js
var RtcPeeringSession = class {
  constructor(session) {
    this.session = session;
    this._pc = new RTCPeerConnection({
      iceServers: [
        { urls: ["stun:stun.services.mozilla.com"] },
        { urls: ["stun:stun.l.google.com:19302"] }
      ]
    });
    this._log = Log2.fromConfig(session.manager.opts, `rtc`, `RtcPeeringSession`);
    this._onDisposingH = this.onDisposing.bind(this);
    this._onReplyH = this.onReply.bind(this);
    this._onSendH = this.onSend.bind(this);
    session.addEventListener(`reply`, this._onReplyH);
    session.addEventListener(`disposing`, this._onDisposingH);
    session.addEventListener(`send`, this._onSendH);
  }
  onSend(evt) {
    const data = evt.detail;
    if (this._dc) {
      console.log(`RTC Sending`, data);
      this._dc.send(JSON.stringify(data));
    } else {
      this.warn(`Cannot send without data channel`);
    }
  }
  onDisposing() {
    this._log.verbose(`onDisposing`);
    this.session.removeEventListener(`reply`, this._onReplyH);
    this.session.removeEventListener(`disposing`, this._onDisposingH);
  }
  onReply(evt) {
    const { reply, bc } = evt.detail;
    const subKind = reply.sub;
    switch (subKind) {
      case `rtc-accept`:
        try {
          const descr = JSON.parse(reply.payload);
          this._pc.setRemoteDescription(descr);
        } catch (ex) {
          this.warn(ex);
        }
        break;
      case `rtc-ice`:
        try {
          const c6 = new RTCIceCandidate({
            sdpMLineIndex: reply.label,
            candidate: reply.candidate
          });
          this._pc.addIceCandidate(c6);
        } catch (ex) {
          this.warn(ex);
          this.warn(reply);
        }
        break;
      default:
        this._log.verbose(`Cannot handle reply ${subKind}`);
    }
  }
  warn(msg) {
    console.warn(`RtcPeeringSession`, msg);
  }
  async start() {
    const p4 = this._pc;
    const dc = this._pc.createDataChannel(`${this.session.remotePeer}`);
    this.setupDataChannel(dc);
    p4.addEventListener(`icecandidate`, (evt) => {
      const c6 = evt.candidate;
      if (c6 === null)
        return;
      this.session.broadcastReply(`peering-reply`, {
        sub: `rtc-ice`,
        peeringSessionId: this.session.id,
        label: c6.sdpMLineIndex,
        id: c6.sdpMid,
        candidate: c6.candidate
      });
    });
    p4.addEventListener(`close`, (evt) => {
      this._log.verbose(`channel close`);
    });
    p4.addEventListener(`error`, (evt) => {
      this._log.verbose(`channel error`);
    });
    p4.addEventListener(`open`, (evt) => {
      this._log.verbose(`channel open`);
    });
    p4.addEventListener(`message`, (evt) => {
      this._log.verbose(`channel message: ${JSON.stringify(evt)}`);
    });
    this._pc = p4;
    const o5 = await p4.createOffer({ offerToReceiveAudio: false, offerToReceiveVideo: false });
    await p4.setLocalDescription(o5);
    const invite = {
      invitee: this.session.remotePeer,
      inviter: this.session.manager.peerId,
      channel: `rtc`,
      peeringSessionId: this.session.id,
      payload: JSON.stringify(o5)
    };
    this.session.broadcastReply(`peering-invite`, invite);
  }
  setupDataChannel(dc) {
    this._dc = dc;
    dc.addEventListener(`close`, (evt) => {
      this._log.verbose(`dc close`);
      this.session.onClosed(`data channel closed`);
    });
    dc.addEventListener(`closing`, (evt) => {
      this._log.verbose(`dc closing`);
    });
    dc.addEventListener(`error`, (evt) => {
      this._log.verbose(`dc error`);
    });
    dc.addEventListener(`message`, (evt) => {
      try {
        const o5 = JSON.parse(evt.data);
        this.session.onMessageReceived(o5, this);
      } catch (e5) {
        this._log.warn(`Could not parse: ${evt.data}`);
      }
    });
    dc.addEventListener(`open`, (evt) => {
      this._log.verbose(`dc open`);
      this.session.onOpened();
    });
  }
  acceptInvitation(i4) {
    this._log.verbose(`Accept invitation from ${i4.inviter}`);
    try {
      const payload = JSON.parse(i4.payload);
      const p4 = this._pc;
      p4.addEventListener(`datachannel`, (evt) => {
        this._log.verbose(`Data channel created!`);
        this.setupDataChannel(evt.channel);
      });
      p4.setRemoteDescription(payload);
      p4.createAnswer().then((descr) => {
        p4.setLocalDescription(descr);
        this.session.broadcastReply(`peering-reply`, {
          invitee: i4.invitee,
          sub: `rtc-accept`,
          peeringSessionId: this.session.id,
          inviter: i4.inviter,
          payload: JSON.stringify(descr)
        });
      });
    } catch (ex) {
      console.warn(ex);
    }
  }
};
var RtcChannelFactory = class {
  constructor() {
  }
  get name() {
    return `rtc`;
  }
  maintain() {
  }
  acceptInvitation(i4, session, bc) {
    const s3 = new RtcPeeringSession(session);
    s3.acceptInvitation(i4);
  }
  initiatePeering(remoteId, session) {
    const s3 = new RtcPeeringSession(session);
    s3.start();
  }
};

// node_modules/@clinth/remote/dist/util/StatusDisplay.js
var StatusDisplay = class {
  constructor(manager, opts = {}) {
    this.manager = manager;
    const defaultOpacity = opts.defaultOpacity ?? 0.1;
    const updateRateMs = opts.updateRateMs ?? 5e3;
    this.hue = opts.hue ?? 90;
    const e5 = this._el = document.getElementById(`remote-status`);
    if (e5 === null)
      return;
    const styleIndicators = (el) => {
      el.style.display = `flex`;
      el.style.alignItems = `center`;
    };
    const bcIndicators = document.createElement(`DIV`);
    bcIndicators.append(this.createIndicator(`ws`, `WebSockets`), this.createIndicator(`bc`, `BroadcastChannel`));
    styleIndicators(bcIndicators);
    e5.append(bcIndicators);
    const nodeIndicators = document.createElement(`DIV`);
    styleIndicators(nodeIndicators);
    e5.append(nodeIndicators);
    e5.style.background = `hsla(${this.hue}, 20%, 50%, 50%)`;
    e5.style.color = `hsl(${this.hue}, 50%, 10%)`;
    e5.style.border = `1px solid hsla(${this.hue}, 20%, 10%, 50%)`;
    e5.style.fontSize = `0.7em`;
    e5.style.position = `fixed`;
    e5.style.bottom = `0`;
    e5.style.right = `0`;
    e5.style.padding = `0.3em`;
    e5.style.opacity = defaultOpacity.toString();
    e5.addEventListener(`pointerover`, () => {
      e5.style.opacity = `1.0`;
    });
    e5.addEventListener(`pointerout`, () => {
      e5.style.opacity = defaultOpacity.toString();
    });
    e5.addEventListener(`click`, () => {
      manager.dump();
    });
    manager.broadcast.addEventListener(`change`, (evt) => {
      const { priorState, newState, source } = evt.detail;
      this.setIndicator(bcIndicators, source.name, newState === `open`, newState);
    });
    manager.peering.addEventListener(`logicalNodeState`, (evt) => {
      const { priorState, newState, node } = evt.detail;
      this.setIndicator(nodeIndicators, node.id, node.state === `open`, node.dumpSessions());
    });
    manager.peering.addEventListener(`logicalNodeAdded`, (evt) => {
      const { type: type2, node } = evt.detail;
      nodeIndicators.append(this.createIndicator(node.id, `Node`));
    });
    manager.peering.addEventListener(`logicalNodeRemoved`, (evt) => {
      const { type: type2, node } = evt.detail;
      const i4 = this.getIndicator(nodeIndicators, node.id);
      if (i4 !== null)
        i4.remove();
    });
    setInterval(() => {
      const nodes = this.manager.peering.getLogicalNodes();
      const seen = /* @__PURE__ */ new Set();
      for (const n7 of nodes) {
        seen.add(n7.id);
        let sessions = n7.dumpSessions();
        const eph = this.manager.peering.getEphemeral(n7.id);
        for (const e6 of eph) {
          sessions += "\nSeen on: " + e6.name + " (" + e6.state + ")";
        }
        this.setIndicator(nodeIndicators, n7.id, n7.state === `open`, sessions);
      }
      const indicators = this.getIndicators(nodeIndicators);
      for (const i4 of indicators) {
        if (!seen.has(i4.getAttribute(`data-for`))) {
          i4.remove();
        }
      }
    }, updateRateMs);
  }
  getIndicators(parent) {
    return Array.from(parent.querySelectorAll(`.remote-indicator`));
  }
  getIndicator(parent, label) {
    return parent.querySelector(`[data-for="${label}"]`);
  }
  setIndicator(parent, label, state, titleAddition = ``) {
    let el = this.getIndicator(parent, label);
    if (el === null) {
      el = this.createIndicator(label, titleAddition);
      parent.append(el);
      return;
    }
    const title = el.getAttribute(`data-title`) + ` ` + titleAddition;
    el.title = title;
    if (state) {
      el.style.border = `1px solid hsla(${this.hue}, 30%, 10%, 50%)`;
    } else {
      el.style.border = ``;
    }
  }
  createIndicator(label, title = ``) {
    const ind = document.createElement(`div`);
    ind.innerText = label;
    ind.title = title;
    ind.classList.add(`remote-indicator`);
    ind.setAttribute(`data-for`, label);
    ind.style.padding = `0.3em`;
    ind.setAttribute(`data-title`, title);
    return ind;
  }
};

// node_modules/@clinth/remote/dist/util/Events.js
var Event2 = class {
  constructor(type2, target) {
    this.target = target;
    this.type = type2;
  }
};
var ErrorEvent = class extends Event2 {
  constructor(error, target) {
    super("error", target);
    this.message = error.message;
    this.error = error;
  }
};
var CloseEvent = class extends Event2 {
  constructor(code = 1e3, reason = "", target) {
    super("close", target);
    this.wasClean = true;
    this.code = code;
    this.reason = reason;
  }
};

// node_modules/@clinth/remote/dist/ReconnectingWebsocket.js
var getGlobalWebSocket = () => {
  if (typeof WebSocket !== "undefined") {
    return WebSocket;
  }
};
var isWebSocket = (w3) => typeof w3 !== "undefined" && !!w3 && w3.CLOSING === 2;
var DEFAULT = {
  maxReconnectionDelay: 1e4,
  minReconnectionDelay: 1e3 + Math.random() * 4e3,
  minUptime: 5e3,
  reconnectionDelayGrowFactor: 1.3,
  connectionTimeout: 4e3,
  maxRetries: Infinity,
  maxEnqueuedMessages: Infinity,
  startClosed: false,
  debug: false
};
var ReconnectingWebSocket = class _ReconnectingWebSocket {
  constructor(url, protocols, options = {}) {
    this._listeners = {
      error: [],
      message: [],
      open: [],
      close: []
    };
    this._retryCount = -1;
    this._shouldReconnect = true;
    this._connectLock = false;
    this._binaryType = "blob";
    this._closeCalled = false;
    this._messageQueue = [];
    this.onclose = null;
    this.onerror = null;
    this.onmessage = null;
    this.onopen = null;
    this._handleOpen = (event2) => {
      this._debug("open event");
      const { minUptime = DEFAULT.minUptime } = this._options;
      clearTimeout(this._connectTimeout);
      this._uptimeTimeout = setTimeout(() => this._acceptOpen(), minUptime);
      this._ws.binaryType = this._binaryType;
      this._messageQueue.forEach((message) => this._ws?.send(message));
      this._messageQueue = [];
      if (this.onopen) {
        this.onopen(event2);
      }
      this._listeners.open.forEach((listener) => this._callEventListener(event2, listener));
    };
    this._handleMessage = (event2) => {
      this._debug("message event");
      if (this.onmessage) {
        this.onmessage(event2);
      }
      this._listeners.message.forEach((listener) => this._callEventListener(event2, listener));
    };
    this._handleError = (event2) => {
      this._debug("error event", event2.message);
      this._disconnect(void 0, event2.message === "TIMEOUT" ? "timeout" : void 0);
      if (this.onerror) {
        this.onerror(event2);
      }
      this._debug("exec error listeners");
      this._listeners.error.forEach((listener) => this._callEventListener(event2, listener));
      this._connect();
    };
    this._handleClose = (event2) => {
      this._debug("close event");
      this._clearTimeouts();
      if (this._shouldReconnect) {
        this._connect();
      }
      if (this.onclose) {
        this.onclose(event2);
      }
      this._listeners.close.forEach((listener) => this._callEventListener(event2, listener));
    };
    this._url = url;
    this._protocols = protocols;
    this._options = options;
    if (this._options.startClosed) {
      this._shouldReconnect = false;
    }
    this._connect();
  }
  static get CONNECTING() {
    return 0;
  }
  static get OPEN() {
    return 1;
  }
  static get CLOSING() {
    return 2;
  }
  static get CLOSED() {
    return 3;
  }
  get CONNECTING() {
    return _ReconnectingWebSocket.CONNECTING;
  }
  get OPEN() {
    return _ReconnectingWebSocket.OPEN;
  }
  get CLOSING() {
    return _ReconnectingWebSocket.CLOSING;
  }
  get CLOSED() {
    return _ReconnectingWebSocket.CLOSED;
  }
  get binaryType() {
    return this._ws ? this._ws.binaryType : this._binaryType;
  }
  set binaryType(value2) {
    this._binaryType = value2;
    if (this._ws) {
      this._ws.binaryType = value2;
    }
  }
  get retryCount() {
    return Math.max(this._retryCount, 0);
  }
  get bufferedAmount() {
    const bytes = this._messageQueue.reduce((acc, message) => {
      if (typeof message === "string") {
        acc += message.length;
      } else if (message instanceof Blob) {
        acc += message.size;
      } else {
        acc += message.byteLength;
      }
      return acc;
    }, 0);
    return bytes + (this._ws ? this._ws.bufferedAmount : 0);
  }
  get extensions() {
    return this._ws ? this._ws.extensions : "";
  }
  get protocol() {
    return this._ws ? this._ws.protocol : "";
  }
  get readyState() {
    if (this._ws) {
      return this._ws.readyState;
    }
    return this._options.startClosed ? _ReconnectingWebSocket.CLOSED : _ReconnectingWebSocket.CONNECTING;
  }
  get url() {
    return this._ws ? this._ws.url : "";
  }
  close(code = 1e3, reason) {
    this._closeCalled = true;
    this._shouldReconnect = false;
    this._clearTimeouts();
    if (!this._ws) {
      this._debug("close enqueued: no ws instance");
      return;
    }
    if (this._ws.readyState === this.CLOSED) {
      this._debug("close: already closed");
      return;
    }
    this._ws.close(code, reason);
  }
  reconnect(code, reason) {
    this._shouldReconnect = true;
    this._closeCalled = false;
    this._retryCount = -1;
    if (!this._ws || this._ws.readyState === this.CLOSED) {
      this._connect();
    } else {
      this._disconnect(code, reason);
      this._connect();
    }
  }
  isReady() {
    if (this._ws && this._ws.readyState === this.OPEN)
      return true;
    return false;
  }
  send(data) {
    if (this._ws && this._ws.readyState === this.OPEN) {
      this._debug("send", data);
      this._ws.send(data);
    } else {
      const { maxEnqueuedMessages = DEFAULT.maxEnqueuedMessages } = this._options;
      if (this._messageQueue.length < maxEnqueuedMessages) {
        this._debug("enqueue", data);
        this._messageQueue.push(data);
      }
    }
  }
  addEventListener(type2, listener) {
    if (this._listeners[type2]) {
      this._listeners[type2].push(listener);
    }
  }
  dispatchEvent(event2) {
    const listeners = this._listeners[event2.type];
    if (listeners) {
      for (const listener of listeners) {
        this._callEventListener(event2, listener);
      }
    }
    return true;
  }
  removeEventListener(type2, listener) {
    if (this._listeners[type2]) {
      this._listeners[type2] = this._listeners[type2].filter((l3) => l3 !== listener);
    }
  }
  _debug(...args) {
    if (this._options.debug) {
      console.log.apply(console, ["RWS>", ...args]);
    }
  }
  _getNextDelay() {
    const { reconnectionDelayGrowFactor = DEFAULT.reconnectionDelayGrowFactor, minReconnectionDelay = DEFAULT.minReconnectionDelay, maxReconnectionDelay = DEFAULT.maxReconnectionDelay } = this._options;
    let delay2 = 0;
    if (this._retryCount > 0) {
      delay2 = minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);
      if (delay2 > maxReconnectionDelay) {
        delay2 = maxReconnectionDelay;
      }
    }
    this._debug("next delay", delay2);
    return delay2;
  }
  _wait() {
    return new Promise((resolve3) => {
      setTimeout(resolve3, this._getNextDelay());
    });
  }
  _getNextUrl(urlProvider) {
    if (typeof urlProvider === "string") {
      return Promise.resolve(urlProvider);
    }
    if (typeof urlProvider === "function") {
      const url = urlProvider();
      if (typeof url === "string") {
        return Promise.resolve(url);
      }
      if (url.then) {
        return url;
      }
    }
    throw Error("Invalid URL");
  }
  _connect() {
    if (this._connectLock || !this._shouldReconnect) {
      return;
    }
    this._connectLock = true;
    const { maxRetries = DEFAULT.maxRetries, connectionTimeout = DEFAULT.connectionTimeout, WebSocket: WebSocket2 = getGlobalWebSocket() } = this._options;
    if (this._retryCount >= maxRetries) {
      this._debug("max retries reached", this._retryCount, ">=", maxRetries);
      return;
    }
    this._retryCount++;
    this._debug("connect", this._retryCount);
    this._removeListeners();
    if (!isWebSocket(WebSocket2)) {
      throw Error("No valid WebSocket class provided");
    }
    this._wait().then(() => this._getNextUrl(this._url)).then((url) => {
      if (this._closeCalled) {
        return;
      }
      this._debug("connect", { url, protocols: this._protocols });
      this._ws = this._protocols ? new WebSocket2(url, this._protocols) : new WebSocket2(url);
      this._ws.binaryType = this._binaryType;
      this._connectLock = false;
      this._addListeners();
      this._connectTimeout = setTimeout(() => this._handleTimeout(), connectionTimeout);
    });
  }
  _handleTimeout() {
    this._debug("timeout event");
    this._handleError(new ErrorEvent(Error("TIMEOUT"), this));
  }
  _disconnect(code = 1e3, reason) {
    this._clearTimeouts();
    if (!this._ws) {
      return;
    }
    this._removeListeners();
    try {
      this._ws.close(code, reason);
      this._handleClose(new CloseEvent(code, reason, this));
    } catch (error) {
    }
  }
  _acceptOpen() {
    this._debug("accept open");
    this._retryCount = 0;
  }
  _callEventListener(event2, listener) {
    if ("handleEvent" in listener) {
      listener.handleEvent(event2);
    } else {
      listener(event2);
    }
  }
  _removeListeners() {
    if (!this._ws) {
      return;
    }
    this._debug("removeListeners");
    this._ws.removeEventListener("open", this._handleOpen);
    this._ws.removeEventListener("close", this._handleClose);
    this._ws.removeEventListener("message", this._handleMessage);
    this._ws.removeEventListener("error", this._handleError);
  }
  _addListeners() {
    if (!this._ws) {
      return;
    }
    this._debug("addListeners");
    this._ws.addEventListener("open", this._handleOpen);
    this._ws.addEventListener("close", this._handleClose);
    this._ws.addEventListener("message", this._handleMessage);
    this._ws.addEventListener("error", this._handleError);
  }
  _clearTimeouts() {
    clearTimeout(this._connectTimeout);
    clearTimeout(this._uptimeTimeout);
  }
};

// node_modules/@clinth/remote/dist/WebsocketBroadcast.js
var WebsocketBroadcast = class extends BroadcasterBase {
  constructor(broadcast, serverUrl) {
    super(`ws`, broadcast, Log2.fromConfig(broadcast._manager.opts, `ws`, `WebsocketBroadcast`));
    const url = serverUrl ?? (location.protocol === "http:" ? "ws://" : "wss://") + location.host + "/ws";
    this._ws = new ReconnectingWebSocket(url);
    let alrightSeenErrorThankYou = false;
    this._ws.addEventListener(`close`, (evt) => {
      this._log.verbose(`close`);
      this.setState(`closed`);
    });
    this._ws.addEventListener(`error`, (evt) => {
      if (evt.message === `TIMEOUT` || alrightSeenErrorThankYou)
        return;
      this._log.warn(`error: ${evt}`);
      alrightSeenErrorThankYou = true;
      this.setState(`error`);
    });
    this._ws.addEventListener(`message`, (evt) => {
      try {
        const m5 = JSON.parse(evt.data);
        this._broadcast.onMessage(m5, this);
      } catch (e5) {
        this._log.warn(e5);
      }
    });
    this._ws.addEventListener(`open`, (evt) => {
      alrightSeenErrorThankYou = false;
      this.setState(`open`);
      this._log.verbose(`Connected to ${url}`);
    });
  }
  toString() {
    return `WebsocketBroadcast`;
  }
  maintain() {
  }
  send(payload) {
    payload = this._broadcast._manager.validateOutgoing(payload);
    payload._channel = `ws-bc`;
    this._ws.send(JSON.stringify(payload));
    return true;
  }
};

// node_modules/@clinth/remote/dist/Manager.js
var Manager = class extends EventTarget {
  constructor(opts = {}) {
    super();
    this.opts = opts;
    this._seenIds = /* @__PURE__ */ new Set();
    this.peerId = opts.peerId ?? (/* @__PURE__ */ new Date()).getMilliseconds() + `-` + Math.floor(Math.random() * 100);
    this._allowNetwork = opts.allowNetwork ?? false;
    this._debugMaintain = opts.debugMaintain ?? false;
    this._defaultLog = opts.defaultLog ?? `error`;
    if (!opts.log)
      opts.log = {};
    if (!opts.log.rtc)
      opts.log.rtc = this._defaultLog;
    if (!opts.log.bc)
      opts.log.bc = this._defaultLog;
    this.log(`Id: ${this.peerId}. network allowed: ${this._allowNetwork}`);
    this.peering = new Peering(this);
    this.broadcast = new Broadcast(this);
    this._channelFactories = [];
    this._statusDisplay = new StatusDisplay(this);
    if (this._allowNetwork) {
      this.broadcast.add(new WebsocketBroadcast(this.broadcast, opts.websocket));
      this.addChannelFactory(new RtcChannelFactory());
    }
    if (BcBroadcast.isSupported()) {
      this.broadcast.add(new BcBroadcast(this.broadcast));
    } else {
      this.log(`BroadcastChannel not supported by this browser`);
    }
    const loopMs = opts.maintainLoopMs ?? 60 * 1e3 + 20 * 1e3 * Math.random();
    setInterval(() => {
      this.maintain();
    }, loopMs);
    setTimeout(() => {
      this.advertise();
    }, 5e3 * Math.random());
  }
  getChannelFactory(name) {
    return this._channelFactories.find((c6) => c6.name === name);
  }
  addChannelFactory(c6) {
    this._channelFactories.push(c6);
  }
  onBroadcastReceived(data, via) {
    this.dispatchEvent(new CustomEvent(`message`, {
      detail: data
    }));
  }
  onMessageReceived(data, via) {
    this.dispatchEvent(new CustomEvent(`message`, {
      detail: data
    }));
  }
  send(data, to5) {
    data = this.validateOutgoing(data);
    if (to5 !== void 0 && to5.length > 0) {
      data._to = to5;
      const n7 = this.peering.getLogicalNode(to5);
      if (n7 !== void 0) {
        if (n7.send(data)) {
          return;
        }
      }
      const channels = this.peering.getEphemeral(to5);
      for (const ch2 of channels) {
        if (ch2.send(data)) {
          console.log(`Sent on channel ${ch2.name}`);
          return;
        }
      }
    }
    this.broadcast.send(data);
  }
  advertise() {
    let f5 = this._channelFactories.map((f6) => f6.name);
    const ad = {
      _kind: `peering-ad`,
      peerId: this.peerId,
      channels: f5.join(", ")
    };
    this.broadcast.send({ ...ad });
  }
  validateOutgoing(payload) {
    const t6 = typeof payload;
    if (t6 === `string` || t6 === `number` || t6 === `boolean`) {
      payload = { data: payload };
    } else if (Array.isArray(payload)) {
      payload = { data: payload };
    } else if (t6 === `bigint` || t6 === `function`) {
      throw new Error(`cannot send type ${t6}`);
    }
    if (payload._id === void 0) {
      const id = shortUuid();
      payload._id = id;
      this._seenIds.add(id);
    }
    payload._from = this.peerId;
    return payload;
  }
  validateIncoming(msg) {
    if (this._seenIds.has(msg._id)) {
      return false;
    }
    this._seenIds.add(msg._id);
    return true;
  }
  maintain() {
    const seen = [...this._seenIds.values()];
    this._seenIds = new Set(seen.slice(seen.length / 2));
    this.peering.maintain();
    this.broadcast.maintain();
    const cf = [...this._channelFactories];
    cf.forEach((c6) => c6.maintain());
    this.advertise();
  }
  dump() {
    console.group(`remote`);
    console.log(`# seen msg ids: ${[...this._seenIds.values()].length}`);
    this.peering.dumpToConsole();
    this.broadcast.dumpToConsole();
    console.groupEnd();
  }
  log(msg) {
    console.log(`Remote`, msg);
  }
};

// node_modules/@clinth/remote/dist/index.js
var Remote = class {
  constructor(opts) {
    this._manager = new Manager(opts);
    this._manager.addEventListener(`message`, (evt) => {
      const d4 = evt.detail;
      delete d4._id;
      delete d4._channel;
      this.onData(d4);
    });
  }
  get id() {
    return this._manager.peerId;
  }
  send(data, to5) {
    this._manager.send(data, to5);
  }
  broadcast(data) {
    this._manager.broadcast.send(data);
  }
  onData(msg) {
  }
};

// src/dispatcher.ts
var Dispatcher = class extends EventTarget {
  #remote;
  constructor(options) {
    super();
    this.#remote = new Remote(options.remote);
  }
  receivedData(mode, data) {
    if (!data) return;
    if (this.#remote) {
      this.#remote.send(JSON.stringify(data));
    }
    if (this.onData) this.onData(mode, data);
    const args = { data, mode };
    this.dispatchEvent(new CustomEvent(`data`, {
      detail: args
    }));
  }
};

// src/ml-vision.ts
var defaults2 = (mode) => {
  const opts = {
    overlay: {
      label: true,
      show: true
    },
    camera: {
      facingMode: `user`
    },
    computeFreqMs: 10,
    mode,
    remote: {
      allowNetwork: false
    },
    verbosity: `errors`,
    wasmBase: "./wasm",
    modelsBase: "/models"
  };
  if (mode === `pose`) opts.pose = PoseDetector.defaults();
  else if (mode === `objects`) opts.objects = ObjectDetector.defaults();
  else if (mode === `face`) opts.face = FaceDetector.defaults();
  return opts;
};
var MlVision2 = class extends EventTarget {
  #overlayEl;
  #proc;
  #opts;
  constructor(elQuery, options = {}) {
    super();
    const lastMode = validateProcessorMode(localStorage.getItem(`last-mode`), `pose`);
    const opts = !options ? defaults2(lastMode) : {
      ...defaults2(options.mode ?? lastMode),
      ...options
    };
    this.#opts = opts;
    this.log = new Log(`MlVision`, opts.verbosity);
    const el = document.querySelector(elQuery);
    if (!el) throw new Error(`VisionElement not found with query: ${elQuery}`);
    this.el = el;
    this.sources = new Sources(opts.camera, this);
    this.dispatcher = new Dispatcher(opts);
    this.#proc = new Processing(this, opts);
  }
  init() {
    const el = this.el;
    const opts = this.#opts;
    el.setOptions(opts);
    el.addEventListener(`source-startstop`, (event2) => {
      const source = event2.detail;
      if (source.id !== this.sources.getCurrentId()) {
        this.log.info(`Different source. Id: ${source.id} Existing: ${this.sources.getCurrentId()}`);
        this.sources.stop();
        this.sources.setSource(source);
      }
      const started = this.sources.startStop();
    });
    el.addEventListener(`request-source`, (event2) => {
      const detail = event2.detail;
      this.sources.stop();
      this.sources.setSource(detail);
      this.sources.start();
    });
    el.addEventListener(`request-recorder`, () => {
      const r5 = this.sources.createRecorder();
      r5.start(this.#proc.computeFreqMs);
      el.recorder = r5;
    });
    el.addEventListener(`request-source-delete`, (event2) => {
      const source = event2.detail;
      this.sources.delete(source);
    });
    el.addEventListener(`request-mode`, (event2) => {
      const req = event2.detail;
      console.log(req);
      this.#proc.setMode(validateProcessorMode(req.mode));
    });
    this.dispatcher.addEventListener(`data`, (event2) => {
      const data = event2.detail;
      el.onReceivedData(data.mode, data.data);
    });
    this.sources.addEventListener(`updated`, () => {
      el.onSourcesUpdated(this.sources.cameras, this.sources.recordings);
    });
    this.sources.addEventListener(`source-change`, (event2) => {
      const source = event2.detail;
      el.notifySourceChange(source);
    });
    this.sources.addEventListener(`state-change`, (e5) => {
      const { priorState, newState } = e5.detail;
      this.log.debug(`${priorState}->${newState}`);
      if (newState === `started`) {
        const video = el.getVideoElement();
        if (video) {
          this.#proc.stop();
          this.#proc.start(video);
        } else {
          console.warn(`Could not start processing because not video element is found`);
        }
      } else if (newState === `stopped`) {
        this.#proc.stop();
      }
      el.notifySourceState(newState, this.sources.currentSourceData);
    });
    this.sources.init();
    if (opts.hideModelSelector) el.hideModelSelector = opts.hideModelSelector;
  }
};

// src/client.ts
var Client = class extends EventTarget {
  #remote;
  constructor(options = {}) {
    super();
    options = {
      allowNetwork: false,
      ...options
    };
    this.#remote = new Remote(options);
    this.#remote.onData = (msg) => {
      const asObj = typeof msg === `object` ? msg : JSON.parse(msg);
      if (this.onData) this.onData(asObj);
      this.dispatchEvent(new CustomEvent(`message`, {
        detail: asObj
      }));
    };
  }
};
export {
  Client,
  MlVision2 as MlVision,
  ModelElement,
  OverlayElement,
  PoseDetector,
  PoseMatcher,
  Processing,
  RecPanel,
  VideoSourceElement,
  VisionElement,
  defaults2 as defaults,
  getLowest,
  getProcessorModes,
  validateProcessorMode
};
/*! Bundled license information:

@lit-labs/ssr-dom-shim/lib/element-internals.js:
  (**
   * @license
   * Copyright 2023 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit-labs/ssr-dom-shim/index.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/async-directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/directives/ref.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@clinth/remote/dist/ReconnectingWebsocket.js:
  (*!
   * Reconnecting WebSocket
   * by Pedro Ladaria <pedro.ladaria@gmail.com>
   * https://github.com/pladaria/reconnecting-websocket
   * License MIT
   *)
*/
//# sourceMappingURL=index.js.map