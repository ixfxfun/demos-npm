{"version":3,"sources":["../../src/client/poses/index.ts","../../node_modules/ixfx/src/util/GuardThrowFromResult.ts","../../node_modules/ixfx/src/util/GuardNumbers.ts","../../node_modules/ixfx/src/geometry/point/Guard.ts","../../node_modules/ixfx/src/geometry/line/FromPoints.ts","../../node_modules/ixfx/src/geometry/line/FromNumbers.ts","../../node_modules/ixfx/src/numbers/Round.ts","../../node_modules/ixfx/src/numbers/Quantise.ts","../../node_modules/ixfx/src/numbers/LinearSpace.ts","../../node_modules/ixfx/src/numbers/NumericArrays.ts","../../node_modules/ixfx/src/flow/IntervalType.ts","../../node_modules/ixfx/src/util/ToString.ts","../../node_modules/ixfx/src/util/IsEqual.ts","../../node_modules/ixfx/dist/chunk-L5EJU35C.js","../../node_modules/ixfx/src/Events.ts","../../node_modules/ixfx/src/DefaultKeyer.ts","../../node_modules/ixfx/src/collections/map/MapMultiFns.ts","../../node_modules/ixfx/src/collections/map/MapOfSimpleBase.ts","../../node_modules/ixfx/src/collections/map/MapOfSimpleMutable.ts","../../node_modules/ixfx/src/collections/set/index.ts","../../node_modules/ixfx/src/collections/set/SetMutable.ts","../../node_modules/ixfx/src/collections/set/SetImmutable.ts","../../node_modules/ixfx/src/collections/set/MassiveSet.ts","../../node_modules/ixfx/src/data/arrays/GuardArray.ts","../../node_modules/ixfx/src/data/arrays/Sort.ts","../../node_modules/ixfx/src/numbers/Wrap.ts","../../node_modules/ixfx/src/numbers/Clamp.ts","../../node_modules/ixfx/src/numbers/Scale.ts","../../node_modules/ixfx/src/random/Types.ts","../../node_modules/ixfx/src/random/String.ts","../../node_modules/ixfx/src/Text.ts","../../node_modules/ixfx/src/iterables/sync/Slice.ts","../../node_modules/ixfx/src/data/arrays/GuardIndex.ts","../../node_modules/ixfx/src/data/arrays/Filter.ts","../../node_modules/ixfx/src/numbers/MinMaxAvg.ts","../../node_modules/ixfx/src/util/GuardFunction.ts","../../node_modules/ixfx/src/util/GuardString.ts","../../node_modules/ixfx/src/util/guards.ts","../../node_modules/ixfx/src/util/GuardArrays.ts","../../node_modules/ixfx/src/util/GuardEmpty.ts","../../node_modules/ixfx/src/util/GuardObject.ts","../../node_modules/ixfx/src/util/MapKeys.ts","../../node_modules/ixfx/src/util/index.ts","../../node_modules/ixfx/src/util/Comparers.ts","../../node_modules/ixfx/src/util/IsEqualTrace.ts","../../node_modules/ixfx/src/util/IsInteger.ts","../../node_modules/ixfx/src/util/Platform.ts","../../node_modules/ixfx/src/util/Results.ts","../../node_modules/ixfx/src/util/KeyValue.ts","../../node_modules/ixfx/src/data/maps/MapFns.ts","../../node_modules/ixfx/src/random/WeightedIndex.ts","../../node_modules/ixfx/src/data/arrays/Random.ts","../../node_modules/ixfx/src/geometry/index.ts","../../node_modules/ixfx/src/geometry/Waypoint.ts","../../node_modules/ixfx/src/geometry/line/JoinPointsToLines.ts","../../node_modules/ixfx/src/geometry/line/Guard.ts","../../node_modules/ixfx/src/geometry/line/GetPointsParameter.ts","../../node_modules/ixfx/src/geometry/line/Length.ts","../../node_modules/ixfx/src/geometry/line/Interpolate.ts","../../node_modules/ixfx/src/geometry/line/Angles.ts","../../node_modules/ixfx/src/geometry/line/Midpoint.ts","../../node_modules/ixfx/src/geometry/line/index.ts","../../node_modules/ixfx/src/geometry/rect/Guard.ts","../../node_modules/ixfx/src/geometry/point/NormaliseByRect.ts","../../node_modules/ixfx/src/geometry/point/GetPointParameter.ts","../../node_modules/ixfx/src/geometry/point/Distance.ts","../../node_modules/ixfx/src/geometry/line/Nearest.ts","../../node_modules/ixfx/src/geometry/line/DistanceSingleLine.ts","../../node_modules/ixfx/src/geometry/point/FindMinimum.ts","../../node_modules/ixfx/src/geometry/rect/Max.ts","../../node_modules/ixfx/src/geometry/point/Bbox.ts","../../node_modules/ixfx/src/geometry/line/Bbox.ts","../../node_modules/ixfx/src/geometry/point/Divider.ts","../../node_modules/ixfx/src/geometry/line/Divide.ts","../../node_modules/ixfx/src/geometry/line/FromFlatArray.ts","../../node_modules/ixfx/src/geometry/Polar.ts","../../node_modules/ixfx/src/geometry/Angles.ts","../../node_modules/ixfx/src/geometry/point/Subtract.ts","../../node_modules/ixfx/src/geometry/point/Empty.ts","../../node_modules/ixfx/src/geometry/line/FromPivot.ts","../../node_modules/ixfx/src/geometry/line/FromPointsToPath.ts","../../node_modules/ixfx/src/geometry/point/IsEqual.ts","../../node_modules/ixfx/src/geometry/line/IsEqual.ts","../../node_modules/ixfx/src/geometry/point/index.ts","../../node_modules/ixfx/src/geometry/point/Abs.ts","../../node_modules/ixfx/src/geometry/point/Angle.ts","../../node_modules/ixfx/src/geometry/point/Apply.ts","../../node_modules/ixfx/src/geometry/point/Centroid.ts","../../node_modules/ixfx/src/geometry/point/Clamp.ts","../../node_modules/ixfx/src/geometry/point/Compare.ts","../../node_modules/ixfx/src/geometry/point/ConvexHull.ts","../../node_modules/ixfx/src/geometry/circle/Guard.ts","../../node_modules/ixfx/src/geometry/circle/DistanceCenter.ts","../../node_modules/ixfx/src/geometry/circle/DistanceFromExterior.ts","../../node_modules/ixfx/src/geometry/circle/IsEqual.ts","../../node_modules/ixfx/src/geometry/point/Sum.ts","../../node_modules/ixfx/src/geometry/circle/Intersections.ts","../../node_modules/ixfx/src/geometry/Intersects.ts","../../node_modules/ixfx/src/geometry/rect/Intersects.ts","../../node_modules/ixfx/src/geometry/rect/Center.ts","../../node_modules/ixfx/src/geometry/point/PointType.ts","../../node_modules/ixfx/src/geometry/rect/Distance.ts","../../node_modules/ixfx/src/geometry/point/DistanceToCenter.ts","../../node_modules/ixfx/src/geometry/point/DistanceToExterior.ts","../../node_modules/ixfx/src/geometry/point/ToArray.ts","../../node_modules/ixfx/src/geometry/point/DotProduct.ts","../../node_modules/ixfx/src/geometry/point/From.ts","../../node_modules/ixfx/src/geometry/point/Interpolate.ts","../../node_modules/ixfx/src/geometry/point/Invert.ts","../../node_modules/ixfx/src/geometry/point/Multiply.ts","../../node_modules/ixfx/src/geometry/point/Magnitude.ts","../../node_modules/ixfx/src/geometry/point/Most.ts","../../node_modules/ixfx/src/geometry/point/Normalise.ts","../../node_modules/ixfx/src/geometry/point/Pipeline.ts","../../node_modules/ixfx/src/geometry/point/ProgressBetween.ts","../../node_modules/ixfx/src/geometry/point/Project.ts","../../node_modules/ixfx/src/geometry/point/Quantise.ts","../../node_modules/ixfx/src/geometry/point/Random.ts","../../node_modules/ixfx/src/geometry/point/Reduce.ts","../../node_modules/ixfx/src/geometry/point/Relation.ts","../../node_modules/ixfx/src/geometry/point/Rotate.ts","../../node_modules/ixfx/src/geometry/point/RotatePointArray.ts","../../node_modules/ixfx/src/geometry/point/Round.ts","../../node_modules/ixfx/src/geometry/point/To.ts","../../node_modules/ixfx/src/geometry/point/WithinRange.ts","../../node_modules/ixfx/src/geometry/point/Wrap.ts","../../node_modules/ixfx/src/geometry/line/Multiply.ts","../../node_modules/ixfx/src/geometry/line/RelativePosition.ts","../../node_modules/ixfx/src/geometry/line/Rotate.ts","../../node_modules/ixfx/src/geometry/line/Subtract.ts","../../node_modules/ixfx/src/geometry/line/Sum.ts","../../node_modules/ixfx/src/geometry/line/ToString.ts","../../node_modules/ixfx/src/geometry/line/ToPath.ts","../../node_modules/ixfx/src/geometry/Layout.ts","../../node_modules/ixfx/src/geometry/CirclePacking.ts","../../node_modules/ixfx/src/geometry/shape/index.ts","../../node_modules/ixfx/src/geometry/rect/Corners.ts","../../node_modules/ixfx/src/geometry/rect/FromTopLeft.ts","../../node_modules/ixfx/src/geometry/circle/IsContainedBy.ts","../../node_modules/ixfx/src/geometry/circle/Intersecting.ts","../../node_modules/ixfx/src/geometry/circle/Random.ts","../../node_modules/ixfx/src/geometry/circle/Center.ts","../../node_modules/ixfx/src/geometry/rect/Random.ts","../../node_modules/ixfx/src/geometry/circle/index.ts","../../node_modules/ixfx/src/geometry/circle/Area.ts","../../node_modules/ixfx/src/geometry/rect/FromCenter.ts","../../node_modules/ixfx/src/geometry/circle/Bbox.ts","../../node_modules/ixfx/src/geometry/circle/ExteriorPoints.ts","../../node_modules/ixfx/src/geometry/circle/InteriorPoints.ts","../../node_modules/ixfx/src/geometry/circle/Perimeter.ts","../../node_modules/ixfx/src/geometry/circle/Interpolate.ts","../../node_modules/ixfx/src/geometry/circle/Multiply.ts","../../node_modules/ixfx/src/geometry/circle/Svg.ts","../../node_modules/ixfx/src/geometry/circle/ToPath.ts","../../node_modules/ixfx/src/geometry/circle/ToPositioned.ts","../../node_modules/ixfx/src/geometry/rect/index.ts","../../node_modules/ixfx/src/geometry/rect/Area.ts","../../node_modules/ixfx/src/geometry/rect/Apply.ts","../../node_modules/ixfx/src/geometry/rect/Cardinal.ts","../../node_modules/ixfx/src/geometry/rect/Edges.ts","../../node_modules/ixfx/src/geometry/rect/Empty.ts","../../node_modules/ixfx/src/geometry/rect/FromElement.ts","../../node_modules/ixfx/src/geometry/rect/FromNumbers.ts","../../node_modules/ixfx/src/geometry/rect/GetRectPositionedParameter.ts","../../node_modules/ixfx/src/geometry/rect/IsEqual.ts","../../node_modules/ixfx/src/geometry/rect/Lengths.ts","../../node_modules/ixfx/src/geometry/rect/Multiply.ts","../../node_modules/ixfx/src/geometry/rect/Divide.ts","../../node_modules/ixfx/src/geometry/rect/Subtract.ts","../../node_modules/ixfx/src/geometry/rect/Sum.ts","../../node_modules/ixfx/src/geometry/rect/ToArray.ts","../../node_modules/ixfx/src/geometry/path/index.ts","../../node_modules/ixfx/src/geometry/bezier/Guard.ts","../../node_modules/ixfx/src/geometry/Grid.ts","../../node_modules/ixfx/src/geometry/bezier/index.ts","../../node_modules/ixfx/node_modules/bezier-js/src/utils.js","../../node_modules/ixfx/node_modules/bezier-js/src/poly-bezier.js","../../node_modules/ixfx/node_modules/bezier-js/src/bezier.js","../../node_modules/ixfx/src/geometry/path/CompoundPath.ts","../../node_modules/ixfx/src/geometry/Ellipse.ts","../../node_modules/ixfx/src/geometry/CurveSimplification.ts","../../node_modules/ixfx/src/geometry/QuadTree.ts","../../node_modules/ixfx/src/geometry/Scaler.ts","../../node_modules/ixfx/src/geometry/rect/Placeholder.ts","../../node_modules/ixfx/src/geometry/Convolve2d.ts","../../node_modules/ixfx/src/visual/ImageDataGrid.ts","../../node_modules/ixfx/src/geometry/arc/index.ts","../../node_modules/ixfx/src/geometry/Vector.ts","../../node_modules/ixfx/src/geometry/SurfacePoints.ts","../../node_modules/ixfx/src/geometry/triangle/index.ts","../../node_modules/ixfx/src/geometry/triangle/Guard.ts","../../node_modules/ixfx/src/geometry/triangle/Edges.ts","../../node_modules/ixfx/src/geometry/triangle/Area.ts","../../node_modules/ixfx/src/geometry/triangle/Centroid.ts","../../node_modules/ixfx/src/geometry/triangle/Perimeter.ts","../../node_modules/ixfx/src/geometry/triangle/InnerCircle.ts","../../node_modules/ixfx/src/geometry/triangle/OuterCircle.ts","../../node_modules/ixfx/src/geometry/triangle/Rotate.ts","../../node_modules/ixfx/src/geometry/triangle/Equilateral.ts","../../node_modules/ixfx/src/geometry/triangle/Right.ts","../../node_modules/ixfx/src/geometry/triangle/Isosceles.ts","../../node_modules/ixfx/src/data/arrays/Pairwise.ts","../../node_modules/ixfx/src/visual/Colour.ts","../../node_modules/ixfx/node_modules/colorjs.io/src/multiply-matrices.js","../../node_modules/ixfx/node_modules/colorjs.io/src/util.js","../../node_modules/ixfx/node_modules/colorjs.io/src/hooks.js","../../node_modules/ixfx/node_modules/colorjs.io/src/defaults.js","../../node_modules/ixfx/node_modules/colorjs.io/src/adapt.js","../../node_modules/ixfx/node_modules/colorjs.io/src/parse.js","../../node_modules/ixfx/node_modules/colorjs.io/src/getColor.js","../../node_modules/ixfx/node_modules/colorjs.io/src/space.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/xyz-d65.js","../../node_modules/ixfx/node_modules/colorjs.io/src/rgbspace.js","../../node_modules/ixfx/node_modules/colorjs.io/src/getAll.js","../../node_modules/ixfx/node_modules/colorjs.io/src/get.js","../../node_modules/ixfx/node_modules/colorjs.io/src/setAll.js","../../node_modules/ixfx/node_modules/colorjs.io/src/set.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/xyz-d50.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/lab.js","../../node_modules/ixfx/node_modules/colorjs.io/src/angles.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/lch.js","../../node_modules/ixfx/node_modules/colorjs.io/src/deltaE/deltaE2000.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/oklab.js","../../node_modules/ixfx/node_modules/colorjs.io/src/deltaE/deltaEOK.js","../../node_modules/ixfx/node_modules/colorjs.io/src/inGamut.js","../../node_modules/ixfx/node_modules/colorjs.io/src/clone.js","../../node_modules/ixfx/node_modules/colorjs.io/src/distance.js","../../node_modules/ixfx/node_modules/colorjs.io/src/deltaE/deltaE76.js","../../node_modules/ixfx/node_modules/colorjs.io/src/deltaE/deltaECMC.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/xyz-abs-d65.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/jzazbz.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/jzczhz.js","../../node_modules/ixfx/node_modules/colorjs.io/src/deltaE/deltaEJz.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/ictcp.js","../../node_modules/ixfx/node_modules/colorjs.io/src/deltaE/deltaEITP.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/cam16.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/hct.js","../../node_modules/ixfx/node_modules/colorjs.io/src/deltaE/deltaEHCT.js","../../node_modules/ixfx/node_modules/colorjs.io/src/deltaE/index.js","../../node_modules/ixfx/node_modules/colorjs.io/src/toGamut.js","../../node_modules/ixfx/node_modules/colorjs.io/src/to.js","../../node_modules/ixfx/node_modules/colorjs.io/src/serialize.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/rec2020-linear.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/rec2020.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/p3-linear.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/srgb-linear.js","../../node_modules/ixfx/node_modules/colorjs.io/src/keywords.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/srgb.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/p3.js","../../node_modules/ixfx/node_modules/colorjs.io/src/display.js","../../node_modules/ixfx/node_modules/colorjs.io/src/equals.js","../../node_modules/ixfx/node_modules/colorjs.io/src/luminance.js","../../node_modules/ixfx/node_modules/colorjs.io/src/contrast/WCAG21.js","../../node_modules/ixfx/node_modules/colorjs.io/src/contrast/APCA.js","../../node_modules/ixfx/node_modules/colorjs.io/src/contrast/Michelson.js","../../node_modules/ixfx/node_modules/colorjs.io/src/contrast/Weber.js","../../node_modules/ixfx/node_modules/colorjs.io/src/contrast/Lstar.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/lab-d65.js","../../node_modules/ixfx/node_modules/colorjs.io/src/contrast/deltaPhi.js","../../node_modules/ixfx/node_modules/colorjs.io/src/contrast.js","../../node_modules/ixfx/node_modules/colorjs.io/src/chromaticity.js","../../node_modules/ixfx/node_modules/colorjs.io/src/deltaE.js","../../node_modules/ixfx/node_modules/colorjs.io/src/variations.js","../../node_modules/ixfx/node_modules/colorjs.io/src/interpolation.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/hsl.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/hsv.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/hwb.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/a98rgb-linear.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/a98rgb.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/prophoto-linear.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/prophoto.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/oklch.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/luv.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/lchuv.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/hsluv.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/hpluv.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/rec2100-pq.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/rec2100-hlg.js","../../node_modules/ixfx/node_modules/colorjs.io/src/CATs.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/acescg.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/acescc.js","../../node_modules/ixfx/node_modules/colorjs.io/src/color.js","../../node_modules/ixfx/node_modules/colorjs.io/src/spaces/index.js","../../node_modules/ixfx/node_modules/colorjs.io/src/space-accessors.js","../../node_modules/ixfx/node_modules/colorjs.io/src/index.js","../../src/client/poses/landmarks.ts","../../src/client/poses/geometry.ts","../../node_modules/ixfx/src/data/maps/GetOrGenerate.ts","../../node_modules/ixfx/src/trackers/TrackerBase.ts","../../node_modules/ixfx/src/trackers/TrackedValue.ts","../../node_modules/ixfx/src/trackers/PrimitiveTracker.ts","../../node_modules/ixfx/src/trackers/NumberTracker.ts","../../node_modules/ixfx/src/trackers/ObjectTracker.ts","../../node_modules/ixfx/src/trackers/PointTracker.ts","../../node_modules/ixfx/src/trackers/TrackUnique.ts","../../node_modules/ixfx/src/trackers/index.ts","../../node_modules/ixfx/src/trackers/FrequencyMutable.ts","../../node_modules/ixfx/src/trackers/IntervalTracker.ts","../../src/client/poses/pose-tracker.ts","../../src/client/poses/poses-tracker.ts","../../src/client/hands/index.ts"],"sourcesContent":["export * from './geometry.js';\nexport * from './landmarks.js';\nexport * from './pose-tracker.js';\nexport * from './poses-tracker.js';\nexport type { PoseData } from '../../types.js';","import type { GuardResultFail, GuardResultOk } from \"./GuardTypes.js\";\n\nexport const throwFromResult = (test: GuardResultFail | GuardResultOk) => {\n  if (test[ 0 ]) return false;\n  else throw new Error(test[ 1 ]);\n}","import { throwFromResult } from \"./GuardThrowFromResult.js\";\nimport type { GuardResult, NumberGuardRange } from \"./GuardTypes.js\";\n\n/**\n * Returns true if `x` is a power of two\n * @param x\n * @returns True if `x` is a power of two\n */\nexport const isPowerOfTwo = (x: number) => Math.log2(x) % 1 === 0;\n\n\n/**\n * Returns `fallback` if `v` is NaN, otherwise returns `v`.\n *\n * Throws if `v` is not a number type.\n * @param v\n * @param fallback\n * @returns\n */\nexport const ifNaN = (v: number, fallback: number): number => {\n  // ✔️ Unit tested\n\n  if (Number.isNaN(v)) return fallback;\n  if (typeof v !== `number`) {\n    throw new TypeError(`v is not a number. Got: ${ typeof v }`);\n  }\n  return v;\n};\n\n/**\n * Parses `value` as an integer, returning it if it meets the `range` criteria.\n * If not, `defaultValue` is returned.\n *\n * ```js\n * const i = integerParse('10', 'positive');    // 10\n * const i = integerParse('10.5', 'positive');  // 10\n * const i = integerParse('0', 'nonZero', 100); // 100\n * ```\n *\n * NaN is returned if criteria does not match and no default is given\n * ```js\n * const i = integerParse('10', 'negative');    // NaN\n * ```\n *\n * @param value\n * @param range\n * @param defaultValue\n * @returns\n */\nexport const integerParse = (\n  //eslint-disable-next-line @typescript-eslint/no-explicit-any\n  value: any,\n  range: NumberGuardRange = ``,\n  defaultValue: number = Number.NaN\n): number => {\n  // ✔️ Unit tested\n  if (value === undefined) return defaultValue;\n  if (value === null) return defaultValue;\n  try {\n    const parsed = Number.parseInt(value);\n    const r = integerTest(parsed, range, `parsed`);\n    return r[ 0 ] ? parsed : defaultValue;\n  } catch {\n    return defaultValue;\n  }\n};\n\n\n/**\n * Checks if `t` is not a number or within specified range.\n * Returns `[false, reason:string]` if invalid or `[true]` if valid.\n * Use {@link throwNumberTest} to throw an error rather than return result.\n * \n * Alternatives: {@link integerTest} for additional integer check, {@link percentTest} for percentage-range.\n *\n * * (empty, default): must be a number type and not NaN.\n * * finite: must be a number, not NaN and not infinite\n * * positive: must be at least zero\n * * negative: must be zero or lower\n * * aboveZero: must be above zero\n * * belowZero: must be below zero\n * * percentage: must be within 0-1, inclusive\n * * nonZero: can be anything except zero\n * * bipolar: can be -1 to 1, inclusive\n * @param value Value to check\n * @param parameterName Name of parameter (for more helpful exception messages)\n * @param range Range to enforce\n * @returns\n */\nexport const numberTest = (\n  value?: unknown,\n  range: NumberGuardRange = ``,\n  parameterName = `?`,\n): GuardResult => {\n  if (value === null) return [ false, `Parameter '${ parameterName }' is null` ];\n  if (typeof value === `undefined`) {\n    return [ false, `Parameter '${ parameterName }' is undefined` ];\n  }\n  if (Number.isNaN(value)) {\n    return [ false, `Parameter '${ parameterName }' is NaN` ];\n  }\n  if (typeof value !== `number`) {\n    return [ false, `Parameter '${ parameterName }' is not a number (${ JSON.stringify(value) })` ];\n  }\n  switch (range) {\n    case `finite`: {\n      if (!Number.isFinite(value)) {\n        return [ false, `Parameter '${ parameterName } must be finite` ];\n      }\n    }\n    case `positive`: {\n      if (value < 0) {\n        return [ false, `Parameter '${ parameterName }' must be at least zero (${ value })` ];\n      }\n      break;\n    } case `negative`: {\n      if (value > 0) {\n        return [ false, `Parameter '${ parameterName }' must be zero or lower (${ value })` ];\n      }\n      break;\n    }\n    case `aboveZero`: {\n      if (value <= 0) {\n        return [ false, `Parameter '${ parameterName }' must be above zero (${ value })` ]\n\n      }\n      break;\n    }\n    case `belowZero`: {\n      if (value >= 0) {\n        return [ false, `Parameter '${ parameterName }' must be below zero (${ value })` ];\n      }\n      break;\n    }\n    case `percentage`: {\n      if (value > 1 || value < 0) {\n        return [ false, `Parameter '${ parameterName }' must be in percentage range (0 to 1). (${ value })` ]\n      }\n      break;\n    }\n    case `nonZero`: {\n      if (value === 0) {\n        return [ false, `Parameter '${ parameterName }' must non-zero. (${ value })` ];\n      }\n      break;\n    }\n    case `bipolar`: {\n      if (value > 1 || value < -1) {\n        return [ false, `Parameter '${ parameterName }' must be in bipolar percentage range (-1 to 1). (${ value })` ];\n      }\n      break;\n    }\n  }\n  return [ true ];\n};\n\n/**\n * Checks if `t` is not a number or within specified range.\n * Throws if invalid. Use {@link numberTest} to test without throwing.\n *\n* * (empty, default): must be a number type and not NaN.\n* * positive: must be at least zero\n* * negative: must be zero or lower\n* * aboveZero: must be above zero\n* * belowZero: must be below zero\n* * percentage: must be within 0-1, inclusive\n* * nonZero: can be anything except zero\n* * bipolar: can be -1 to 1, inclusive\n* \n * Alternatives: {@link integerTest} for additional integer check, {@link percentTest} for percentage-range.\n * @param value Value to test\n * @param range Range\n * @param parameterName Name of parameter \n */\nexport const throwNumberTest = (value?: unknown,\n  range: NumberGuardRange = ``,\n  parameterName = `?`) => {\n  throwFromResult(numberTest(value, range, parameterName));\n}\n\n/**\n * Returns test of `value` being in the range of 0-1.\n * Equiv to `number(value, `percentage`);`\n *\n * This is the same as calling ```number(t, `percentage`)```\n * @param value Value to check\n * @param parameterName Param name for customising exception message\n * @returns\n */\nexport const percentTest = (value: number, parameterName = `?`): GuardResult =>\n  numberTest(value, `percentage`, parameterName);\n\nexport const throwPercentTest = (value: number, parameterName = `?`) => {\n  throwFromResult(percentTest(value, parameterName));\n}\n/**\n * Checks if `value` an integer and meets additional criteria.\n * See {@link numberTest} for guard details, or use that if integer checking is not required.\n *\n * Note:\n * * `bipolar` will mean -1, 0 or 1.\n * * positive: must be at least zero\n * * negative: must be zero or lower\n * * aboveZero: must be above zero\n * * belowZero: must be below zero\n * * percentage: must be within 0-1, inclusive\n * * nonZero: can be anything except zero\n * @param value Value to check\n * @param parameterName Param name for customising exception message\n * @param range Guard specifier.\n */\nexport const integerTest = (\n  value: number | undefined,\n  range: NumberGuardRange = ``,\n  parameterName = `?`\n): GuardResult => {\n  // ✔️ Unit tested\n  const r = numberTest(value, range, parameterName);\n  if (!r[ 0 ]) return r;\n  if (!Number.isInteger(value)) {\n    return [ false, `Param '${ parameterName }' is not an integer` ];\n  }\n  return [ true ];\n};\n\nexport const throwIntegerTest = (value: number | undefined,\n  range: NumberGuardRange = ``,\n  parameterName = `?`) => {\n  throwFromResult(integerTest(value, range, parameterName));\n}\n","import type { Point, Point3d } from \"./PointType.js\";\nimport { throwNumberTest } from '../../util/GuardNumbers.js';\n\n/**\n * Returns true if p.x and p.y === null\n * @param p\n * @returns\n */\nexport const isNull = (p: Point) => p.x === null && p.y === null;\n\n/***\n * Returns true if p.x or p.y isNaN\n */\nexport const isNaN = (p: Point) => Number.isNaN(p.x) || Number.isNaN(p.y);\n\n\n/**\n * Throws an error if point is invalid\n * @param p\n * @param name\n */\nexport function guard(p: Point, name = `Point`) {\n  if (p === undefined) {\n    throw new Error(\n      `'${ name }' is undefined. Expected {x,y} got ${ JSON.stringify(p) }`\n    );\n  }\n  if (p === null) {\n    throw new Error(\n      `'${ name }' is null. Expected {x,y} got ${ JSON.stringify(p) }`\n    );\n  }\n  if (p.x === undefined) {\n    throw new Error(\n      `'${ name }.x' is undefined. Expected {x,y} got ${ JSON.stringify(p) }`\n    );\n  }\n  if (p.y === undefined) {\n    throw new Error(\n      `'${ name }.y' is undefined. Expected {x,y} got ${ JSON.stringify(p) }`\n    );\n  }\n  if (typeof p.x !== `number`) {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new TypeError(`'${ name }.x' must be a number. Got ${ p.x }`);\n  }\n  if (typeof p.y !== `number`) {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new TypeError(`'${ name }.y' must be a number. Got ${ p.y }`);\n  }\n\n  if (p.x === null) throw new Error(`'${ name }.x' is null`);\n  if (p.y === null) throw new Error(`'${ name }.y' is null`);\n\n  if (Number.isNaN(p.x)) throw new Error(`'${ name }.x' is NaN`);\n  if (Number.isNaN(p.y)) throw new Error(`'${ name }.y' is NaN`);\n}\n\n/**\n * Throws if parameter is not a valid point, or either x or y is 0\n * @param pt\n * @returns\n */\nexport const guardNonZeroPoint = (pt: Point | Point3d, name = `pt`) => {\n  guard(pt, name);\n  throwNumberTest(pt.x, `nonZero`, `${ name }.x`);\n  throwNumberTest(pt.y, `nonZero`, `${ name }.y`);\n  if (typeof pt.z !== `undefined`) {\n    throwNumberTest(pt.z, `nonZero`, `${ name }.z`);\n  }\n\n  return true;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport function isPoint(p: number | unknown): p is Point {\n  if (p === undefined) return false;\n  if (p === null) return false;\n  if ((p as Point).x === undefined) return false;\n  if ((p as Point).y === undefined) return false;\n  return true;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport const isPoint3d = (p: Point | unknown): p is Point3d => {\n  if (p === undefined) return false;\n  if (p === null) return false;\n  if ((p as Point3d).x === undefined) return false;\n  if ((p as Point3d).y === undefined) return false;\n  if ((p as Point3d).z === undefined) return false;\n  return true;\n};\n\n/**\n * Returns true if both x and y is 0.\n * Use `Points.Empty` to return an empty point.\n * @param p\n * @returns\n */\nexport const isEmpty = (p: Point) => p.x === 0 && p.y === 0;\n\n/**\n * Returns true if point is a placeholder, where both x and y\n * are `NaN`.\n *\n * Use Points.Placeholder to return a placeholder point.\n * @param p\n * @returns\n */\nexport const isPlaceholder = (p: Point) =>\n  Number.isNaN(p.x) && Number.isNaN(p.y);\n","import type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { guard as guardPoint } from '../point/Guard.js';\n\n/**\n * Returns a line from two points\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Line from 0,1 to 10,15\n * const line = Lines.fromPoints( { x:0, y:1 }, { x:10, y:15 });\n * // line is: { a: { x: 0, y: 1}, b: { x: 10, y: 15 } };\n * ```\n * @param a Start point\n * @param b End point\n * @returns \n */\nexport const fromPoints = (a: Point, b: Point): Line => {\n  guardPoint(a, `a`);\n  guardPoint(b, `b`);\n  a = Object.freeze({ ...a });\n  b = Object.freeze({ ...b });\n  return Object.freeze({\n    a: a,\n    b: b\n  });\n};\n\n","import { fromPoints } from \"./FromPoints.js\";\nimport type { Line } from \"./LineType.js\";\n\n/**\n * Returns a line from a basis of coordinates (x1, y1, x2, y2)\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Line from 0,1 -> 10,15\n * Lines.fromNumbers(0, 1, 10, 15);\n * ```\n * @param x1 \n * @param y1 \n * @param x2 \n * @param y2 \n * @returns \n */\nexport const fromNumbers = (x1: number, y1: number, x2: number, y2: number): Line => {\n  if (Number.isNaN(x1)) throw new Error(`x1 is NaN`);\n  if (Number.isNaN(x2)) throw new Error(`x2 is NaN`);\n  if (Number.isNaN(y1)) throw new Error(`y1 is NaN`);\n  if (Number.isNaN(y2)) throw new Error(`y2 is NaN`);\n\n  const a = { x: x1, y: y1 };\n  const b = { x: x2, y: y2 };\n  return fromPoints(a, b);\n};","import { throwIntegerTest, throwNumberTest } from \"../util/GuardNumbers.js\";\n\nexport function round(decimalPlaces: number, v: number): number;\nexport function round(decimalPlaces: number): (v: number) => number;\n\n/**\n * Rounds a number.\n *\n * If one parameter is given, it's the decimal places,\n * and a rounding function is returned:\n * ```js\n * import { round } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * const r = round(2);\n * r(10.12355); // 10.12\n * ```\n *\n * If two parameters are given, the first is decimal places,\n * the second the value to round.\n * ```js\n * round(2, 10.12355); // 10.12\n * ```\n * @param decimalPlaces\n * @returns\n */\nexport function round(a: number, b?: number) {\n  throwIntegerTest(a, `positive`, `decimalPlaces`);\n\n  //eslint-disable-next-line functional/no-let\n  let rounder;\n  if (a === 0) rounder = Math.round;\n  else {\n    const p = Math.pow(10, a);\n    rounder = (v: number) => Math.floor(v * p) / p;\n  }\n\n  return b === undefined ? rounder : rounder(b);\n}\n\n\n/**\n * Rounds `v` up to the nearest multiple of `multiple`\n * ```\n * roundMultiple(19, 20); // 20\n * roundMultiple(21, 20); // 40\n * ```\n * @param v\n * @param multiple\n * @returns\n */\n// export const roundUpToMultiple = (v: number, multiple: number): number => {\n//   throwNumberTest(v, `nonZero`, `v`);\n//   throwNumberTest(multiple, `nonZero`, `multiple`);\n//   return Math.ceil(v / multiple) * multiple;\n// };\n","import { throwIntegerTest, throwNumberTest } from \"../util/GuardNumbers.js\";\n\n/**\n * Rounds `v` by `every`. Middle values are rounded up by default.\n *\n * ```js\n * quantiseEvery(11, 10);  // 10\n * quantiseEvery(25, 10);  // 30\n * quantiseEvery(0, 10);   // 0\n * quantiseEvery(4, 10);   // 0\n * quantiseEvery(100, 10); // 100\n * ```\n * \n * Also works with decimals\n * ```js\n * quantiseEvery(1.123, 0.1); // 1.1\n * quantiseEvery(1.21, 0.1);  // 1.2\n * ```\n *\n * @param v Value to quantise\n * @param every Number to quantise to\n * @param middleRoundsUp If _true_ (default), the exact middle rounds up to next step.\n * @returns\n */\nexport const quantiseEvery = (\n  v: number,\n  every: number,\n  middleRoundsUp = true\n) => {\n\n  const everyStr = every.toString();\n  const decimal = everyStr.indexOf(`.`);\n  let multiplier = 1;\n  if (decimal >= 0) {\n    let d = everyStr.substring(decimal + 1).length;\n    multiplier = 10 * d;\n    every = Math.floor(multiplier * every);\n    v = v * multiplier;\n  }\n  throwNumberTest(v, ``, `v`);\n  throwIntegerTest(every, ``, `every`);\n\n  let div = v / every;\n  const divModule = div % 1;\n  div = Math.floor(div);\n  if ((divModule === 0.5 && middleRoundsUp) || divModule > 0.5) div++;\n  const vv = (every * div) / multiplier;\n  return vv;\n};","import { throwNumberTest } from \"../util/GuardNumbers.js\";\nimport { round } from \"./Round.js\";\n\n/**\n * Generates a `step`-length series of values between `start` and `end` (inclusive).\n * Each value will be equally spaced.\n *\n * ```js\n * for (const v of linearSpace(1, 5, 6)) {\n *  // Yields: [ 1, 1.8, 2.6, 3.4, 4.2, 5 ]\n * }\n * ```\n *\n * Numbers can be produced from large to small as well\n * ```js\n * const values = [...linearSpace(10, 5, 3)];\n * // Yields: [10, 7.5, 5]\n * ```\n * @param start Start number (inclusive)\n * @param end  End number (inclusive)\n * @param steps How many steps to make from start -> end\n * @param precision Number of decimal points to round to\n */\nexport function* linearSpace(\n  start: number,\n  end: number,\n  steps: number,\n  precision?: number\n): IterableIterator<number> {\n  throwNumberTest(start, ``, `start`);\n  throwNumberTest(end, ``, `end`);\n\n  throwNumberTest(steps, ``, `steps`);\n  const r = precision ? round(precision) : (v: number) => v;\n  const step = (end - start) / (steps - 1);\n\n  throwNumberTest(step, ``, `step`);\n  if (!Number.isFinite(step)) {\n    throw new TypeError(`Calculated step value is infinite`);\n  }\n\n  //eslint-disable-next-line functional/no-let\n  for (let index = 0; index < steps; index++) {\n    const v = start + step * index;\n    yield r(v);\n  }\n}\n","/**\n * Applies a function `fn` to the elements of an array, weighting them based on their relative position.\n *\n * ```js\n * import { weight } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * import { gaussian } from 'https://unpkg.com/ixfx/dist/modulation.js';\n * // Six items\n * weight([1,1,1,1,1,1], gaussian());\n *\n * // Yields:\n * // [0.02, 0.244, 0.85, 0.85, 0.244, 0.02]\n * ```\n *\n * `fn` is expected to map (0..1) => (0..1), such as an easing function. The input to the\n * `fn` is the relative position of an element. Thus the first element will be 0, the middle 0.5 and so on.\n * The output of `fn` is then multiplied by the original value.\n *\n * In the below example (which is also the default if `fn` is not specified), the relative position is\n * how values are weighted:\n *\n * ```js\n * weight([1,1,1,1,1,1], (relativePos) => relativePos);\n * // Yields:\n * // [0, 0.2, 0.4, 0.6, 0.8, 1]\n * ```\n *\n * Non-numbers in `data` will be silently ignored (this filtering happens first, so relative index values are sane still).\n *\n * @param data Array of numbers\n * @param fn Returns a weighting based on the given relative position. If unspecified, `(x) => x` is used.\n */\nexport const weight = (\n  data: Array<number> | ReadonlyArray<number>,\n  fn?: (relativePos: number) => number\n): Array<number> => {\n  const f = fn ?? ((x: number) => x);\n  const valid = validNumbers(data);\n  return valid.map(\n    (v: number, index: number) => {\n      const x = v * f(index / (valid.length - 1));\n      return x;\n    }\n  );\n};\n\n/**\n * Returns an array of all valid numbers from `data`\n *\n * @param data\n * @returns\n */\nexport const validNumbers = (data: ReadonlyArray<number>) =>\n  data.filter((d) => typeof d === `number` && !Number.isNaN(d));\n\n/**\n * Returns the dot product of arbitrary-sized arrays. Assumed they are of the same length.\n * @param values\n * @returns\n */\nexport const dotProduct = (\n  values: ReadonlyArray<ReadonlyArray<number>>\n): number => {\n  let r = 0;\n  const length = values[ 0 ].length;\n\n  for (let index = 0; index < length; index++) {\n    let t = 0;\n    for (const [ p, value ] of values.entries()) {\n      if (p === 0) t = value[ index ];\n      else {\n        t *= value[ index ];\n      }\n    }\n    r += t;\n  }\n  return r;\n};\n\n/**\n * Calculates the average of all numbers in an array.\n * Array items which aren't a valid number are ignored and do not factor into averaging.\n *\n * Use {@link minMaxAvg} if you want min, max and total as well.\n *\n * @example\n * ```js\n * import * as Numbers from 'https://unpkg.com/ixfx/dist/numbers.js';\n *\n * // Average of a list\n * const avg = Numbers.average([1, 1.4, 0.9, 0.1]);\n *\n * // Average of a variable\n * const data = [100,200];\n * Numbers.average(data);\n * ```\n *\n * @see {@link averageWeighted} To weight items based on position in array\n * @param data Data to average.\n * @returns Average of array\n */\nexport const average = (data: ReadonlyArray<number>): number => {\n  // ✔ UNIT TESTED\n  if (data === undefined) throw new Error(`data parameter is undefined`);\n  const valid = validNumbers(data);\n  const total = valid.reduce((accumulator, v) => accumulator + v, 0);\n  return total / valid.length;\n};\n\n/**\n * Returns the minimum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/Numbers.js';\n * Numbers.min([10, 20, 0]); // Yields 0\n * ```\n * @param data\n * @returns Minimum number\n */\nexport const min = (data: ReadonlyArray<number>): number =>\n  Math.min(...validNumbers(data));\n\n/**\n * Returns the index of the largest value.\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/Numbers.js';\n * const v = [ 10, 40, 5 ];\n * Numbers.maxIndex(v); // Yields 1\n * ```\n * @param data Array of numbers\n * @returns Index of largest value\n */\nexport const maxIndex = (data: ReadonlyArray<number>): number =>\n  // eslint-disable-next-line unicorn/no-array-reduce\n  data.reduce(\n    (bestIndex, value, index, array) =>\n      value > array[ bestIndex ] ? index : bestIndex,\n    0\n  );\n\n/**\n * Returns the index of the smallest value.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/Numbers.js';\n * const v = [ 10, 40, 5 ];\n * Numbers.minIndex(v); // Yields 2\n * ```\n * @param data Array of numbers\n * @returns Index of smallest value\n */\nexport const minIndex = (...data: ReadonlyArray<number>): number =>\n  // eslint-disable-next-line unicorn/no-array-reduce\n  data.reduce(\n    (bestIndex, value, index, array) =>\n      value < array[ bestIndex ] ? index : bestIndex,\n    0\n  );\n\n/**\n * Returns the maximum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * Numbers.max(100, 200, 50); // 200\n * ```\n * @param data List of numbers\n * @returns Maximum number\n */\nexport const max = (data: ReadonlyArray<number>): number =>\n  Math.max(...validNumbers(data));\n\n/**\n * Returns the total of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * Numbers.total([1, 2, 3]); // 6\n * ```\n * @param data Array of numbers\n * @returns Total\n */\nexport const total = (data: ReadonlyArray<number>): number =>\n  // eslint-disable-next-line unicorn/no-array-reduce\n  data.reduce((previous, current) => {\n    if (typeof current !== `number`) return previous;\n    if (Number.isNaN(current)) return previous;\n    if (Number.isFinite(current)) return previous;\n    return previous + current;\n  }, 0);\n\n/**\n * Returns the maximum out of `data` without pre-filtering for speed.\n *\n * For most uses, {@link max} should suffice.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * Numbers.maxFast([ 10, 0, 4 ]); // 10\n * ```\n * @param data\n * @returns Maximum\n */\n//eslint-disable-next-line functional/prefer-immutable-types\nexport const maxFast = (data: ReadonlyArray<number> | Float32Array): number => {\n  //eslint-disable-next-line functional/no-let\n  let m = Number.MIN_SAFE_INTEGER;\n  //eslint-disable-next-line functional/no-let\n  for (const datum of data) {\n    m = Math.max(m, datum);\n  }\n  return m;\n};\n\n/**\n * Returns the total of `data` without pre-filtering for speed.\n *\n * For most uses, {@link total} should suffice.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * Numbers.totalFast([ 10, 0, 4 ]); // 14\n * ```\n * @param data\n * @returns Maximum\n */\n//eslint-disable-next-line functional/prefer-immutable-types\nexport const totalFast = (data: ReadonlyArray<number> | Float32Array): number => {\n  //eslint-disable-next-line functional/no-let\n  let m = 0;\n  //eslint-disable-next-line functional/no-let\n  for (const datum of data) {\n    m += datum;\n  }\n  return m;\n};\n\n/**\n * Returns the maximum out of `data` without pre-filtering for speed.\n *\n * For most uses, {@link max} should suffice.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * Numbers.minFast([ 10, 0, 100 ]); // 0\n * ```\n * @param data\n * @returns Maximum\n */\n//eslint-disable-next-line functional/prefer-immutable-types\nexport const minFast = (data: ReadonlyArray<number> | Float32Array): number => {\n  //eslint-disable-next-line functional/no-let\n  let m = Number.MIN_SAFE_INTEGER;\n  //eslint-disable-next-line functional/no-let\n  for (const datum of data) {\n    m = Math.min(m, datum);\n  }\n  return m;\n};\n","import { numberTest } from '../util/GuardNumbers.js';\nimport { round } from '../numbers/Round.js';\n\n/**\n * Interval types allows for more expressive coding, rather than embedding millisecond values.\n * \n * That is, we can use `{ mins: 5 }` to mean 5 minutes rather than `5*60*1000` \n * or worse, 300000, for the same value.\n *\n * @example\n * ```js\n * { hours: 1 };  // 1 hour\n * { mins: 5 };   // 5 mins\n * { secs: 5 };   // 5 secs\n * { millis: 5 }; // 5 milliseconds\n * ```\n * \n * If several fields are used, this sums their value\n * ```js\n * { secs: 2, millis: 1 }; // equal 2001 milliseconds.\n * ```\n * \n * Wherever ixfx takes an `Interval`, you can also just provide a number instead.\n * This will be taken as a millisecond value.\n * \n * @see {@link intervalToMs} to convert to milliseconds.\n * @see {@link isInterval} check whether input is an Interval type\n * @see {@link elapsedToHumanString} render interval in human-friendly form\n */\nexport type Interval =\n  | number\n  | {\n    readonly millis?: number;\n    readonly secs?: number;\n    readonly hours?: number;\n    readonly mins?: number;\n  };\n\n// export function intervalToMs(interval: Interval | undefined): number | undefined;\n// export function intervalToMs(\n//   interval: Interval | undefined,\n//   defaultNumber: number\n// ): number;\n\n\n/**\n * Return the millisecond value of an Interval.\n * \n * ```js\n * intervalToMs(100); // 100\n * intervalToMs({ millis: 100 }); // 100\n * ```\n *\n * Use `defaultNumber` to return a default in the case of\n * _undefined_ or invalid input.\n *\n * ```js\n * intervalToMs(undefined);      // throws error\n * intervalToMs(undefined, 100); // 100\n * ```\n *\n * If no default is provided, an exception is thrown.\n * @param interval Interval\n * @param defaultNumber Default value if `interval` is _undefined_ or invalid\n * @returns Milliseconds\n */\nexport function intervalToMs(\n  interval: Interval | undefined,\n  defaultNumber?: number\n): number {\n  if (isInterval(interval)) {\n    // Number given, must be millis?\n    if (typeof interval === `number`) return interval;\n\n    let ms = interval.millis ?? 0;\n    ms += (interval.hours ?? 0) * 60 * 60 * 1000;\n    ms += (interval.mins ?? 0) * 60 * 1000;\n    ms += (interval.secs ?? 0) * 1000;\n    return ms;\n  } else {\n    if (typeof defaultNumber !== `undefined`) return defaultNumber;\n    throw new Error(`Not a valid interval: ${ interval }`);\n  }\n}\n\n/**\n * Returns _true_ if `interval` matches the {@link Interval} type.\n * @param interval \n * @returns _True_ if `interval` is an {@link Interval}.\n */\nexport function isInterval(interval: number | Interval | undefined): interval is Interval {\n  if (interval === undefined) return false;\n  if (interval === null) return false;\n  if (typeof interval === `number`) {\n    if (Number.isNaN(interval)) return false;\n    if (!Number.isFinite(interval)) return false;\n    return true;\n  } else if (typeof interval !== `object`) return false;\n\n  const hasMillis = `millis` in interval;\n  const hasSecs = `secs` in interval;\n  const hasMins = `mins` in interval;\n  const hasHours = `hours` in interval;\n  if (hasMillis && !numberTest(interval.millis)[ 0 ]) return false;\n  if (hasSecs && !numberTest(interval.secs)[ 0 ]) return false;\n  if (hasMins && !numberTest(interval.mins)[ 0 ]) return false;\n  if (hasHours && !numberTest(interval.hours)[ 0 ]) return false;\n  if (hasMillis || hasSecs || hasHours || hasMins) return true;\n  return false;\n}\n\n/**\n * Returns a human-readable representation\n * of some elapsed milliseconds\n * \n * @example\n * ```js\n * elapsedToHumanString(10);      // `10ms`\n * elapsedToHumanString(2000);    // `2s`\n * elapsedToHumanString(65*1000); // `1mins`\n * ```\n * @param millisOrFunction Milliseconds as a number, {@link Interval} or function that resolve to a number\n * @param rounding Rounding (default: 2)\n * @returns \n */\nexport const elapsedToHumanString = (millisOrFunction: number | (() => number) | Interval, rounding = 2): string => {\n  let interval: number | undefined = {} = 0;\n  if (typeof millisOrFunction === `function`) {\n    const intervalResult = millisOrFunction();\n    return elapsedToHumanString(intervalResult);\n  } else if (typeof millisOrFunction === `number`) {\n    interval = millisOrFunction;\n  } else if (typeof millisOrFunction === `object`) {\n    interval = intervalToMs(interval);\n  }\n\n  let ms = intervalToMs(interval);\n  if (typeof ms === `undefined`) return `(undefined)`;\n  if (ms < 1000) return `${ round(rounding, ms) }ms`;\n  ms /= 1000;\n  if (ms < 120) return `${ ms.toFixed(1) }secs`;\n  ms /= 60;\n  if (ms < 60) return `${ ms.toFixed(2) }mins`;\n  ms /= 60;\n  return `${ ms.toFixed(2) }hrs`;\n};","export type ToString<V> = (itemToMakeStringFor: V) => string;\n// Via Vuejs\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst objectToString = Object.prototype.toString\nconst toTypeString = (value: unknown): string =>\n  objectToString.call(value)\nexport const isMap = (value: unknown): value is Map<any, any> =>\n  toTypeString(value) === `[object Map]`\nexport const isSet = (value: unknown): value is Set<any> =>\n  toTypeString(value) === `[object Set]`\n\n/**\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\n */\nexport const toStringDefault = <V>(itemToMakeStringFor: V): string =>\n  typeof itemToMakeStringFor === `string`\n    ? itemToMakeStringFor\n    : JSON.stringify(itemToMakeStringFor);\n\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const defaultToString = (object: any): string => {\n  //ECMA specification: http://www.ecma-international.org/ecma-262/6.0/#sec-tostring\n  if (object === null) return `null`;\n  if (typeof object === `boolean` || typeof object === `number`) {\n    return object.toString();\n  }\n\n  if (typeof object === `string`) return object;\n  if (typeof object === `symbol`) throw new TypeError(`Symbol cannot be converted to string`);\n  return JSON.stringify(object);\n};","import { toStringDefault } from \"./ToString.js\";\n\n/**\n * If input is a string, it is returned.\n * Otherwise, it returns the result of JSON.stringify() with fields ordered.\n * \n * This allows for more consistent comparisons when object field orders are different but values the same.\n * @param itemToMakeStringFor \n * @returns \n */\nexport const toStringOrdered = (itemToMakeStringFor: any) => {\n  if (typeof itemToMakeStringFor === `string`) return itemToMakeStringFor;\n  const allKeys = new Set<string>();\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  JSON.stringify(itemToMakeStringFor, (key: string, value: any) => (allKeys.add(key), value));\n  return JSON.stringify(itemToMakeStringFor, [ ...allKeys ].sort());\n}\n\n/**\n * Function that returns true if `a` and `b` are considered equal\n */\nexport type IsEqual<T> = (a: T, b: T) => boolean;\n\n/**\n * Default comparer function is equiv to checking `a === b`.\n * Use {@link isEqualValueDefault} to compare by value, via comparing JSON string representation.\n */\nexport const isEqualDefault = <T>(a: T, b: T): boolean => a === b;\n\n/**\n * Comparer returns true if string representation of `a` and `b` are equal.\n * Use {@link isEqualDefault} to compare using === semantics\n * Uses `toStringDefault` to generate a string representation (via `JSON.stringify`).\n * \n * Returns _false_ if the ordering of fields is different, even though values are identical:\n * ```js\n * isEqualValueDefault({ a: 10, b: 20}, { b: 20, a: 10 }); // false\n * ```\n * \n * Use {@link isEqualValueIgnoreOrder} to ignore order (with an overhead of additional processing).\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * ```\n * \n * Use {@link isEqualValuePartial} to partially match `b` against `a`.\n * @returns True if the contents of `a` and `b` are equal\n */\nexport const isEqualValueDefault = <T>(a: T, b: T): boolean => {\n  // ✔ UNIT TESTED\n  if (a === b) return true; // Object references are the same, or string values are the same\n  return toStringDefault(a) === toStringDefault(b); // String representations are the same\n};\n\n/**\n * Returns _true_ if `a` contains the values of `b`. `a` may contain other values, but we\n * only check against what is in `b`. `a` and `b` must both be simple objects.\n * \n * ```js\n * const obj = {\n *  name: `Elle`,\n *  size: 100,\n *  colour: {\n *    red: 0.5,\n *    green: 0.1,\n *    blue: 0.2\n *  }\n * }\n * \n * isEqualValuePartial(obj, { name: `Elle` }); // true\n * isEqualValuePartial(obj, { name: { colour: red: { 0.5, green: 0.1  }} }); // true\n * \n * isEqualValuePartial(obj, { name: `Ellen` });     // false\n * isEqualValuePartial(obj, { lastname: `Elle` });  // false\n * ```\n * @param a \n * @param b \n * @param fieldComparer \n * @returns \n */\nexport const isEqualValuePartial = <T1 extends Record<string, any>, T2 extends Record<string, any>>(a: T1, b: T2, fieldComparer?: IsEqual<any>): boolean => {\n  if (typeof a !== `object`) throw new Error(`Parameter 'a' expected to be object`);\n  if (typeof b !== `object`) throw new Error(`Parameter 'b' expected to be object`);\n\n  if (Object.is(a, b)) return true;\n  const comparer = fieldComparer ?? isEqualValuePartial;\n  for (const entryB of Object.entries(b)) {\n    const valueA = a[ entryB[ 0 ] ];\n    const valueB = entryB[ 1 ];\n    if (typeof valueA === `object` && typeof valueB === `object`) {\n      if (!comparer(valueA, valueB)) {\n        return false;\n      }\n    } else {\n      if (valueA !== valueB) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n\n\n/**\n * Comparer returns true if string representation of `a` and `b` are equal, regardless of field ordering.\n * Uses `toStringOrdered` to generate a string representation (via JSON.stringify`).\n * \n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * isEqualValue({ a: 10, b: 20}, { b: 20, a: 10 }); // false, fields are different order\n * ```\n * \n * There is an overhead to ordering fields. Use {@link isEqualValueDefault} if it's not possible that field ordering will change.\n * @returns True if the contents of `a` and `b` are equal\n * @typeParam T - Type of objects being compared\n */\nexport const isEqualValueIgnoreOrder = <T>(a: T, b: T): boolean => {\n  // ✔ UNIT TESTED\n  if (a === b) return true; // Object references are the same, or string values are the same\n  return toStringOrdered(a) === toStringOrdered(b); // String representations are the same\n};","var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\n\nexport {\n  __commonJS,\n  __export,\n  __toESM,\n  __decorateClass,\n  __privateGet,\n  __privateAdd,\n  __privateSet,\n  __privateMethod\n};\n//# sourceMappingURL=chunk-L5EJU35C.js.map","\nimport type { ISimpleEventEmitter, Listener } from './ISimpleEventEmitter.js';\nimport { ofSimpleMutable } from './collections/map/MapOfSimpleMutable.js';\nimport { intervalToMs, type Interval } from './flow/IntervalType.js';\n\n/**\n * Subscribes to events on `target`, returning the event data\n * from the first event that fires.\n * \n * By default waits a maximum of 1 minute.\n * \n * Automatically unsubscribes on success or failure (ie. timeout)\n * \n * ```js\n * // Event will be data from either event, whichever fires first\n * // Exception is thrown if neither fires within 1 second\n * const event = await eventRace(document.body, [`pointermove`, `pointerdown`], { timeout: 1000 });\n * ```\n * @param target Event source\n * @param eventNames Event name(s)\n * @param options Options\n * @returns \n */\nexport const eventRace = (target: EventTarget, eventNames: Array<string>, options: Partial<{ timeout: Interval, signal: AbortSignal }> = {}) => {\n  const intervalMs = intervalToMs(options.timeout, 60 * 1000);\n  const signal = options.signal;\n  let triggered = false;\n  let disposed = false;\n  let timeout: ReturnType<typeof setTimeout> | undefined;\n\n  const promise = new Promise<Event>((resolve, reject) => {\n    const onEvent = (event: Event) => {\n      if (`type` in event) {\n        if (eventNames.includes(event.type)) {\n          triggered = true;\n          resolve(event);\n          dispose();\n        } else {\n          console.warn(`eventRace: Got event '${ event.type }' that is not in race list`);\n        }\n      } else {\n        console.warn(`eventRace: Event data does not have expected 'type' field`);\n        console.log(event);\n      }\n    }\n\n    for (const name of eventNames) {\n      target.addEventListener(name, onEvent);\n    }\n\n    const dispose = () => {\n      if (disposed) return;\n      if (timeout !== undefined) clearTimeout(timeout);\n      timeout = undefined;\n      disposed = true;\n      for (const name of eventNames) {\n        target.removeEventListener(name, onEvent);\n      }\n    }\n\n    timeout = setTimeout(() => {\n      if (triggered || disposed) return;\n      dispose();\n      reject(new Error(`eventRace: Events not fired within interval. Events: ${ JSON.stringify(eventNames) } Interval: ${ intervalMs }`));\n    }, intervalMs);\n\n\n    signal?.addEventListener(`abort`, () => {\n      if (triggered || disposed) return;\n      dispose();\n      reject(new Error(`Abort signal received ${ signal.reason }`));\n    });\n  });\n  return promise;\n}\n\n\nexport class SimpleEventEmitter<Events> implements ISimpleEventEmitter<Events> {\n  readonly #listeners = ofSimpleMutable<Listener<Events>>();\n  #disposed = false;\n\n  dispose() {\n    if (this.#disposed) return;\n    this.clearEventListeners();\n  }\n\n  get isDisposed() {\n    return this.#disposed;\n  }\n\n  /**\n   * Fire event\n   * @param type Type of event\n   * @param args Arguments for event\n   * @returns\n   */\n  protected fireEvent<K extends keyof Events>(type: K, args: Events[ K ]) {\n    if (this.#disposed) throw new Error(`Disposed`);\n    const listeners = this.#listeners.get(type as string);\n    //console.log(`Firing ${type as string}`);\n    for (const l of listeners) {\n      l(args, this);\n    }\n  }\n\n  /**\n   * Adds event listener.\n   * \n   * @throws Error if emitter is disposed\n   * @typeParam K - Events\n   * @param name Event name\n   * @param listener Event handler\n   */\n  addEventListener<K extends keyof Events>(\n    name: K,\n    listener: (event: Events[ K ], sender: SimpleEventEmitter<Events>) => void\n  ): void {\n    if (this.#disposed) throw new Error(`Disposed`);\n    this.#listeners.addKeyedValues(\n      name as string,\n      listener as Listener<Events>\n    );\n  }\n\n  /**\n   * Remove event listener\n   *\n   * @param listener\n   */\n  removeEventListener<K extends keyof Events>(\n    type: K,\n    listener: (event: Events[ K ], sender: SimpleEventEmitter<Events>) => void\n  ) {\n    if (this.#disposed) return;\n\n    // listener: Listener<Events>): void {\n    this.#listeners.deleteKeyValue(\n      type as string,\n      listener as Listener<Events>\n    );\n  }\n\n  /**\n   * Clear all event listeners\n   * @private\n   */\n  clearEventListeners() {\n    if (this.#disposed) return;\n    this.#listeners.clear();\n  }\n}\n\n// type TestEventMap = {\n//   readonly change: TestEvent\n//   readonly other: TestEvent2;\n// }\n\n// interface TestEvent2 {\n//   readonly something: string;\n// }\n// interface TestEvent {\n//   readonly blah: boolean;\n// }\n\n// class TestEmitter extends SimpleEventEmitter<TestEventMap> {\n//   constructor() {\n//     super();\n//     this.addEventListener(`change`, (e) => {\n//       e.blah;\n//     });\n//   }\n// }\n\n/*\nexport class Event {\n  public target: any;\n  public type: string;\n  constructor(type: string, target: any) {\n    this.target = target;\n    this.type = type;\n  }\n}\n\nexport class ErrorEvent extends Event {\n  public message: string;\n  public error: Error;\n  constructor(error: Error, target: any) {\n    super('error', target);\n    this.message = error.message;\n    this.error = error;\n  }\n}\n\nexport class CloseEvent extends Event {\n  public code: number;\n  public reason: string;\n  public wasClean = true;\n  constructor(code = 1000, reason = '', target: any) {\n    super('close', target);\n    this.code = code;\n    this.reason = reason;\n  }\n}\nexport interface WebSocketEventMap {\n  close: CloseEvent;\n  error: ErrorEvent;\n  message: MessageEvent;\n  open: Event;\n}\n\nexport interface WebSocketEventListenerMap {\n  close: (event: CloseEvent) => void | {handleEvent: (event: CloseEvent) => void};\n  error: (event: ErrorEvent) => void | {handleEvent: (event: ErrorEvent) => void};\n  message: (event: MessageEvent) => void | {handleEvent: (event: MessageEvent) => void};\n  open: (event: Event) => void | {handleEvent: (event: Event) => void};\n}\n*/\n\nexport { type ISimpleEventEmitter, type Listener } from './ISimpleEventEmitter.js';","/**\n * If values are strings, uses that as the key.\n * Otherwise uses `JSON.stringify`.\n * @param a\n * @returns\n */\nexport const defaultKeyer = <V>(a: V) => {\n  return typeof a === `string` ? a : JSON.stringify(a);\n};","// ✔ UNIT TESTED\n\nimport { type IsEqual, isEqualDefault } from '../../util/IsEqual.js';\nimport type { IMapOf } from './IMapOf.js';\nimport type { IWithEntries } from '../../data/maps/IMappish.js';\n\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', ['a', 'b', 'c']);\n * map.set('there', ['d', 'e', 'f']);\n *\n * const entry = firstEntry(map, (value, key) => {\n *  return (value === 'e');\n * });\n * // Entry is: ['there', ['d', 'e', 'f']]\n * ```\n *\n * An alternative is {@link firstEntryByValue} to search by value.\n * @param map Map to search\n * @param predicate Filter function returns true when there is a match of value\n * @returns Entry, or _undefined_ if `filter` function never returns _true_\n */\nexport const firstEntry = <K, V>(\n  map: IWithEntries<K, Iterable<V>>,\n  predicate: (value: V, key: K) => boolean\n): readonly [ key: K, value: Iterable<V> ] | undefined => {\n  for (const e of map.entries()) {\n    const val = e[ 1 ];\n    for (const subValue of val) {\n      if (predicate(subValue, e[ 0 ])) return e;\n    }\n  }\n};\n\n/**\n * Returns the size of the largest key, or 0 if empty.\n */\nexport const lengthMax = <V>(map: IMapOf<V>): number => {\n  //eslint-disable-next-line functional/no-let\n  let largest: readonly [ string, number ] = [ '', 0 ];\n  for (const e of map.keysAndCounts()) {\n    if (e[ 1 ] > largest[ 1 ]) {\n      largest = e;\n    }\n  }\n  return largest[ 1 ];\n};\n\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', ['a', 'b', 'c']);\n * map.set('there', ['d', 'e', 'f']);\n *\n * const entry = firstEntryByValue(map, 'e');\n * // Entry is: ['there', ['d', 'e', 'f']]\n * ```\n *\n * An alternative is {@link firstEntry} to search by predicate function.\n * @param map Map to search\n * @param value Value to seek\n * @param isEqual Filter function which checks equality. Uses JS comparer by default.\n * @returns Entry, or _undefined_ if `value` not found.\n */\nexport const firstEntryByValue = <K, V>(\n  map: IWithEntries<K, Iterable<V>>,\n  value: V,\n  isEqual: IsEqual<V> = isEqualDefault\n): readonly [ key: K, value: Iterable<V> ] | undefined => {\n  for (const e of map.entries()) {\n    const val = e[ 1 ];\n    for (const subValue of val) {\n      if (isEqual(subValue, value)) return e;\n    }\n  }\n};\n","import { defaultKeyer } from '../../DefaultKeyer.js';\nimport { type IsEqual, isEqualDefault } from '../../util/IsEqual.js';\nimport { firstEntryByValue } from './MapMultiFns.js';\n\nexport class MapOfSimpleBase<V> {\n  protected map: Map<string, ReadonlyArray<V>>;\n  protected readonly groupBy;\n  protected valueEq;\n\n  /**\n   * Constructor\n   * @param groupBy Creates keys for values when using `addValue`. By default uses JSON.stringify\n   * @param valueEq Compare values. By default uses JS logic for equality\n   */\n  constructor(\n    groupBy: (value: V) => string = defaultKeyer,\n    valueEq: IsEqual<V> = isEqualDefault<V>,\n    initial: Array<[ string, ReadonlyArray<V> ]> = []\n  ) {\n    this.groupBy = groupBy;\n    this.valueEq = valueEq;\n    this.map = new Map(initial);\n  }\n\n\n  /**\n   * Iterate over all entries\n   */\n  *entriesFlat(): IterableIterator<[ key: string, value: V ]> {\n    for (const key of this.map.keys()) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      for (const value of this.map.get(key)!) {\n        yield [ key, value ];\n      }\n    }\n  }\n\n  *entries(): IterableIterator<[ key: string, value: Array<V> ]> {\n    for (const [ k, v ] of this.map.entries()) {\n      yield [ k, [ ...v ] ];\n    }\n  }\n\n  firstKeyByValue(value: V, eq: IsEqual<V> = isEqualDefault) {\n    const entry = firstEntryByValue(this, value, eq);\n    if (entry) return entry[ 0 ];\n  }\n\n  /**\n   * Get all values under `key`\n   * @param key\n   * @returns\n   */\n  *get(key: string): IterableIterator<V> {\n    const m = this.map.get(key);\n    if (!m) return;\n    yield* m.values();\n  }\n\n  /**\n   * Iterate over all keys\n   */\n  *keys(): IterableIterator<string> {\n    yield* this.map.keys();\n  }\n\n  /**\n   * Iterate over all values (regardless of key)\n   */\n  *valuesFlat(): IterableIterator<V> {\n    for (const entries of this.map) {\n      yield* entries[ 1 ];\n    }\n  }\n\n  /**\n   * Iterate over keys and length of values stored under keys\n   */\n  *keysAndCounts(): IterableIterator<[ string, number ]> {\n    for (const entries of this.map) {\n      yield [ entries[ 0 ], entries[ 1 ].length ];\n    }\n  }\n\n  /**\n   * Returns _true_ if `key` exists\n   * @param key\n   * @returns\n   */\n  //eslint-disable-next-line functional/prefer-tacit\n  has(key: string): boolean {\n    return this.map.has(key);\n  }\n\n  /**\n   * Returns _true_ if `value` exists under `key`.\n   * @param key Key\n   * @param value Value to seek under `key`\n   * @returns _True_ if `value` exists under `key`.\n   */\n  hasKeyValue(key: string, value: V): boolean {\n    const values = this.map.get(key);\n    if (!values) return false;\n    for (const v of values) {\n      if (this.valueEq(v, value)) return true;\n    }\n    return false;\n  }\n\n  /**\n   * Debug dump of contents\n   * @returns\n   */\n  debugString(): string {\n    // eslint-disable-next-line functional/no-let\n    let r = ``;\n    const keys = [ ...this.map.keys() ];\n    keys.every((k) => {\n      const v = this.map.get(k);\n      if (v === undefined) return;\n      r += k + ` (${ v.length }) = ${ JSON.stringify(v) }\\r\\n`;\n    });\n    return r;\n  }\n\n  /**\n   * _True_ if empty\n   */\n  get isEmpty(): boolean {\n    return this.map.size === 0;\n  }\n\n  /**\n   * Return number of values stored under `key`.\n   * Returns 0 if `key` is not found.\n   * @param key\n   * @returns\n   */\n  count(key: string): number {\n    const values = this.map.get(key);\n    if (!values) return 0;\n    return values.length;\n  }\n\n  get lengthKeys() {\n    return this.map.size;\n  }\n\n}\n","import { defaultKeyer } from '../../DefaultKeyer.js';\nimport { type IsEqual, isEqualDefault } from '../../util/IsEqual.js';\nimport type { IMapOfMutable } from './IMapOfMutable.js';\nimport { MapOfSimpleBase } from './MapOfSimpleBase.js';\n\n/**\n * A simple mutable map of arrays, without events. It can store multiple values\n * under the same key.\n *\n * For a fancier approaches, consider ofArrayMutable, ofCircularMutable or ofSetMutable.\n *\n * @example\n * ```js\n * const m = mapOfSimpleMutable();\n * m.add(`hello`, 1, 2, 3); // Adds numbers under key `hello`\n * m.delete(`hello`);       // Deletes everything under `hello`\n *\n * const hellos = m.get(`hello`); // Get list of items under `hello`\n * ```\n *\n * Constructor takes a `groupBy` parameter, which yields a string key for a value. This is the\n * basis by which values are keyed when using `addValues`.\n *\n * Constructor takes a `valueEq` parameter, which compares values. This is used when checking\n * if a value exists under a key, for example.\n * @typeParam V - Type of items\n */\nexport class MapOfSimpleMutable<V>\n  extends MapOfSimpleBase<V>\n  implements IMapOfMutable<V> {\n  addKeyedValues(key: string, ...values: ReadonlyArray<V>) {\n    const existing = this.map.get(key);\n    if (existing === undefined) {\n      this.map.set(key, values);\n    } else {\n      this.map.set(key, [ ...existing, ...values ]);\n    }\n  }\n\n\n  /**\n   * Adds a value, automatically extracting a key via the\n   * `groupBy` function assigned in the constructor options.\n   * @param values Adds several values\n   */\n  addValue(...values: ReadonlyArray<V>) {\n    for (const v of values) {\n      const key = this.groupBy(v);\n      this.addKeyedValues(key, v);\n    }\n  }\n\n  /**\n   * Delete `value` under a particular `key`\n   * @param key\n   * @param value\n   * @returns _True_ if `value` was found under `key`\n   */\n  deleteKeyValue(key: string, value: V): boolean {\n    const existing = this.map.get(key);\n    if (existing === undefined) return false;\n    const without = existing.filter((existingValue) => !this.valueEq(existingValue, value));\n    this.map.set(key, without);\n    return without.length < existing.length;\n  }\n\n  /**\n   * Deletes `value` regardless of key.\n   *\n   * Uses the constructor-defined equality function.\n   * @param value Value to delete\n   * @returns\n   */\n  deleteByValue(value: V): boolean {\n    //eslint-disable-next-line functional/no-let\n    let del = false;\n    const entries = [ ...this.map.entries() ];\n    for (const keyEntries of entries) {\n      for (const values of keyEntries[ 1 ]) {\n        if (this.valueEq(values, value)) {\n          del = true;\n          this.deleteKeyValue(keyEntries[ 0 ], value);\n        }\n      }\n    }\n    return del;\n  }\n\n  /**\n   * Deletes all values under `key`,\n   * @param key\n   * @returns _True_ if `key` was found and values stored\n   */\n  delete(key: string): boolean {\n    const values = this.map.get(key);\n    if (!values) return false;\n    if (values.length === 0) return false;\n    this.map.delete(key);\n    return true;\n  }\n\n  /**\n   * Clear contents\n   */\n  clear() {\n    this.map.clear();\n  }\n}\n\n/**\n * A simple mutable map of arrays, without events. It can store multiple values\n * under the same key.\n *\n * For a fancier approaches, consider {@link ofArrayMutable}, {@link ofCircularMutable} or {@link ofSetMutable}.\n *\n * @example\n * ```js\n * const m = mapOfSimpleMutable();\n * m.add(`hello`, 1, 2, 3); // Adds numbers under key `hello`\n * m.delete(`hello`);       // Deletes everything under `hello`\n *\n * const hellos = m.get(`hello`); // Get list of items under `hello`\n * ```\n *\n * @typeParam V - Type of items\n * @returns New instance\n */\nexport const ofSimpleMutable = <V>(\n  groupBy: (value: V) => string = defaultKeyer,\n  valueEq: IsEqual<V> = isEqualDefault<V>\n): IMapOfMutable<V> => new MapOfSimpleMutable<V>(groupBy, valueEq);\n","\n\nexport { mutable } from './SetMutable.js';\nexport { immutable } from './SetImmutable.js';\nexport { type ISetMutable } from './ISetMutable.js';\nexport { type ISetImmutable } from './ISetImmutable.js';\nexport * from './MassiveSet.js';\nexport type * from './Types.js';","// ✔ UNIT TESTED\nimport type { ToString } from '../../util/index.js';\nimport { defaultKeyer } from '../../DefaultKeyer.js';\nimport { SimpleEventEmitter } from '../../Events.js';\nimport { type ISetMutable } from './ISetMutable.js';\nimport { type ValueSetEventMap } from './Types.js';\n\n/**\n * Creates a {@link ISetMutable}.\n * @param keyString Function that produces a key based on a value. If unspecified, uses `JSON.stringify`\n * @returns\n */\nexport const mutable = <V>(\n  keyString?: ToString<V> | undefined\n): ISetMutable<V> => new SetStringMutable(keyString);\n\n/**\n * Mutable string set\n */\nexport class SetStringMutable<V>\n  extends SimpleEventEmitter<ValueSetEventMap<V>>\n  implements ISetMutable<V> {\n  // ✔ UNIT TESTED\n  /* eslint-disable functional/prefer-readonly-type */\n  store = new Map<string, V>();\n  keyString: ToString<V>;\n\n  /**\n   * Constructor\n   * @param keyString Function which returns a string version of added items. If unspecified `JSON.stringify`\n   */\n  constructor(keyString: ToString<V> | undefined) {\n    super();\n    this.keyString = keyString ?? defaultKeyer<V>;\n  }\n\n  /**\n   * Number of items stored in set\n   */\n  get size() {\n    return this.store.size;\n  }\n\n  /**\n   * Adds one or more items to set. `add` event is fired for each item\n   * @param values items to add\n   */\n  add(...values: Array<V>): boolean {\n    //eslint-disable-next-line functional/no-let\n    let somethingAdded = false;\n    for (const value of values) {\n      const isUpdated = this.has(value);\n      this.store.set(this.keyString(value), value);\n      super.fireEvent(`add`, { value: value, updated: isUpdated });\n      if (!isUpdated) somethingAdded = true;\n    }\n    return somethingAdded;\n  }\n\n  /**\n   * Returns values from set as an iterable\n   * @returns\n   */\n  //eslint-disable-next-line functional/prefer-tacit\n  values() {\n    return this.store.values();\n  }\n\n  /**\n   * Clear items from set\n   */\n  clear() {\n    this.store.clear();\n    super.fireEvent(`clear`, true);\n  }\n\n  /**\n   * Delete value from set.\n   * @param v Value to delete\n   * @returns _True_ if item was found and removed\n   */\n  delete(v: V): boolean {\n    const isDeleted = this.store.delete(this.keyString(v));\n    if (isDeleted) super.fireEvent(`delete`, v);\n    return isDeleted;\n  }\n\n  /**\n   * Returns _true_ if item exists in set\n   * @param v\n   * @returns\n   */\n  has(v: V): boolean {\n    return this.store.has(this.keyString(v));\n  }\n\n  /**\n   * Returns array copy of set\n   * @returns Array copy of set\n   */\n  toArray(): Array<V> {\n    return [ ...this.store.values() ];\n  }\n}\n","import { defaultKeyer } from '../../DefaultKeyer.js';\nimport { type ToString, toStringDefault } from '../../util/index.js';\nimport { type ISetImmutable } from './ISetImmutable.js';\n\nexport class SetStringImmutable<V> implements ISetImmutable<V> {\n  private store: Map<string, V>;\n  private keyString;\n\n  //eslint-disable-next-line functional/prefer-immutable-types\n  constructor(keyString?: ToString<V>, map?: Map<string, V>) {\n    this.store = map ?? new Map<string, V>();\n    this.keyString = keyString ?? defaultKeyer<V>;\n  }\n\n  get size(): number {\n    return this.store.size;\n  }\n\n  add(...values: ReadonlyArray<V>): ISetImmutable<V> {\n    const s = new Map<string, V>(this.store);\n    for (const v of values) {\n      const key = this.keyString(v);\n      s.set(key, v);\n    }\n    return new SetStringImmutable<V>(this.keyString, s);\n  }\n\n  delete(v: V): ISetImmutable<V> {\n    const s = new Map<string, V>(this.store);\n    const key = this.keyString(v);\n    if (s.delete(key)) return new SetStringImmutable(this.keyString, s);\n    return this;\n  }\n\n  has(v: V): boolean {\n    const key = this.keyString(v);\n    return this.store.has(key);\n  }\n\n  toArray(): Array<V> {\n    return [ ...this.store.values() ];\n  }\n\n  *values() {\n    yield* this.store.values();\n  }\n}\n\n/**\n * Immutable set that uses a `keyString` function to determine uniqueness\n *\n * @param keyString Function that produces a key based on a value. If unspecified, uses `JSON.stringify`.\n * @returns\n */\nexport const immutable = <V>(\n  keyString: ToString<V> = toStringDefault\n): ISetImmutable<V> => new SetStringImmutable(keyString);\n","/**\n * MassiveSet supports semantics similar to Set, but without the\n * limitation on how much data is stored.\n * \n * It only supports strings, and stores data in a hierarchy.\n * \n * ```js\n * const set = new MassiveSet(); // maxDepth=1 default\n * set.add(`test`);\n * set.add(`bloorp`);\n * ```\n * \n * In the above example, it will create a subtree for the first letter\n * of each key, putting the value underneath it. So we'd get a sub\n * MassiveSet for every key starting with 't' and every one starting with 'b'.\n * \n * If `maxDepth` was 2, we'd get the same two top-level nodes, but then\n * another sub-node based on the _second_ character of the value.\n * \n * It's not a very smart data-structure since it does no self-balancing\n * or tuning.\n */\nexport class MassiveSet {\n  #depth\n  #maxDepth;\n  children = new Map<string, MassiveSet>();\n  values: Array<string> = [];\n\n  constructor(maxDepth = 1, depth = 0) {\n    this.#depth = depth;\n    this.#maxDepth = maxDepth;\n  }\n\n  /**\n   * Returns the number of values stored in just this level of the set\n   * @returns \n   */\n  sizeLocal() {\n    return this.values.length;\n  }\n\n  /**\n   * Returns the number of branches at this node\n   * Use {@link sizeChildrenDeep} to count all branches recursively\n   * @returns \n   */\n  sizeChildren() {\n    return [ ...this.children.values() ].length;\n  }\n\n  sizeChildrenDeep() {\n    let t = this.sizeChildren();\n    for (const c of this.children.values()) {\n      t += c.sizeChildrenDeep();\n    }\n    return t;\n  }\n\n  /**\n   * Returns the total number of values stored in the set\n   */\n  size() {\n    let x = this.values.length;\n    for (const set of this.children.values()) {\n      x += set.size();\n    }\n    return x;\n  }\n\n  add(value: string) {\n    if (typeof value !== `string`) throw new Error(`Param 'value' must be a string. Got: ${ typeof value }`);\n\n    if (value.length === 0) throw new Error(`Param 'value' is empty`);\n\n    const destination = this.#getChild(value, true);\n    if (destination === this) {\n      if (!this.hasLocal(value)) {\n        this.values.push(value);\n      }\n      return;\n    }\n\n    if (!destination) throw new Error(`Could not create child set for: ${ value }`);\n    destination.add(value);\n  }\n\n  remove(value: string): boolean {\n    if (typeof value !== `string`) throw new Error(`Param 'value' must be a string. Got: ${ typeof value }`);\n    if (value.length === 0) throw new Error(`Param 'value' is empty`);\n\n    const destination = this.#getChild(value, false);\n    if (destination === undefined) return false;\n    if (destination === this) {\n      if (this.hasLocal(value)) {\n        this.values = this.values.filter(v => v !== value);\n        return true;\n      }\n      return false; // Not found\n    }\n    return destination.remove(value);\n  }\n\n  debugDump() {\n    const r = this.#dumpToArray();\n    for (const rr of r) {\n      console.log(rr);\n    }\n  }\n\n  #dumpToArray(depth = 0) {\n    const r: Array<string> = [];\n    r.push(`Depth: ${ this.#depth } Max: ${ this.#maxDepth }`);\n    for (const [ key, value ] of this.children.entries()) {\n      const dumped = value.#dumpToArray(depth + 1);\n      r.push(` key: ${ key }`);\n      for (const d of dumped) {\n        r.push(` `.repeat(depth + 1) + d);\n      }\n    }\n\n    r.push(`Values: (${ this.values.length })`);\n    for (const v of this.values) {\n      r.push(` ${ v }`);\n    }\n    return r.map(line => ` `.repeat(depth) + line);\n  }\n\n  #getChild(value: string, create: boolean) {\n    if (value === undefined) throw new Error(`Param 'value' undefined`);\n    if (this.#depth === this.#maxDepth) return this;\n    if (value.length <= this.#depth) return this;\n    const k = value[ this.#depth ];\n    if (k === undefined) throw new Error(`Logic error. Depth: ${ this.#depth } Len: ${ value.length }`);\n    let child = this.children.get(k);\n    if (child === undefined && create) {\n      child = new MassiveSet(this.#maxDepth, this.#depth + 1);\n      this.children.set(k, child);\n    }\n    return child;\n  }\n\n  /**\n   * Returns _true_ if `value` stored on this node\n   * @param value \n   * @returns \n   */\n  hasLocal(value: string) {\n    for (const v of this.values) {\n      if (v === value) return true;\n    }\n    return false;\n  }\n\n  has(value: string): boolean {\n    if (typeof value !== `string`) return false;\n\n    const destination = this.#getChild(value, false);\n    if (destination === undefined) return false;\n    if (destination === this) return this.hasLocal(value);\n    return destination.has(value);\n  }\n}","/**\n * Throws an error if `array` parameter is not a valid array\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n * Arrays.guardArray(someVariable);\n * ```\n * @private\n * @param array\n * @param name\n */\nexport const guardArray = <V>(array: ArrayLike<V>, name = `?`) => {\n  if (array === undefined) {\n    throw new TypeError(`Param '${ name }' is undefined. Expected array.`);\n  }\n  if (array === null) {\n    throw new TypeError(`Param '${ name }' is null. Expected array.`);\n  }\n  if (!Array.isArray(array)) {\n    throw new TypeError(`Param '${ name }' not an array as expected`);\n  }\n};\n","import { guardArray } from './GuardArray.js';\n/**\n * Sorts an array of objects in ascending order\n * by the given property name, assuming it is a number.\n *\n * ```js\n * const data = [\n *  { size: 10, colour: `red` },\n *  { size: 20, colour: `blue` },\n *  { size: 5, colour: `pink` }\n * ];\n * const sorted = Arrays.sortByNumericProperty(data, `size`);\n *\n * Yields items ascending order:\n * [ { size: 5, colour: `pink` }, { size: 10, colour: `red` }, { size: 20, colour: `blue` } ]\n * ```\n * @param data\n * @param propertyName\n */\nexport const sortByNumericProperty = <V, K extends keyof V>(\n  data: ReadonlyArray<V> | Array<V>,\n  propertyName: K\n) => [ ...data ].sort((a, b) => {\n  guardArray(data, `data`);\n  const av = a[ propertyName ];\n  const bv = b[ propertyName ];\n  if (av < bv) return -1;\n  if (av > bv) return 1;\n  return 0;\n});\n\nexport const sortByProperty = <V, K extends keyof V>(\n  data: ReadonlyArray<V> | Array<V>,\n  propertyName: K\n) => [ ...data ].sort((a, b) => {\n  guardArray(data, `data`);\n  const av = a[ propertyName ];\n  const bv = b[ propertyName ];\n  if (av < bv) return -1;\n  if (av > bv) return 1;\n  return 0;\n});","/* eslint-disable unicorn/prevent-abbreviations */\nimport { throwNumberTest, throwIntegerTest } from '../util/GuardNumbers.js';\n\n/**\n * Wraps an integer number within a specified range, defaulting to degrees (0-360). Use {@link wrap} for floating-point wrapping.\n *\n * This is useful for calculations involving degree angles and hue, which wrap from 0-360.\n * Eg: to add 200 to 200, we don't want 400, but 40.\n *\n * ```js\n * const v = wrapInteger(200+200, 0, 360); // 40\n * ```\n *\n * Or if we minus 100 from 10, we don't want -90 but 270\n * ```js\n * const v = wrapInteger(10-100, 0, 360); // 270\n * ```\n *\n * `wrapInteger` uses 0-360 as a default range, so both of these\n * examples could just as well be:\n *\n * ```js\n * wrapInteger(200+200);  // 40\n * wrapInteger(10-100);  // 270\n * ```\n *\n * Non-zero starting points can be used. A range of 20-70:\n * ```js\n * const v = wrapInteger(-20, 20, 70); // 50\n * ```\n *\n * Note that the minimum value is inclusive, while the maximum is _exclusive_.\n * So with the default range of 0-360, 360 is never reached:\n *\n * ```js\n * wrapInteger(360); // 0\n * wrapInteger(361); // 1\n * ```\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * @param v Value to wrap\n * @param min Integer minimum of range (default: 0). Inclusive\n * @param max Integer maximum of range (default: 360). Exlusive\n * @returns\n */\nexport const wrapInteger = (v: number, min = 0, max = 360) => {\n  throwIntegerTest(v, undefined, `v`);\n  throwIntegerTest(min, undefined, `min`);\n  throwIntegerTest(max, undefined, `max`);\n\n  if (v === min) return min;\n  if (v === max) return min; // Wraps\n  if (v > 0 && v < min) v += min;\n\n  v -= min;\n  max -= min;\n  v = v % max;\n\n  if (v < 0) v = max - Math.abs(v) + min;\n  return v + min;\n};\n\n/**\n * Wraps floating point numbers to be within a range (default: 0..1). Use {@link wrapInteger} if you want to wrap integer values.\n *\n * This logic makes sense for some things like rotation angle.\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * ```js\n * wrap(1.2);   // 0.2\n * wrap(2);     // 1.0\n * wrap(-0.2); // 0.8\n * ```\n *\n * A range can be provided too:\n * ```js\n * wrap(30, 20, 50);  \t // 30\n * wrap(60, 20, 50);    //  30\n * ```\n * @param v\n * @param min\n * @param max\n * @returns\n */\nexport const wrap = (v: number, min = 0, max = 1) => {\n  throwNumberTest(v, ``, `min`);\n  throwNumberTest(min, ``, `min`);\n  throwNumberTest(max, ``, `max`);\n\n  if (v === min) return min;\n  if (v === max) return min; // Wraps\n\n  while (v <= min || v >= max) {\n    if (v === max) break;\n    if (v === min) break;\n    if (v > max) {\n      v = min + (v - max);\n    } else if (v < min) {\n      v = max - (min - v);\n    }\n  }\n  return v;\n};\n\n/**\n * Performs a calculation within a wrapping number range. This is a lower-level function.\n * See also: {@link wrapInteger} for simple wrapping within a range.\n *\n * `min` and `max` define the start and end of the valid range, inclusive. Eg for hue degrees it'd be 0, 360.\n * `a` and `b` is the range you want to work in.\n *\n * For example, let's say you want to get the middle point between a hue of 30 and a hue of 330 (ie warmer colours):\n * ```js\n * wrapRange(0,360, (distance) => {\n *  // for a:0 and b:330, distance would be 90 from 30 degrees to 330 (via zero)\n *  return distance * 0.5; // eg return middle point\n * }, 30, 330);\n * ```\n *\n * The return value of the callback should be in the range of 0-distance. `wrapRange` will subsequently\n * conform it to the `min` and `max` range before it's returned to the caller.\n *\n * @param a Output start (eg. 60)\n * @param b Output end (eg 300)\n * @param min Range start (eg 0)\n * @param max Range end (eg 360)\n * @param fn Returns a computed value from 0 to `distance`.\n * @returns\n */\nexport const wrapRange = (\n  min: number,\n  max: number,\n  fn: (distance: number) => number,\n  a: number,\n  b: number\n) => {\n  //eslint-disable-next-line functional/no-let\n  let r = 0;\n  const distF = Math.abs(b - a);\n  // When b is wrapped forwards\n  const distFwrap = Math.abs(max - a + b);\n  // When b is wrapped backwards (10, 300)\n  const distBWrap = Math.abs(a + (360 - b));\n\n  const distMin = Math.min(distF, distFwrap, distBWrap);\n  if (distMin === distBWrap) {\n    // (10, 300) = 70\n    r = a - fn(distMin);\n  } else if (distMin === distFwrap) {\n    // (300, 60) = 120\n    r = a + fn(distMin);\n  } else {\n    // Forwards or backwards without wrapping\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (a > b) {\n      // (240,120) -- backwards\n      r = a - fn(distMin);\n    } else {\n      // (120,240) -- forwards\n      r = a + fn(distMin);\n    }\n  }\n  return wrapInteger(r, min, max);\n};\n","/**\n * Clamps a value between min and max (both inclusive)\n * Defaults to a 0-1 range, useful for percentages.\n *\n * @example Usage\n * ```js\n * // 0.5 - just fine, within default of 0 to 1\n * clamp(0.5);\n * // 1 - above default max of 1\n * clamp(1.5);\n * // 0 - below range\n * clamp(-50, 0, 100);\n * // 50 - within range\n * clamp(50, 0, 50);\n * ```\n *\n * For clamping integer ranges, consider {@link clampIndex }\n * For clamping `{ x, y }` points, consider {@link Geometry.Points.clamp | Geometry.Points.clamp}.\n * For clamping bipolar values: {@link Bipolar.clamp}\n * @param value Value to clamp\n * @param min value (inclusive)\n * @param max value (inclusive)\n * @returns Clamped value\n */\nexport const clamp = (value: number, min = 0, max = 1) => {\n  // ✔ UNIT TESTED\n  if (Number.isNaN(value)) throw new Error(`'value' parameter is NaN`);\n  if (Number.isNaN(min)) throw new Error(`'min' parameter is NaN`);\n  if (Number.isNaN(max)) throw new Error(`'max' parameter is NaN`);\n\n  if (value < min) return min;\n  if (value > max) return max;\n  return value;\n};\n\n/**\n * Clamps integer `v` between 0 (inclusive) and array length or length (exclusive).\n * Returns value then will always be at least zero, and a valid array index.\n *\n * @example Usage\n * ```js\n * // Array of length 4\n * const myArray = [`a`, `b`, `c`, `d`];\n * clampIndex(0, myArray);    // 0\n * clampIndex(4, myArray);    // 3\n * clampIndex(-1, myArray);   // 0\n *\n * clampIndex(5, 3); // 2\n * ```\n *\n * Throws an error if `v` is not an integer.\n *\n * For some data it makes sense that data might 'wrap around' if it exceeds the\n * range. For example rotation angle. Consider using {@link wrap} for this.\n *\n * @param v Value to clamp (must be an interger)\n * @param arrayOrLength Array, or length of bounds (must be an integer)\n * @returns Clamped value, minimum will be 0, maximum will be one less than `length`.\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const clampIndex = (\n  v: number,\n  arrayOrLength: number | ReadonlyArray<any>\n): number => {\n  // ✔ UNIT TESTED\n  if (!Number.isInteger(v)) {\n    throw new TypeError(`v parameter must be an integer (${ v })`);\n  }\n  const length = Array.isArray(arrayOrLength)\n    ? arrayOrLength.length\n    : (arrayOrLength as number);\n\n  if (!Number.isInteger(length)) {\n    throw new TypeError(\n      `length parameter must be an integer (${ length }, ${ typeof length })`\n    );\n  }\n  v = Math.round(v);\n  if (v < 0) return 0;\n  if (v >= length) return length - 1;\n  return v;\n};\n","import { clamp } from './Clamp.js';\nimport { throwNumberTest } from '../util/GuardNumbers.js';\n\n/**\n * Scales `v` from an input range to an output range (aka `map`)\n *\n * For example, if a sensor's useful range is 100-500, scale it to a percentage:\n *\n * ```js\n * import { scale } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * scale(sensorReading, 100, 500, 0, 1);\n * ```\n *\n * `scale` defaults to a percentage-range output, so you can get away with:\n * ```js\n * scale(sensorReading, 100, 500);\n * ```\n *\n * If `v` is outside of the input range, it will likewise be outside of the output range.\n * Use {@link scaleClamped} to clip value to range.\n *\n * If inMin and inMax are equal, outMax will be returned.\n *\n * An easing function can be provided for non-linear scaling. In this case\n * the input value is 'pre scaled' using the function before it is applied to the\n * output range.\n *\n * ```js\n * scale(sensorReading, 100, 500, 0, 1, Easings.gaussian());\n * ```\n * @param v Value to scale\n * @param inMin Input minimum\n * @param inMax Input maximum\n * @param outMin Output minimum. If not specified, 0\n * @param outMax Output maximum. If not specified, 1\n * @param easing Easing function\n * @returns Scaled value\n */\nexport const scale = (\n  v: number,\n  inMin: number,\n  inMax: number,\n  outMin?: number,\n  outMax?: number,\n  easing?: (v: number) => number\n): number => scaler(inMin, inMax, outMin, outMax, easing)(v);\n\n/**\n * Returns a scaling function\n * @param inMin Input minimum\n * @param inMax Input maximum\n * @param outMin Output minimum. If not specified, 0\n * @param outMax Output maximum. If not specified, 1\n * @param easing Easing function\n * @returns\n */\nexport const scaler = (\n  inMin: number,\n  inMax: number,\n  outMin?: number,\n  outMax?: number,\n  easing?: (v: number) => number\n): ((v: number) => number) => {\n\n  const oMax = outMax ?? 1;\n  const oMin = outMin ?? 0;\n\n  return (v: number): number => {\n    if (inMin === inMax) return oMax;\n\n    let a = (v - inMin) / (inMax - inMin);\n    if (easing !== undefined) a = easing(a);\n    return a * (oMax - oMin) + oMin;\n  };\n};\n\n/**\n * As {@link scale}, but result is clamped to be\n * within `outMin` and `outMax`.\n *\n * @param v\n * @param inMin\n * @param inMax\n * @param outMin 1 by default\n * @param outMax 0 by default d\n * @param easing\n * @returns\n */\nexport const scaleClamped = (\n  v: number,\n  inMin: number,\n  inMax: number,\n  outMin?: number,\n  outMax?: number,\n  easing?: (v: number) => number\n): number => {\n  if (outMax === undefined) outMax = 1;\n  if (outMin === undefined) outMin = 0;\n  if (inMin === inMax) return outMax;\n\n  const x = scale(v, inMin, inMax, outMin, outMax, easing);\n  return clamp(x, outMin, outMax);\n};\n\n/**\n * Scales an input percentage to a new percentage range.\n *\n * If you have an input percentage (0-1), `scalePercentageOutput` maps it to an\n * _output_ percentage of `outMin`-`outMax`.\n *\n * ```js\n * import { scalePercentages } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Scales 50% to a range of 0-10%\n * scalePercentages(0.5, 0, 0.10); // 0.05 - 5%\n * ```\n *\n * An error is thrown if any parameter is outside of percentage range. This added\n * safety is useful for catching bugs. Otherwise, you could just as well call\n * `scale(percentage, 0, 1, outMin, outMax)`.\n *\n * If you want to scale some input range to percentage output range, just use `scale`:\n * ```js\n * import { scale } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Yields 0.5\n * scale(2.5, 0, 5);\n * ```\n * @param percentage Input value, within percentage range\n * @param outMin Output minimum, between 0-1\n * @param outMax Output maximum, between 0-1\n * @returns Scaled value between outMin-outMax.\n */\nexport const scalePercentages = (\n  percentage: number,\n  outMin: number,\n  outMax = 1\n): number => {\n  throwNumberTest(percentage, `percentage`, `v`);\n  throwNumberTest(outMin, `percentage`, `outMin`);\n  throwNumberTest(outMax, `percentage`, `outMax`);\n  return scale(percentage, 0, 1, outMin, outMax);\n};\n\n/**\n * Scales an input percentage value to an output range\n * If you have an input percentage (0-1), `scalePercent` maps it to an output range of `outMin`-`outMax`.\n * ```js\n * import { scalePercent } from 'https://unpkg.com/ixfx/dist/data.js';\n * scalePercent(0.5, 10, 20); // 15\n * ```\n *\n * @see {@link scalerPercent} Returns a function\n * @param v Value to scale\n * @param outMin Minimum for output\n * @param outMax Maximum for output\n * @returns\n */\nexport const scalePercent = (\n  v: number,\n  outMin: number,\n  outMax: number\n): number => scalerPercent(outMin, outMax)(v);\n\n/**\n * Returns a function that scales an input percentage value to an output range\n * @see {@link scalePercent} Calculates value\n * @param outMin\n * @param outMax\n * @returns Function that takes a single argument\n */\nexport const scalerPercent = (outMin: number, outMax: number) => {\n  return (v: number) => {\n    throwNumberTest(v, `percentage`, `v`);\n    return scale(v, 0, 1, outMin, outMax);\n  };\n};\n","/**\n * A random source.\n *\n * Predefined sources: {@link defaultRandom}, {@link gaussianSource}, {@link weightedSource}\n */\nexport type RandomSource = () => number;\n\n\nexport type StringOptions = Readonly<{\n  length: number;\n  source?: RandomSource;\n}>\n\n/**\n * Default random number generator: `Math.random`.\n */\nexport const defaultRandom = Math.random;\n\nexport type RandomOptions = Readonly<{\n  max: number;\n  min?: number;\n  source?: RandomSource;\n}>\n\nexport type GenerateRandomOptions = RandomOptions & Readonly<{\n  /**\n   * If true, number range is looped\n   */\n  loop?: boolean;\n}>;","import { defaultRandom, type StringOptions } from \"./Types.js\";\n\n/**\n * Returns a string of random letters and numbers of a given `length`.\n *\n * ```js\n * string();  // Random string of length 5\n * string(4); // eg. `4afd`\n * ```\n * @param lengthOrOptions Length of random string, or options.\n * @returns Random string\n */\nexport const string = (lengthOrOptions: number | StringOptions = 5) => {\n  const options =\n    typeof lengthOrOptions === `number` ? { length: lengthOrOptions } : lengthOrOptions;\n  const calculate = options.source ?? defaultRandom;\n  return calculate()\n    .toString(36)\n    .slice(2, length + 2);\n};","import { integerTest } from './util/GuardNumbers.js';\nimport { throwFromResult } from './util/GuardThrowFromResult.js';\nexport { string as random } from './random/String.js';\n\n/**\n * Given a long string, abbreviates it with ...\n * ```js\n * abbreviate(`This is something`, 7); // `This is...`\n * ```\n * \n * If `source` is under `maxLength` the original is returned.\n * @param source \n * @param maxLength Maximum length. Defaults to 20\n * @returns \n */\nexport const abbreviate = (source: string, maxLength = 15) => {\n  // ✔️ Unit tested\n  throwFromResult(integerTest(maxLength, `aboveZero`, `maxLength`));\n  if (typeof source !== `string`) throw new Error(`Parameter 'source' is not a string`);\n\n  if (source.length > maxLength && source.length > 3) {\n    if (maxLength > 15) {\n      const chunk = Math.round((maxLength - 2) / 2);\n      return source.slice(0, chunk) + `...` + source.slice(-chunk);\n    }\n    return source.slice(0, maxLength) + `...`;\n  }\n  return source;\n}\n\n/**\n * Uses JSON.toString() on `source`, but abbreviates result.\n * @param source Object to stringify\n * @param maxLength Default 20\n * @returns \n */\nexport const toStringAbbreviate = (source: any, maxLength = 20) => {\n  if (source === undefined) return `(undefined)`;\n  if (source === null) return `(null)`;\n  return abbreviate(JSON.stringify(source), maxLength);\n}\n\n/**\n * Returns source text that is between `start` and `end` match strings. Returns _undefined_ if start/end is not found.\n *\n * ```js\n * // Yields ` orange `;\n * between(`apple orange melon`, `apple`, `melon`);\n * ```\n * @param source Source text\n * @param start Start match\n * @param end If undefined, the `start` string will be looked for\n * @param lastEndMatch If true, looks for the last match of `end` (default). If false, looks for the first match.\n * @returns\n */\nexport const between = (\n  source: string,\n  start: string,\n  end?: string,\n  lastEndMatch = true\n): string | undefined => {\n  // ✔ Unit tested\n\n  const startPos = source.indexOf(start);\n  if (startPos < 0) return;\n\n  if (end === undefined) end = start;\n\n  const endPos = lastEndMatch\n    ? source.lastIndexOf(end)\n    : source.indexOf(end, startPos + 1);\n  if (endPos < 0) return;\n\n  return source.slice(startPos + 1, endPos);\n};\n\n/**\n * Like {@link between}, but also returns the source string without the start/end match and what's between.\n * ```js\n * const [src,between] = betweenChomp('hello [there] friend', '[', ']');\n * // src: 'hello  friend'\n * // between: 'there'\n * ```\n * @param source\n * @param start\n * @param end\n * @param lastEndMatch\n * @returns\n */\nexport const betweenChomp = (\n  source: string,\n  start: string,\n  end?: string,\n  lastEndMatch = true\n): [ source: string, between: string | undefined ] => {\n  // ✔ Unit tested\n  if (typeof source !== `string`) throw new Error(`Parameter 'source' is not a string`);\n  if (typeof start !== `string`) throw new Error(`Parameter 'start' is not a string`);\n  if (end !== undefined && typeof end !== `string`) throw new Error(`Parameter 'end' is not a string`);\n  const startPos = source.indexOf(start);\n  if (startPos < 0) return [ source, undefined ];\n\n  if (end === undefined) end = start;\n\n  const endPos = lastEndMatch\n    ? source.lastIndexOf(end)\n    : source.indexOf(end, startPos + 1);\n  if (endPos < 0) return [ source, undefined ];\n\n  const between = source.slice(startPos + 1, endPos);\n  const sourceResult = source.slice(0, startPos) + source.slice(endPos + 1);\n  return [ sourceResult, between ];\n};\n/**\n * Returns first position of the given character code, or -1 if not found.\n * @param source Source string\n * @param code Code to seek\n * @param start Start index, 0 by default\n * @param end End index (inclusive), source.length-1 by default\n * @returns Found position, or -1 if not found\n */\nexport const indexOfCharCode = (\n  source: string,\n  code: number,\n  start = 0,\n  end = source.length - 1\n): number => {\n  //eslint-disable-next-line functional/no-let\n  for (let index = start; index <= end; index++) {\n    if (source.codePointAt(index) === code) return index;\n  }\n  return -1;\n};\n\n/**\n * Returns `source` with a given number of characters removed from start position.\n *\n * ```js\n * // Remove three characters starting at position 1\n * omitChars(`hello there`, 1, 3); // ie. removes 'ell'\n * // Yields: `ho there`\n * ```\n * @param source\n * @param removeStart Start point to remove\n * @param removeLength Number of characters to remove\n * @returns\n */\nexport const omitChars = (\n  source: string,\n  removeStart: number,\n  removeLength: number\n) =>\n  source.slice(0, removeStart) +\n  source.slice(removeStart + removeLength);\n\n/**\n * Splits a string into `length`-size chunks.\n *\n * If `length` is greater than the length of `source`, a single element array is returned with source.\n * The final array element may be smaller if we ran out of characters.\n *\n * ```js\n * splitByLength(`hello there`, 2);\n * // Yields:\n * // [`he`, `ll`, `o `, `th`, `er`, `e`]\n * ```\n * @param source Source string\n * @param length Length of each chunk\n * @returns\n */\nexport const splitByLength = (\n  source: string | null,\n  length: number\n): ReadonlyArray<string> => {\n  throwFromResult(integerTest(length, `aboveZero`, `length`));\n  if (source === null) throw new Error(`source parameter null`);\n  if (typeof source !== `string`) {\n    throw new TypeError(`source parameter not a string`);\n  }\n\n  // ✔ Unit tested\n  const chunks = Math.ceil(source.length / length);\n  const returnValue: Array<string> = [];\n  //eslint-disable-next-line functional/no-let\n  let start = 0;\n\n  //eslint-disable-next-line functional/no-let\n  for (let c = 0; c < chunks; c++) {\n    //eslint-disable-next-line functional/immutable-data\n    returnValue.push(source.slice(start, start + length));\n    start += length;\n  }\n  return returnValue;\n};\n\n\n\n/**\n * Returns the `source` string up until (and excluding) `match`. \n * \n * By default, if match is not found, all of `source` is returned.\n *\n * ```js\n * // Yields `apple `\n * untilMarch(`apple orange melon`, `orange`);\n * ```\n * \n * If match is not found, fallback can be returned instead:\n * ```js\n * // Yields 'lemon'\n * untilMatch(`apple orange mellon`, `kiwi`, { fallback: `lemon` });\n * ```\n * \n * Or an exception thrown\n * ```js\n * // Throws\n * untilMatch(`apple orange mellon`, `kiwi`, { ifNoMatch: `throw` });\n * ```\n * @param source\n * @param match\n * @param startPos If provided, gives the starting offset. Default 0\n */\n// export const untilMatch = (\n//   source: string,\n//   match: string,\n//   options: Partial<UntilMatchOptions> = {}\n// ): string => {\n//   //  ✔️ Unit tested\n//   let fallback = options.fallback;\n//   const ifNoMatch = options.ifNoMatch ?? (fallback ? `fallback` : `original`);\n//   if (ifNoMatch === `original`) fallback = source;\n//   if (ifNoMatch === `fallback` && fallback === undefined) throw new Error(`Fallback must be provided`);\n//   const startPos = options.startPos ?? undefined;\n//   const fromEnd = options.fromEnd ?? false;\n//   const m = fromEnd\n//     ? source.lastIndexOf(match, startPos)\n//     : source.indexOf(match, startPos);\n\n//   if (m < 0) {\n//     if (ifNoMatch === `throw`) throw new Error(`Match string not found in source`);\n//     // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n//     return fallback!;\n//   }\n//   return source.slice(startPos ?? 0, m);\n// };\n\n\n// export type UntilMatchOptions = MatchOptions & {\n//   ifNoMatch: `throw` | `original` | `fallback`,\n//   fallback?: string\n// }\n\nexport type MatchOptions = {\n  startPos: number;\n  fromEnd: boolean;\n  ifNoMatch: `throw` | `original` | `fallback`,\n  fallback: string\n}\n\n// export const afterMatch = (\n//   source: string,\n//   match: string,\n//   options: MatchOptions = {}\n// ): string => {\n//   if (source === undefined) throw new Error(`Param 'source' is undefined`);\n\n//   //  ✔️ Unit tested\n//   const startPos = options.startPos ?? undefined;\n//   const fromEnd = options.fromEnd ?? false;\n\n//   const m = fromEnd\n//     ? source.lastIndexOf(match, startPos)\n//     : source.indexOf(match, startPos);\n\n//   if (m < 0) return source;\n//   return source.slice(Math.max(0, m + match.length));\n// };\n\n/**\n * Returns all the text in `source` that precedes (and does not include) `match`. If not found, `source` is returned.\n * \n * See also: {@link beforeMatch}, {@link beforeAfterMatch}.\n * \n * ```js\n * afterMatch(`Hello. There`, `.`); // ' There'\n * afterMatch(`Hello, there', `,`); // 'Hello, there'\n * ```\n * \n * If `source` is _undefined_, an error is thrown.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const beforeMatch = (\n  source: string,\n  match: string,\n  options: Partial<MatchOptions> = {}\n): string => {\n  const ba = beforeAfterMatch(source, match, options);\n  return ba[ 0 ];\n}\n\n/**\n * Returns all the text in `source` that follows `match`. If not found, `source` is returned.\n * \n * See also: {@link beforeMatch}, {@link beforeAfterMatch}.\n * \n * ```js\n * afterMatch(`Hello. There`, `.`); // ' There'\n * afterMatch(`Hello, there', `,`); // 'Hello, there'\n * ```\n * \n * If `source` is _undefined_, an error is thrown.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const afterMatch = (\n  source: string,\n  match: string,\n  options: Partial<MatchOptions> = {}\n): string => {\n  const ba = beforeAfterMatch(source, match, options);\n  return ba[ 1 ];\n}\n\n/**\n * Returns the text that is before and after `match`.\n * \n * See also: {@link beforeMatch}, {@link afterMatch}.\n * \n * If `match` is at the end of start of `source`, after or before might be an empty string.\n * @param source \n * @param match \n * @param options \n * @returns \n */\nexport const beforeAfterMatch = (source: string, match: string, options: Partial<MatchOptions> = {}): [ before: string, after: string ] => {\n  if (source === undefined) throw new Error(`Param 'source' is undefined`);\n\n  let fallback = options.fallback;\n  const ifNoMatch = options.ifNoMatch ?? (fallback ? `fallback` : `original`);\n  if (ifNoMatch === `original`) fallback = source;\n  if (ifNoMatch === `fallback` && fallback === undefined) throw new Error(`Fallback must be provided`);\n\n  const startPos = options.startPos ?? undefined;\n  const fromEnd = options.fromEnd ?? false;\n\n  const m = fromEnd\n    ? source.lastIndexOf(match, startPos)\n    : source.indexOf(match, startPos);\n\n  if (m < 0 && ifNoMatch === `throw`) throw new Error(`Match '${ match }' not found in source.`);\n  if (m < 0 && ifNoMatch === `original`) return [ source, source ];\n  if (m < 0 && ifNoMatch === `fallback`) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return [ fallback!, fallback! ];\n  }\n  return [\n    source.slice(0, m),\n    source.slice(Math.max(0, m + match.length))\n  ]\n}\n/**\n * 'Unwraps' a string, removing one or more 'wrapper' strings that it starts and ends with.\n * Only removes when a matching end is found.\n * ```js\n * unwrap(\"'hello'\", \"'\");        // hello\n * // No mataching end 'a', so nothing happens\n * unwrap(\"apple\", \"a\");          // apple\n * unwrap(\"wow\", \"w\");            // o\n * unwrap(`\"'blah'\"`, '\"', \"'\");  // blah\n * ```\n * @param source\n * @param wrappers\n * @returns\n */\nexport const unwrap = (\n  source: string,\n  ...wrappers: ReadonlyArray<string>\n): string => {\n  //eslint-disable-next-line functional/no-let\n  let matched = false;\n  do {\n    matched = false;\n    for (const w of wrappers) {\n      if (source.startsWith(w) && source.endsWith(w)) {\n        source = source.slice(w.length, source.length - w.length * 2 + 1);\n        matched = true;\n      }\n    }\n  } while (matched);\n\n  return source;\n};\n\n/**\n * A range\n */\nexport type Range = {\n  /**\n   * Text of range\n   */\n  readonly text: string;\n  /**\n   * Start position, with respect to source text\n   */\n  readonly start: number;\n  /**\n   * End position, with respect to source text\n   */\n  readonly end: number;\n  /**\n   * Index of range. First range is 0\n   */\n  readonly index: number;\n}\n\nexport type LineSpan = {\n  readonly start: number;\n  readonly end: number;\n  readonly length: number;\n}\n\n/**\n * Calculates the span, defined in {@link Range} indexes, that includes `start` through to `end` character positions.\n *\n * After using {@link splitRanges} to split text, `lineSpan` is used to associate some text coordinates with ranges.\n *\n * @param ranges Ranges\n * @param start Start character position, in source text reference\n * @param end End character position, in source text reference\n * @returns Span\n */\nexport const lineSpan = (\n  ranges: ReadonlyArray<Range>,\n  start: number,\n  end: number\n): LineSpan => {\n  //eslint-disable-next-line functional/no-let\n  let s = -1;\n  //eslint-disable-next-line functional/no-let\n  let endPos = -1;\n  //eslint-disable-next-line functional/no-let\n  for (const [ index, r ] of ranges.entries()) {\n    s = index;\n    if (r.text.length === 0) continue;\n    if (start < r.end) {\n      break;\n    }\n  }\n\n  //eslint-disable-next-line functional/no-let\n  for (let index = s; index < ranges.length; index++) {\n    const r = ranges[ index ];\n    endPos = index;\n    if (end === r.end) {\n      endPos = index + 1;\n      break;\n    }\n    if (end < r.end) {\n      break;\n    }\n  }\n  return { length: endPos - s, start: s, end: endPos };\n};\n\n/**\n * Splits a source string into ranges:\n * ```js\n * const ranges = splitRanges(\"hello;there;fella\", \";\");\n * ```\n *\n * Each range consists of:\n * ```js\n * {\n *  text: string  - the text of range\n *  start: number - start pos of range, wrt to source\n *  end: number   - end pos of range, wrt to source\n *  index: number - index of range (starting at 0)\n * }\n * ```\n * @param source\n * @param split\n * @returns\n */\nexport const splitRanges = (\n  source: string,\n  split: string\n): ReadonlyArray<Range> => {\n  //eslint-disable-next-line functional/no-let\n  let start = 0;\n  //eslint-disable-next-line functional/no-let\n  let text = ``;\n  const ranges: Array<Range> = [];\n  //eslint-disable-next-line functional/no-let\n  let index = 0;\n  //eslint-disable-next-line functional/no-let,unicorn/prevent-abbreviations\n  for (let i = 0; i < source.length; i++) {\n    if (source.indexOf(split, i) === i) {\n      //eslint-disable-next-line functional/no-let\n      const end = i;\n      //eslint-disable-next-line functional/immutable-data\n      ranges.push({\n        text,\n        start,\n        end,\n        index,\n      });\n      start = end + 1;\n      text = ``;\n      index++;\n    } else {\n      text += source.charAt(i);\n    }\n  }\n  if (start < source.length) {\n    //eslint-disable-next-line functional/immutable-data\n    ranges.push({ text, start, index, end: source.length });\n  }\n  return ranges;\n};\n\n/**\n * Counts the number of times one of `chars` appears at the front of\n * a string, contiguously.\n *\n * ```js\n * countCharsFromStart(`  hi`, ` `); // 2\n * countCharsFromStart(`hi  `, ` `); // 0\n * countCharsFromStart(`  hi  `, ` `); // 2\n * ```\n * @param source\n * @param chars\n * @returns\n */\nexport const countCharsFromStart = (\n  source: string,\n  ...chars: ReadonlyArray<string>\n): number => {\n  //eslint-disable-next-line functional/no-let\n  let counted = 0;\n  //eslint-disable-next-line functional/no-let\n  for (let index = 0; index < source.length; index++) {\n    if (chars.includes(source.charAt(index))) {\n      counted++;\n    } else {\n      break;\n    }\n  }\n  return counted;\n};\n\n/**\n * Returns _true_ if `source` starts and ends with `start` and `end`. Case-sensitive.\n * If _end_ is omitted, the the `start` value will be used.\n *\n * ```js\n * startsEnds(`This is a string`, `This`, `string`); // True\n * startsEnds(`This is a string`, `is`, `a`); // False\n * starsEnds(`test`, `t`); // True, starts and ends with 't'\n * ```\n * @param source String to search within\n * @param start Start\n * @param end End (if omitted, start will be looked for at end as well)\n * @returns True if source starts and ends with provided values.\n */\nexport const startsEnds = (\n  source: string,\n  start: string,\n  end: string = start\n): boolean => source.startsWith(start) && source.endsWith(end);\n\n//eslint-disable-next-line no-useless-escape\nexport const htmlEntities = (source: string): string =>\n  source.replaceAll(/[&<>\\u00A0-\\u9999]/g, (index) => `&#${ index.codePointAt(0) };`);\n\n\n/**\n * Simple wilcard matching. Use '*' in `pattern` to denote any number of characters.\n * ```js\n * // Must start with 'cat'\n * wildcard(`cat*`,`caterpillar`); // true\n * // Must end with 'cat'\n * wildcat(`*cat`, `bobcat`);  // true\n * // 'cat' anywhere in string\n * wildcard(`*cat*`, `see cat run`); // true\n * ```\n * @param pattern \n * @returns \n */\nexport const wildcard = (pattern: string) => {\n  // Based on source: https://stackoverflow.com/questions/26246601/wildcard-string-comparison-in-javascript\n  // for this solution to work on any string, no matter what characters it has\n  const escapeRegex = (value: string) => value.replaceAll(/([!$()*+./:=?[\\\\\\]^{|}])/g, `\\\\$1`);\n\n  // \".\"  => Find a single character, except newline or line terminator\n  // \".*\" => Matches any string that contains zero or more characters\n  pattern = pattern.split(`*`).map(m => escapeRegex(m)).join(`.*`);\n\n  // \"^\"  => Matches any string with the following at the beginning of it\n  // \"$\"  => Matches any string with that in front at the end of it\n  pattern = `^` + pattern + `$`\n\n  // Create a regular expression object for matching string\n  const regex = new RegExp(pattern);\n\n  return (value: string) => {\n    // Returns true if it finds a match, otherwse it returns false\n    return regex.test(value);\n  }\n}","export function* slice<V>(\n  it: Iterable<V>,\n  start = 0,\n  end = Number.POSITIVE_INFINITY\n) {\n  // https://surma.github.io/underdash/\n  const iit = it[ Symbol.iterator ]();\n  if (end < start) throw new Error(`Param 'end' should be more than 'start'`);\n\n  for (; start > 0; start--, end--) iit.next();\n\n  for (const v of it) {\n    if (end-- > 0) {\n      yield v;\n    } else {\n      break;\n    }\n  }\n}","import { throwIntegerTest } from \"../../util/GuardNumbers.js\";\nimport { guardArray } from \"./GuardArray.js\";\n/**\n * Throws if `index` is an invalid array index for `array`, and if\n * `array` itself is not a valid array.\n * @param array\n * @param index\n */\nexport const guardIndex = <V>(\n  array: ArrayLike<V>,\n  index: number,\n  name = `index`\n) => {\n  guardArray(array);\n  throwIntegerTest(index, `positive`, name);\n  if (index > array.length - 1) {\n    throw new Error(\n      `'${ name }' ${ index } beyond array max of ${ array.length - 1 }`\n    );\n  }\n};","import { isEqualDefault, type IsEqual } from \"../../util/IsEqual.js\";\nimport { guardArray } from \"./GuardArray.js\";\nimport { guardIndex } from \"./GuardIndex.js\";\n\nexport const withoutUndefined = <V>(data: ReadonlyArray<V> | Array<V>): Array<V> => {\n  return data.filter(v => v !== undefined);\n}\n\n/**\n * Returns two separate arrays of everything that `filter` returns _true_,\n * and everything it returns _false_ on. The in-built Array.filter() in\n * constrast only returns things that `filter` returns _true_ for.\n *\n * ```js\n * const [ matching, nonMatching ] = filterAB(data, v => v.enabled);\n * // `matching` is a list of items from `data` where .enabled is true\n * // `nonMatching` is a list of items from `data` where .enabled is false\n * ```\n * @param data Array of data to filter\n * @param filter Function which returns _true_ to add items to the A list, or _false_ for items to add to the B list\n * @returns Array of two elements. The first is items that match `filter`, the second is items that do not.\n */\nexport const filterAB = <V>(\n  data: ReadonlyArray<V>,\n  filter: (a: V) => boolean\n): [ a: Array<V>, b: Array<V> ] => {\n  const a: Array<V> = [];\n  const b: Array<V> = [];\n  for (const datum of data) {\n    //eslint-disable-next-line functional/immutable-data\n    if (filter(datum)) a.push(datum);\n    //eslint-disable-next-line functional/immutable-data\n    else b.push(datum);\n  }\n  return [ a, b ];\n};\n\n/**\n * Yields elements from `array` that match a given `predicate`, and moreover are between\n * the given `startIndex` (inclusive) and `endIndex` (exclusive).\n *\n * While this can be done with in the in-built `array.filter` function, it will\n * needlessly iterate through the whole array. It also avoids another alternative\n * of slicing the array before using `filter`.\n *\n * ```js\n * import { filterBetween } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Return 'registered' people between and including array indexes 5-10\n * const filtered = [...filterBetween(people, person => person.registered, 5, 10)];\n * ```\n * @param array Array to filter\n * @param predicate Filter function\n * @param startIndex Start index (defaults to 0)\n * @param endIndex End index (by default runs until end)\n */\nexport function* filterBetween<V>(\n  array: ReadonlyArray<V> | Array<V>,\n  predicate: (\n    value: V,\n    index: number,\n    array: ReadonlyArray<V> | Array<V>\n  ) => boolean,\n  startIndex?: number,\n  endIndex?: number\n): Generator<V> {\n  guardArray(array);\n  if (typeof startIndex === `undefined`) startIndex = 0;\n  if (typeof endIndex === `undefined`) endIndex = array.length; //- 1;\n  guardIndex(array, startIndex, `startIndex`);\n  guardIndex(array, endIndex - 1, `endIndex`);\n\n  //const t: Array<V> = [];\n\n  //eslint-disable-next-line functional/no-let\n  for (let index = startIndex; index < endIndex; index++) {\n    //eslint-disable-next-line functional/immutable-data\n    if (predicate(array[ index ], index, array)) yield array[ index ];//t.push(array[ index ]);\n  }\n  //return t;\n};\n\n\n/**\n * Returns an array with value(s) omitted. If value is not found, result will be a copy of input.\n * Value checking is completed via the provided `comparer` function.\n * By default checking whether `a === b`. To compare based on value, use the `isEqualValueDefault` comparer.\n *\n * @example\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const data = [100, 20, 40];\n * const filtered = Arrays.without(data, 20); // [100, 40]\n * ```\n *\n * @example Using value-based comparison\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const data = [{name: `Alice`}, {name:`Sam`}];\n *\n * // This wouldn't work as expected, because the default comparer uses instance,\n * // not value:\n * Arrays.without(data, {name: `Alice`});\n *\n * // So instead we can use a value comparer:\n * Arrays.without(data, {name:`Alice`}, isEqualValueDefault);\n * ```\n *\n * @example Use a function\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const data = [{name: `Alice`}, {name:`Sam`}];\n * Arrays.without(data, {name:`ALICE`}, (a, b) => {\n *  return (a.name.toLowerCase() === b.name.toLowerCase());\n * });\n * ```\n *\n * Consider {@link remove} to remove an item by index.\n *\n * @typeParam V - Type of array items\n * @param sourceArray Source array\n * @param toRemove Value(s) to remove\n * @param comparer Comparison function. If not provided `Util.isEqualDefault` is used, which compares using `===`\n * @return Copy of array without value.\n */\nexport const without = <V>(\n  //eslint-disable-next-line functional/prefer-readonly-type\n  sourceArray: ReadonlyArray<V> | Array<V>,\n  toRemove: V | Array<V>,\n  comparer: IsEqual<V> = isEqualDefault\n): Array<V> => {\n  if (Array.isArray(toRemove)) {\n    const returnArray = []\n    for (const source of sourceArray) {\n      if (!toRemove.some(v => comparer(source, v))) {\n        returnArray.push(source);\n      }\n    }\n    return returnArray;\n  } else {\n    return sourceArray.filter((v) => !comparer(v, toRemove));\n  }\n}","import { slice } from '../iterables/sync/Slice.js';\nimport { filterBetween } from '../data/arrays/Filter.js';\nimport type { MinMaxAvgOpts, MinMaxAvgTotal } from './Types.js';\n\n/**\n * Returns the min, max, avg and total of the array or iterable.\n * Any values that are invalid are silently skipped over.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n *\n * const v = [10, 2, 4.2, 99];\n * const mma = Arrays.minMaxAvg(v);\n * Yields: { min: 2, max: 99, total: 115.2, avg: 28.8 }\n * ```\n *\n * Use {@link Numbers.average}, {@link Numbers.max}, {@link Numbers.min} or {@link Numbers.total} if you only need one of these.\n *\n * A start and end range can be provided if the calculation should be restricted to a part\n * of the input array. By default the whole array is used.\n *\n * It's also possible to use an iterable as input.\n * ```js\n * Arrays.minMaxAvg(count(5,1)); // Averages 1,2,3,4,5\n * ```\n * @param data\n * @param opts Allows restriction of range that is examined\n * @returns `{min, max, avg, total}`\n */\nexport const minMaxAvg = (\n  //eslint-disable-next-line functional/prefer-readonly-type\n  data: ReadonlyArray<number> | Array<number> | Iterable<number>,\n  opts: MinMaxAvgOpts = {}\n): MinMaxAvgTotal => {\n  if (data === undefined) throw new Error(`'data' is undefined`);\n  if (!Array.isArray(data)) {\n    if (`next` in data) {\n      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n      if (opts.startIndex || opts.endIndex) {\n        data = slice(data, opts.startIndex, opts.endIndex);\n      }\n      //eslint-disable-next-line functional/no-let\n      let total = 0;\n      //eslint-disable-next-line functional/no-let\n      let min = Number.MAX_SAFE_INTEGER;\n      //eslint-disable-next-line functional/no-let\n      let max = Number.MIN_SAFE_INTEGER;\n      //eslint-disable-next-line functional/no-let\n      let samples = 0;\n      for (const v of data) {\n        if (typeof v !== `number`) {\n          throw new TypeError(`Generator should yield numbers. Got: ${ typeof v }`);\n        }\n        total += v;\n        samples++;\n        min = Math.min(min, v);\n        max = Math.max(max, v);\n      }\n      return {\n        avg: total / samples,\n        total,\n        max,\n        min,\n      };\n    } else {\n      throw new Error(`'data' parameter is neither array or iterable`);\n    }\n  }\n\n  if (data.length === 0) {\n    return {\n      total: 0,\n      min: 0,\n      max: 0,\n      avg: 0,\n    };\n  }\n  const startIndex = opts.startIndex ?? 0;\n  const endIndex = opts.endIndex ?? data.length;\n\n  const validNumbers = [ ...filterBetween<number>(\n    data,\n    (d) => typeof d === `number` && !Number.isNaN(d),\n    startIndex,\n    endIndex\n  ) ];\n  const total = validNumbers.reduce((accumulator, v) => accumulator + v, 0);\n  return {\n    total: total,\n    max: Math.max(...validNumbers),\n    min: Math.min(...validNumbers),\n    avg: total / validNumbers.length,\n  };\n};\n","import type { GuardResult } from \"./GuardTypes.js\";\n\nexport const isFunction = (object: unknown): object is (...args: Array<any>) => any => object instanceof Function;\n\nexport const functionTest = (value: unknown, parameterName = `?`): GuardResult => {\n  if (value === undefined) return [ false, `Param '${ parameterName }' is undefined. Expected: function.` ];\n  if (value === null) return [ false, `Param '${ parameterName }' is null. Expected: function.` ];\n  if (typeof value !== `function`) return [ false, `Param '${ parameterName }' is type '${ typeof value }'. Expected: function` ];\n  return [ true ];\n}\n\nexport const throwFunctionTest = (value: unknown, parameterName = `?`) => {\n  const [ ok, msg ] = functionTest(value, parameterName);\n  if (ok) return;\n  throw new TypeError(msg);\n}","import type { GuardResult } from \"./GuardTypes.js\";\nimport { throwFromResult } from \"./GuardThrowFromResult.js\";\n\nexport type StringGuardRange = `` | `non-empty`\n\n/**\n * Throws an error if parameter is not an string\n * @param value\n * @param parameterName\n */\nexport const stringTest = (value: unknown, range: StringGuardRange = ``, parameterName = `?`): GuardResult => {\n  if (typeof value !== `string`) return [ false, `Param '${ parameterName } is not type string. Got: ${ typeof value }` ];\n  switch (range) {\n    case `non-empty`:\n      if (value.length === 0) return [ false, `Param '${ parameterName } is empty` ];\n      break;\n  }\n  return [ true ];\n};\n\nexport const throwStringTest = (value: unknown, range: StringGuardRange = ``, parameterName = `?`) => {\n  throwFromResult(stringTest(value, range, parameterName));\n}\n\n","export * from './GuardArrays.js';\nexport * from './GuardEmpty.js';\nexport * from './GuardFunction.js';\nexport * from './GuardNumbers.js';\nexport * from './GuardObject.js';\nexport * from './GuardThrowFromResult.js';\nexport * from './GuardString.js';\n","import type { GuardResult } from \"./GuardTypes.js\";\nimport { throwFromResult } from \"./GuardThrowFromResult.js\";\n\n/**\n * Throws an error if parameter is not an array\n * @param value\n * @param parameterName\n */\nexport const arrayTest = (value: unknown, parameterName = `?`): GuardResult => {\n  if (!Array.isArray(value)) {\n    return [ false, `Parameter '${ parameterName }' is expected to be an array'` ];\n  }\n  return [ true ];\n};\n\nexport const throwArrayTest = (value: unknown, parameterName = `?`) => {\n  throwFromResult(arrayTest(value, parameterName));\n}\n\n/**\n * Returns true if parameter is an array of strings\n * @param value\n * @returns\n */\nexport const isStringArray = (value: unknown): boolean => {\n  if (!Array.isArray(value)) return false;\n  return !value.some((v) => typeof v !== `string`);\n};\n","import type { GuardResult } from \"./GuardTypes.js\";\n/**\n * Throws if `value` is _undefined_ or _null_.\n * @param value\n * @param parameterName\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const nullUndef = (value: any, parameterName = `?`): GuardResult => {\n  if (typeof value === `undefined`) {\n    return [ false, `${ parameterName } param is undefined` ];\n  }\n  if (value === null) return [ false, `${ parameterName } param is null` ];\n  return [ true ];\n};\n\nexport const throwNullUndef = (value: any, parameterName = `?`) => {\n  const r = nullUndef(value, parameterName);\n  if (r[ 0 ]) return;\n  throw new Error(r[ 1 ]);\n}\n\n/** Throws an error if parameter is not defined */\nexport const defined = <T>(argument: T | undefined): argument is T =>\n  argument !== undefined;\n","/**\n * Returns _true_ if `value` is a plain object\n * \n * ```js\n * isPlainObject(`text`); // false\n * isPlainObject(document); // false\n * isPlainObject({ hello: `there` }); // true\n * ```\n * @param value \n * @returns \n */\nexport const isPlainObject = (value: unknown) => {\n  if (typeof value !== `object` || value === null) return false;\n  const prototype = Object.getPrototypeOf(value);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n\n/**\n * Returns _true_ if `value` is primitive value or plain object\n * @param value \n * @returns \n */\nexport const isPlainObjectOrPrimitive = (value: unknown) => {\n  const t = typeof value;\n  if (t === `symbol`) return false;\n  if (t === `function`) return false;\n  if (t === `bigint`) return true;\n  if (t === `number`) return true;\n  if (t === `string`) return true;\n  if (t === `boolean`) return true;\n  return isPlainObject(value);\n}","export const mapKeys = <TKey extends string | number | symbol>(object: Record<any, any>, mapFunction: (key: string) => TKey) => {\n  // @ts-expect-error\n  const destinationObject: Record<TKey, any> = {};\n  for (const entries of Object.entries(object)) {\n    const key = mapFunction(entries[ 0 ]);\n    destinationObject[ key ] = entries[ 1 ];\n  }\n  return destinationObject;\n}","export type * from './ArrayTypes.js';\nexport type * from './GuardTypes.js';\nexport * from './Comparers.js';\nexport * as Guards from './guards.js';\nexport * from './IsEqual.js';\nexport * from './IsEqualTrace.js';\nexport * from './IsInteger.js';\nexport * from './MapKeys.js';\nexport * from './Platform.js';\nexport * from './Results.js';\nexport * from './ToString.js';\nexport * from './KeyValue.js';","import { defaultToString } from \"./ToString.js\";\n\nexport type CompareResult = number; // 0 | 1 | -1;\nexport type Comparer<V> = (a: V, b: V) => CompareResult;\n\n/**\n * Sort numbers in ascending order.\n *\n * ```js\n * [10, 4, 5, 0].sort(numericComparer);\n * // Yields: [0, 4, 5, 10]\n * [10, 4, 5, 0].sort(comparerInverse(numericComparer));\n * // Yields: [ 10, 5, 4, 0]\n * ```\n * @param x\n * @param y\n * @returns\n */\nexport const numericComparer = (x: number, y: number): CompareResult => {\n  // ✔️ Unit tested\n  if (x === y) return 0;\n  if (x > y) return 1;\n  return -1;\n};\n\n/**\n * Default sort comparer, following same sematics as Array.sort.\n * Consider using {@link defaultComparer} to get more logical sorting of numbers.\n *\n * Note: numbers are sorted in alphabetical order, eg:\n * ```js\n * [ 10, 20, 5, 100 ].sort(jsComparer); // same as .sort()\n * // Yields: [10, 100, 20, 5]\n * ```\n * @param x\n * @param y\n * @returns\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const jsComparer = (x: any, y: any): CompareResult => {\n  // ✔️ Unit tested\n\n  // Via https://stackoverflow.com/questions/47334234/how-to-implement-array-prototype-sort-default-compare-function\n  if (x === undefined && y === undefined) return 0;\n  if (x === undefined) return 1;\n  if (y === undefined) return -1;\n\n  const xString = defaultToString(x);\n  const yString = defaultToString(y);\n\n  if (xString < yString) return -1;\n  if (xString > yString) return 1;\n  return 0;\n};\n\n/**\n * Inverts the source comparer.\n * @param comparer\n * @returns\n */\nexport const comparerInverse = <V>(comparer: Comparer<V>): Comparer<V> => {\n  return (x: V, y: V) => {\n    const v = comparer(x, y);\n    return v * -1;\n  };\n};\n\n/**\n * Compares numbers by numeric value, otherwise uses the default\n * logic of string comparison.\n *\n * Is an ascending sort:\n *  b, a, c -> a, b, c\n *  10, 5, 100 -> 5, 10, 100\n * @param x\n * @param y\n * @see {@link comparerInverse} Inverted order\n * @returns\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const defaultComparer = (x: any, y: any): CompareResult => {\n  if (typeof x === `number` && typeof y === `number`) {\n    return numericComparer(x, y);\n  }\n  return jsComparer(x, y);\n};","import { toStringAbbreviate } from \"../Text.js\";\nimport type { IsEqual } from \"./IsEqual.js\";\n\n\n/**\n * Wraps the `eq` function, tracing the input data result\n * ```js\n * // Init trace\n * const traceEq = isEqualTrace(isEqualValueDefault); \n * // Use it in some function that takes IsEqual<T>\n * compare(a, b, eq);\n * ```\n * @param eq \n * @returns \n */\nexport const isEqualTrace = <T>(eq: IsEqual<T>): IsEqual<T> => {\n  return (a, b) => {\n    const result = eq(a, b);\n    console.log(`isEqualTrace eq: ${ result } a: ${ toStringAbbreviate(a) } b: ${ toStringAbbreviate(b) }`);\n    return result;\n  }\n}","/**\n * Returns _true_ if `value` is an integer. Parses string input, but\n * all other data types return _false_.\n * \n * ```js\n * isInteger(1);      // true\n * isInteger(1.1);    // false\n * isInteger(`1`);    // true\n * isInteger(`1.1`);  // false\n * isInteger(true);   // false\n * isInteger(false);  // false\n * ```\n * \n * Returns _false_ for _undefined_, NaN, booleans and infinite numbers.\n * @param value \n * @returns \n */\nexport const isInteger = (value: string | number) => {\n  if (value === undefined) return false;\n  if (typeof value === `string`) {\n    const v = Number.parseInt(value);\n    if (Number.isNaN(v)) return false;\n    if (v.toString() === value.toString()) return true;\n    return false;\n  }\n  if (typeof value === `number`) {\n    if (Number.isNaN(value)) return false;\n    if (!Number.isFinite(value)) return false;\n    if (Math.round(value) === value) return true;\n    return false;\n  }\n  return false;\n}","//eslint-disable-next-line functional/functional-parameters\nexport const runningiOS = () =>\n  [\n    `iPad Simulator`,\n    `iPhone Simulator`,\n    `iPod Simulator`,\n    `iPad`,\n    `iPhone`,\n    `iPod`,\n  ].includes(navigator.platform) ||\n  // iPad on iOS 13 detection\n  (navigator.userAgent.includes(`Mac`) && `ontouchend` in document);","export type Result<T> = {\n  success: boolean\n  value?: T\n  error?: Error | string\n}\n\nexport type ResultOk<T> = {\n  success: true\n  value: T\n}\n\nexport type ResultError = {\n  success: false\n  error: Error | string\n}\n\n/**\n * If `result` is an error, throws it, otherwise ignored.\n * @param result \n * @returns \n */\nexport function throwResult<T>(result: Result<T>): result is ResultOk<T> {\n  if (result.success) return true;\n  if (typeof result.error === `string`) throw new Error(result.error);\n  throw result.error;\n}","\nimport type { KeyValue } from '../PrimitiveTypes.js';\nimport { defaultComparer } from './index.js';\nimport { minMaxAvg as arrayMinMaxAg } from '../numbers/MinMaxAvg.js';\n\n// const byKey = (reverse = false) => pipe(\n//   reverse ? reverseOrd(S.Ord) : S.Ord,\n//   contramap((v: KeyValue) => v[ 0 ])\n// );\n\n// export const byValueString = (reverse = false) => pipe(\n//   reverse ? reverseOrd(S.Ord) : S.Ord,\n//   contramap((v: KeyValue) => v[ 1 ] as string)\n// );\n\n// const byValueNumber = (reverse = false) => pipe(\n//   reverse ? reverseOrd(N.Ord) : N.Ord,\n//   contramap((v: KeyValue) => v[ 1 ] as number)\n// );\n\n// export const sortByKey = (reverse = false) => sort<KeyValue>(byKey(reverse));\n// export const sortByValueString = (reverse = false) => sort<KeyValue>(byValueString(reverse));\n// export const sortByValueNumber = (reverse = false) => sort<KeyValue>(byValueNumber(reverse));\n\n// eslint-disable-next-line functional/prefer-readonly-type,functional/prefer-immutable-types\nexport type KeyValueSorter = (data: Array<KeyValue>) => Array<KeyValue>;\n\nconst sorterByValueIndex = (index: number, reverse = false) => {\n  return (values: Array<KeyValue>) => {\n    const s = values.toSorted((a, b) => {\n      return defaultComparer(a[ index ], b[ index ]);\n    });\n    if (reverse) return s.reverse();\n    return s;\n  }\n}\n\nexport type SortSyles = `value` | `value-reverse` | `key` | `key-reverse`;\nexport const getSorter = (sortStyle: SortSyles): KeyValueSorter => {\n  switch (sortStyle) {\n    case `value`: {\n      return sorterByValueIndex(1, false);\n    }\n    case `value-reverse`: {\n      return sorterByValueIndex(1, true);\n    }\n    case `key`: {\n      return sorterByValueIndex(0, false);\n    }\n    case `key-reverse`: {\n      return sorterByValueIndex(0, true);\n    }\n    default: {\n      throw new Error(`Unknown sorting value '${ (sortStyle as string) }'. Expecting: value, value-reverse, key or key-reverse`);\n    }\n  }\n};\n\n\nexport const minMaxAvg = (entries: ReadonlyArray<KeyValue>, conversionFunction?: (v: KeyValue) => number) => {\n  const converter = conversionFunction ?? ((v: KeyValue) => v[ 1 ] as number);\n  const values = entries.map<number>(entry => converter(entry));\n  return arrayMinMaxAg(values);\n};","import { isEqualDefault, type IsEqual } from '../../util/IsEqual.js';\nimport {\n  toStringDefault,\n  defaultComparer,\n  type ToString,\n} from '../../util/index.js';\nimport type { IWithEntries } from '../../data/maps/IMappish.js';\n\n// ✔ UNIT TESTED!\n/**\n * Gets the closest integer key to `target` in `data`.\n * * Requires map to have numbers as keys, not strings\n * * Math.round is used for rounding `target`.\n *\n * Examples:\n * ```js\n * // Assuming numeric keys 1, 2, 3, 4 exist:\n * getClosestIntegerKey(map, 3);    // 3\n * getClosestIntegerKey(map, 3.1);  // 3\n * getClosestIntegerKey(map, 3.5);  // 4\n * getClosestIntegerKey(map, 3.6);  // 4\n * getClosestIntegerKey(map, 100);  // 4\n * getClosestIntegerKey(map, -100); // 1\n * ```\n * @param data Map\n * @param target Target value\n * @returns\n */\nexport const getClosestIntegerKey = (\n  data: ReadonlyMap<number, any>,\n  target: number\n): number => {\n  target = Math.round(target);\n  if (data.has(target)) {\n    return target;\n  } else {\n    //eslint-disable-next-line functional/no-let\n    let offset = 1;\n    while (offset < 1000) {\n      if (data.has(target - offset)) return target - offset;\n      else if (data.has(target + offset)) return target + offset;\n      offset++;\n    }\n    throw new Error(`Could not find target ${ target }`);\n  }\n};\n\n/**\n * Returns the first value in `data` that matches a key from `keys`.\n * ```js\n * // Iterate, yielding: `a.b.c.d`, `b.c.d`, `c.d`, `d`\n * const keys = Text.segmentsFromEnd(`a.b.c.d`);\n * // Gets first value that matches a key (starting from most precise)\n * const value = getFromKeys(data, keys);\n * ```\n * @param data \n * @param keys \n * @returns \n */\nexport const getFromKeys = <T>(data: ReadonlyMap<string, T>, keys: Iterable<string>): T | undefined => {\n  for (const key of keys) {\n    if (data.has(key)) return data.get(key);\n  }\n}\n\n/**\n * Returns true if map contains `value` under `key`, using `comparer` function. Use {@link hasAnyValue} if you don't care\n * what key value might be under.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n *\n * @example Find key value based on string equality\n * ```js\n * hasKeyValue(map,`hello`, `samantha`, (a, b) => a === b);\n * ```\n * @param map Map to search\n * @param key Key to search\n * @param value Value to search\n * @param comparer Function to determine match\n * @returns True if key is found\n */\nexport const hasKeyValue = <K, V>(\n  map: ReadonlyMap<K, V>,\n  key: K,\n  value: V,\n  comparer: IsEqual<V>\n): boolean => {\n  if (!map.has(key)) return false;\n  const values = [ ...map.values() ];\n  return values.some((v) => comparer(v, value));\n};\n\n/**\n * Deletes all key/values from map where value matches `value`,\n * with optional comparer. Mutates map.\n *\n * ```js\n * import { Maps } from \"https://unpkg.com/ixfx/dist/collections.js\"\n *\n * // Compare fruits based on their colour property\n * const colourComparer = (a, b) => a.colour === b.colour;\n *\n * // Deletes all values where .colour = `red`\n * Maps.deleteByValue(map, { colour: `red` }, colourComparer);\n * ```\n * @param map\n * @param value\n * @param comparer\n */\nexport const deleteByValue = <K, V>(\n  map: ReadonlyMap<K, V>,\n  value: V,\n  comparer: IsEqual<V> = isEqualDefault\n) => {\n  for (const entry of Object.entries(map)) {\n    if (comparer(entry[ 1 ], value)) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      (map as any).delete(entry[ 0 ]);\n    }\n  }\n};\n\n\n\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = firstEntryByPredicate(map, (value, key) => {\n *  return (value === 'b');\n * });\n * // Entry is: ['there', 'b']\n * ```\n *\n * An alternative is {@link firstEntryByValue} to search by value.\n * @param map Map to search\n * @param predicate Filter function returns true when there is a match of value\n * @returns Entry, or _undefined_ if `filter` function never returns _true_\n */\nexport const firstEntryByPredicate = <K, V>(\n  map: IWithEntries<K, V>,\n  predicate: (value: V, key: K) => boolean\n): readonly [ key: K, value: V ] | undefined => {\n  for (const entry of map.entries()) {\n    if (predicate(entry[ 1 ], entry[ 0 ])) return entry;\n  }\n};\n\n/**\n * Finds first entry by value.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = firstEntryByValue(map, 'b');\n * // Entry is: ['there', 'b']\n * ```\n *\n * An alternative is {@link firstEntryByValue} to search by predicate function.\n * @param map Map to search\n * @param value Value to seek\n * @param isEqual Filter function which checks equality. Uses JS comparer by default.\n * @returns Entry, or _undefined_ if `value` not found.\n */\nexport const firstEntryByValue = <K, V>(\n  map: IWithEntries<K, V>,\n  value: V,\n  isEqual: IsEqual<V> = isEqualDefault\n): readonly [ key: K, value: V ] | undefined => {\n  for (const entry of map.entries()) {\n    if (isEqual(entry[ 1 ], value)) return entry;\n  }\n};\n\n\n\n/**\n * Adds items to a map only if their key doesn't already exist\n *\n * Uses provided {@link Util.ToString} function to create keys for items. Item is only added if it doesn't already exist.\n * Thus the older item wins out, versus normal `Map.set` where the newest wins.\n *\n *\n * @example\n * ```js\n * import { Maps } from \"https://unpkg.com/ixfx/dist/collections.js\";\n * const map = new Map();\n * const peopleArray = [ _some people objects..._];\n * Maps.addKeepingExisting(map, p => p.name, ...peopleArray);\n * ```\n * @param set\n * @param hasher\n * @param values\n * @returns\n */\nexport const addKeepingExisting = <V>(\n  set: ReadonlyMap<string, V> | undefined,\n  hasher: ToString<V>,\n  ...values: ReadonlyArray<V>\n) => {\n  const s = set === undefined ? new Map() : new Map(set);\n  for (const v of values) {\n    const hashResult = hasher(v);\n    if (s.has(hashResult)) continue;\n    s.set(hashResult, v);\n  }\n  return s;\n};\n\n/**\n * Returns a array of entries from a map, sorted by value.\n *\n * ```js\n * const m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n *\n * // Compare by name\n * const comparer = (a, b) => defaultComparer(a.name, b.name);\n *\n * // Get sorted values\n * const sorted = Maps.sortByValue(m, comparer);\n * ```\n *\n * `sortByValue` takes a comparison function that should return -1, 0 or 1 to indicate order of `a` to `b`. If not provided, {@link Util.defaultComparer} is used.\n * @param map\n * @param comparer\n * @returns\n */\nexport const sortByValue = <K, V>(\n  map: ReadonlyMap<K, V>,\n  comparer?: (a: V, b: V) => number\n) => {\n  const f = comparer ?? defaultComparer;\n  return [ ...map.entries() ].sort((a, b) => f(a[ 1 ], b[ 1 ]));\n};\n\n/**\n * Returns an array of entries from a map, sorted by a property of the value\n *\n * ```js\n * cosnt m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n * const sorted = Maps.sortByValue(m, `name`);\n * ```\n * @param map Map to sort\n * @param property Property of value\n * @param compareFunction Comparer. If unspecified, uses a default.\n */\nexport const sortByValueProperty = <K, V, Z>(\n  map: ReadonlyMap<K, V>,\n  property: string,\n  compareFunction?: (a: Z, b: Z) => number\n) => {\n  const cfn = typeof compareFunction === `undefined` ? defaultComparer : compareFunction;\n  return [ ...map.entries() ].sort((aE, bE) => {\n    const a = aE[ 1 ];\n    const b = bE[ 1 ];\n    // @ts-expect-error\n    return cfn(a[ property ], b[ property ]);\n  });\n};\n/**\n * Returns _true_ if any key contains `value`, based on the provided `comparer` function. Use {@link hasKeyValue}\n * if you only want to find a value under a certain key.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n * @example Finds value where name is 'samantha', regardless of other properties\n * ```js\n * hasAnyValue(map, {name:`samantha`}, (a, b) => a.name === b.name);\n * ```\n *\n * Works by comparing `value` against all values contained in `map` for equality using the provided `comparer`.\n *\n * @param map Map to search\n * @param value Value to find\n * @param comparer Function that determines matching. Should return true if `a` and `b` are considered equal.\n * @returns True if value is found\n */\nexport const hasAnyValue = <K, V>(\n  map: ReadonlyMap<K, V>,\n  value: V,\n  comparer: IsEqual<V>\n): boolean => {\n  const entries = [ ...map.entries() ];\n  return entries.some((kv) => comparer(kv[ 1 ], value));\n};\n\n/**\n * Returns values where `predicate` returns true.\n *\n * If you just want the first match, use `find`\n *\n * @example All people over thirty\n * ```js\n * // for-of loop\n * for (const v of filter(people, person => person.age > 30)) {\n *\n * }\n * // If you want an array\n * const overThirty = Array.from(filter(people, person => person.age > 30));\n * ```\n * @param map Map\n * @param predicate Filtering predicate\n * @returns Values that match predicate\n */\n//eslint-disable-next-line func-style\nexport function* filter<V>(\n  map: ReadonlyMap<string, V>,\n  predicate: (v: V) => boolean\n) {\n  for (const v of map.values()) {\n    if (predicate(v)) yield v;\n  }\n}\n\n//export const filter = <V>(map:ReadonlyMap<string, V>, predicate:(v:V) => boolean):ReadonlyArray<V> => Array.from(map.values()).filter(predicate);\n\n/**\n * Copies data to an array\n * @param map\n * @returns\n */\nexport const toArray = <V>(map: ReadonlyMap<string, V>): ReadonlyArray<V> =>\n  [ ...map.values() ];\n\n\n/**\n * import { Maps } from 'https://unpkg.com/ixfx/dist/data.js';\n * Returns a Map from an iterable. By default throws an exception\n * if iterable contains duplicate values.\n *\n * ```js\n * const data = [\n *  { fruit: `granny-smith`, family: `apple`, colour: `green` }\n *  { fruit: `mango`, family: `stone-fruit`, colour: `orange` }\n * ];\n * const map = Maps.fromIterable(data, v => v.fruit);\n * ```\n * @param data Input data\n * @param keyFunction Function which returns a string id. By default uses the JSON value of the object.\n * @param allowOverwrites When set to _true_, items with same id will silently overwrite each other, with last write wins. _false_ by default.\n * @returns\n */\nexport const fromIterable = <V>(\n  data: Iterable<V>,\n  keyFunction = toStringDefault<V>,\n  allowOverwrites = false\n): ReadonlyMap<string, V> => {\n  const m = new Map<string, V>();\n  for (const d of data) {\n    const id = keyFunction(d);\n    if (m.has(id) && !allowOverwrites) {\n      throw new Error(\n        `id ${ id } is already used and new data will overwrite it. `\n      );\n    }\n    m.set(id, d);\n  }\n  return m;\n};\n\n/**\n * Returns a Map from an object, or array of objects.\n * Assumes the top-level properties of the object is the key.\n *\n * ```js\n * import { Maps } from 'https://unpkg.com/ixfx/dist/data.js';\n * const data = {\n *  Sally: { name: `Sally`, colour: `red` },\n *  Bob: { name: `Bob`, colour: `pink` }\n * };\n * const map = Maps.fromObject(data);\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To add an object to an existing map, use {@link addObject}.\n * @param data\n * @returns\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any,functional/prefer-readonly-type\nexport const fromObject = <V>(data: any): ReadonlyMap<string, V> => {\n  //eslint-disable-next-line @typescript-eslint/no-explicit-any,functional/prefer-readonly-type\n  const map = new Map<string, V>();\n  if (Array.isArray(data)) {\n    for (const d of data) addObject<V>(map, d);\n  } else {\n    addObject<V>(map, data);\n  }\n  return map;\n};\n\n/**\n * Adds an object to an existing map. It assumes a structure where\n * each top-level property is a key:\n *\n * ```js\n * import { Maps } from 'https://unpkg.com/ixfx/dist/data.js';\n * const data = {\n *  Sally: { colour: `red` },\n *  Bob:   { colour: `pink` }\n * };\n * const map = new Map();\n * Maps.addObject(map, data);\n *\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To create a new map from an object, use {@link fromObject} instead.\n * @param map\n * @param data\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any,functional/prefer-readonly-type\nexport const addObject = <V>(map: Map<string, V>, data: any) => {\n  const entries = Object.entries(data);\n  for (const [ key, value ] of entries) {\n    map.set(key, value as V);\n  }\n};\n/**\n * Returns the first found value that matches `predicate` or _undefined_.\n *\n * Use {@link some} if you don't care about the value, just whether it appears.\n * Use {@link filter} to get all value(s) that match `predicate`.\n *\n * @example First person over thirty\n * ```js\n * const overThirty = find(people, person => person.age > 30);\n * ```\n * @param map Map to search\n * @param predicate Function that returns true for a matching value\n * @returns Found value or _undefined_\n */\nexport const find = <V>(\n  map: ReadonlyMap<string, V>,\n  predicate: (v: V) => boolean\n): V | undefined => [ ...map.values() ].find(v => predicate(v));\n\n/**\n * Returns _true_ if `predicate` yields _true_ for any value in `map`.\n * Use {@link find} if you want the matched value.\n * ```js\n * const map = new Map();\n * map.set(`fruit`, `apple`);\n * map.set(`colour`, `red`);\n * Maps.some(map, v => v === `red`);    // true\n * Maps.some(map, v => v === `orange`); // false\n * ```\n * @param map \n * @param predicate \n * @returns \n */\nexport const some = <V>(map: ReadonlyMap<string, V>, predicate: (v: V) => boolean): boolean => [ ...map.values() ].some(v => predicate(v));\n\n/**\n * Converts a map to a simple object, transforming from type `T` to `K` as it does so. If no transforms are needed, use {@link toObject}.\n *\n * ```js\n * const map = new Map();\n * map.set(`name`, `Alice`);\n * map.set(`pet`, `dog`);\n *\n * const o = mapToObjectTransform(map, v => {\n *  ...v,\n *  registered: true\n * });\n *\n * // Yields: { name: `Alice`, pet: `dog`, registered: true }\n * ```\n *\n * If the goal is to create a new map with transformed values, use {@link transformMap}.\n * @param m\n * @param valueTransform\n * @typeParam T Value type of input map\n * @typeParam K Value type of destination map\n * @returns\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const mapToObjectTransform = <T, K>(\n  m: ReadonlyMap<string, T>,\n  valueTransform: (value: T) => K\n): Readonly<Record<string, K>> =>\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return, unicorn/no-array-reduce\n  [ ...m ].reduce((object: any, [ key, value ]) => {\n    const t = valueTransform(value);\n    /* eslint-disable-next-line functional/immutable-data */\n    object[ key ] = t;\n    return object;\n  }, {});\n\n/**\n * Zips together an array of keys and values into an object. Requires that\n * `keys` and `values` are the same length.\n *\n * @example\n * ```js\n * const o = zipKeyValue([`a`, `b`, `c`], [0, 1, 2])\n * Yields: { a: 0, b: 1, c: 2}\n *```\n * @param keys String keys\n * @param values Values\n * @typeParam V Type of values\n * @return Object with keys and values\n */\nexport const zipKeyValue = <V>(\n  keys: ReadonlyArray<string>,\n  values: ArrayLike<V | undefined>\n) => {\n  if (keys.length !== values.length) {\n    throw new Error(`Keys and values arrays should be same length`);\n  }\n  return Object.fromEntries(keys.map((k, index) => [ k, values[ index ] ]));\n};\n\n//#region Functions by Kees C. Bakker\n// Functions by Kees C. Bakker\n// https://keestalkstech.com/2021/10/having-fun-grouping-arrays-into-maps-with-typescript/\n\n/**\n * Like `Array.map`, but for a Map. Transforms from Map<K,V> to Map<K,R>, returning as a new Map.\n *\n * @example\n * ```js\n * const mapOfStrings = new Map();\n * mapOfStrings.set(`a`, `10`);\n * mapOfStrings.get(`a`); // Yields `10` (a string)\n *\n * // Convert a map of string->string to string->number\n * const mapOfInts = transformMap(mapOfStrings, (value, key) => parseInt(value));\n *\n * mapOfInts.get(`a`); // Yields 10 (a proper number)\n * ```\n *\n * If you want to combine values into a single object, consider instead  {@link mapToObjectTransform}.\n * @param source\n * @param transformer\n * @typeParam K Type of keys (generally a string)\n * @typeParam V Type of input map values\n * @typeParam R Type of output map values\n * @returns\n */\nexport const transformMap = <K, V, R>(\n  source: ReadonlyMap<K, V>,\n  transformer: (value: V, key: K) => R\n) => new Map(Array.from(source, (v) => [ v[ 0 ], transformer(v[ 1 ], v[ 0 ]) ]));\n\n/**\n * Converts a `Map` to a plain object, useful for serializing to JSON.\n * To convert back to a map use {@link fromObject}.\n *\n * @example\n * ```js\n * const map = new Map();\n * map.set(`Sally`, { name: `Sally`, colour: `red` });\n * map.set(`Bob`, { name: `Bob`, colour: `pink });\n *\n * const objects = Maps.toObject(map);\n * // Yields: {\n * //  Sally: { name: `Sally`, colour: `red` },\n * //  Bob: { name: `Bob`, colour: `pink` }\n * // }\n * ```\n * @param m\n * @returns\n */\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nexport const toObject = <T>(\n  m: ReadonlyMap<string, T>\n): Readonly<Record<string, T>> =>\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  [ ...m ].reduce((object: any, [ key, value ]) => {\n    /* eslint-disable-next-line functional/immutable-data */\n    object[ key ] = value;\n    return object;\n  }, {});\n\n/**\n * Converts Map to Array with a provided `transformer` function. Useful for plucking out certain properties\n * from contained values and for creating a new map based on transformed values from an input map.\n *\n * @example Get an array of ages from a map of Person objects\n * ```js\n * let person = { age: 29, name: `John`};\n * map.add(person.name, person);\n *\n * const ages = mapToArray(map, (key, person) => person.age);\n * // [29, ...]\n * ```\n *\n * In the above example, the `transformer` function returns a number, but it could\n * just as well return a transformed version of the input:\n *\n * ```js\n * // Return with random heights and uppercased name\n * mapToArray(map, (key, person) => ({\n *  ...person,\n *  height: Math.random(),\n *  name: person.name.toUpperCase();\n * }))\n * // Yields:\n * // [{height: 0.12, age: 29, name: \"JOHN\"}, ...]\n * ```\n * @param m\n * @param transformer A function that takes a key and item, returning a new item.\n * @returns\n */\nexport const mapToArray = <K, V, R>(\n  m: ReadonlyMap<K, V>,\n  transformer: (key: K, item: V) => R\n): ReadonlyArray<R> => [ ...m.entries() ].map((x) => transformer(x[ 0 ], x[ 1 ]));\n// End Functions by Kees C. Bakker\n//#endregion\n\n/**\n * Returns a result of a merged into b.\n * B is always the 'newer' data that takes\n * precedence.\n */\nexport type MergeReconcile<V> = (a: V, b: V) => V;\n\n/**\n * Merges maps left to right, using the provided\n * `reconcile` function to choose a winner when keys overlap.\n *\n * There's also {@link Data.Arrays.mergeByKey Arrays.mergeByKey} if you don't already have a map.\n *\n * For example, if we have the map A:\n * 1 => `A-1`, 2 => `A-2`, 3 => `A-3`\n *\n * And map B:\n * 2 => `B-1`, 2 => `B-2`, 4 => `B-4`\n *\n * If they are merged with the reconile function:\n * ```js\n * const reconcile = (a, b) => b.replace(`-`, `!`);\n * const output = mergeByKey(reconcile, mapA, mapB);\n * ```\n *\n * The final result will be:\n *\n * 1 => `B!1`, 2 => `B!2`, 3 => `A-3`, 4 => `B-4`\n *\n * In this toy example, it's obvious how the reconciler transforms\n * data where the keys overlap. For the keys that do not overlap -\n * 3 and 4 in this example - they are copied unaltered.\n *\n * A practical use for `mergeByKey` has been in smoothing keypoints\n * from a TensorFlow pose. In this case, we want to smooth new keypoints\n * with older keypoints. But if a keypoint is not present, for it to be\n * passed through.\n *\n * @param reconcile\n * @param maps\n */\nexport const mergeByKey = <K, V>(\n  reconcile: MergeReconcile<V>,\n  ...maps: ReadonlyArray<ReadonlyMap<K, V>>\n): ReadonlyMap<K, V> => {\n  const result = new Map<K, V>();\n  for (const m of maps) {\n    for (const [ mk, mv ] of m) {\n      //eslint-disable-next-line functional/no-let\n      let v = result.get(mk);\n      v = v ? reconcile(v, mv) : mv;\n      result.set(mk, v);\n    }\n  }\n  return result;\n};\n","import { type RandomSource, defaultRandom } from \"./Types.js\";\n\n/**\n* Returns a random number from 0..weightings.length, distributed by the weighting values.\n* \n* eg: produces 0 20% of the time, 1 50% of the time, 2 30% of the time\n* ```js\n* weightedIndex([0.2, 0.5, 0.3]);\n* ```\n* @param weightings \n* @param rand \n* @returns \n*/\nexport const weightedIndex = (weightings: Array<number>, rand: RandomSource = defaultRandom): () => number => {\n  const precompute: Array<number> = [];\n  let total = 0;\n  // eslint-disable-next-line unicorn/no-for-loop\n  for (let index = 0; index < weightings.length; index++) {\n    total += weightings[ index ];\n    precompute[ index ] = total;\n  }\n  if (total !== 1) throw new Error(`Weightings should add up to 1. Got: ${ total }`);\n\n  return (): number => {\n    const v = rand();\n    // eslint-disable-next-line unicorn/no-for-loop\n    for (let index = 0; index < precompute.length; index++) {\n      if (v <= precompute[ index ]) return index;\n    }\n    throw new Error(`Bug: weightedIndex could not select index`);\n  }\n}","import { weightedIndex } from \"../../random/WeightedIndex.js\";\nimport type { RandomSource } from \"../../random/Types.js\";\nimport { guardArray } from \"./GuardArray.js\";\n\n/**\n * Returns a random array index.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const v = [`blue`, `red`, `orange`];\n * Arrays.randomIndex(v); // Yields 0, 1 or 2\n * ```\n *\n * Use {@link randomElement} if you want a value from `array`, not index.\n *\n * @param array Array\n * @param rand Random generator. `Math.random` by default.\n * @returns\n */\nexport const randomIndex = <V>(\n  array: ArrayLike<V>,\n  rand: RandomSource = Math.random\n): number => Math.floor(rand() * array.length);\n\n\n/**\n * Removes a random item from an array, returning both the item and the new array as a result.\n * Does not modify the original array unless `mutate` parameter is true.\n *\n * @example Without changing source\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const data = [100, 20, 40];\n * const {value, array} = Arrays.randomPluck(data);\n * // value: 20, array: [100, 40], data: [100, 20, 40];\n * ```\n *\n * @example Mutating source\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const data = [100, 20, 40];\n * const {value} = Arrays.randomPluck(data, true);\n * // value: 20, data: [100, 40];\n * ```\n *\n * @typeParam V - Type of items in array\n * @param array Array to pluck item from\n * @param mutate If _true_, changes input array. _False_ by default.\n * @param rand Random generatr. `Math.random` by default.\n * @return Returns an object `{value:V|undefined, array:V[]}`\n *\n */\nexport const randomPluck = <V>(\n  array: ReadonlyArray<V> | Array<V>,\n  mutate = false,\n  rand: RandomSource = Math.random\n): { readonly value: V | undefined; readonly array: Array<V> } => {\n  if (array === undefined) throw new Error(`array is undefined`);\n  if (!Array.isArray(array)) throw new Error(`'array' param is not an array`);\n  if (array.length === 0) return { value: undefined, array: [] };\n  const index = randomIndex(array, rand);\n  if (mutate) {\n    return {\n      value: array[ index ],\n      //eslint-disable-next-line functional/immutable-data\n      array: array.splice(index, 1),\n    };\n  } else {\n    // Copy array, remove item from that\n    const t = [ ...array ];\n    //eslint-disable-next-line functional/immutable-data\n    t.splice(index, 1);\n    return {\n      value: array[ index ],\n      array: t,\n    };\n  }\n};\n\n\n/**\n * Returns random element.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const v = [`blue`, `red`, `orange`];\n * Arrays.randomElement(v); // Yields `blue`, `red` or `orange`\n * ```\n *\n * Use {@link randomIndex} if you want a random index within `array`.\n *\n * @param array\n * @param rand Random generator. `Math.random` by default.\n * @returns\n */\nexport const randomElement = <V>(\n  array: ArrayLike<V>,\n  rand: RandomSource = Math.random\n): V => {\n  guardArray(array, `array`);\n  return array[ Math.floor(rand() * array.length) ];\n};\n\n\n/**\n * Selects a random array index, biased by the provided `weightings`.\n * \n * In the below example, `a` will be picked 20% of the time, `b` 50% and so on.\n * ```js\n * const data =    [  `a`,  `b`,  `c`,  `d` ]\n * const weights = [ 0.2,  0.5,  0.1,  0.2 ] \n * ```\n * @param array \n * @param weightings \n * @param randomSource \n */\nexport const randomElementWeightedSource = <V>(array: ArrayLike<V>, weightings: Array<number>, randomSource: RandomSource = Math.random) => {\n  if (array.length !== weightings.length) throw new Error(`Lengths of 'array' and 'weightings' should be the same.`);\n  const r = weightedIndex(weightings, randomSource);\n  return (): V => {\n    const index = r();\n    return array[ index ];\n  }\n}\n\n/**\n * Returns a shuffled copy of the input array.\n * @example\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const d = [1, 2, 3, 4];\n * const s = Arrays.shuffle(d);\n * // d: [1, 2, 3, 4], s: [3, 1, 2, 4]\n * ```\n * @param dataToShuffle\n * @param rand Random generator. `Math.random` by default.\n * @returns Copy with items moved around randomly\n * @typeParam V - Type of array items\n */\nexport const shuffle = <V>(\n  dataToShuffle: ReadonlyArray<V>,\n  rand: RandomSource = Math.random\n): Array<V> => {\n  const array = [ ...dataToShuffle ];\n  // eslint-disable-next-line  functional/no-let\n  for (let index = array.length - 1; index > 0; index--) {\n    const index_ = Math.floor(rand() * (index + 1));\n    [ array[ index ], array[ index_ ] ] = [ array[ index_ ], array[ index ] ];\n  }\n  return array;\n};","export * as Waypoints from './Waypoint.js';\nexport * as Layouts from './Layout.js';\n\nexport * as Circles from './circle/index.js';\nexport * as Lines from './line/index.js';\nexport * as Rects from './rect/index.js';\nexport * as Points from './point/index.js';\nexport * as Paths from './path/index.js';\nexport * as Grids from './Grid.js';\nexport * as Beziers from './bezier/index.js';\nexport * as Compound from './path/CompoundPath.js';\nexport * as Ellipses from './Ellipse.js';\nexport type * from './Types.js';\n\nexport * from './Angles.js';\nexport * as CurveSimplification from './CurveSimplification.js';\n\n/**\n * Quad tree is a datastructure for efficiently determining whether\n * a point/shape is at a location\n * - {@link quadTree}: Create a quad tree\n */\nexport * as QuadTree from './QuadTree.js';\n\nexport * as Scaler from './Scaler.js';\nexport * as Convolve2d from './Convolve2d.js';\n\n/**\n * Work with arcs. Arcs are a angle-limited circle, describing a wedge.\n * \n * {@link ArcPositioned} has a origin x,y.\n * \n * Conversions:\n * - {@link fromDegrees}\n * - {@link toLine}: A line from start/end position of arc\n * - {@link toSvg}: Returns an SVG representation of arc\n * \n * Calculations:\n * - {@link bbox}: Bounding box\n * - {@link interpolate}: Interplate two arcs\n * - {@link point}: Find a point on the arc, given an angle\n * - {@link length}: Circumference of arc\n * \n * Comparisons:\n * - {@link isArc}: Returns true if object is Arc-ish\n * - {@link isEqual}: Returns true if two objects have identical arc properties\n */\nexport * as Arcs from './arc/index.js';\n\n/**\n * Generate a few basic geometric shapes\n * Overview:\n * * {@link arrow}\n * * {@link starburst}\n */\nexport * as Shapes from './shape/index.js';\n\n/**\n * Helper functions for working with vectors, which can either be a {@link Point} or Polar {@link Polar.Coord}.\n * While most of the functionality is provided in either of those modules, the Vector module lets you cleanly\n * interoperate between these two coordinates.\n */\nexport * as Vectors from './Vector.js';\n\n\n/**\n * Work with Polar coordinates.\n * A {@link Polar.Coord} is just `{ angleRadians:number, distance: number }`.\n * \n * Conversion: {@link toCartesian}, {@link fromCartesian}, {@link toString}\n * \n * Math: {@link divide}, {@link invert}, {@link multiply}, {@link dotProduct}\n * \n * Geometric manipulations: {@link rotate}, {@link rotateDegrees}\n * \n * Cleaning: {@link clampMagnitude}, {@link normalise}\n * \n * Debugging: {@link toString}\n * \n * Comparisons: {@link isAntiParallel}, {@link isOpposite}, {@link isParallel}, {@link isPolarCoord}\n */\nexport * as Polar from './Polar.js';\n\n/**\n * Functions for producing points within a shape.\n * Useful for creating patterns.\n * \n * Overview:\n * * {@link sphereFibonacci}: Generate points on a sphere\n * * {@link circleVogelSpiral}: Generate a sunflower-esque pattern of points in a circle \n */\nexport * as SurfacePoints from './SurfacePoints.js';\n\n/**\n * Triangle processing.\n * \n * Helpers for creating:\n * - {@link Triangles.fromFlatArray}: Create from `[ x1, y1, x2, y2, x3, y3 ]`\n * - {@link Triangles.fromPoints}: Create from three `{ x, y }` sets\n * - {@link Triangles.fromRadius}: Equilateral triangle of a given radius and center\n * \n * There are sub-modules for dealing with particular triangles:\n * - {@link Triangles.Equilateral}: Equilateral triangls\n * - {@link Triangles.Right}: Right-angled triangles\n * - {@link Triangles.Isosceles}: Iscosceles triangles\n * \n * Calculations\n * - {@link angles}: Internal angles in radians. {@link anglesDegrees} for degrees. \n * - {@link area}: Area of triangle\n * - {@link bbox}: Bounding box\n * - {@link centroid}: Centroid of triangle\n * - {@link perimeter}: Calculate perimeter\n * - {@link lengths}: Return array lengths of triangle's edges\n * - {@link rotate}, {@link rotateByVertex}\n * \n * Conversions\n * - {@link edges}: Edges of triangle as {@link Line}\n * - {@link corners}: Corner positions\n * - {@link innerCircle}: Largest circle to fit within triangle\n * - {@link outerCircle}: Largest circle to enclose triangle\n * - {@link toFlatArray}\n * \n * Comparisons\n * - {@link intersectsPoint}: Whether a point intersects triangle\n * - {@link isEqual}: Check whether two triangles have equal values\n * - {@link isAcute}, {@link isEquilateral}, {@link isIsosceles}, {@link isRightAngle}\n * - {@link isTriangle}: Returns true if object has expected properties of a triangle\n */\nexport * as Triangles from './triangle/index.js';\n\n// try {\n//   if (typeof window !== `undefined`) {\n//     //eslint-disable-next-line functional/immutable-data,@typescript-eslint/no-explicit-any\n//     (window as any).ixfx = { ...(window as any).ixfx, Geometry: { Circles, Arcs, Lines, Rects, Points, Paths, Grids, Beziers, Compound, Ellipses, Polar, Shapes, radiansFromAxisX, radianToDegree, degreeToRadian } };\n//   }\n// } catch { /* no-op */ }\n","import type { CirclePositioned } from \"./circle/CircleType.js\";\nimport type { Path } from \"./path/PathType.js\";\nimport type { Point } from \"./point/PointType.js\";\nimport { joinPointsToLines } from './line/JoinPointsToLines.js';\nimport { toPath } from './line/ToPath.js';\nimport { distance as PointsDistance } from \"./point/Distance.js\";\nimport { sortByNumericProperty } from \"../data/arrays/Sort.js\";\n\nexport type Waypoint = CirclePositioned;\n\nexport type WaypointOpts = {\n  readonly maxDistanceFromLine: number;\n  readonly enforceOrder: boolean;\n};\n\n/**\n * Create from set of points, connected in order starting at array position 0.\n * @param waypoints \n * @param opts \n * @returns \n */\nexport const fromPoints = (\n  waypoints: ReadonlyArray<Point>,\n  opts: Partial<WaypointOpts> = {}\n) => {\n  const lines = joinPointsToLines(...waypoints);\n  return init(\n    lines.map((l) => toPath(l)),\n    opts\n  );\n};\n\n/**\n * Result \n */\nexport type WaypointResult = {\n  /**\n   * Path being compared against\n   */\n  path: Path\n  /**\n   * Index of this path in original `paths` array\n   */\n  index: number\n  /**\n   * Nearest point on path. See also {@link distance}\n   */\n  nearest: Point\n  /**\n   * Closest distance to path. See also {@link nearest}\n   */\n  distance: number\n  /**\n   * Rank of this result, 0 being highest.\n   */\n  rank: number\n  /**\n   * Relative position on this path segment\n   * 0 being start, 0.5 middle and so on.\n   */\n  positionRelative: number\n}\n\n/**\n * Given point `pt`, returns a list of {@link WaypointResult}, comparing\n * this point to a set of paths.\n * ```js\n * // Init once with a set of paths\n * const w = init(paths);\n * // Now call with a point to get results\n * const results = w({ x: 10, y: 20 });\n * ```\n */\nexport type Waypoints = (pt: Point) => Array<WaypointResult>\n\n/**\n * Initialise\n * \n * Options:\n * * maxDistanceFromLine: Distances greater than this are not matched. Default 0.1\n * @param paths \n * @param opts \n * @returns \n */\nexport const init = (paths: ReadonlyArray<Path>, opts: Partial<WaypointOpts> = {}): Waypoints => {\n  //const enforceOrder = opts.enforceOrder ?? true;\n  const maxDistanceFromLine = opts.maxDistanceFromLine ?? 0.1;\n\n  const checkUnordered = (pt: Point): Array<WaypointResult> => {\n    const results = paths.map((p, index) => {\n      const nearest = p.nearest(pt);\n      const distance = PointsDistance(pt, nearest);\n\n      // Relative position of nearest point on this path segment\n      const positionRelative = p.relativePosition(nearest, maxDistanceFromLine);;\n      return { positionRelative, path: p, index, nearest, distance, rank: Number.MAX_SAFE_INTEGER };\n    });\n\n    const filtered = results.filter((v) => v.distance <= maxDistanceFromLine);\n    const sorted = sortByNumericProperty(filtered, `distance`);\n\n    // Assign ranks\n    // eslint-disable-next-line unicorn/no-for-loop\n    for (let rank = 0; rank < sorted.length; rank++) {\n      sorted[ rank ].rank = rank;\n    }\n    return sorted;\n  };\n\n  // const checkUnordered = (p:Point) => {\n  //   // Calculate progress of pointer between all the waypoint lines\n  //   const progresses = lines.map((line, index) => (\n  //     {\n  //       index,\n  //       score: Points.progressBetween(p, line.a, line.b)\n  //     }));\n  //   // Sort by closest\n  //   const sorted = Arrays.sortByNumericProperty(progresses, `score`);\n  // };\n  return checkUnordered;\n};\n","import type { Point } from \"../point/PointType.js\";\nimport { fromPoints } from \"./FromPoints.js\";\nimport type { PolyLine } from \"./LineType.js\";\n\n/**\n * Returns an array of lines that connects provided points. Note that line is not closed.\n * \n * Eg, if points a,b,c are provided, two lines are provided: a->b and b->c.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const lines = Lines.joinPointsToLines(ptA, ptB, ptC);\n * // lines is an array of, well, lines\n * ```\n * @param points \n * @returns \n */\nexport const joinPointsToLines = (...points: ReadonlyArray<Point>): PolyLine => {\n  const lines = [];\n\n  let start = points[ 0 ];\n\n  for (let index = 1; index < points.length; index++) {\n    //eslint-disable-next-line functional/immutable-data\n    lines.push(fromPoints(start, points[ index ]));\n    start = points[ index ];\n  }\n  return lines;\n};","import { isPoint } from \"../point/Guard.js\";\nimport type { Line, PolyLine } from \"./LineType.js\";\n\n/**\n * Returns true if `p` is a valid line, containing `a` and `b` Points.\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.isLine(l);\n * ```\n * @param p Value to check\n * @returns True if a valid line.\n */\nexport const isLine = (p: any): p is Line => {\n  if (p === undefined) return false;\n  if ((p as Line).a === undefined) return false;\n  if ((p as Line).b === undefined) return false;\n  if (!isPoint((p as Line).a)) return false;\n  if (!isPoint((p as Line).b)) return false;\n  return true;\n};\n\n/**\n * Returns true if `p` is a {@link PolyLine}, ie. an array of {@link Line}s.\n * Validates all items in array.\n * @param p \n * @returns\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isPolyLine = (p: any): p is PolyLine => {\n  if (!Array.isArray(p)) return false;\n\n  const valid = !p.some(v => !isLine(v));\n  return valid;\n};\n\n/**\n * Throws an exception if:\n * * line is undefined\n * * a or b parameters are missing\n * \n * Does not validate points\n * @param line \n * @param name \n */\nexport const guard = (line: Line, name = `line`) => {\n  if (line === undefined) throw new Error(`${ name } undefined`);\n  if (line.a === undefined) throw new Error(`${ name }.a undefined. Expected {a:Point, b:Point}. Got: ${ JSON.stringify(line) }`);\n  if (line.b === undefined) throw new Error(`${ name }.b undefined. Expected {a:Point, b:Point} Got: ${ JSON.stringify(line) }`);\n};","import type { Point } from \"../point/PointType.js\";\nimport { isLine } from \"./Guard.js\";\nimport type { Line } from \"./LineType.js\";\nimport { guard as guardPoint } from '../point/Guard.js';\n\n/**\n * Returns [a,b] points from either a line parameter, or two points.\n * It additionally applies the guardPoint function to ensure validity.\n * This supports function overloading.\n * @ignore\n * @param aOrLine \n * @param b \n * @returns \n */\nexport const getPointParameter = (aOrLine: Point | Line, b?: Point): readonly [ Point, Point ] => {\n\n  let a;\n  if (isLine(aOrLine)) {\n    b = aOrLine.b;\n    a = aOrLine.a;\n  } else {\n    a = aOrLine;\n    if (b === undefined) throw new Error(`Since first parameter is not a line, two points are expected. Got a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) }`);\n  }\n  guardPoint(a, `a`);\n  guardPoint(a, `b`);\n\n  return [ a, b ];\n};","import type { Point } from \"../point/PointType.js\";\nimport { getPointParameter } from \"./GetPointsParameter.js\";\nimport { isPolyLine } from \"./Guard.js\";\nimport type { Line, PolyLine } from \"./LineType.js\";\n\n/**\n * Returns the length between two points\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.length(ptA, ptB);\n * ```\n * @param a First point\n * @param b Second point\n * @returns \n */\nexport function length(a: Point, b: Point): number;\n\n/**\n * Returns length of line. If a polyline (array of lines) is provided,\n * it is the sum total that is returned.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.length(a: {x:0, y:0}, b: {x: 100, y:100});\n * Lines.length(lines);\n * ```\n * @param line Line\n */\nexport function length(line: Line | PolyLine): number;\n\n/**\n * Returns length of line, polyline or between two points\n * \n * @param aOrLine Point A, line or polyline (array of lines)\n * @param pointB Point B, if first parameter is a point\n * @returns Length (total accumulated length for arrays)\n */\n//eslint-disable-next-line func-style\nexport function length(aOrLine: Point | Line | PolyLine, pointB?: Point): number {\n  if (isPolyLine(aOrLine)) {\n    const sum = aOrLine.reduce((accumulator, v) => length(v) + accumulator, 0);\n    return sum;\n  }\n  if (aOrLine === undefined) throw new TypeError(`Parameter 'aOrLine' is undefined`);\n  const [ a, b ] = getPointParameter(aOrLine, pointB);\n  const x = b.x - a.x;\n  const y = b.y - a.y;\n  if (a.z !== undefined && b.z !== undefined) {\n    const z = b.z - a.z;\n    return Math.hypot(x, y, z);\n  } else {\n    return Math.hypot(x, y);\n  }\n}\n","import { throwNumberTest, throwPercentTest } from \"../../util/GuardNumbers.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { getPointParameter } from \"./GetPointsParameter.js\";\nimport { length } from \"./Length.js\";\n/**\n * Calculates a point in-between `a` and `b`.\n * \n * If an interpolation amount below 0 or above 1 is given, _and_\n * `allowOverflow_ is true, a point will be returned that is extended\n * past `line`. This is useful for easing functions which might\n * briefly go past the limits.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Get {x,y} at 50% along line\n * Lines.interpolate(0.5, line);\n * \n * // Get {x,y} at 80% between point A and B\n * Lines.interpolate(0.8, ptA, ptB);\n * ```\n * @param amount Relative position, 0 being at a, 0.5 being halfway, 1 being at b\n * @param a Start\n * @param pointB End\n * @returns Point between a and b\n */\nexport function interpolate(amount: number, a: Point, pointB: Point, allowOverflow?: boolean): Point;\n\n/**\n * Calculates a point in-between `line`'s start and end points.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Get {x, y } at 50% along line\n * Lines.interpolate(0.5, line);\n * ```\n * \n * Any additional properties from `b`  are returned on the result as well.\n * @param amount 0..1 \n * @param line Line\n * @param allowOverflow If true, interpolation amount is permitted to exceed 0..1, extending the line\n */\nexport function interpolate(amount: number, line: Line, allowOverflow?: boolean): Point;\n\n/**\n * Calculates a point in-between a line's start and end points.\n * \n * @param amount Interpolation amount\n * @param aOrLine Line, or first point\n * @param pointBOrAllowOverflow Second point (if needed) or allowOverflow.\n * @param allowOverflow If true, interpolation amount is permitted to exceed 0..1, extending the line.\n * @returns \n */\n//eslint-disable-next-line func-style\nexport function interpolate(amount: number, aOrLine: Point | Line, pointBOrAllowOverflow?: Point | boolean, allowOverflow?: boolean): Point {\n\n  if (typeof pointBOrAllowOverflow === `boolean`) {\n    allowOverflow = pointBOrAllowOverflow;\n    pointBOrAllowOverflow = undefined;\n  }\n\n  // eslint-disable-next-line unicorn/no-negated-condition\n  if (!allowOverflow) throwPercentTest(amount, `amount`);\n  else throwNumberTest(amount, ``, `amount`);\n\n  const [ a, b ] = getPointParameter(aOrLine, pointBOrAllowOverflow);\n\n  const d = length(a, b);\n  const d2 = d * (1 - amount);\n\n  // Points are identical, return a copy of b\n  if (d === 0 && d2 === 0) return Object.freeze({ ...b });\n\n  const x = b.x - (d2 * (b.x - a.x) / d);\n  const y = b.y - (d2 * (b.y - a.y) / d);\n\n  return Object.freeze({\n    ...b,\n    x: x,\n    y: y\n  });\n}\n","import { interpolate } from \"./Interpolate.js\";\nimport type { Line } from \"./LineType.js\";\nimport { length } from \"./Length.js\";\nimport type { Point } from \"../point/PointType.js\";\n\nconst directionVector = (line: Line): Point => ({\n  x: line.b.x - line.a.x,\n  y: line.b.y - line.a.y\n});\n\n\n\nconst directionVectorNormalised = (line: Line): Point => {\n  const l = length(line);\n  const v = directionVector(line);\n  return {\n    x: v.x / l,\n    y: v.y / l\n  };\n};\n\n/**\n * Returns a parallel line to `line` at `distance`.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const l = Lines.parallel(line, 10);\n * ```\n * @param line\n * @param distance \n */\nexport const parallel = (line: Line, distance: number): Line => {\n  const dv = directionVector(line);\n  const dvn = directionVectorNormalised(line);\n  const a = {\n    x: line.a.x - dvn.y * distance,\n    y: line.a.y + dvn.x * distance\n  };\n  return {\n    a,\n    b: {\n      x: a.x + dv.x,\n      y: a.y + dv.y\n    }\n  };\n};\n\n/**\n * Returns a point perpendicular to `line` at a specified `distance`. Use negative\n * distances for the other side of line.\n * ```\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Project a point 100 units away from line, at its midpoint.\n * const pt = Lines.perpendicularPoint(line, 100, 0.5);\n * ```\n * @param line Line\n * @param distance Distance from line. Use negatives to flip side\n * @param amount Relative place on line to project point from. 0 projects from A, 0.5 from the middle, 1 from B.\n */\nexport const perpendicularPoint = (line: Line, distance: number, amount = 0) => {\n  const origin = interpolate(amount, line);\n  const dvn = directionVectorNormalised(line);\n  return {\n    x: origin.x - dvn.y * distance,\n    y: origin.y + dvn.x * distance\n  };\n};\n","import type { Point } from \"../point/PointType.js\";\nimport { interpolate } from \"./Interpolate.js\";\nimport type { Line } from \"./LineType.js\";\nimport { getPointParameter } from \"./GetPointsParameter.js\";\n\n/**\n * Returns the mid-point of a line (same as `interpolate` with an amount of 0.5)\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.midpoint(line); // Returns {x, y}\n * ```\n * @param aOrLine \n * @param pointB \n * @returns \n */\nexport const midpoint = (aOrLine: Point | Line, pointB?: Point): Point => {\n  const [ a, b ] = getPointParameter(aOrLine, pointB);\n  return interpolate(0.5, a, b);\n};","import type { Point } from '../point/PointType.js';\nimport type { Line } from './LineType.js';\n//import * as Points from '../point/index.js';\nimport { normaliseByRect as PointsNormaliseByRect } from '../point/NormaliseByRect.js';\nimport { minFast } from '../../numbers/NumericArrays.js';\nimport { distanceSingleLine } from './DistanceSingleLine.js';\nimport { isLine } from './Guard.js';\nimport { length } from './Length.js';\nimport { interpolate } from './Interpolate.js';\nimport { isPoint, isEmpty as PointIsEmpty, isPlaceholder as PointIsPlaceholder } from '../point/Guard.js';\nexport * from './Angles.js';\nexport * from './Bbox.js';\nexport * from './DistanceSingleLine.js';\nexport * from './Divide.js';\nexport * from './FromFlatArray.js';\nexport * from './FromNumbers.js';\nexport * from './FromPoints.js';\nexport * from './FromPivot.js';\nexport * from './FromPointsToPath.js';\nexport * from './GetPointsParameter.js';\nexport * from './Guard.js';\nexport * from './Interpolate.js';\nexport * from './IsEqual.js';\nexport * from './JoinPointsToLines.js';\nexport * from './Length.js';\nexport type * from './LinePathType.js';\nexport type * from './LineType.js';\nexport * from './Midpoint.js';\nexport * from './Multiply.js';\nexport * from './Nearest.js';\nexport * from './RelativePosition.js';\nexport * from './Rotate.js';\nexport * from './Subtract.js';\nexport * from './Sum.js';\nexport * from './ToPath.js';\nexport * from './ToString.js';\n\n//eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Empty = Object.freeze({\n  a: Object.freeze({ x: 0, y: 0 }),\n  b: Object.freeze({ x: 0, y: 0 })\n});\n\n//eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Placeholder = Object.freeze({\n  a: Object.freeze({ x: Number.NaN, y: Number.NaN }),\n  b: Object.freeze({ x: Number.NaN, y: Number.NaN })\n});\n\n/**\n * Returns true if `l` is the same as Line.Empty, that is\n * the `a` and `b` points are Points.Empty.\n * @param l \n * @returns \n */\nexport const isEmpty = (l: Line): boolean => PointIsEmpty(l.a) && PointIsEmpty(l.b);\n\nexport const isPlaceholder = (l: Line): boolean => PointIsPlaceholder(l.a) && PointIsPlaceholder(l.b);\n\n\n\n\n/**\n * Applies `fn` to both start and end points.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Line 10,10 -> 20,20\n * const line = Lines.fromNumbers(10,10, 20,20);\n * \n * // Applies randomisation to both x and y.\n * const rand = (p) => ({\n *  x: p.x * Math.random(),\n *  y: p.y * Math.random()\n * });\n * \n * // Applies our randomisation function\n * const line2 = apply(line, rand);\n * ```\n * @param line Line\n * @param fn Function that takes a point and returns a point\n * @returns \n */\nexport const apply = (line: Line, fn: (p: Point) => Point) => Object.freeze<Line>(\n  {\n    ...line,\n    a: fn(line.a),\n    b: fn(line.b)\n  }\n);\n\n\n/**\n * Returns the angle in radians of a line, or two points\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.angleRadian(line);\n * Lines.angleRadian(ptA, ptB);\n * ```\n * @param lineOrPoint \n * @param b \n * @returns \n */\nexport const angleRadian = (lineOrPoint: Line | Point, b?: Point): number => {\n  let a: Point;\n  if (isLine(lineOrPoint)) {\n    a = lineOrPoint.a;\n    b = lineOrPoint.b;\n  } else {\n    a = lineOrPoint;\n    if (b === undefined) throw new Error(`b point must be provided`);\n  }\n  return Math.atan2(b.y - a.y, b.x - a.x);\n};\n\n/**\n * Normalises start and end points by given width and height. Useful\n * for converting an absolutely-defined line to a relative one.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.normaliseByRect(l, 10, 10);\n * // Yields: 0.1,0.1 -> 1,1\n * ```\n * @param line \n * @param width\n * @param height \n * @returns \n */\nexport const normaliseByRect = (line: Line, width: number, height: number): Line => Object.freeze({\n  ...line,\n  a: PointsNormaliseByRect(line.a, width, height),\n  b: PointsNormaliseByRect(line.b, width, height)\n});\n\n\n/**\n * Returns true if `point` is within `maxRange` of `line`.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const line = Lines.fromNumbers(0,20,20,20);\n * Lines.withinRange(line, {x:0,y:21}, 1); // True\n * ```\n * @param line\n * @param point\n * @param maxRange \n * @returns True if point is within range\n */\nexport const withinRange = (line: Line, point: Point, maxRange: number): boolean => {\n  const calculatedDistance = distance(line, point);\n  return calculatedDistance <= maxRange;\n};\n\n\n/**\n * Calculates [slope](https://en.wikipedia.org/wiki/Slope) of line.\n * \n * @example\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.slope(line);\n * Lines.slope(ptA, ptB)\n * ```\n * @param lineOrPoint Line or point. If point is provided, second point must be given too\n * @param b Second point if needed\n * @returns \n */\nexport const slope = (lineOrPoint: Line | Point, b?: Point): number => {\n\n  let a: Point;\n  if (isLine(lineOrPoint)) {\n\n    a = lineOrPoint.a;\n    b = lineOrPoint.b;\n  } else {\n    a = lineOrPoint;\n    if (b === undefined) throw new Error(`b parameter required`);\n  }\n  if (b === undefined) {\n    throw new TypeError(`Second point missing`)\n  } else {\n    return (b.y - a.y) / (b.x - a.x);\n  }\n};\n\n\n/**\n * Scales a line from its midpoint\n * \n * @example Shorten by 50%, anchored at the midpoint\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const l = {\n *  a: {x:50, y:50}, b: {x: 100, y: 90}\n * }\n * const l2 = Lines.scaleFromMidpoint(l, 0.5);\n * ```\n * @param line\n * @param factor \n */\nexport const scaleFromMidpoint = (line: Line, factor: number): Line => {\n  const a = interpolate(factor / 2, line);\n  const b = interpolate(0.5 + factor / 2, line);\n  return { a, b };\n};\n\n/**\n * Calculates `y` where `line` intersects `x`.\n * @param line Line to extend\n * @param x Intersection of x-axis.\n */\nexport const pointAtX = (line: Line, x: number): Point => {\n  const y = line.a.y + (x - line.a.x) * slope(line);\n  return Object.freeze({ x: x, y });\n};\n\n/**\n * Returns a line extended from its `a` point by a specified distance\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const line = {a: {x: 0, y:0}, b: {x:10, y:10} }\n * const extended = Lines.extendFromA(line, 2);\n * ```\n * @param line\n * @param distance\n * @return Newly extended line\n */\nexport const extendFromA = (line: Line, distance: number): Line => {\n  const calculatedLength = length(line);\n  return Object.freeze({\n    ...line,\n    a: line.a,\n    b: Object.freeze({\n      x: line.b.x + (line.b.x - line.a.x) / calculatedLength * distance,\n      y: line.b.y + (line.b.y - line.a.y) / calculatedLength * distance,\n    })\n  });\n};\n\n/**\n * Yields every integer point along `line`. \n * \n * @example Basic usage\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const l = { a: {x: 0, y: 0}, b: {x: 100, y: 100} };\n * for (const p of Lines.pointsOf(l)) {\n *  // Do something with point `p`...\n * }\n * ```\n * \n * Some precision is lost as start and end\n * point is also returned as an integer.\n * \n * Uses [Bresenham's line algorithm](https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm)\n * @param line Line\n */\n//eslint-disable-next-line func-style\nexport function* pointsOf(line: Line): Generator<Point> {\n  // Via https://play.ertdfgcvb.xyz/#/src/demos/dyna\n  const { a, b } = line;\n  let x0 = Math.floor(a.x);\n  let y0 = Math.floor(a.y);\n  const x1 = Math.floor(b.x);\n  const y1 = Math.floor(b.y);\n  const dx = Math.abs(x1 - x0);\n  const dy = -Math.abs(y1 - y0);\n  const sx = x0 < x1 ? 1 : -1;\n  const sy = y0 < y1 ? 1 : -1;\n  // eslint-disable-next-line unicorn/prevent-abbreviations\n  let err = dx + dy;\n\n  while (true) {\n    yield { x: x0, y: y0 };\n    if (x0 === x1 && y0 === y1) break;\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    const e2 = 2 * err;\n    if (e2 >= dy) {\n      err += dy;\n      x0 += sx;\n    }\n    if (e2 <= dx) {\n      err += dx;\n      y0 += sy;\n    }\n  }\n}\n\n/**\n * Returns the distance of `point` to the \n * nearest point on `line`.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const d = Lines.distance(line, {x:10,y:10});\n * ```\n * \n * If an array of lines is provided, the shortest distance is returned.\n * @param line Line (or array of lines)\n * @param point Point to check against\n * @returns Distance\n */\nexport const distance = (line: Line | ReadonlyArray<Line>, point: Point): number => {\n  if (Array.isArray(line)) {\n    const distances = line.map(l => distanceSingleLine(l, point));\n    return minFast(distances);\n  } else {\n    return distanceSingleLine(line as Line, point);\n  }\n};\n\n/**\n * Returns an array representation of line: [a.x, a.y, b.x, b.y]\n * \n * See {@link fromFlatArray} to create a line _from_ this representation.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.toFlatArray(line);\n * Lines.toFlatArray(pointA, pointB);\n * ```\n * @param {Point} a\n * @param {Point} b\n * @returns {number[]}\n */\nexport const toFlatArray = (a: Point | Line, b: Point): ReadonlyArray<number> => {\n  if (isLine(a)) {\n    return [ a.a.x, a.a.y, a.b.x, a.b.y ];\n  } else if (isPoint(a) && isPoint(b)) {\n    return [ a.x, a.y, b.x, b.y ];\n  } else {\n    throw new Error(`Expected single line parameter, or a and b points`);\n  }\n};\n\n/**\n * Yields all the points of all the lines.\n * \n * ```js\n * const lines = [ ..some array of lines.. ];\n * for (const pt of Lines.asPoints(lines)) {\n *  // Yields a and then b of each point sequentially\n * }\n * ```\n * @param lines \n */\n//eslint-disable-next-line func-style\nexport function* asPoints(lines: Iterable<Line>) {\n  for (const l of lines) {\n    yield l.a;\n    yield l.b;\n  }\n}\n\n/**\n * Returns an SVG description of line\n * ```\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js';\n * Lines.toSvgString(ptA, ptB);\n * ```\n * @param a \n * @param b \n * @returns \n */\nexport const toSvgString = (a: Point, b: Point): ReadonlyArray<string> => [ `M${ a.x } ${ a.y } L ${ b.x } ${ b.y }` ];\n","import type { RectPositioned, Rect } from \"./RectTypes.js\";\nimport { guard as PointsGuard } from '../point/Guard.js';\nimport type { Point } from '../point/PointType.js';\n\n/**\n * Throws an error if the dimensions of the rectangle are undefined, NaN or negative.\n * @param d \n * @param name \n */\nexport const guardDim = (d: number, name = `Dimension`) => {\n  if (d === undefined) throw new Error(`${ name } is undefined`);\n  if (Number.isNaN(d)) throw new Error(`${ name } is NaN`);\n  if (d < 0) throw new Error(`${ name } cannot be negative`);\n};\n\n/**\n * Throws an error if rectangle is missing fields or they\n * are not valid.\n * \n * Checks:\n * * `width` and `height` must be defined on `rect`\n * * dimensions (w & h) must not be NaN\n * * dimensions (w & h) must not be negative\n * \n * If `rect` has x,y, this value is checked as well.\n * @param rect\n * @param name\n */\nexport const guard = (rect: Rect, name = `rect`) => {\n  if (rect === undefined) throw new Error(`{$name} undefined`);\n  if (isPositioned(rect)) PointsGuard(rect, name);\n  guardDim(rect.width, name + `.width`);\n  guardDim(rect.height, name + `.height`);\n};\n\n/**\n * Returns a positioned rect or if it's not possible, throws an error.\n * \n * If `rect` does not have a position, `origin` is used.\n * If `rect` is positioned and `origin` is provided, returned result uses `origin` as x,y instead.\n * ```js\n * // Returns input because it's positioned\n * getRectPositioned({ x:1, y:2, width:10, height:20 });\n * \n * // Returns { x:1, y:2, width:10, height:20 }\n * getRectPositioned({ width:10, height:20 }, { x:1, y:2 });\n *  \n * // Throws, because we have no point\n * getRectPositioned({width:10,height:20})\n * ```\n * @param rect \n * @param origin \n * @returns \n */\nexport const getRectPositioned = (rect: Rect | RectPositioned, origin?: Point): RectPositioned => {\n  guard(rect);\n  if (isPositioned(rect) && origin === undefined) {\n    return rect;\n  }\n  if (origin === undefined) throw new Error(`Unpositioned rect needs origin parameter`);\n  return Object.freeze({ ...rect, ...origin });\n\n}\n\n/**\n * Throws an error if `rect` is does not have a position, or\n * is an invalid rectangle\n * @param rect \n * @param name \n */\nexport const guardPositioned = (rect: RectPositioned, name = `rect`) => {\n  if (!isPositioned(rect)) throw new Error(`Expected ${ name } to have x,y`);\n  guard(rect, name);\n};\n\n/**\n * Returns _true_ if `rect` has width and height values of 0.\n * Use Rects.Empty or Rects.EmptyPositioned to generate an empty rectangle.\n * @param rect \n * @returns \n */\nexport const isEmpty = (rect: Rect): boolean =>\n  rect.width === 0 && rect.height === 0;\n\n/**\n * Returns _true_ if `rect` is a placeholder, with both width and height values of NaN.\n * Use Rects.Placeholder or Rects.PlaceholderPositioned to generate a placeholder.\n * @param rect \n * @returns \n */\nexport const isPlaceholder = (rect: Rect): boolean =>\n  Number.isNaN(rect.width) && Number.isNaN(rect.height);\n\n/**\n * Returns _true_ if `rect` has position (x,y) fields.\n * @param rect Point, Rect or RectPositiond\n * @returns\n */\nexport const isPositioned = (\n  rect: Point | Rect | RectPositioned\n): rect is Point =>\n  (rect as Point).x !== undefined && (rect as Point).y !== undefined;\n\n/**\n * Returns _true_ if `rect` has width and height fields.\n * @param rect\n * @returns\n */\nexport const isRect = (rect: unknown): rect is Rect => {\n  if (rect === undefined) return false;\n  if ((rect as Rect).width === undefined) return false;\n  if ((rect as Rect).height === undefined) return false;\n  return true;\n};\n\n/**\n * Returns _true_ if `rect` is a positioned rectangle\n * Having width, height, x and y properties.\n * @param rect\n * @returns\n */\nexport const isRectPositioned = (\n  rect: any\n): rect is RectPositioned => isRect(rect) && isPositioned(rect);\n","import { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport type { Rect } from \"../rect/RectTypes.js\";\nimport { isRect } from \"../rect/Guard.js\";\nimport { isPoint } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Normalises a point by a given width and height\n * @param point Point\n * @param width Width\n * @param height Height\n */\nexport function normaliseByRect(\n  point: Point,\n  width: number,\n  height: number\n): Point;\n\n/**\n * Normalises a point by a given rect's width and height\n * @param pt \n * @param rect \n */\nexport function normaliseByRect(pt: Point, rect: Rect): Point;\n\n/**\n * Normalises x,y by width and height so it is on a 0..1 scale\n * @param x\n * @param y\n * @param width\n * @param height\n */\nexport function normaliseByRect(\n  x: number,\n  y: number,\n  width: number,\n  height: number\n): Point;\n\n/**\n * Normalises a point so it is on a 0..1 scale\n * @param a Point, or x\n * @param b y coord or width\n * @param c height or width\n * @param d height\n * @returns Point\n */\nexport function normaliseByRect(\n  a: Point | number,\n  b: number | Rect,\n  c?: number,\n  d?: number\n): Point {\n  // ✔️ Unit tested\n  if (isPoint(a)) {\n    if (typeof b === `number` && c !== undefined) {\n      throwNumberTest(b, `positive`, `width`);\n      throwNumberTest(c, `positive`, `height`);\n    } else {\n      if (!isRect(b)) {\n        throw new Error(`Expected second parameter to be a rect`);\n      }\n      c = b.height;\n      b = b.width;\n    }\n    return Object.freeze({\n      x: a.x / b,\n      y: a.y / c,\n    });\n  } else {\n    throwNumberTest(a, `positive`, `x`);\n    if (typeof b !== `number`) {\n      throw new TypeError(`Expecting second parameter to be a number (width)`);\n    }\n    if (typeof c !== `number`) {\n      throw new TypeError(`Expecting third parameter to be a number (height)`);\n    }\n\n    throwNumberTest(b, `positive`, `y`);\n    throwNumberTest(c, `positive`, `width`);\n    if (d === undefined) throw new Error(`Expected height parameter`);\n    throwNumberTest(d, `positive`, `height`);\n    return Object.freeze({\n      x: a / c,\n      y: b / d,\n    });\n  }\n}","import { isPoint } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\n\n/**\n * Returns a Point form of either a point, x,y params or x,y,z params.\n * If parameters are undefined, an empty point is returned (0, 0)\n * @ignore\n * @param a\n * @param b\n * @returns\n */\nexport function getPointParameter(\n  a?: Point | number | Array<number> | ReadonlyArray<number>,\n  b?: number | boolean,\n  c?: number\n): Point | Point3d {\n  if (a === undefined) return { x: 0, y: 0 };\n\n  if (Array.isArray(a)) {\n    if (a.length === 0) return Object.freeze({ x: 0, y: 0 });\n    if (a.length === 1) return Object.freeze({ x: a[ 0 ], y: 0 });\n    if (a.length === 2) return Object.freeze({ x: a[ 0 ], y: a[ 1 ] });\n    if (a.length === 3) return Object.freeze({ x: a[ 0 ], y: a[ 1 ], z: a[ 2 ] });\n    throw new Error(\n      `Expected array to be 1-3 elements in length. Got ${ a.length }.`\n    );\n  }\n\n  if (isPoint(a)) {\n    return a;\n  } else if (typeof a !== `number` || typeof b !== `number`) {\n    throw new TypeError(\n      `Expected point or x,y as parameters. Got: a: ${ JSON.stringify(\n        a\n      ) } b: ${ JSON.stringify(b) }`\n    );\n  }\n\n  // x,y,z\n  if (typeof c === `number`) {\n    return Object.freeze({ x: a, y: b, z: c });\n  }\n  // x,y\n  return Object.freeze({ x: a, y: b });\n}","import { guard, isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from './PointType.js';\nimport { getPointParameter } from \"./GetPointParameter.js\";\n\nexport function distance(a: Point, b?: Point): number;\nexport function distance(a: Point, x: number, y: number): number;\n\n/**\n * Calculate distance between two points.\n *\n * ```js\n * // Distance between two points\n * const ptA = { x: 0.5, y:0.8 };\n * const ptB = { x: 1, y: 0.4 };\n * distance(ptA, ptB);\n * // Or, provide x,y as parameters\n * distance(ptA, 0.4, 0.9);\n *\n * // Distance from ptA to x: 0.5, y:0.8, z: 0.1\n * const ptC = { x: 0.5, y:0.5, z: 0.3 };\n * // With x,y,z as parameters:\n * distance(ptC, 0.5, 0.8, 0.1);\n * ```\n * @param a First point\n * @param xOrB Second point, or x coord\n * @param y y coord, if x coord is given\n * @param z Optional z coord, if x and y are given.\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function distance(\n  a: Point | Point3d,\n  xOrB?: Point | Point3d | number,\n  y?: number,\n  z?: number\n): number {\n  const pt = getPointParameter(xOrB, y, z);\n  guard(pt, `b`);\n  guard(a, `a`);\n  return isPoint3d(pt) && isPoint3d(a) ? Math.hypot(pt.x - a.x, pt.y - a.y, pt.z - a.z) : Math.hypot(pt.x - a.x, pt.y - a.y);\n}\n","import type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { distance as PointsDistance } from \"../point/Distance.js\";\nimport { minIndex } from \"../../numbers/NumericArrays.js\";\n/**\n * Returns the nearest point on `line` closest to `point`.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const pt = Lines.nearest(line, {x:10,y:10});\n * ```\n * \n * If an array of lines is provided, it will be the closest point amongst all the lines\n * @param line Line or array of lines\n * @param point\n * @returns Point `{ x, y }`\n */\nexport const nearest = (line: Line | ReadonlyArray<Line>, point: Point): Point => {\n\n  const n = (line: Line): Point => {\n    const { a, b } = line;\n    const atob = { x: b.x - a.x, y: b.y - a.y };\n    const atop = { x: point.x - a.x, y: point.y - a.y };\n    const length = atob.x * atob.x + atob.y * atob.y;\n\n\n    let dot = atop.x * atob.x + atop.y * atob.y;\n    const t = Math.min(1, Math.max(0, dot / length));\n    dot = (b.x - a.x) * (point.y - a.y) - (b.y - a.y) * (point.x - a.x);\n    return { x: a.x + atob.x * t, y: a.y + atob.y * t };\n  };\n\n  if (Array.isArray(line)) {\n    const pts = line.map(l => n(l));\n    const dists = pts.map(p => PointsDistance(p, point));\n    return Object.freeze<Point>(pts[ minIndex(...dists) ]);\n  } else {\n    return Object.freeze<Point>(n(line as Line));\n  }\n};","import type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { guard } from './Guard.js';\nimport { guard as guardPoint } from '../point/Guard.js';\nimport { length } from \"./Length.js\";\nimport { nearest } from \"./Nearest.js\";\n/**\n * Returns the distance of `point` to the nearest point on `line`\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const distance = Lines.distanceSingleLine(line, pt);\n * ```\n * @param line Line\n * @param point Target point\n * @returns \n */\nexport const distanceSingleLine = (line: Line, point: Point): number => {\n  guard(line, `line`);\n  guardPoint(point, `point`);\n\n  if (length(line) === 0) {\n    // Line is really a point\n    return length(line.a, point);\n  }\n\n  const near = nearest(line, point);\n  return length(near, point);\n};","import type { Point } from \"./PointType.js\";\n\n/**\n * Returns the 'minimum' point from an array of points, using a comparison function.\n *\n * @example Find point closest to a coordinate\n * ```js\n * const points = [...];\n * const center = {x: 100, y: 100};\n *\n * const closestToCenter = findMinimum((a, b) => {\n *  const aDist = distance(a, center);\n *  const bDist = distance(b, center);\n *  if (aDistance < bDistance) return a;\n *  return b;\n * }, points);\n * ```\n * @param comparer Compare function returns the smallest of `a` or `b`\n * @param points\n * @returns\n */\nexport const findMinimum = (\n  comparer: (a: Point, b: Point) => Point,\n  ...points: ReadonlyArray<Point>\n): Point => {\n  if (points.length === 0) throw new Error(`No points provided`);\n  let min = points[ 0 ];\n  for (const p of points) {\n    min = comparer(min, p);\n  }\n  return min;\n};","import type { Point } from \"../point/PointType.js\";\nimport type { RectPositioned } from \"./RectTypes.js\";\n\n/**\n * Returns a rectangle based on provided four corners.\n *\n * To create a rectangle that contains an arbitary set of points, use {@link Geometry.Points.bbox | Geometry.Points.bbox}.\n *\n * Does some sanity checking such as:\n *  - x will be smallest of topLeft/bottomLeft\n *  - y will be smallest of topRight/topLeft\n *  - width will be largest between top/bottom left and right\n *  - height will be largest between left and right top/bottom\n *\n */\nexport const maxFromCorners = (\n  topLeft: Point,\n  topRight: Point,\n  bottomRight: Point,\n  bottomLeft: Point\n): RectPositioned => {\n  if (topLeft.y > bottomRight.y) {\n    throw new Error(`topLeft.y greater than bottomRight.y`);\n  }\n  if (topLeft.y > bottomLeft.y) {\n    throw new Error(`topLeft.y greater than bottomLeft.y`);\n  }\n\n  const w1 = topRight.x - topLeft.x;\n  const w2 = bottomRight.x - bottomLeft.x;\n  const h1 = Math.abs(bottomLeft.y - topLeft.y);\n  const h2 = Math.abs(bottomRight.y - topRight.y);\n  return {\n    x: Math.min(topLeft.x, bottomLeft.x),\n    y: Math.min(topRight.y, topLeft.y),\n    width: Math.max(w1, w2),\n    height: Math.max(h1, h2),\n  };\n};\n","import type { RectPositioned } from \"../rect/RectTypes.js\";\nimport { findMinimum } from \"./FindMinimum.js\";\nimport type { Point } from \"./PointType.js\";\nimport { maxFromCorners as RectsMaxFromCorners } from '../rect/Max.js';\n/**\n * Returns the minimum rectangle that can enclose all provided points\n * @param points\n * @returns\n */\nexport const bbox = (...points: ReadonlyArray<Point>): RectPositioned => {\n  const leftMost = findMinimum((a, b) => {\n    return a.x < b.x ? a : b;\n  }, ...points);\n  const rightMost = findMinimum((a, b) => {\n    return a.x > b.x ? a : b;\n  }, ...points);\n  const topMost = findMinimum((a, b) => {\n    return a.y < b.y ? a : b;\n  }, ...points);\n  const bottomMost = findMinimum((a, b) => {\n    return a.y > b.y ? a : b;\n  }, ...points);\n\n  const topLeft = { x: leftMost.x, y: topMost.y };\n  const topRight = { x: rightMost.x, y: topMost.y };\n  const bottomRight = { x: rightMost.x, y: bottomMost.y };\n  const bottomLeft = { x: leftMost.x, y: bottomMost.y };\n  return RectsMaxFromCorners(topLeft, topRight, bottomRight, bottomLeft);\n};\n","import type { RectPositioned } from \"../rect/RectTypes.js\";\nimport type { Line } from \"./LineType.js\";\nimport { bbox as PointsBbox } from \"../point/Bbox.js\";\n/**\n * Returns a rectangle that encompasses dimension of line\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js';\n * const rect = Lines.bbox(line);\n * ```\n */\nexport const bbox = (line: Line): RectPositioned => PointsBbox(line.a, line.b);\n","import { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport { getPointParameter } from \"./GetPointParameter.js\";\nimport { guard, guardNonZeroPoint, isPoint } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\nimport { guard as RectsGuard, isRect } from '../rect/Guard.js'\nimport type { Rect } from \"../rect/RectTypes.js\";\n/**\n * Divides point a by rectangle:\n * ```js\n * return {\n *  x: a.x / rect.width,\n *  y: a.y / rect.hight\n * };\n * ```\n * \n * Or point:\n * ```js\n * return {\n *  x: a.x / b.x,\n *  y: a.y / b.y\n * }\n * ```\n * \n * \n * Dividing by zero will give Infinity for that dimension.\n * @param a\n * @param rectOrPoint\n */\nexport function divide(a: Point, rectOrPoint: Rect | Point): Point;\n\n/**\n * Divides a point by x,y.\n * ```js\n * return {\n *  x: a.x / x,\n *  y: b.y / y\n * };\n * ```\n * \n * Dividing by zero will give Infinity for that dimension.\n * @param a Point\n * @param x X divisor\n * @param y Y divisor. If unspecified, x divisor is used.\n */\nexport function divide(a: Point, x: number, y?: number): Point;\n\n/**\n * Divides two sets of points:\n * ```js\n * return {\n *  x: x1 / x2,\n *  y: y1 / y2\n * };\n * ```\n * \n * Dividing by zero will give Infinity for that dimension.\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n */\nexport function divide(x1: number, y1: number, x2?: number, y2?: number): Point;\n\n/**\n * Divides a from b. If a contains a zero, that axis will be returned as zero\n * @param a\n * @param b\n * @param c\n * @param d\n * @returns\n */\nexport function divide(\n  a: Point | number,\n  b: Rect | Point | number,\n  c?: number,\n  d?: number\n): Point {\n  // ✔️ Unit tested\n\n  if (isPoint(a)) {\n    guard(a, `a`);\n    if (isPoint(b)) {\n      //guardNonZeroPoint(b);\n      return Object.freeze({\n        x: a.x / b.x,\n        y: a.y / b.y,\n      });\n    } else if (isRect(b)) {\n      RectsGuard(b, `rect`);\n      return Object.freeze({\n        x: a.x / b.width,\n        y: a.y / b.height,\n      });\n    } else {\n      if (c === undefined) c = b;\n      guard(a);\n      throwNumberTest(b, `nonZero`, `x`);\n      throwNumberTest(c, `nonZero`, `y`);\n      return Object.freeze({\n        x: a.x / b,\n        y: a.y / c,\n      });\n    }\n  } else {\n    if (typeof b !== `number`) {\n      throw new TypeError(`expected second parameter to be y1 coord`);\n    }\n    throwNumberTest(a, `positive`, `x1`);\n    throwNumberTest(b, `positive`, `y1`);\n    if (c === undefined) c = 1;\n    if (d === undefined) d = c;\n    throwNumberTest(c, `nonZero`, `x2`);\n    throwNumberTest(d, `nonZero`, `y2`);\n\n    return Object.freeze({\n      x: a / c,\n      y: b / d,\n    });\n  }\n}\n\n/**\n * Returns a function that divides a point:\n * ```js\n * const f = divider(100, 200);\n * f(50,100); // Yields: { x: 0.5, y: 0.5 }\n * ```\n *\n * Input values can be Point, separate x,y and optional z values or an array:\n * ```js\n * const f = divider({ x: 100, y: 100 });\n * const f = divider( 100, 100 );\n * const f = divider([ 100, 100 ]);\n * ```\n *\n * Likewise the returned function an take these as inputs:\n * ```js\n * f({ x: 100, y: 100});\n * f( 100, 100 );\n * f([ 100, 100 ]);\n * ```\n *\n * Function throws if divisor has 0 for any coordinate (since we can't divide by 0)\n * @param a Divisor point, array of points or x\n * @param b Divisor y value\n * @param c Divisor z value\n * @returns\n */\n//eslint-disable-next-line functional/prefer-readonly-type\nexport function divider(a: Point | number | Array<number>, b?: number, c?: number) {\n  const divisor = getPointParameter(a, b, c);\n  guardNonZeroPoint(divisor, `divisor`);\n\n  return (\n    aa: Point | number | Array<number>,\n    bb?: number,\n    cc?: number\n  ): Point | Point3d => {\n    const dividend = getPointParameter(aa, bb, cc);\n\n    return typeof dividend.z === `undefined` ? Object.freeze({\n      x: dividend.x / divisor.x,\n      y: dividend.y / divisor.y,\n    }) : Object.freeze({\n      x: dividend.x / divisor.x,\n      y: dividend.y / divisor.y,\n      z: dividend.z / (divisor.z ?? 1),\n    });\n  };\n}\n","import type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { divide as PointDivide } from '../point/Divider.js';\n/**\n * Divides both start and end points by given x,y\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.divide(l, {x:2, y:4});\n * // Yields: 0.5,0.25 -> 5,2.5\n * ```\n * \n * Dividing by zero will give Infinity for that dimension.\n * @param line \n * @param point \n * @returns \n */\nexport const divide = (line: Line, point: Point): Line => Object.freeze({\n  ...line,\n  a: PointDivide(line.a, point),\n  b: PointDivide(line.b, point)\n});","import { fromNumbers } from \"./FromNumbers.js\";\nimport type { Line } from \"./LineType.js\";\n\n/**\n * Returns a line from four numbers [x1,y1,x2,y2].\n * \n * See {@link toFlatArray} to create an array from a line.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const line = Lines.fromFlatArray(...[0, 0, 100, 100]);\n * // line is {a: { x:0, y:0 }, b: { x: 100, y: 100 } }\n * ```\n * @param array Array in the form [x1,y1,x2,y2]\n * @returns Line\n */\nexport const fromFlatArray = (array: ReadonlyArray<number>): Line => {\n  if (!Array.isArray(array)) throw new Error(`arr parameter is not an array`);\n  if (array.length !== 4) throw new Error(`array is expected to have length four`);\n  return fromNumbers(array[ 0 ], array[ 1 ], array[ 2 ], array[ 3 ]);\n};","import { degreeToRadian, radianToDegree } from './Angles.js';\nimport { throwNumberTest } from \"../util/GuardNumbers.js\";\nimport type { Point } from './point/PointType.js';\nimport { subtract } from './point/Subtract.js';\nimport { Empty } from './point/Empty.js';\nimport { isPoint, guard as PointGuard } from './point/Guard.js';\n\n//eslint-disable-next-line @typescript-eslint/naming-convention\nconst EmptyCartesian = Object.freeze({ x: 0, y: 0 });\n\n/**\n * Polar coordinate, made up of a distance and angle in radians.\n * Most computations involving PolarCoord require an `origin` as well.\n */\nexport type Coord = {\n  readonly distance: number;\n  readonly angleRadian: number;\n};\n\n/**\n * Converts to Cartesian coordiantes\n */\ntype ToCartesian = {\n  (point: Coord, origin?: Point): Point;\n  (distance: number, angleRadians: number, origin?: Point): Point;\n};\n\n/**\n * Returns true if `p` seems to be a {@link Polar.Coord} (ie has both distance & angleRadian fields)\n * @param p\n * @returns True if `p` seems to be a PolarCoord\n */\nexport const isPolarCoord = (p: unknown): p is Coord => {\n  if ((p as Coord).distance === undefined) return false;\n  if ((p as Coord).angleRadian === undefined) return false;\n  return true;\n};\n\n/**\n * Converts a Cartesian coordinate to polar\n *\n * ```js\n * import { Polar } from 'https://unpkg.com/ixfx/dist/geometry.js';\n *\n * // Yields: { angleRadian, distance }\n * const polar = Polar.fromCartesian({x: 50, y: 50}, origin);\n * ```\n *\n * Any additional properties of `point` are copied to object.\n * @param point Point\n * @param origin Origin\n * @returns\n */\nexport const fromCartesian = (\n  point: Point,\n  origin: Point\n): Coord => {\n  point = subtract(point, origin);\n  //eslint-disable-next-line functional/no-let\n  //let a =  Math.atan2(point.y, point.x);\n  //if (a < 0) a = Math.abs(a);\n  //else a = Math.PI + (Math.PI - a);\n\n  const angle = Math.atan2(point.y, point.x);\n  //if (point.x < 0 && point.y > 0) angle += 180;\n  //if (point.x > 0 && point.y < 0) angle += 360;\n  //if (point.x < 0 && point.y < 0) angle += 180;\n\n  return Object.freeze({\n    ...point,\n    angleRadian: angle,\n    distance: Math.hypot(point.x, point.y),\n  });\n};\n\n/**\n * Converts to Cartesian coordinate from polar.\n *\n * ```js\n * import { Polar } from 'https://unpkg.com/ixfx/dist/geometry.js';\n *\n * const origin = { x: 50, y: 50}; // Polar origin\n * // Yields: { x, y }\n * const polar = Polar.toCartesian({ distance: 10, angleRadian: 0 }, origin);\n * ```\n *\n * Distance and angle can be provided as numbers intead:\n *\n * ```\n * // Yields: { x, y }\n * const polar = Polar.toCartesian(10, 0, origin);\n * ```\n *\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const toCartesian: ToCartesian = (\n  a: Coord | number,\n  b?: Point | number,\n  c?: Point\n): Point => {\n  if (isPolarCoord(a)) {\n    if (b === undefined) b = Empty;\n    if (isPoint(b)) {\n      return polarToCartesian(a.distance, a.angleRadian, b);\n    }\n    throw new Error(\n      `Expecting (Coord, Point). Second parameter is not a point`\n    );\n  } else if (typeof a === `object`) {\n    throw new TypeError(\n      `First param is an object, but not a Coord: ${ JSON.stringify(a) }`\n    );\n  } else {\n    if (typeof a === `number` && typeof b === `number`) {\n      if (c === undefined) c = Empty;\n      if (!isPoint(c)) {\n        throw new Error(\n          `Expecting (number, number, Point). Point param wrong type`\n        );\n      }\n      return polarToCartesian(a, b, c);\n    } else {\n      throw new TypeError(\n        `Expecting parameters of (number, number). Got: (${ typeof a }, ${ typeof b }, ${ typeof c }). a: ${ JSON.stringify(\n          a\n        ) }`\n      );\n    }\n  }\n};\n\n/**\n * Produces an Archimedean spiral. It's a generator.\n *\n * ```js\n * const s = spiral(0.1, 1);\n * for (const coord of s) {\n *  // Use Polar coord...\n *  if (coord.step === 1000) break; // Stop after 1000 iterations\n * }\n * ```\n *\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\n */\n//eslint-disable-next-line func-style\nexport function* spiral(\n  smoothness: number,\n  zoom: number\n): IterableIterator<Coord & { readonly step: number }> {\n  //eslint-disable-next-line functional/no-let\n  let step = 0;\n\n  while (true) {\n    //eslint-disable-next-line functional/no-let\n    const a = smoothness * step++;\n    yield {\n      distance: zoom * a,\n      angleRadian: a,\n      step: step,\n    };\n  }\n}\n\n/**\n * Returns a rotated coordinate\n * @param c Coordinate\n * @param amountRadian Amount to rotate, in radians\n * @returns\n */\nexport const rotate = (c: Coord, amountRadian: number): Coord =>\n  Object.freeze({\n    ...c,\n    angleRadian: c.angleRadian + amountRadian,\n  });\n\nexport const normalise = (c: Coord): Coord => {\n  //guard(v, `v`);\n  if (c.distance === 0) throw new Error(`Cannot normalise vector of length 0`);\n  return Object.freeze({\n    ...c,\n    distance: 1,\n  });\n};\n\n/**\n * Throws an error if Coord is invalid\n * @param p\n * @param name\n */\nexport const guard = (p: Coord, name = `Point`) => {\n  if (p === undefined) {\n    throw new Error(\n      `'${ name }' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p === null) {\n    throw new Error(\n      `'${ name }' is null. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p.angleRadian === undefined) {\n    throw new Error(\n      `'${ name }.angleRadian' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p.distance === undefined) {\n    throw new Error(\n      `'${ name }.distance' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (typeof p.angleRadian !== `number`) {\n    throw new TypeError(\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      `'${ name }.angleRadian' must be a number. Got ${ p.angleRadian }`\n    );\n  }\n  if (typeof p.distance !== `number`) {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new TypeError(`'${ name }.distance' must be a number. Got ${ p.distance }`);\n  }\n\n  if (p.angleRadian === null) throw new Error(`'${ name }.angleRadian' is null`);\n  if (p.distance === null) throw new Error(`'${ name }.distance' is null`);\n\n  if (Number.isNaN(p.angleRadian)) {\n    throw new TypeError(`'${ name }.angleRadian' is NaN`);\n  }\n  if (Number.isNaN(p.distance)) throw new Error(`'${ name }.distance' is NaN`);\n};\n/**\n * Calculate dot product of two PolarCoords.\n *\n * Eg, power is the dot product of force and velocity\n *\n * Dot products are also useful for comparing similarity of\n *  angle between two unit PolarCoords.\n * @param a\n * @param b\n * @returns\n */\nexport const dotProduct = (a: Coord, b: Coord): number => {\n  guard(a, `a`);\n  guard(b, `b`);\n  return a.distance * b.distance * Math.cos(b.angleRadian - a.angleRadian);\n};\n\n/**\n * Inverts the direction of coordinate. Ie if pointing north, will point south.\n * @param p\n * @returns\n */\nexport const invert = (p: Coord): Coord => {\n  guard(p, `c`);\n  return Object.freeze({\n    ...p,\n    angleRadian: p.angleRadian - Math.PI,\n  });\n};\n\n/**\n * Returns true if PolarCoords have same magnitude but opposite direction\n * @param a\n * @param b\n * @returns\n */\nexport const isOpposite = (a: Coord, b: Coord): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n  if (a.distance !== b.distance) return false;\n  return a.angleRadian === -b.angleRadian;\n};\n\n/**\n * Returns true if Coords have the same direction, regardless of magnitude\n * @param a\n * @param b\n * @returns\n */\nexport const isParallel = (a: Coord, b: Coord): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n  return a.angleRadian === b.angleRadian;\n};\n\n/**\n * Returns true if coords are opposite direction, regardless of magnitude\n * @param a\n * @param b\n * @returns\n */\nexport const isAntiParallel = (a: Coord, b: Coord): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n  return a.angleRadian === -b.angleRadian;\n};\n\n/**\n * Returns a rotated coordinate\n * @param c Coordinate\n * @param amountDeg Amount to rotate, in degrees\n * @returns\n */\nexport const rotateDegrees = (c: Coord, amountDeg: number): Coord =>\n  Object.freeze({\n    ...c,\n    angleRadian: c.angleRadian + degreeToRadian(amountDeg),\n  });\n\n/**\n * Produces an Archimedian spiral with manual stepping.\n * @param step Step number. Typically 0, 1, 2 ...\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\n * @returns\n */\nexport const spiralRaw = (\n  step: number,\n  smoothness: number,\n  zoom: number\n): Coord => {\n  const a = smoothness * step;\n  return Object.freeze({\n    distance: zoom * a,\n    angleRadian: a,\n  });\n};\n\n/**\n * Multiplies the magnitude of a coord by `amt`.\n * Direction is unchanged.\n * @param v\n * @param amt\n * @returns\n */\nexport const multiply = (v: Coord, amt: number): Coord => {\n  guard(v);\n  throwNumberTest(amt, ``, `amt`);\n  return Object.freeze({\n    ...v,\n    distance: v.distance * amt,\n  });\n};\n\n/**\n * Divides the magnitude of a coord by `amt`.\n * Direction is unchanged.\n * @param v\n * @param amt\n * @returns\n */\nexport const divide = (v: Coord, amt: number): Coord => {\n  guard(v);\n  throwNumberTest(amt, ``, `amt`);\n  return Object.freeze({\n    ...v,\n    distance: v.distance / amt,\n  });\n};\n\n/**\n * Clamps the magnitude of a vector\n * @param v\n * @param max\n * @param min\n * @returns\n */\nexport const clampMagnitude = (v: Coord, max = 1, min = 0): Coord => {\n  let mag = v.distance;\n  if (mag > max) mag = max;\n  if (mag < min) mag = min;\n  return Object.freeze({\n    ...v,\n    distance: mag,\n  });\n};\n\n/**\n * Converts a polar coordinate to Cartesian\n * @param distance Distance\n * @param angleRadians Angle in radians\n * @param origin Origin, or 0,0 by default.\n * @returns\n */\nconst polarToCartesian = (\n  distance: number,\n  angleRadians: number,\n  origin: Point = Empty\n): Point => {\n  PointGuard(origin);\n  return Object.freeze({\n    x: origin.x + distance * Math.cos(angleRadians),\n    y: origin.y + distance * Math.sin(angleRadians),\n  });\n};\n\n/**\n * Returns a human-friendly string representation `(distance, angleDeg)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport const toString = (p: Coord, digits?: number): string => {\n  if (p === undefined) return `(undefined)`;\n  if (p === null) return `(null)`;\n\n  const angleDeg = radianToDegree(p.angleRadian);\n  const d = digits ? p.distance.toFixed(digits) : p.distance;\n  const a = digits ? angleDeg.toFixed(digits) : angleDeg;\n  return `(${ d },${ a })`;\n};\n\nexport const toPoint = (v: Coord, origin = EmptyCartesian): Point => {\n  guard(v, `v`);\n  return Object.freeze({\n    x: origin.x + v.distance * Math.cos(v.angleRadian),\n    y: origin.y + v.distance * Math.sin(v.angleRadian),\n  });\n};\n","import type { Point } from './point/PointType.js';\n/**\n * Convert angle in degrees to angle in radians.\n * @param angleInDegrees \n * @returns \n */\nexport function degreeToRadian(angleInDegrees: number): number;\n\n/**\n * Convert angles in degrees to angles in radians\n * @param angleInDegrees \n */\nexport function degreeToRadian(angleInDegrees: ReadonlyArray<number>): ReadonlyArray<number>;\n\n//eslint-disable-next-line func-style\nexport function degreeToRadian(angleInDegrees: number | ReadonlyArray<number>): number | ReadonlyArray<number> {\n  return Array.isArray(angleInDegrees) ? angleInDegrees.map(v => v * (Math.PI / 180)) : (angleInDegrees as number) * (Math.PI / 180);\n}\n\nexport function radianInvert(angleInRadians: number) {\n  return (angleInRadians + Math.PI) % (2 * Math.PI);\n}\n\n/**\n * Convert angle in radians to angle in degrees\n * @param angleInRadians\n * @returns \n */\nexport function radianToDegree(angleInRadians: number): number;\n\n/**\n * Convert angles in radians to angles in degrees\n * @param angleInRadians \n */\nexport function radianToDegree(angleInRadians: ReadonlyArray<number>): ReadonlyArray<number>;\n\n//eslint-disable-next-line func-style\nexport function radianToDegree(angleInRadians: number | ReadonlyArray<number>): number | ReadonlyArray<number> {\n  return Array.isArray(angleInRadians) ? angleInRadians.map(v => v * 180 / Math.PI) : (angleInRadians as number) * 180 / Math.PI;\n}\n\n\n/**\n * Angle from x-axis to point (ie. `Math.atan2`)\n * @param point \n * @returns \n */\nexport const radiansFromAxisX = (point: Point): number => Math.atan2(point.x, point.y);\n","import { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport { guard, isPoint } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Returns `a` minus `b`\n *\n * ie.\n * ```js\n * return {\n *   x: a.x - b.x,\n *   y: a.y - b.y\n * };\n * ```\n * @param a Point a\n * @param b Point b\n * @returns Point\n */\nexport function subtract(a: Point, b: Point): Point;\n\n/**\n * Returns `a` minus the given coordinates.\n *\n * ie:\n * ```js\n * return {\n *  x: a.x - x,\n *  y: a.y - y\n * }\n * ```\n * @param a Point\n * @param x X coordinate\n * @param y Y coordinate (if omitted, x is used as well)\n */\nexport function subtract(a: Point, x: number, y?: number): Point;\n\n/**\n * Subtracts two sets of x,y pairs.\n *\n * If first parameter is a Point, any additional properties of it\n * are included in returned Point.\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n */\nexport function subtract(x1: number, y1: number, x2: number, y2: number): Point;\n\n//eslint-disable-next-line func-style\nexport function subtract(\n  a: Point | number,\n  b: Point | number,\n  c?: number,\n  d?: number\n): Point {\n  if (isPoint(a)) {\n    guard(a, `a`);\n    if (isPoint(b)) {\n      guard(b, `b`);\n      return Object.freeze({\n        ...a,\n        x: a.x - b.x,\n        y: a.y - b.y,\n      });\n    } else {\n      if (c === undefined) c = b;\n      return Object.freeze({\n        ...a,\n        x: a.x - b,\n        y: a.y - c,\n      });\n    }\n  } else {\n    throwNumberTest(a, ``, `a`);\n    if (typeof b !== `number`) {\n      throw new TypeError(`Second parameter is expected to by y value`);\n    }\n    throwNumberTest(b, ``, `b`);\n\n    if (Number.isNaN(c)) throw new Error(`Third parameter is NaN`);\n    if (Number.isNaN(d)) throw new Error(`Fourth parameter is NaN`);\n\n    if (c === undefined) c = 0;\n    if (d === undefined) d = 0;\n    return Object.freeze({\n      x: a - c,\n      y: b - d,\n    });\n  }\n}\n","/**\n * An empty point of `{ x:0, y:0 }`.\n *\n * Use `isEmpty` to check if a point is empty.\n */\nexport const Empty = { x: 0, y: 0 } as const;","import type { Point } from \"../point/PointType.js\"\nimport * as Polar from \"../Polar.js\";\nimport { radianInvert } from \"../Angles.js\";\n\n/**\n * Creates a line from an origin point.\n * ```js\n * // Line of length 0.2 with middle at 0.5,0.5\n * fromPivot({ x:0.5, y:0.5 }, 0.2);\n * // Same line, but on an angle\n * fromPivot({ x:0.5, y:0.5 }, 0.2, degreesToRadian(45));\n * \n * // ...now with pivot point at 20%, rather than center\n * fromPivot({ x:0.5, y:0.5 }, 0.2, degreesToRadian(45), 0.2);\n * ```\n * \n * Examples:\n * * Angle of 0 (deg/rad) results in a horizontal line,\n * * Angle of 90deg in a vertical line. \n * * Angle of 45deg will be angled downwards.\n * \n * @param origin Origin to pivot around\n * @param length Total length of line\n * @param angleRadian Angle of line, in radians\n * @param balance Percentage of where origin ought to be on line. Default: 0.5, meaning the middle of line\n */\nexport const fromPivot = (origin: Point = { x: 0.5, y: 0.5 }, length: number = 1, angleRadian: number = 0, balance: number = 0.5) => {\n  const left = length * balance;\n  const right = length * (1 - balance);\n  const a = Polar.toCartesian(left, radianInvert(angleRadian), origin);\n  const b = Polar.toCartesian(right, angleRadian, origin);\n  return Object.freeze({\n    a, b\n  });\n}","import type { Point } from \"../point/PointType.js\";\nimport { fromPoints } from \"./FromPoints.js\";\nimport type { LinePath } from \"./LinePathType.js\";\nimport { toPath } from \"./ToPath.js\";\n\n/**\n * Returns a {@link LinePath} from two points\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const path = Lines.fromPointsToPath(ptA, ptB);\n * ```\n * @param a \n * @param b \n * @returns \n */\nexport const fromPointsToPath = (a: Point, b: Point): LinePath => toPath(fromPoints(a, b));\n","import type { Point } from \"./PointType.js\";\n\n/**\n * Returns _true_ if the points have identical values\n *\n * ```js\n * const a = {x: 10, y: 10};\n * const b = {x: 10, y: 10;};\n * a === b        // False, because a and be are different objects\n * isEqual(a, b)   // True, because a and b are same value\n * ```\n * @param p Points\n * @returns _True_ if points are equal\n */\nexport const isEqual = (...p: ReadonlyArray<Point>): boolean => {\n  if (p === undefined) throw new Error(`parameter 'p' is undefined`);\n  if (p.length < 2) return true;\n\n  for (let index = 1; index < p.length; index++) {\n    if (p[ index ].x !== p[ 0 ].x) return false;\n    if (p[ index ].y !== p[ 0 ].y) return false;\n  }\n  return true;\n};","import type { Line } from \"./LineType.js\";\nimport { isEqual as PointsIsEqual } from '../point/IsEqual.js';\n/**\n * Returns true if the lines have the same value. Note that only\n * the line start and end points are compared. So the lines might\n * be different in other properties, and `isEqual` will still return\n * true.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const a = { a: {x:0,  y: 10 }, b: { x: 20, y: 20 }};\n * const b = { a: {x:0,  y: 10 }, b: { x: 20, y: 20 }};\n * a === b; // false, because they are different objects\n * Lines.isEqual(a, b); // true, because they have the same value\n * ```\n * @param {Line} a\n * @param {Line} b\n * @returns {boolean}\n */\nexport const isEqual = (a: Line, b: Line): boolean => PointsIsEqual(a.a, b.a) && PointsIsEqual(a.b, b.b);","export * from './Abs.js';\nexport * from './Angle.js';\nexport * from './Apply.js';\nexport * from './Bbox.js';\nexport * from './Centroid.js';\nexport * from './Clamp.js';\nexport * from './Compare.js';\nexport * from './ConvexHull.js';\nexport * from './Distance.js';\nexport * from './DistanceToCenter.js';\nexport * from './DistanceToExterior.js';\nexport * from './Divider.js';\nexport * from './DotProduct.js';\nexport * from './Empty.js';\nexport * from './FindMinimum.js';\nexport * from './From.js';\nexport * from './GetPointParameter.js';\nexport * from './Guard.js';\nexport * from './Interpolate.js';\nexport * from './Invert.js';\nexport * from './IsEqual.js';\nexport * from './Magnitude.js';\nexport * from './Most.js';\nexport * from './Multiply.js';\nexport * from './Normalise.js';\nexport * from './NormaliseByRect.js';\nexport * from './Pipeline.js';\nexport * from './PointRelationTypes.js';\nexport * from './PointType.js';\nexport * from './ProgressBetween.js';\nexport * from './Project.js';\nexport * from './Quantise.js';\nexport * from './Random.js';\nexport * from './Reduce.js';\nexport * from './Relation.js';\nexport * from './Rotate.js';\nexport * from './RotatePointArray.js';\nexport * from './Round.js';\nexport * from './Subtract.js';\nexport * from './Sum.js';\nexport * from './To.js';\nexport * from './ToArray.js';\nexport * from './WithinRange.js';\nexport * from './Wrap.js';\nexport type { Point, Point3d } from './PointType.js';\n","import type { Point } from \"./PointType.js\";\n\n/**\n * Returns a point with Math.abs applied to x and y.\n * ```js\n * Points.abs({ x:1,  y:1  }); // { x: 1, y: 1 }\n * Points.abs({ x:-1, y:1  }); // { x: 1, y: 1 }\n * Points.abs({ x:-1, y:-1 }); // { x: 1, y: 1 }\n * ```\n * @param pt\n * @returns\n */\nexport const abs = (pt: Point) => ({\n  ...pt,\n  x: Math.abs(pt.x),\n  y: Math.abs(pt.y),\n});","import { guard } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Returns the angle in radians between `a` and `b`.\n *\n * Eg if `a` is the origin, and `b` is another point,\n * in degrees one would get 0 to -180 when `b` was above `a`.\n *  -180 would be `b` in line with `a`.\n * Same for under `a`.\n *\n * Providing a third point `c` gives the interior angle, where `b` is the middle point.\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const angleRadian = (a: Point, b?: Point, c?: Point) => {\n  guard(a, `a`);\n\n  if (b === undefined) {\n    return Math.atan2(a.y, a.x);\n  }\n  guard(b, `b`);\n  if (c === undefined) {\n    return Math.atan2(b.y - a.y, b.x - a.x);\n  }\n\n  guard(c, `c`);\n  return Math.atan2(b.y - a.y, b.x - a.x) - Math.atan2(c.y - a.y, c.x - a.x);\n};","import { guard } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Applies `fn` on `x` and `y` fields, returning all other fields as well\n * ```js\n * const p = {x:1.234, y:4.9};\n * const p2 = Points.apply(p, Math.round);\n * // Yields: {x:1, y:5}\n * ```\n *\n * The name of the field is provided as well. Here we only round the `x` field:\n *\n * ```js\n * const p = {x:1.234, y:4.9};\n * const p2 = Points.apply(p, (v, field) => {\n *  if (field === `x`) return Math.round(v);\n *  return v;\n * });\n * ```\n * @param pt\n * @param fn\n * @returns\n */\nexport const apply = (\n  pt: Point,\n  fn: (v: number, field?: string) => number\n): Point => {\n  guard(pt, `pt`);\n\n  return Object.freeze<Point>({\n    ...pt,\n    x: fn(pt.x, `x`),\n    y: fn(pt.y, `y`),\n  });\n}","import { isPoint } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Calculates the [centroid](https://en.wikipedia.org/wiki/Centroid#Of_a_finite_set_of_points) of a set of points\n * Undefined values are skipped over.\n *\n * ```js\n * // Find centroid of a list of points\n * const c1 = centroid(p1, p2, p3, ...);\n *\n * // Find centroid of an array of points\n * const c2 = centroid(...pointsArray);\n * ```\n * @param points\n * @returns A single point\n */\nexport const centroid = (...points: ReadonlyArray<Point | undefined>): Point => {\n  if (!Array.isArray(points)) throw new Error(`Expected list of points`);\n  // eslint-disable-next-line unicorn/no-array-reduce\n  const sum = points.reduce<Point>(\n    (previous, p) => {\n      if (p === undefined) return previous; // Ignore undefined\n      if (Array.isArray(p)) {\n        throw new TypeError(\n          `'points' list contains an array. Did you mean: centroid(...myPoints)?`\n        );\n      }\n      if (!isPoint(p)) {\n        throw new Error(\n          `'points' contains something which is not a point: ${ JSON.stringify(\n            p\n          ) }`\n        );\n      }\n      return {\n        x: previous.x + p.x,\n        y: previous.y + p.y,\n      };\n    },\n    { x: 0, y: 0 }\n  );\n\n  return Object.freeze({\n    x: sum.x / points.length,\n    y: sum.y / points.length,\n  });\n};\n\n","import { clamp as clampNumber } from '../../numbers/Clamp.js';\nimport { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport { isPoint } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\n\n/**\n * Clamps a point to be between `min` and `max` (0 & 1 by default)\n * @param pt Point\n * @param min Minimum value (0 by default)\n * @param max Maximum value (1 by default)\n */\nexport function clamp(pt: Point, min?: number, max?: number): Point;\n\n/**\n * Clamps an x,y pair to be between `min` and `max` (0 & 1 by default)\n * @param x X coordinate\n * @param y Y coordinate\n * @param min Minimum value (0 by default)\n * @param max Maximum value (1 by default)\n */\nexport function clamp(x: number, y: number, min?: number, max?: number): Point;\nexport function clamp(\n  a: Point | number,\n  b?: number,\n  c?: number,\n  d?: number\n): Point {\n  // ✔️ Unit tested\n\n  if (isPoint(a)) {\n    if (b === undefined) b = 0;\n    if (c === undefined) c = 1;\n    throwNumberTest(b, ``, `min`);\n    throwNumberTest(c, ``, `max`);\n    return Object.freeze({\n      x: clampNumber(a.x, b, c),\n      y: clampNumber(a.y, b, c),\n    });\n  } else {\n    if (b === undefined) throw new Error(`Expected y coordinate`);\n    if (c === undefined) c = 0;\n    if (d === undefined) d = 1;\n    throwNumberTest(a, ``, `x`);\n    throwNumberTest(b, ``, `y`);\n    throwNumberTest(c, ``, `min`);\n    throwNumberTest(d, ``, `max`);\n\n    return Object.freeze({\n      x: clampNumber(a, c, d),\n      y: clampNumber(b, c, d),\n    });\n  }\n}\n","import type { Point } from \"./PointType.js\";\n\n/**\n * Returns -2 if both x & y of a is less than b\n * Returns -1 if either x/y of a is less than b\n *\n * Returns 2 if both x & y of a is greater than b\n * Returns 1 if either x/y of a is greater than b's x/y\n *\n * Returns 0 if x/y of a and b are equal\n * @param a\n * @param b\n * @returns\n */\nexport const compare = (a: Point, b: Point): number => {\n  if (a.x < b.x && a.y < b.y) return -2;\n  if (a.x > b.x && a.y > b.y) return 2;\n  if (a.x < b.x || a.y < b.y) return -1;\n  if (a.x > b.x || a.y > b.y) return 1;\n  if (a.x === b.x && a.x === b.y) return 0;\n  return Number.NaN;\n};\n\n/**\n * Compares points based on x value. Y value is ignored.\n * \n * Return values:\n * * 0: If a.x === b.x\n * * 1: a is to the right of b (ie. a.x > b.x)\n * * -1: a is to the left of b (ie. a.x < b.x)\n *\n * @example Sorting by x\n * ```js\n * arrayOfPoints.sort(Points.compareByX);\n * ```\n * \n * @param a\n * @param b\n * @returns\n */\nexport const compareByX = (a: Point, b: Point): number => {\n  if (a.x === b.x) return 0;\n  if (a.x < b.x) return -1;\n  return 1;\n\n  // a.x - b.x || a.y - b.y;\n}\n\n/**\n * Compares points based on Y value. X value is ignored.\n * Returns values:\n * * 0: If a.y === b.y\n * * 1: A is below B (ie. a.y > b.y)\n * * -1: A is above B (ie. a.y < b.y)\n *\n * @example Sorting by Y\n * ```js\n * arrayOfPoints.sort(Points.compareByY);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const compareByY = (a: Point, b: Point): number => {\n  if (a.y === b.y) return 0;\n  if (a.y < b.y) return -1;\n  return 1;\n}","import { compareByX } from \"./Compare.js\";\nimport { isEqual } from \"./IsEqual.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Simple convex hull impementation. Returns a set of points which\n * enclose `pts`.\n *\n * For more power, see something like [Hull.js](https://github.com/AndriiHeonia/hull)\n * @param pts\n * @returns\n */\nexport const convexHull = (...pts: ReadonlyArray<Point>): ReadonlyArray<Point> => {\n  const sorted = [ ...pts ].sort(compareByX);\n  if (sorted.length === 1) return sorted;\n\n  const x = (points: Array<Point>) => {\n    const v: Array<Point> = [];\n    for (const p of points) {\n      while (v.length >= 2) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const q = v.at(-1)!;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const r = v.at(-2)!;\n        if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) {\n          //eslint-disable-next-line functional/immutable-data\n          v.pop();\n        } else break;\n      }\n      //eslint-disable-next-line functional/immutable-data\n      v.push(p);\n    }\n    //eslint-disable-next-line functional/immutable-data\n    v.pop();\n    return v;\n  };\n\n  const upper = x(sorted);\n  //eslint-disable-next-line functional/immutable-data\n  const lower = x(sorted.reverse());\n\n  if (upper.length === 1 && lower.length === 1 && isEqual(lower[ 0 ], upper[ 0 ])) {\n    return upper;\n  }\n  return [ ...upper, ...lower ];\n};","import { guard as guardPoint } from '../point/Guard.js';\nimport type { Point } from '../point/PointType.js';\nimport type { Circle, CirclePositioned } from './CircleType.js';\n\n/**\n * Throws if radius is out of range. If x,y is present, these will be validated too.\n * @param circle \n * @param parameterName \n */\nexport const guard = (circle: CirclePositioned | Circle, parameterName = `circle`) => {\n  if (isCirclePositioned(circle)) {\n    guardPoint(circle, `circle`);\n  }\n\n  if (Number.isNaN(circle.radius)) throw new Error(`${ parameterName }.radius is NaN`);\n  if (circle.radius <= 0) throw new Error(`${ parameterName }.radius must be greater than zero`);\n};\n\n/**\n * Throws if `circle` is not positioned or has dodgy fields\n * @param circle \n * @param parameterName \n * @returns \n */\nexport const guardPositioned = (circle: CirclePositioned, parameterName = `circle`) => {\n  if (!isCirclePositioned(circle)) throw new Error(`Expected a positioned circle with x,y`);\n  guard(circle, parameterName);\n};\n\n/***\n * Returns true if radius, x or y are NaN\n */\nexport const isNaN = (a: Circle | CirclePositioned): boolean => {\n  if (Number.isNaN(a.radius)) return true;\n  if (isCirclePositioned(a)) {\n    if (Number.isNaN(a.x)) return true;\n    if (Number.isNaN(a.y)) return true;\n  }\n  return false;\n};\n\n\n/**\n * Returns true if parameter has x,y. Does not verify if parameter is a circle or not\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * \n * const circleA = { radius: 5 };\n * Circles.isPositioned(circle); // false\n * \n * const circleB = { radius: 5, x: 10, y: 10 }\n * Circles.isPositioned(circle); // true\n * ```\n * @param p Circle\n * @returns \n */\nexport const isPositioned = (p: Circle | Point): p is Point => (p as Point).x !== undefined && (p as Point).y !== undefined;\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isCircle = (p: any): p is Circle => (p as Circle).radius !== undefined;\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isCirclePositioned = (p: any): p is CirclePositioned => isCircle(p) && isPositioned(p);","import type { CirclePositioned } from \"./CircleType.js\";\nimport { distance as pointsDistance } from '../point/Distance.js';\nimport { guardPositioned, isCirclePositioned } from \"./Guard.js\";\nimport type { Point } from '../point/PointType.js';\n\n/**\n * Returns the distance between two circle centers.\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * const circleA = { radius: 5, x: 5, y: 5 }\n * const circleB = { radius: 10, x: 20, y: 20 }\n * const distance = Circles.distanceCenter(circleA, circleB);\n * ```\n * Throws an error if either is lacking position.\n * @param a \n * @param b \n * @returns Distance\n */\nexport const distanceCenter = (a: CirclePositioned, b: CirclePositioned | Point): number => {\n  guardPositioned(a, `a`);\n  if (isCirclePositioned(b)) {\n    guardPositioned(b, `b`);\n  }\n  return pointsDistance(a, b);\n};\n","import type { CirclePositioned } from \"./CircleType.js\";\nimport { distanceCenter } from \"./DistanceCenter.js\";\nimport { isPoint as PointsIsPoint } from \"../point/Guard.js\";\nimport { distance as PointsDistance } from \"../point/Distance.js\";\nimport { guardPositioned, isCirclePositioned } from \"./Guard.js\";\nimport type { Point } from '../point/PointType.js';\n\n/**\n * Returns the distance between the exterior of two circles, or between the exterior of a circle and point.\n * If `b` overlaps or is enclosed by `a`, distance is 0.\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * const circleA = { radius: 5, x: 5, y: 5 }\n * const circleB = { radius: 10, x: 20, y: 20 }\n * const distance = Circles.distanceCenter(circleA, circleB);\n * ```\n * @param a\n * @param b \n */\nexport const distanceFromExterior = (a: CirclePositioned, b: CirclePositioned | Point): number => {\n  guardPositioned(a, `a`);\n  if (isCirclePositioned(b)) {\n    return Math.max(0, distanceCenter(a, b) - a.radius - b.radius);\n  } else if (PointsIsPoint(b)) {\n    const distribution = PointsDistance(a, b);\n    if (distribution < a.radius) return 0;\n    return distribution;\n  } else throw new Error(`Second parameter invalid type`);\n};","import type { Circle, CirclePositioned } from \"./CircleType.js\";\nimport { isCirclePositioned } from \"./Guard.js\";\n\n/**\n * Returns true if the two objects have the same values\n *\n * ```js\n * const circleA = { radius: 10, x: 5, y: 5 };\n * const circleB = { radius: 10, x: 5, y: 5 };\n * \n * circleA === circleB; // false, because identity of objects is different\n * Circles.isEqual(circleA, circleB); // true, because values are the same\n * ```\n * \n * Circles must both be positioned or not.\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (a: CirclePositioned | Circle, b: CirclePositioned | Circle): boolean => {\n  if (a.radius !== b.radius) return false;\n\n  if (isCirclePositioned(a) && isCirclePositioned(b)) {\n    if (a.x !== b.x) return false;\n    if (a.y !== b.y) return false;\n    if (a.z !== b.z) return false;\n    return true;\n  } else if (!isCirclePositioned(a) && !isCirclePositioned(b)) {\n    // no-op\n  } else return false; // one is positioned one not\n\n  return false;\n};","import { Empty } from \"./Empty.js\";\nimport { guard, isPoint } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\ntype Sum = {\n  /**\n   * Adds two sets of coordinates. If y is omitted, the parameter for x is added to both x and y\n   */\n  (aX: number, aY: number, bX: number, bY: number): Point;\n  /**\n   * Add x,y to a\n   */\n  (a: Point, x: number, y?: number): Point;\n  /**\n   * Add two points\n   */\n  (a: Point, b?: Point): Point;\n};\n\n/**\n * Returns a Point of `a` plus `b`. ie:\n *\n * ```js\n * return {\n *   x: a.x + b.x,\n *   y: a.y + b.y\n * };\n * ```\n *\n * Usage:\n *\n * ```js\n * sum(ptA, ptB);\n * sum(x1, y1, x2, y2);\n * sum(ptA, x2, y2);\n * sum(ptA, xAndY);\n * ```\n */\nexport const sum: Sum = function (\n  a: Point | number,\n  b: Point | number | undefined,\n  c?: number,\n  d?: number\n): Point {\n  // ✔️ Unit tested\n  if (a === undefined) throw new TypeError(`a missing`);\n\n  let ptA: Point | undefined;\n  let ptB: Point | undefined;\n  if (isPoint(a)) {\n    ptA = a;\n    if (b === undefined) b = Empty;\n    if (isPoint(b)) {\n      ptB = b;\n    } else {\n      if (b === undefined) throw new Error(`Expects x coordinate`);\n      ptB = { x: b, y: c ?? b };\n    }\n  } else if (!isPoint(b)) {\n    // Neither of first two params are points\n    if (b === undefined) throw new Error(`Expected number as second param`);\n    ptA = { x: a, y: b };\n    if (c === undefined) throw new Error(`Expects x coordiante`);\n    ptB = { x: c, y: d ?? 0 };\n  }\n\n  if (ptA === undefined) throw new Error(`ptA missing. a: ${ JSON.stringify(a) }`);\n  if (ptB === undefined) throw new Error(`ptB missing. b: ${ JSON.stringify(b) }`);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  return Object.freeze({\n    x: ptA.x + ptB.x,\n    y: ptA.y + ptB.y,\n  });\n};\n","import { isEqual } from \"./IsEqual.js\";\nimport { sum as PointsSum } from \"../point/Sum.js\";\nimport { subtract as PointsSubtract } from \"../point/Subtract.js\";\nimport type { Point } from '../point/PointType.js';\nimport type { CirclePositioned } from \"./CircleType.js\";\nimport type { Line } from \"../line/LineType.js\";\n\n/**\n * Returns the point(s) of intersection between a circle and line.\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * const circle = { radius: 5, x: 5, y: 5 };\n * const line = { a: { x: 0, y: 0 }, b: { x: 10, y: 10 } };\n * const pts = Circles.intersectionLine(circle, line);\n * ```\n * @param circle \n * @param line \n * @returns Point(s) of intersection, or empty array\n */\nexport const intersectionLine = (circle: CirclePositioned, line: Line): ReadonlyArray<Point> => {\n  const v1 = {\n    x: line.b.x - line.a.x,\n    y: line.b.y - line.a.y\n  };\n  const v2 = {\n    x: line.a.x - circle.x,\n    y: line.a.y - circle.y\n  };\n\n  const b = (v1.x * v2.x + v1.y * v2.y) * -2;\n  const c = 2 * (v1.x * v1.x + v1.y * v1.y);\n\n  const d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - circle.radius * circle.radius));\n  if (Number.isNaN(d)) return []; // no intercept\n\n  const u1 = (b - d) / c;  // these represent the unit distance of point one and two on the line\n  const u2 = (b + d) / c;\n\n  const returnValue = [];\n  if (u1 <= 1 && u1 >= 0) {  // add point if on the line segment\n    //eslint-disable-next-line functional/immutable-data\n    returnValue.push({\n      x: line.a.x + v1.x * u1,\n      y: line.a.y + v1.y * u1\n    });\n  }\n  if (u2 <= 1 && u2 >= 0) {  // second add point if on the line segment\n    //eslint-disable-next-line functional/immutable-data\n    returnValue.push({\n      x: line.a.x + v1.x * u2,\n      y: line.a.y + v1.y * u2\n    });\n  }\n  return returnValue;\n};\n\n\n/**\n * \n * Returns the points of intersection betweeen `a` and `b`.\n * \n * Returns an empty array if circles are equal, one contains the other or if they don't touch at all.\n *\n * @param a Circle\n * @param b Circle\n * @returns Points of intersection, or an empty list if there are none\n */\nexport const intersections = (a: CirclePositioned, b: CirclePositioned): ReadonlyArray<Point> => {\n  const vector = PointsSubtract(b, a);\n  const centerD = Math.hypot((vector.y), (vector.x));\n\n  // Do not intersect\n  if (centerD > a.radius + b.radius) return [];\n\n  // Circle contains another\n  if (centerD < Math.abs(a.radius - b.radius)) return [];\n\n  // Circles are the same\n  if (isEqual(a, b)) return [];\n\n  const centroidD = ((a.radius * a.radius) - (b.radius * b.radius) + (centerD * centerD)) / (2 * centerD);\n  const centroid = {\n    x: a.x + (vector.x * centroidD / centerD),\n    y: a.y + (vector.y * centroidD / centerD)\n  };\n\n  const centroidIntersectionD = Math.sqrt((a.radius * a.radius) - (centroidD * centroidD));\n\n  const intersection = {\n    x: -vector.y * (centroidIntersectionD / centerD),\n    y: vector.x * (centroidIntersectionD / centerD)\n  };\n  return [\n    PointsSum(centroid, intersection),\n    PointsSubtract(centroid, intersection)\n  ];\n};\n","import { intersections as circleIntersections } from \"./circle/Intersections.js\";\nimport type { CirclePositioned } from \"./circle/CircleType.js\";\nimport type { RectPositioned } from \"./rect/index.js\";\n\nexport const circleRect = (a: CirclePositioned, b: RectPositioned) => {\n  // https://yal.cc/rectangle-circle-intersection-test/\n  const deltaX = a.x - Math.max(b.x, Math.min(a.x, b.x + b.width));\n  const deltaY = a.y - Math.max(b.y, Math.min(a.y, b.y + b.height));\n  return (deltaX * deltaX + deltaY * deltaY) < (a.radius * a.radius);\n};\n\nexport const circleCircle = (a: CirclePositioned, b: CirclePositioned) => circleIntersections(a, b).length === 2;","import { guard } from \"./Guard.js\";\nimport { isPositioned, isRectPositioned } from \"./Guard.js\";\nimport { isCirclePositioned } from '../circle/Guard.js';\nimport * as Intersects from '../Intersects.js';\nimport { isPoint } from \"../point/Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport type { CirclePositioned } from \"../circle/CircleType.js\";\n/**\n * Returns _true_ if `point` is within, or on boundary of `rect`.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * Rects.intersectsPoint(rect, { x: 100, y: 100});\n * ```\n * @param rect\n * @param point\n */\nexport function intersectsPoint(\n  rect: Rect | RectPositioned,\n  point: Point\n): boolean;\n\n/**\n * Returns true if x,y coordinate is within, or on boundary of `rect`.\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * Rects.intersectsPoint(rect, 100, 100);\n * ```\n * @param rect\n * @param x\n * @param y\n */\nexport function intersectsPoint(\n  rect: Rect | RectPositioned,\n  x: number,\n  y: number\n): boolean;\n\n/**\n * Returns true if point is within or on boundary of `rect`.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * Rects.intersectsPoint(rect, { x: 100, y: 100});\n * Rects.intersectsPoint(rect, 100, 100);\n * ```\n * @param rect\n * @param a\n * @param b\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function intersectsPoint(\n  rect: Rect | RectPositioned,\n  a: Point | number,\n  b?: number\n): boolean {\n  guard(rect, `rect`);\n  //eslint-disable-next-line functional/no-let\n  let x = 0;\n  //eslint-disable-next-line functional/no-let\n  let y = 0;\n  if (typeof a === `number`) {\n    if (b === undefined) throw new Error(`x and y coordinate needed`);\n    x = a;\n    y = b;\n  } else {\n    x = a.x;\n    y = a.y;\n  }\n  if (isPositioned(rect)) {\n    if (x - rect.x > rect.width || x < rect.x) return false;\n    if (y - rect.y > rect.height || y < rect.y) return false;\n  } else {\n    // Assume 0,0\n    if (x > rect.width || x < 0) return false;\n    if (y > rect.height || y < 0) return false;\n  }\n  return true;\n}\n\n/**\n * Returns true if `a` or `b` overlap, are equal, or `a` contains `b`.\n * A rectangle can be checked for intersections with another RectPositioned, CirclePositioned or Point.\n *\n */\nexport const isIntersecting = (\n  a: RectPositioned,\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  b: CirclePositioned | Point\n): boolean => {\n  if (!isRectPositioned(a)) {\n    throw new Error(`a parameter should be RectPositioned`);\n  }\n\n  if (isCirclePositioned(b)) {\n    return Intersects.circleRect(b, a);\n  } else if (isPoint(b)) {\n    return intersectsPoint(a, b);\n  }\n  throw new Error(`Unknown shape for b: ${ JSON.stringify(b) }`);\n};","import { isPoint } from \"../point/Guard.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport { getRectPositioned, guard } from \"./Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\n\n/**\n * Returns the center of a rectangle as a {@link Geometry.Point}.\n *  If the rectangle lacks a position and `origin` parameter is not provided, 0,0 is used instead.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const p = Rects.center({x:10, y:20, width:100, height:50});\n * const p2 = Rects.center({width: 100, height: 50}); // Assumes 0,0 for rect x,y\n * ```\n * @param rect Rectangle\n * @param origin Optional origin. Overrides `rect` position if available. If no position is available 0,0 is used by default.\n * @returns\n */\nexport const center = (\n  rect: RectPositioned | Rect,\n  origin?: Point\n): Point => {\n  guard(rect);\n  if (origin === undefined && isPoint(rect)) origin = rect;\n  else if (origin === undefined) origin = { x: 0, y: 0 }; // throw new Error(`Unpositioned rect needs origin param`);\n\n  const r = getRectPositioned(rect, origin);\n  return Object.freeze({\n    x: origin.x + rect.width / 2,\n    y: origin.y + rect.height / 2,\n  });\n};","/**\n * A point, consisting of x, y and maybe z fields.\n */\nexport type Point = {\n  readonly x: number;\n  readonly y: number;\n  readonly z?: number;\n};\n\nexport type Point3d = Point & {\n  readonly z: number;\n};\n\n/**\n * Placeholder point, where x and y is `NaN`.\n * Use `isPlaceholder` to check if a point is a placeholder.\n */\n//eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Placeholder = Object.freeze({ x: Number.NaN, y: Number.NaN });\n","import { guardPositioned } from \"./Guard.js\";\nimport { intersectsPoint } from \"./Intersects.js\";\nimport { center } from \"./Center.js\";\nimport type { RectPositioned } from \"./RectTypes.js\";\nimport { type Point } from '../point/PointType.js';\nimport { guard as PointsGuard } from '../point/Guard.js';\nimport { distance as PointsDistance } from '../point/Distance.js';\n\n/**\n * Returns the distance from the perimeter of `rect` to `pt`.\n * If the point is within the rectangle, 0 is returned.\n *\n * If `rect` does not have an x,y it's assumed to be 0,0\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 0, y: 0 };\n * Rects.distanceFromExterior(rect, { x: 20, y: 20 });\n * ```\n * @param rect Rectangle\n * @param pt Point\n * @returns Distance\n */\nexport const distanceFromExterior = (\n  rect: RectPositioned,\n  pt: Point\n): number => {\n  guardPositioned(rect, `rect`);\n  PointsGuard(pt, `pt`);\n  if (intersectsPoint(rect, pt)) return 0;\n  const dx = Math.max(rect.x - pt.x, 0, pt.x - rect.x + rect.width);\n  const dy = Math.max(rect.y - pt.y, 0, pt.y - rect.y + rect.height);\n  return Math.hypot(dx, dy);\n};\n\n/**\n * Return the distance of `pt` to the center of `rect`.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 0, y: 0 };\n * Rects.distanceFromCenter(rect, { x: 20, y: 20 });\n * ```\n * @param rect\n * @param pt\n * @returns\n */\nexport const distanceFromCenter = (\n  rect: RectPositioned,\n  pt: Point\n): number => PointsDistance(center(rect), pt);\n","import { distanceFromExterior as circleDistanceFromExterior } from \"../circle/DistanceFromExterior.js\";\nimport { distance } from \"./Distance.js\";\nimport { isPoint } from \"./Guard.js\";\nimport { distanceFromExterior as rectDistanceFromExterior } from \"../rect/Distance.js\";\nimport type { Point } from \"./PointType.js\";\nimport { isCirclePositioned } from \"../circle/Guard.js\";\nimport { isRectPositioned } from \"../rect/Guard.js\";\nimport type { PointCalculableShape } from \"../shape/index.js\";\n\n/**\n * Returns the distance from point `a` to the center of `shape`.\n * @param a Point\n * @param shape Point, or a positioned Rect or Circle.\n * @returns\n */\nexport const distanceToCenter = (\n  a: Point,\n  shape: PointCalculableShape\n): number => {\n  if (isRectPositioned(shape)) {\n    return rectDistanceFromExterior(shape, a);\n  }\n  if (isCirclePositioned(shape)) {\n    return circleDistanceFromExterior(shape, a);\n  }\n  if (isPoint(shape)) return distance(a, shape);\n  throw new Error(`Unknown shape`);\n};","import { distanceFromExterior as circleDistanceFromExterior } from \"../circle/DistanceFromExterior.js\";\nimport { distance, isPoint } from \"./index.js\";\nimport type { Point, PointCalculableShape } from \"../Types.js\";\nimport { distanceFromExterior as rectDistanceFromExterior } from \"../rect/Distance.js\";\nimport { isCirclePositioned } from \"../circle/Guard.js\";\nimport { isRectPositioned } from \"../rect/Guard.js\";\n\n/**\n * Returns the distance from point `a` to the exterior of `shape`.\n *\n * @example Distance from point to rectangle\n * ```\n * const distance = distanceToExterior(\n *  {x: 50, y: 50},\n *  {x: 100, y: 100, width: 20, height: 20}\n * );\n * ```\n *\n * @example Find closest shape to point\n * ```\n * import {minIndex} from '../data/arrays.js';\n * const shapes = [ some shapes... ]; // Shapes to compare against\n * const pt = { x: 10, y: 10 };       // Comparison point\n * const distances = shapes.map(v => distanceToExterior(pt, v));\n * const closest = shapes[minIndex(...distances)];\n * ```\n * @param a Point\n * @param shape Point, or a positioned Rect or Circle.\n * @returns\n */\nexport const distanceToExterior = (\n  a: Point,\n  shape: PointCalculableShape\n): number => {\n  if (isRectPositioned(shape)) {\n    return rectDistanceFromExterior(shape, a);\n  }\n  if (isCirclePositioned(shape)) {\n    return circleDistanceFromExterior(shape, a);\n  }\n  if (isPoint(shape)) return distance(a, shape);\n  throw new Error(`Unknown shape`);\n};","import type { Point } from \"./PointType.js\";\n\n/**\n * Returns point as an array in the form [x,y]. This can be useful for some libraries\n * that expect points in array form.\n *\n * ```\n * const p = {x: 10, y:5};\n * const p2 = toArray(p); // yields [10,5]\n * ```\n * @param p\n * @returns\n */\nexport const toArray = (p: Point): ReadonlyArray<number> => [ p.x, p.y ];\n","import { dotProduct as ArraysDotProduct } from '../../numbers/NumericArrays.js';\nimport type { Point } from './PointType.js';\nimport { toArray } from './ToArray.js';\n\nexport const dotProduct = (...pts: ReadonlyArray<Point>): number => {\n  const a = pts.map(p => toArray(p));\n  return ArraysDotProduct(a);\n};","import type { Point } from \"./PointType.js\";\n\n/**\n * Returns a point from two coordinates or an array of [x,y]\n * @example\n * ```js\n * let p = from([10, 5]); // yields {x:10, y:5}\n * let p = from(10, 5);   // yields {x:10, y:5}\n * let p = from(10);      // yields {x:10, y:0} 0 is used for default y\n * let p = from();        // yields {x:0, y:0}  0 used for default x & y\n * ```\n * @param xOrArray\n * @param [y]\n * @returns Point\n */\nexport const from = (\n  xOrArray?: number | ReadonlyArray<number>,\n  y?: number\n): Point => {\n  if (Array.isArray(xOrArray)) {\n    if (xOrArray.length !== 2) {\n      throw new Error(`Expected array of length two, got ${ xOrArray.length }`);\n    }\n    return Object.freeze({\n      x: xOrArray[ 0 ],\n      y: xOrArray[ 1 ],\n    });\n  } else {\n    if (xOrArray === undefined) xOrArray = 0;\n    else if (Number.isNaN(xOrArray)) throw new Error(`x is NaN`);\n    if (y === undefined) y = 0;\n    else if (Number.isNaN(y)) throw new Error(`y is NaN`);\n    return Object.freeze({ x: xOrArray as number, y: y });\n  }\n};\n\n\n/**\n * Returns an array of points from an array of numbers.\n *\n * Array can be a continuous series of x, y values:\n * ```\n * [1,2,3,4] would yield: [{x:1, y:2}, {x:3, y:4}]\n * ```\n *\n * Or it can be an array of arrays:\n * ```\n * [[1,2], [3,4]] would yield: [{x:1, y:2}, {x:3, y:4}]\n * ```\n * @param coords\n * @returns\n */\nexport const fromNumbers = (\n  ...coords: ReadonlyArray<ReadonlyArray<number>> | ReadonlyArray<number>\n): ReadonlyArray<Point> => {\n  const pts: Array<Point> = [];\n\n  if (Array.isArray(coords[ 0 ])) {\n    // [[x,y],[x,y]...]\n    for (const coord of (coords as Array<Array<number>>)) {\n      if (!(coord.length % 2 === 0)) {\n        throw new Error(`coords array should be even-numbered`);\n      }\n      //eslint-disable-next-line  functional/immutable-data\n      pts.push(Object.freeze({ x: coord[ 0 ], y: coord[ 1 ] }));\n    }\n  } else {\n    // [x,y,x,y,x,y]\n    if (coords.length % 2 !== 0) {\n      throw new Error(`Expected even number of elements: [x,y,x,y...]`);\n    }\n\n    for (let index = 0; index < coords.length; index += 2) {\n      //eslint-disable-next-line  functional/immutable-data\n      pts.push(\n        Object.freeze({ x: coords[ index ] as number, y: coords[ index + 1 ] as number })\n      );\n    }\n  }\n  return pts;\n};\n","import type { Point } from \"./PointType.js\";\nimport { interpolate as lineInterpolate } from '../line/Interpolate.js';\n\n/**\n * Returns a relative point between two points\n * ```js\n * interpolate(0.5, a, b); // Halfway point between a and b\n * ```\n *\n * Alias for Lines.interpolate(amount, a, b);\n *\n * @param amount Relative amount, 0-1\n * @param a\n * @param b\n * @param allowOverflow If true, length of line can be exceeded for `amount` of below 0 and above `1`.\n * @returns {@link Point}\n */\nexport const interpolate = (\n  amount: number,\n  a: Point,\n  b: Point,\n  allowOverflow = false\n): Point => lineInterpolate(amount, a, b, allowOverflow); //({x: (1-amt) * a.x + amt * b.x, y:(1-amt) * a.y + amt * b.y });\n","import { isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\n\n/**\n * Inverts one or more axis of a point\n * ```js\n * invert({x:10, y:10}); // Yields: {x:-10, y:-10}\n * invert({x:10, y:10}, `x`); // Yields: {x:-10, y:10}\n * ```\n * @param pt Point to invert\n * @param what Which axis. If unspecified, both axies are inverted\n * @returns\n */\nexport const invert = (\n  pt: Point | Point3d,\n  what: `both` | `x` | `y` | `z` = `both`\n): Point => {\n  switch (what) {\n    case `both`: {\n      return isPoint3d(pt) ? Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n        y: pt.y * -1,\n        z: pt.z * -1,\n      }) : Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n        y: pt.y * -1,\n      });\n    }\n    case `x`: {\n      return Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n      });\n    }\n    case `y`: {\n      return Object.freeze({\n        ...pt,\n        y: pt.y * -1,\n      });\n    }\n    case `z`: {\n      if (isPoint3d(pt)) {\n        return Object.freeze({\n          ...pt,\n          z: pt.z * -1,\n        });\n      } else throw new Error(`pt parameter is missing z`);\n    }\n    default: {\n      throw new Error(`Unknown what parameter. Expecting 'both', 'x' or 'y'`);\n    }\n  }\n};","import { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport { isRect } from \"../rect/Guard.js\";\nimport type { Rect } from \"../rect/RectTypes.js\";\nimport { guard as RectsGuard } from '../rect/Guard.js'\nimport type { Point, Point3d } from \"./PointType.js\";\nimport { guard, isPoint, isPoint3d } from \"./Guard.js\";\n\n/**\n * Multiply by a width,height or x,y\n * ```\n * return {\n *  x: a.x * rect.width,\n *  y: a.y * rect.height\n * };\n * ```\n * @param a\n * @param rectOrPoint\n */\nexport function multiply(a: Point, rectOrPoint: Rect | Point): Point;\n\n/**\n * Returns `a` multipled by some x and/or y scaling factor\n *\n * ie.\n * ```js\n * return {\n *  x: a.x * x\n *   y: a.y * y\n * }\n * ```\n *\n * Usage:\n * ```js\n * multiply(pt, 10, 100); // Scale pt by x:10, y:100\n * multiply(pt, Math.min(window.innerWidth, window.innerHeight)); // Scale both x,y by viewport with or height, whichever is smaller\n * ```\n * @param a Point to scale\n * @param x Scale factor for x axis\n * @param y Scale factor for y axis (if not specified, the x value is used)\n * @returns Scaled point\n */\nexport function multiply(a: Point, x: number, y?: number): Point;\n\n/**\n * Returns `a` multiplied by `b` point, or given x and y.\n * ie.\n * ```js\n * return {\n *   x: a.x * b.x,\n *   y: a.y * b.y\n * };\n * ```\n * @param a\n * @param bOrX\n * @param y\n * @returns\n */\n/* eslint-disable func-style */\nexport function multiply(\n  a: Point,\n  bOrX: Rect | Point | number,\n  y?: number\n): Point {\n  // ✔️ Unit tested\n\n  guard(a, `a`);\n  if (typeof bOrX === `number`) {\n    if (typeof y === `undefined`) y = bOrX;\n    throwNumberTest(y, ``, `y`);\n    throwNumberTest(bOrX, ``, `x`);\n    return Object.freeze({ x: a.x * bOrX, y: a.y * y });\n  } else if (isPoint(bOrX)) {\n    guard(bOrX, `b`);\n    return Object.freeze({\n      x: a.x * bOrX.x,\n      y: a.y * bOrX.y,\n    });\n  } else if (isRect(bOrX)) {\n    RectsGuard(bOrX, `rect`);\n    return Object.freeze({\n      x: a.x * bOrX.width,\n      y: a.y * bOrX.height,\n    });\n  } else {\n    throw new Error(\n      `Invalid arguments. a: ${ JSON.stringify(a) } b: ${ JSON.stringify(bOrX) }`\n    );\n  }\n}\n\n/**\n * Multiplies all components by `v`.\n * Existing properties of `pt` are maintained.\n *\n * ```js\n * multiplyScalar({ x:2, y:4 }, 2);\n * // Yields: { x:4, y:8 }\n * ```\n * @param pt Point\n * @param v Value to multiply by\n * @returns\n */\nexport const multiplyScalar = (\n  pt: Point | Point3d,\n  v: number\n): Point | Point3d => {\n  return isPoint3d(pt) ? Object.freeze({\n    ...pt,\n    x: pt.x * v,\n    y: pt.y * v,\n    z: pt.z * v,\n  }) : Object.freeze({\n    ...pt,\n    x: pt.x * v,\n    y: pt.y * v,\n  });\n};\n\n","import { distance } from \"./Distance.js\";\nimport { multiply } from \"./Multiply.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Clamps the magnitude of a point.\n * This is useful when using a Point as a vector, to limit forces.\n * @param pt\n * @param max Maximum magnitude (1 by default)\n * @param min Minimum magnitude (0 by default)\n * @returns\n */\nexport const clampMagnitude = (pt: Point, max = 1, min = 0): Point => {\n  const length = distance(pt);\n  let ratio = 1;\n  if (length > max) {\n    ratio = max / length;\n  } else if (length < min) {\n    ratio = min / length;\n  }\n  return ratio === 1 ? pt : multiply(pt, ratio, ratio);\n};","import { findMinimum } from \"./FindMinimum.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Returns the left-most of the provided points.\n *\n * Same as:\n * ```js\n * findMinimum((a, b) => {\n *  if (a.x <= b.x) return a;\n *  return b;\n *}, ...points)\n * ```\n *\n * @param points\n * @returns\n */\nexport const leftmost = (...points: ReadonlyArray<Point>): Point =>\n  findMinimum((a, b) => (a.x <= b.x ? a : b), ...points);\n\n/**\n * Returns the right-most of the provided points.\n *\n * Same as:\n * ```js\n * findMinimum((a, b) => {\n *  if (a.x >= b.x) return a;\n *  return b;\n *}, ...points)\n * ```\n *\n * @param points\n * @returns\n */\nexport const rightmost = (...points: ReadonlyArray<Point>): Point =>\n  findMinimum((a, b) => (a.x >= b.x ? a : b), ...points);\n","import { Empty } from \"./Empty.js\";\nimport { getPointParameter } from \"./GetPointParameter.js\";\nimport { isPoint } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\nconst length = (ptOrX: Point | number, y?: number): number => {\n  if (isPoint(ptOrX)) {\n    y = ptOrX.y;\n    ptOrX = ptOrX.x;\n  }\n  if (y === undefined) throw new Error(`Expected y`);\n  return Math.hypot(ptOrX, y);\n};\n\n\n\n/**\n * Normalise point as a unit vector.\n *\n * ```js\n * normalise({x:10, y:20});\n * normalise(10, 20);\n * ```\n * @param ptOrX Point, or x value\n * @param y y value if first param is x\n * @returns\n */\nexport const normalise = (ptOrX: Point | number, y?: number): Point => {\n  const pt = getPointParameter(ptOrX, y);\n  const l = length(pt);\n  if (l === 0) return Empty;\n  return Object.freeze({\n    ...pt,\n    x: pt.x / l,\n    y: pt.y / l,\n  });\n};","import type { Point } from \"./PointType.js\";\n\n/**\n * Runs a sequential series of functions on `pt`. The output from one feeding into the next.\n * ```js\n * const p = Points.pipelineApply(somePoint, Points.normalise, Points.invert);\n * ```\n *\n * If you want to make a reusable pipeline of functions, consider {@link pipeline} instead.\n * @param point\n * @param pipelineFns\n * @returns\n */\nexport const pipelineApply = (\n  point: Point,\n  ...pipelineFns: ReadonlyArray<(pt: Point) => Point>\n): Point => pipeline(...pipelineFns)(point); // pipeline.reduce((prev, curr) => curr(prev), pt);\n\n/**\n * Returns a pipeline function that takes a point to be transformed through a series of functions\n * ```js\n * // Create pipeline\n * const p = Points.pipeline(Points.normalise, Points.invert);\n *\n * // Now run it on `somePoint`.\n * // First we normalised, and then invert\n * const changedPoint = p(somePoint);\n * ```\n *\n * If you don't want to create a pipeline, use {@link pipelineApply}.\n * @param pipeline Pipeline of functions\n * @returns\n */\nexport const pipeline =\n  (...pipeline: ReadonlyArray<(pt: Point) => Point>) =>\n    (pt: Point) =>\n      // eslint-disable-next-line unicorn/no-array-reduce\n      pipeline.reduce((previous, current) => current(previous), pt);\n","\nimport { isPoint3d } from \"./Guard.js\";\nimport type { Point3d, Point } from \"./PointType.js\";\nimport { subtract } from \"./Subtract.js\";\n\n/**\n * Computes the progress between two waypoints, given `position`.\n * \n * [Source](https://www.habrador.com/tutorials/math/2-passed-waypoint/?s=09)\n * @param position Current position\n * @param waypointA Start\n * @param waypointB End\n * @returns \n */\nexport const progressBetween = (\n  position: Point | Point3d,\n  waypointA: Point | Point3d,\n  waypointB: Point | Point3d\n) => {\n  // Via: https://www.habrador.com/tutorials/math/2-passed-waypoint/?s=09\n  // from -> current\n  const a = subtract(position, waypointA);\n\n  // from -> to\n  const b = subtract(waypointB, waypointA);\n\n  return isPoint3d(a) && isPoint3d(b) ? (\n    (a.x * b.x + a.y * b.y + a.z * b.z) / (b.x * b.x + b.y * b.y + b.z * b.z)\n  ) : (a.x * b.x + a.y * b.y) / (b.x * b.x + b.y * b.y);\n};","import type { Point } from \"./PointType.js\";\n\n/**\n * Project `origin` by `distance` and `angle` (radians).\n *\n * To figure out rotation, imagine a horizontal line running through `origin`.\n * * Rotation = 0 deg puts the point on the right of origin, on same y-axis\n * * Rotation = 90 deg/3:00 puts the point below origin, on the same x-axis\n * * Rotation = 180 deg/6:00 puts the point on the left of origin on the same y-axis\n * * Rotation = 270 deg/12:00 puts the point above the origin, on the same x-axis\n *\n * ```js\n * // Yields a point 100 units away from 10,20 with 10 degrees rotation (ie slightly down)\n * const a = Points.project({x:10, y:20}, 100, degreeToRadian(10));\n * ```\n * @param origin\n * @param distance\n * @param angle\n * @returns\n */\nexport const project = (origin: Point, distance: number, angle: number) => {\n  const x = Math.cos(angle) * distance + origin.x;\n  const y = Math.sin(angle) * distance + origin.y;\n  return { x, y };\n};","import { quantiseEvery as quantiseEveryNumber } from '../../numbers/Quantise.js';\nimport { guard } from './Guard.js';\nimport type { Point } from './PointType.js';\n\n/**\n * Quantises a point\n * @param pt \n * @param snap \n * @param middleRoundsUp \n * @returns \n */\nexport const quantiseEvery = (pt: Point, snap: Point, middleRoundsUp = true) => {\n  guard(pt, `pt`);\n  guard(snap, `snap`);\n  return Object.freeze({\n    x: quantiseEveryNumber(pt.x, snap.x, middleRoundsUp),\n    y: quantiseEveryNumber(pt.y, snap.y, middleRoundsUp),\n  });\n}","import { type RandomSource, defaultRandom } from '../../random/Types.js';\nimport type { Point } from './PointType.js';\n\n/**\n * Returns a random point on a 0..1 scale.\n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const pt = Points.random(); // eg {x: 0.2549012, y:0.859301}\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * import { weightedSource } from \"https://unpkg.com/ixfx/dist/random.js\"\n * const pt = Points.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport const random = (rando?: RandomSource): Point => {\n  if (rando === undefined) rando = defaultRandom;\n\n  return Object.freeze({\n    x: rando(),\n    y: rando(),\n  });\n};","import type { Point } from \"./PointType.js\";\n\n/**\n * Reduces over points, treating _x_ and _y_ separately.\n *\n * ```\n * // Sum x and y values\n * const total = Points.reduce(points, (p, acc) => {\n *  return {x: p.x + acc.x, y: p.y + acc.y}\n * });\n * ```\n * @param pts Points to reduce\n * @param fn Reducer\n * @param initial Initial value, uses `{ x:0, y:0 }` by default\n * @returns\n */\nexport const reduce = (\n  pts: ReadonlyArray<Point>,\n  fn: (p: Point, accumulated: Point) => Point,\n  initial?: Point\n): Point => {\n  if (initial === undefined) initial = { x: 0, y: 0 }\n  let accumulator = initial;\n  for (const p of pts) {\n    accumulator = fn(p, accumulator);\n  };\n  return accumulator;\n};","import { angleRadian } from \"./Angle.js\";\nimport { centroid } from \"./Centroid.js\";\nimport { distance } from \"./Distance.js\";\nimport { getPointParameter } from \"./GetPointParameter.js\";\nimport type { PointRelation } from \"./PointRelationTypes.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Tracks the relation between two points.\n * \n * 1. Call `Points.relation` with the initial reference point\n * 2. You get back a function\n * 3. Call the function with a new point to compute relational information.\n * \n * It computes angle, average, centroid, distance and speed.\n * \n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Reference point: 50,50\n * const t = Points.relation({x:50,y:50}); // t is a function\n *\n * // Invoke the returned function with a point\n * const relation = t({ x:0, y:0 }); // Juicy relational data\n * ```\n * \n * Or with destructuring:\n * \n * ```js\n * const { angle, distanceFromStart, distanceFromLast, average, centroid, speed } = t({ x:0,y:0 });\n * ```\n *\n * x & y coordinates can also be used as parameters:\n * ```js\n * const t = Points.relation(50, 50);\n * const result = t(0, 0);\n * // result.speed, result.angle ...\n * ```\n *\n * Note that intermediate values are not stored. It keeps the initial\n * and most-recent point. If you want to compute something over a set\n * of prior points, you may want to use {@link Trackers.points}\n * @param a Initial point, or x value\n * @param b y value, if first option is a number.\n * @returns\n */\nexport const relation = (a: Point | number, b?: number): PointRelation => {\n  const start = getPointParameter(a, b);\n  let totalX = 0;\n  let totalY = 0;\n  let count = 0;\n  let lastUpdate = performance.now();\n  let lastPoint = start;\n  const update = (aa: Point | number, bb?: number) => {\n    const p = getPointParameter(aa, bb);\n    totalX += p.x;\n    totalY += p.y;\n    count++;\n\n    const distanceFromStart = distance(p, start);\n    const distanceFromLast = distance(p, lastPoint);\n\n    // Track speed\n    const now = performance.now();\n    const speed = distanceFromLast / (now - lastUpdate);\n    lastUpdate = now;\n\n    lastPoint = p;\n\n    return Object.freeze({\n      angle: angleRadian(p, start),\n      distanceFromStart,\n      distanceFromLast,\n      speed,\n      centroid: centroid(p, start),\n      average: {\n        x: totalX / count,\n        y: totalY / count,\n      },\n    });\n  };\n\n  return update;\n};\n\n","import { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport type { Point } from \"./PointType.js\";\nimport { guard } from \"./Guard.js\";\nimport { fromCartesian as PolarFromCartesian } from \"../Polar.js\";\nimport { rotate as PolarRotate, toCartesian as PolarToCartesian } from \"../Polar.js\";\n/**\n * Rotate a single point by a given amount in radians\n * @param pt\n * @param amountRadian\n * @param origin\n */\nexport function rotate(pt: Point, amountRadian: number, origin?: Point): Point;\n\n/**\n * Rotate several points by a given amount in radians\n * @param pt Points\n * @param amountRadian Amount to rotate in radians. If 0 is given, a copy of the input array is returned\n * @param origin Origin to rotate around. Defaults to 0,0\n */\nexport function rotate(\n  pt: ReadonlyArray<Point>,\n  amountRadian: number,\n  origin?: Point\n): ReadonlyArray<Point>;\n\nexport function rotate(\n  pt: Point | ReadonlyArray<Point>,\n  amountRadian: number,\n  origin?: Point\n): Point | ReadonlyArray<Point> {\n  if (origin === undefined) origin = { x: 0, y: 0 };\n  guard(origin, `origin`);\n  throwNumberTest(amountRadian, ``, `amountRadian`);\n  const arrayInput = Array.isArray(pt);\n\n  // no-op\n  if (amountRadian === 0) return pt;\n\n  if (!arrayInput) {\n    pt = [ pt as Point ];\n  }\n\n  const ptAr = pt as ReadonlyArray<Point>;\n  for (const [ index, p ] of ptAr.entries()) guard(p, `pt[${ index }]`);\n\n  const asPolar = ptAr.map((p) => PolarFromCartesian(p, origin));\n  const rotated = asPolar.map((p) => PolarRotate(p, amountRadian));\n  const asCartesisan = rotated.map((p) => PolarToCartesian(p, origin));\n  return arrayInput ? asCartesisan : asCartesisan[ 0 ];\n}","\n//eslint-disable-next-line functional/prefer-readonly-type\nexport const rotatePointArray = (\n  v: ReadonlyArray<ReadonlyArray<number>>,\n  amountRadian: number\n): Array<Array<number>> => {\n  const mat = [\n    [ Math.cos(amountRadian), -Math.sin(amountRadian) ],\n    [ Math.sin(amountRadian), Math.cos(amountRadian) ],\n  ];\n  const result = [];\n  for (const [ index, element ] of v.entries()) {\n    //eslint-disable-next-line functional/immutable-data\n    result[ index ] = [\n      mat[ 0 ][ 0 ] * element[ 0 ] + mat[ 0 ][ 1 ] * element[ 1 ],\n      mat[ 1 ][ 0 ] * element[ 0 ] + mat[ 1 ][ 1 ] * element[ 1 ],\n    ];\n  }\n  return result;\n};","import { round as roundNumber } from '../../numbers/Round.js';\nimport { getPointParameter } from './GetPointParameter.js';\nimport type { Point } from './PointType.js';\n\n/**\n * Round the point's _x_ and _y_ to given number of digits\n * @param ptOrX \n * @param yOrDigits \n * @param digits \n * @returns \n */\nexport const round = (ptOrX: Point | number, yOrDigits?: number, digits?: number): Point => {\n  const pt = getPointParameter(ptOrX, yOrDigits);\n  digits = digits ?? yOrDigits;\n  digits = digits ?? 2;\n  return Object.freeze({\n    ...pt,\n    x: roundNumber(digits, pt.x),\n    y: roundNumber(digits, pt.y)\n  })\n}","import { guard } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Returns a point with rounded x,y coordinates. By default uses `Math.round` to round.\n * ```js\n * toIntegerValues({x:1.234, y:5.567}); // Yields: {x:1, y:6}\n * ```\n *\n * ```js\n * toIntegerValues(pt, Math.ceil); // Use Math.ceil to round x,y of `pt`.\n * ```\n * @param pt Point to round\n * @param rounder Rounding function, or Math.round by default\n * @returns\n */\nexport const toIntegerValues = (\n  pt: Point,\n  rounder: (x: number) => number = Math.round\n): Point => {\n  guard(pt, `pt`);\n  return Object.freeze({\n    x: rounder(pt.x),\n    y: rounder(pt.y),\n  });\n};\n\n/**\n * Returns a human-friendly string representation `(x, y)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport function toString(p: Point, digits?: number): string {\n  if (p === undefined) return `(undefined)`;\n  if (p === null) return `(null)`;\n  guard(p, `pt`);\n\n  const x = digits ? p.x.toFixed(digits) : p.x;\n  const y = digits ? p.y.toFixed(digits) : p.y;\n\n  if (p.z === undefined) {\n    return `(${ x },${ y })`;\n  } else {\n    const z = digits ? p.z.toFixed(digits) : p.z;\n    return `(${ x },${ y },${ z })`;\n  }\n}","import { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport type { Point } from \"./PointType.js\";\nimport { guard } from \"./Guard.js\";\n\n/**\n * Returns true if two points are within a specified range on both axes.\n * \n * Provide a point for the range to set different x/y range, or pass a number\n * to use the same range for both axis.\n *\n * Note this simply compares x,y values it does not calcuate distance.\n *\n * @example\n * ```js\n * withinRange({x:100,y:100}, {x:101, y:101}, 1); // True\n * withinRange({x:100,y:100}, {x:105, y:101}, {x:5, y:1}); // True\n * withinRange({x:100,y:100}, {x:105, y:105}, {x:5, y:1}); // False - y axis too far\n * ```\n * @param a\n * @param b\n * @param maxRange\n * @returns\n */\nexport const withinRange = (\n  a: Point,\n  b: Point,\n  maxRange: Point | number\n): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n\n  if (typeof maxRange === `number`) {\n    throwNumberTest(maxRange, `positive`, `maxRange`);\n    maxRange = { x: maxRange, y: maxRange };\n  } else {\n    guard(maxRange, `maxRange`);\n  }\n  const x = Math.abs(b.x - a.x);\n  const y = Math.abs(b.y - a.y);\n  return x <= maxRange.x && y <= maxRange.y;\n};","import { wrap as wrapNumber } from '../../numbers/Wrap.js';\nimport { guard } from './Guard.js';\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Wraps a point to be within `ptMin` and `ptMax`.\n * Note that max values are _exclusive_, meaning the return value will always be one less.\n *\n * Eg, if a view port is 100x100 pixels, wrapping the point 150,100 yields 50,99.\n *\n * ```js\n * // Wraps 150,100 to on 0,0 -100,100 range\n * wrap({x:150,y:100}, {x:100,y:100});\n * ```\n *\n * Wrap normalised point:\n * ```js\n * wrap({x:1.2, y:1.5}); // Yields: {x:0.2, y:0.5}\n * ```\n * @param pt Point to wrap\n * @param ptMax Maximum value, or `{ x:1, y:1 }` by default\n * @param ptMin Minimum value, or `{ x:0, y:0 }` by default\n * @returns Wrapped point\n */\nexport const wrap = (\n  pt: Point,\n  ptMax?: Point,\n  ptMin?: Point\n): Point => {\n\n  if (ptMax === undefined) ptMax = { x: 1, y: 1 };\n  if (ptMin === undefined) ptMin = { x: 0, y: 0 };\n\n  // ✔️ Unit tested\n  guard(pt, `pt`);\n  guard(ptMax, `ptMax`);\n  guard(ptMin, `ptMin`);\n\n  return Object.freeze({\n    x: wrapNumber(pt.x, ptMin.x, ptMax.x),\n    y: wrapNumber(pt.y, ptMin.y, ptMax.y),\n  });\n};\n","import type { Point } from \"../Types.js\";\nimport type { Line } from \"./LineType.js\";\nimport { multiply as PointsMultiply } from \"../point/index.js\";\n/**\n * Multiplies start and end of line by point.x, point.y.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1, 1, 10, 10);\n * const ll = Lines.multiply(l, {x:2, y:3});\n * // Yields: 2,20 -> 3,30\n * ```\n * @param line \n * @param point \n * @returns \n */\nexport const multiply = (line: Line, point: Point): Line => (Object.freeze({\n  ...line,\n  a: PointsMultiply(line.a, point),\n  b: PointsMultiply(line.b, point)\n}));","import type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { length } from \"./Length.js\";\nimport { distance as PointsDistance } from \"../point/Distance.js\";\n/**\n * Returns the relative position of `pt` along `line`.\n * Warning: assumes `pt` is actually on `line`. Results may be bogus if not.\n * @param line \n * @param pt \n */\nexport const relativePosition = (line: Line, pt: Point): number => {\n  const fromStart = PointsDistance(line.a, pt);\n  const total = length(line);\n  return fromStart / total;\n}","import type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { rotate as PointRotate } from '../point/index.js';\nimport { interpolate } from \"./Interpolate.js\";\n\n/**\n * Returns a line that is rotated by `angleRad`. By default it rotates\n * around its center, but an arbitrary `origin` point can be provided.\n * If `origin` is a number, it's presumed to be a 0..1 percentage of the line.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Rotates line by 0.1 radians around point 10,10\n * const r = Lines.rotate(line, 0.1, {x:10,y:10});\n * \n * // Rotate line by 5 degrees around its center\n * const r = Lines.rotate(line, degreeToRadian(5));\n * \n * // Rotate line by 5 degres around its end point\n * const r = Lines.rotate(line, degreeToRadian(5), line.b);\n * \n * // Rotate by 90 degrees at the 80% position\n * const r = Lines.rotated = rotate(line, Math.PI / 2, 0.8);\n * ```\n * @param line Line to rotate\n * @param amountRadian Angle in radians to rotate by\n * @param origin Point to rotate around. If undefined, middle of line will be used\n * @returns \n */\nexport const rotate = (line: Line, amountRadian?: number, origin?: Point | number): Line => {\n  if (amountRadian === undefined || amountRadian === 0) return line;\n  if (origin === undefined) origin = 0.5;\n  if (typeof origin === `number`) {\n    origin = interpolate(origin, line.a, line.b);\n  }\n  return Object.freeze({\n    ...line,\n    a: PointRotate(line.a, amountRadian, origin),\n    b: PointRotate(line.b, amountRadian, origin)\n  });\n};","import type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { subtract as PointsSubtract } from \"../point/Subtract.js\";\n\n/**\n * Subtracts both start and end points by given x,y\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.subtract(l, {x:2, y:4});\n * // Yields: -1,-3 -> 8,6\n * ```\n * @param line \n * @param point \n * @returns \n */\nexport const subtract = (line: Line, point: Point): Line => Object.freeze({\n  ...line,\n  a: PointsSubtract(line.a, point),\n  b: PointsSubtract(line.b, point)\n});","import type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { sum as PointsSum } from '../point/Sum.js';\n\n/**\n * Adds both start and end points by given x,y\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.sum(l, {x:2, y:4});\n * // Yields: 3,5 -> 12,14\n * ```\n * @param line \n * @param point \n * @returns \n */\nexport const sum = (line: Line, point: Point): Line => Object.freeze({\n  ...line,\n  a: PointsSum(line.a, point),\n  b: PointsSum(line.b, point)\n});","import type { Point } from \"../point/PointType.js\";\nimport { guard, isLine } from \"./Guard.js\";\nimport type { Line } from \"./LineType.js\";\nimport { toString as PointsToString } from '../point/index.js';\n/**\n * Returns a string representation of two points\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * console.log(Lines.toString(a, b)));\n * ```\n * @param a \n * @param b \n * @returns \n */\nexport function toString(a: Point, b: Point): string;\n\n/**\n * Returns a string representation of a line \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.toString(line);\n * ```\n * @param line \n */\nexport function toString(line: Line): string;\n\n/**\n * Returns a string representation of a line or two points.\n * @param a\n * @param b \n * @returns \n */\n//eslint-disable-next-line func-style\nexport function toString(a: Point | Line, b?: Point): string {\n  if (isLine(a)) {\n    guard(a, `a`);\n    b = a.b;\n    a = a.a;\n  } else if (b === undefined) throw new Error(`Expect second point if first is a point`);\n  return PointsToString(a) + `-` + PointsToString(b);\n}\n\n","import type { LinePath } from \"./LinePathType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { length } from \"./Length.js\";\nimport { interpolate } from \"./Interpolate.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport { parallel, perpendicularPoint } from \"./Angles.js\";\nimport { midpoint } from \"./Midpoint.js\";\nimport { toFlatArray, toSvgString, slope, withinRange, apply } from \"./index.js\";\nimport { bbox } from \"./Bbox.js\";\nimport { relativePosition } from \"./RelativePosition.js\";\nimport { sum } from \"./Sum.js\";\nimport { divide } from \"./Divide.js\";\nimport { rotate } from \"./Rotate.js\";\nimport { nearest } from \"./Nearest.js\";\nimport { distanceSingleLine } from './DistanceSingleLine.js';\nimport { isEqual } from \"./IsEqual.js\";\nimport { multiply } from \"./Multiply.js\";\nimport { subtract } from \"./Subtract.js\";\nimport { toString } from \"./ToString.js\";\n/**\n * Returns a path wrapper around a line instance. This is useful if there are a series\n * of operations you want to do with the same line because you don't have to pass it\n * in as an argument to each function.\n * \n * Note that the line is immutable, so a function like `sum` returns a new LinePath,\n * wrapping the result of `sum`.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Create a path\n * const l = Lines.toPath(fromNumbers(0,0,10,10));\n * \n * // Now we can use it...\n * l.length();\n * \n * // Mutate functions return a new path\n * const ll = l.sum({x:10,y:10});\n * ll.length();\n * ```\n * @param line \n * @returns \n */\nexport const toPath = (line: Line): LinePath => {\n  const { a, b } = line;\n  return Object.freeze({\n    ...line,\n    length: () => length(a, b),\n    interpolate: (amount: number) => interpolate(amount, a, b),\n    relativePosition: (point: Point) => relativePosition(line, point),\n    bbox: () => bbox(line),\n    toString: () => toString(a, b),\n    toFlatArray: () => toFlatArray(a, b),\n    toSvgString: () => toSvgString(a, b),\n    toPoints: () => [ a, b ],\n    rotate: (amountRadian: number, origin: Point) => toPath(rotate(line, amountRadian, origin)),\n    nearest: (point: Point) => nearest(line, point),\n    sum: (point: Point) => toPath(sum(line, point)),\n    divide: (point: Point) => toPath(divide(line, point)),\n    multiply: (point: Point) => toPath(multiply(line, point)),\n    subtract: (point: Point) => toPath(subtract(line, point)),\n    midpoint: () => midpoint(a, b),\n    distanceToPoint: (point: Point) => distanceSingleLine(line, point),\n    parallel: (distance: number) => parallel(line, distance),\n    perpendicularPoint: (distance: number, amount?: number) => perpendicularPoint(line, distance, amount),\n    slope: () => slope(line),\n    withinRange: (point: Point, maxRange: number) => withinRange(line, point, maxRange),\n    isEqual: (otherLine: Line) => isEqual(line, otherLine),\n    apply: (fn: (point: Point) => Point) => toPath(apply(line, fn)),\n    kind: `line`\n  });\n};","export * as CirclePacking from './CirclePacking.js';","import { sortByNumericProperty } from \"../data/arrays/Sort.js\";\nimport type { RandomSource } from \"../random/Types.js\";\nimport { randomPoint as ShapesRandomPoint, type ShapePositioned } from \"./shape/index.js\";\nimport { isIntersecting as CirclesIsIntersecting } from \"./circle/Intersecting.js\";\nimport type { Circle, CirclePositioned } from \"./circle/CircleType.js\";\nimport type { Point } from \"./point/PointType.js\";\n\nexport type RandomOpts = {\n  readonly attempts?: number\n  readonly randomSource?: RandomSource\n}\n/**\n * Naive randomised circle packing.\n * [Algorithm by Taylor Hobbs](https://tylerxhobbs.com/essays/2016/a-randomized-approach-to-cicle-packing)\n */\nexport const random = (circles: ReadonlyArray<Circle>, container: ShapePositioned, opts: RandomOpts = {}) => {\n  if (!Array.isArray(circles)) throw new Error(`Parameter 'circles' is not an array`);\n  const attempts = opts.attempts ?? 2000;\n\n  const sorted = sortByNumericProperty(circles, `radius`);\n  const positionedCircles: Array<CirclePositioned> = [];\n\n  const willHit = (b: Point, radius: number) => positionedCircles.some(v => CirclesIsIntersecting(v, b, radius));\n\n  while (sorted.length > 0) {\n    //eslint-disable-next-line functional/immutable-data\n    const circle = sorted.pop();\n    if (!circle) break;\n\n    const randomPointOpts = { ...opts, margin: { x: circle.radius, y: circle.radius } };\n\n    //eslint-disable-next-line functional/no-let\n    for (let index = 0; index < attempts; index++) {\n      const position = ShapesRandomPoint(container, randomPointOpts);\n      if (!willHit(position, circle.radius)) {\n        //eslint-disable-next-line functional/immutable-data\n        positionedCircles.push(Object.freeze({ ...circle, ...position }));\n        break;\n      }\n    }\n  }\n\n  return positionedCircles;\n};","import { toCartesian } from '../Polar.js';\nimport { throwIntegerTest } from \"../../util/GuardNumbers.js\";\nimport { Triangles, Points } from '../index.js';\nimport type { Triangle } from '../triangle/TriangleType.js';\nimport { isCirclePositioned, isCircle } from '../circle/Guard.js';\nimport type { RandomSource } from '../../random/Types.js';\nimport { corners as RectsCorners } from '../rect/Corners.js';\nimport { center as RectsCenter } from '../rect/Center.js';\nimport { fromTopLeft as RectsFromTopLeft } from '../rect/FromTopLeft.js';\nimport { isIntersecting as CirclesIsIntersecting } from '../circle/Intersecting.js';\nimport { randomPoint as circleRandomPoint } from '../circle/Random.js';\nimport { center as circleCenter } from '../circle/Center.js';\nimport { randomPoint as rectRandomPoint } from '../rect/Random.js';\nimport { isRect, isRectPositioned } from '../rect/Guard.js';\nimport { isIntersecting as RectsIsIntersecting } from '../rect/Intersects.js';\nimport type { Rect, RectPositioned, } from '../rect/RectTypes.js';\nimport type { CirclePositioned, Circle } from '../circle/CircleType.js';\nimport type { Line, PolyLine } from '../line/LineType.js';\nimport type { Point, Point3d } from './../point/PointType.js';\n\nexport type ShapePositioned = CirclePositioned | RectPositioned;\nexport type ContainsResult = `none` | `contained`;\n\nexport type Sphere = Point3d & {\n  readonly radius: number;\n};\n\nexport type PointCalculableShape =\n  | PolyLine\n  | Line\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  | RectPositioned\n  | Point\n  | CirclePositioned\n  ;\n\n/**\n * Returns the intersection result between a and b.\n * `a` can be a {@link CirclePositioned} or {@link RectPositioned}\n * `b` can be as above or a {@link Point}.\n * @param a\n * @param b\n */\nexport const isIntersecting = (\n  a: ShapePositioned,\n  b: ShapePositioned | Point\n): boolean => {\n  if (isCirclePositioned(a)) {\n    return CirclesIsIntersecting(a, b);\n  } else if (isRectPositioned(a)) {\n    return RectsIsIntersecting(a, b);\n  }\n  throw new Error(\n    `a or b are unknown shapes. a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) }`\n  );\n};\n\n// export enum Quadrant {\n//   Nw, Ne, Sw, Se\n// }\n\nexport type ShapeRandomPointOpts = {\n  readonly randomSource: RandomSource;\n};\n\n/**\n * Returns a random point within a shape.\n * `shape` can be {@link CirclePositioned} or {@link RectPositioned}\n * @param shape \n * @param opts \n * @returns \n */\nexport const randomPoint = (\n  shape: ShapePositioned,\n  opts: Partial<ShapeRandomPointOpts> = {}\n): Point => {\n  if (isCirclePositioned(shape)) {\n    return circleRandomPoint(shape, opts);\n  } else if (isRectPositioned(shape)) {\n    return rectRandomPoint(shape, opts);\n  }\n  throw new Error(`Unknown shape. Only CirclePositioned and RectPositioned are supported.`);\n};\n\n// export type Shape = {\n//   intersects(x:Point|Shape):ContainsResult\n//   readonly kind:`circular`\n\n// }\n\n/**\n * Returns the center of a shape\n * Shape can be: rectangle, triangle, circle\n * @param shape\n * @returns\n */\nexport const center = (\n  shape?: Rect | Triangle | Circle\n): Point => {\n  if (shape === undefined) {\n    return Object.freeze({ x: 0.5, y: 0.5 });\n  } else if (isRect(shape)) {\n    return RectsCenter(shape);\n  } else if (Triangles.isTriangle(shape)) {\n    return Triangles.centroid(shape);\n  } else if (isCircle(shape)) {\n    return circleCenter(shape);\n  } else {\n    throw new Error(`Unknown shape: ${ JSON.stringify(shape) }`);\n  }\n};\n\n/**\n * Generates a starburst shape, returning an array of points. By default, initial point is top and horizontally-centred.\n *\n * ```\n * // Generate a starburst with four spikes\n * const pts = starburst(4, 100, 200);\n * ```\n *\n * `points` of two produces a lozenge shape.\n * `points` of three produces a triangle shape.\n * `points` of five is the familiar 'star' shape.\n *\n * Note that the path will need to be closed back to the first point to enclose the shape.\n *\n * @example Create starburst and draw it. Note use of 'loop' flag to close the path\n * ```\n * const points = starburst(4, 100, 200);\n * Drawing.connectedPoints(ctx, pts, {loop: true, fillStyle: `orange`, strokeStyle: `red`});\n * ```\n *\n * Options:\n * * initialAngleRadian: angle offset to begin from. This overrides the `-Math.PI/2` default.\n *\n * @param points Number of points in the starburst. Defaults to five, which produces a typical star\n * @param innerRadius Inner radius. A proportionally smaller inner radius makes for sharper spikes. If unspecified, 50% of the outer radius is used.\n * @param outerRadius Outer radius. Maximum radius of a spike to origin\n * @param opts Options\n * @param origin Origin, or `{ x:0, y:0 }` by default.\n */\nexport const starburst = (\n  outerRadius: number,\n  points = 5,\n  innerRadius?: number,\n  origin: Point = Points.Empty,\n  opts?: { readonly initialAngleRadian?: number }\n): ReadonlyArray<Point> => {\n  throwIntegerTest(points, `positive`, `points`);\n  const angle = (Math.PI * 2) / points;\n  const angleHalf = angle / 2;\n\n  const initialAngle = opts?.initialAngleRadian ?? -Math.PI / 2;\n  if (innerRadius === undefined) innerRadius = outerRadius / 2;\n\n  //eslint-disable-next-line functional/no-let\n  let a = initialAngle;\n  const pts = [];\n\n  //eslint-disable-next-line functional/no-let\n  for (let index = 0; index < points; index++) {\n    const peak = toCartesian(outerRadius, a, origin);\n    const left = toCartesian(innerRadius, a - angleHalf, origin);\n    const right = toCartesian(innerRadius, a + angleHalf, origin);\n\n    //eslint-disable-next-line functional/immutable-data\n    pts.push(left, peak);\n    //eslint-disable-next-line functional/immutable-data\n    if (index + 1 < points) pts.push(right);\n    a += angle;\n  }\n  return pts;\n};\n\nexport type ArrowOpts = {\n  readonly arrowSize?: number;\n  readonly tailLength?: number;\n  readonly tailThickness?: number;\n  readonly angleRadian?: number;\n};\n\n/**\n * Returns the points forming an arrow.\n *\n * @example Create an arrow anchored by its tip at 100,100\n * ```js\n * const opts = {\n *  tailLength: 10,\n *  arrowSize: 20,\n *  tailThickness: 5,\n *  angleRadian: degreeToRadian(45)\n * }\n * const arrow = Shapes.arrow({x:100, y:100}, `tip`, opts); // Yields an array of points\n *\n * // Eg: draw points\n * Drawing.connectedPoints(ctx, arrow, {strokeStyle: `red`, loop: true});\n * ```\n *\n * @param origin Origin of arrow\n * @param from Does origin describe the tip, tail or middle?\n * @param opts Options for arrow\n * @returns\n */\nexport const arrow = (\n  origin: Point,\n  from: `tip` | `tail` | `middle`,\n  opts: ArrowOpts = {}\n): ReadonlyArray<Point> => {\n  const tailLength = opts.tailLength ?? 10;\n  const tailThickness = opts.tailThickness ?? Math.max(tailLength / 5, 5);\n  const angleRadian = opts.angleRadian ?? 0;\n  const arrowSize = opts.arrowSize ?? Math.max(tailLength / 5, 15);\n\n  const triAngle = Math.PI / 2;\n\n  let tri: Triangle;\n  let tailPoints: ReadonlyArray<Point>;\n\n  if (from === `tip`) {\n    tri = Triangles.equilateralFromVertex(origin, arrowSize, triAngle);\n    tailPoints = RectsCorners(\n      RectsFromTopLeft(\n        { x: tri.a.x - tailLength, y: origin.y - tailThickness / 2 },\n        tailLength,\n        tailThickness\n      )\n    );\n  } else if (from === `middle`) {\n    const midX = tailLength + arrowSize / 2;\n    const midY = tailThickness / 2;\n    tri = Triangles.equilateralFromVertex(\n      {\n        x: origin.x + arrowSize * 1.2,\n        y: origin.y,\n      },\n      arrowSize,\n      triAngle\n    );\n\n    tailPoints = RectsCorners(\n      RectsFromTopLeft(\n        { x: origin.x - midX, y: origin.y - midY },\n        tailLength + arrowSize,\n        tailThickness\n      )\n    );\n  } else {\n    //const midY = origin.y - tailThickness/2;\n    tailPoints = RectsCorners(\n      RectsFromTopLeft(\n        { x: origin.x, y: origin.y - tailThickness / 2 },\n        tailLength,\n        tailThickness\n      )\n    );\n    tri = Triangles.equilateralFromVertex(\n      { x: origin.x + tailLength + arrowSize * 0.7, y: origin.y },\n      arrowSize,\n      triAngle\n    );\n  }\n\n  const arrow = Points.rotate(\n    [\n      tailPoints[ 0 ],\n      tailPoints[ 1 ],\n      tri.a,\n      tri.b,\n      tri.c,\n      tailPoints[ 2 ],\n      tailPoints[ 3 ],\n    ],\n    angleRadian,\n    origin\n  );\n\n  return arrow;\n};\n","import { type Point } from \"../point/PointType.js\";\nimport { getRectPositioned } from \"./Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\n\n/**\n * Returns the four corners of a rectangle as an array of Points.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 0, y: 0};\n * const pts = Rects.corners(rect);\n * ```\n *\n * If the rectangle is not positioned, is origin can be provided.\n * Order of corners: ne, nw, sw, se\n * @param rect\n * @param origin\n * @returns\n */\nexport const corners = (\n  rect: RectPositioned | Rect,\n  origin?: Point\n): ReadonlyArray<Point> => {\n  const r = getRectPositioned(rect, origin);\n  return [\n    { x: r.x, y: r.y },\n    { x: r.x + r.width, y: r.y },\n    { x: r.x + r.width, y: r.y + r.height },\n    { x: r.x, y: r.y + r.height },\n  ];\n};","import type { Point } from \"../point/PointType.js\";\nimport { guardDim } from \"./Guard.js\";\nimport type { RectPositioned } from \"./RectTypes.js\";\nimport { guard as PointsGuard } from '../point/Guard.js';\n\n/**\n * Creates a rectangle from its top-left coordinate, a width and height.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Rectangle at 50,50 with width of 100, height of 200.\n * const rect = Rects.fromTopLeft({ x: 50, y:50 }, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport const fromTopLeft = (\n  origin: Point,\n  width: number,\n  height: number\n): RectPositioned => {\n  guardDim(width, `width`);\n  guardDim(height, `height`);\n  PointsGuard(origin, `origin`);\n\n  return { x: origin.x, y: origin.y, width: width, height: height };\n};\n","import { isPoint } from \"../point/Guard.js\";\nimport { distanceCenter } from \"./DistanceCenter.js\";\nimport { isCircle } from \"./Guard.js\";\nimport type { CirclePositioned } from \"./CircleType.js\";\nimport type { Point } from '../point/PointType.js';\n\n/**\n * Returns true if `b` is completely contained by `a`\n *\n * ```js\n * // Compare two points\n * isContainedBy(circleA, circleB);\n * \n * // Compare a circle with a point\n * isContainedBy(circleA, {x: 10, y: 20});\n * \n * // Define radius as third parameter\n * isContainedBy(circleA, {x: 10, y: 20}, 20);\n * ```\n * @param a Circle\n * @param b Circle or point to compare to\n * @param c Radius to accompany parameter b if it's a point\n * @returns\n */\nexport const isContainedBy = (a: CirclePositioned, b: CirclePositioned | Point, c?: number): boolean => {\n  const d = distanceCenter(a, b);\n  if (isCircle(b)) {\n    return (d < Math.abs(a.radius - b.radius));\n  } else if (isPoint(b)) {\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (c === undefined) {\n      return d <= a.radius;\n    } else {\n      // Defining a circle\n      return (d < Math.abs(a.radius - c));\n    }\n  } else throw new Error(`b parameter is expected to be CirclePositioned or Point`);\n};\n","import type { CirclePositioned } from \"./CircleType.js\";\nimport * as Intersects from '../Intersects.js';\nimport { isContainedBy } from \"./IsContainedBy.js\";\nimport { isCircle } from \"./Guard.js\";\nimport { isRectPositioned } from \"../rect/Guard.js\";\nimport { isEqual as PointsIsEqual } from \"../point/IsEqual.js\";\nimport type { Point } from '../point/PointType.js';\nimport { isPoint } from '../point/Guard.js';\nimport type { RectPositioned } from \"../rect/index.js\";\n\n/**\n * Returns true if `a` or `b` overlap, are equal, or `a` contains `b`.\n * A circle can be checked for intersections with another CirclePositioned, Point or RectPositioned.\n * \n * Use `intersections` to find the points of intersection.\n *\n * @param a Circle\n * @param b Circle or point to test\n * @returns True if circle overlap\n */\nexport const isIntersecting = (a: CirclePositioned, b: CirclePositioned | Point | RectPositioned, c?: number): boolean => {\n  if (PointsIsEqual(a, b)) return true;\n  if (isContainedBy(a, b, c)) return true;\n  if (isCircle(b)) {\n    return Intersects.circleCircle(a, b);\n  } else if (isRectPositioned(b)) {\n    return Intersects.circleRect(a, b);\n  } else if (isPoint(b) && c !== undefined) {\n    return Intersects.circleCircle(a, { ...b, radius: c });\n  }\n  return false;\n};","import type { Point } from \"../point/PointType.js\";\nimport type { Circle, CirclePositioned, CircleRandomPointOpts } from \"./CircleType.js\";\nimport { isCirclePositioned } from \"./Guard.js\";\nimport { sum as PointsSum } from \"../point/Sum.js\";\nimport { toCartesian as PolarToCartesian } from \"../Polar.js\";\nconst piPi = Math.PI * 2;\n/**\n * Returns a random point within a circle.\n * \n * By default creates a uniform distribution.\n * \n * ```js\n * const pt = randomPoint({radius: 5});\n * const pt = randomPoint({radius: 5, x: 10, y: 20});\n * ```'\n * \n * Generate points with a gaussian distribution\n * ```js\n * const pt = randomPoint(circle, {\n *  randomSource: Random.gaussian\n * })\n * ```\n * @param within Circle to generate a point within\n * @param opts Options\n * @returns \n */\nexport const randomPoint = (within: Circle | CirclePositioned, opts: Partial<CircleRandomPointOpts> = {}): Point => {\n  const offset: Point = isCirclePositioned(within) ? within : { x: 0, y: 0 };\n  const strategy = opts.strategy ?? `uniform`;\n  const margin = opts.margin ?? 0;\n  const radius = within.radius - margin;\n  const rand = opts.randomSource ?? Math.random;\n  switch (strategy) {\n    case `naive`: {\n      return PointsSum(offset, PolarToCartesian(rand() * radius, rand() * piPi));\n    }\n    case `uniform`: {\n      return PointsSum(offset, PolarToCartesian(Math.sqrt(rand()) * radius, rand() * piPi));\n    }\n    default: {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      throw new Error(`Unknown strategy '${ strategy }'. Expects 'uniform' or 'naive'`);\n    }\n  }\n};","import type { CirclePositioned, Circle } from \"./CircleType.js\";\nimport { isCirclePositioned } from \"./Guard.js\";\n\n/**\n * Returns the center of a circle\n * \n * If the circle has an x,y, that is the center.\n * If not, `radius` is used as the x and y.\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * const circle = { radius: 5, x: 10, y: 10};\n * \n * // Yields: { x: 5, y: 10 }\n * Circles.center(circle);\n * ```\n * \n * It's a trivial function, but can make for more understandable code\n * @param circle \n * @returns Center of circle\n */\nexport const center = (circle: CirclePositioned | Circle) => {\n  return isCirclePositioned(circle) ? Object.freeze({ x: circle.x, y: circle.y }) : Object.freeze({ x: circle.radius, y: circle.radius });\n};","import { type RandomSource, defaultRandom } from '../../random/Types.js';\nimport { sum as PointsSum } from '../point/Sum.js';\nimport type { Point } from '../point/PointType.js';\nimport { isPositioned } from './Guard.js';\nimport type { Rect, RectPositioned } from './RectTypes.js';\n/**\n * Returns a random positioned Rect on a 0..1 scale.\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const r = Rects.random(); // eg {x: 0.2549012, y:0.859301, width: 0.5212, height: 0.1423 }\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * import { weightedSource } from \"https://unpkg.com/ixfx/dist/random.js\"\n * const r = Rects.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport const random = (rando?: RandomSource): RectPositioned => {\n  if (rando === undefined) rando = defaultRandom;\n\n  return Object.freeze({\n    x: rando(),\n    y: rando(),\n    width: rando(),\n    height: rando(),\n  });\n};\n\nexport type RectRandomPointOpts = {\n  readonly strategy?: `naive`;\n  readonly randomSource?: RandomSource;\n  readonly margin?: { readonly x: number; readonly y: number };\n};\n\n/**\n * Returns a random point within a rectangle.\n *\n * By default creates a uniform distribution.\n *\n * ```js\n * const pt = randomPoint({width: 5, height: 10});\n * ```'\n * @param within Rectangle to generate a point within\n * @param options Options\n * @returns\n */\nexport const randomPoint = (\n  within: Rect | RectPositioned,\n  options: RectRandomPointOpts = {}\n): Point => {\n  // TODO: Does not implement uniform distribution\n  // See: https://math.stackexchange.com/questions/366474/find-coordinates-of-n-points-uniformly-distributed-in-a-rectangle\n  const rand = options.randomSource ?? defaultRandom;\n  const margin = options.margin ?? { x: 0, y: 0 };\n\n  const x = rand() * (within.width - margin.x - margin.x);\n  const y = rand() * (within.height - margin.y - margin.y);\n\n  const pos = { x: x + margin.x, y: y + margin.y };\n  return isPositioned(within) ? PointsSum(pos, within) : Object.freeze(pos);\n};","export * from './Area.js';\nexport * from './Bbox.js';\nexport * from './Center.js';\nexport type * from './CircleType.js';\nexport * from './CircularPath.js';\nexport * from './DistanceCenter.js';\nexport * from './DistanceFromExterior.js';\nexport * from './ExteriorPoints.js';\nexport * from './Guard.js';\nexport * from './InteriorPoints.js';\nexport * from './Interpolate.js';\nexport * from './Intersecting.js';\nexport * from './Intersections.js';\nexport * from './IsContainedBy.js';\nexport * from './IsEqual.js';\nexport * from './Multiply.js';\nexport * from './Perimeter.js';\nexport * from './Random.js';\nexport * from './Svg.js';\nexport * from './ToPath.js';\nexport * from './ToPositioned.js';\n\n","import type { Circle } from \"./CircleType.js\";\nimport { guard } from \"./Guard.js\";\n\n/**\n * Returns the area of `circle`.\n * @param circle \n * @returns \n */\nexport const area = (circle: Circle) => {\n  guard(circle);\n  return Math.PI * circle.radius * circle.radius;\n};","import { type RectPositioned } from \"./RectTypes.js\";\n\nimport type { Point } from \"../point/PointType.js\";\nimport { guard as PointsGuard } from '../point/Guard.js';\nimport { guardDim } from \"./Guard.js\";\n/**\n * Initialises a rectangle based on its center, a width and height\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Rectangle with center at 50,50, width 100 height 200\n * Rects.fromCenter({x: 50, y:50}, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport const fromCenter = (\n  origin: Point,\n  width: number,\n  height: number\n): RectPositioned => {\n  PointsGuard(origin, `origin`);\n\n  guardDim(width, `width`);\n  guardDim(height, `height`);\n\n  const halfW = width / 2;\n  const halfH = height / 2;\n  return {\n    x: origin.x - halfW,\n    y: origin.y - halfH,\n    width: width,\n    height: height,\n  };\n};","import type { RectPositioned } from \"../Types.js\";\nimport type { CirclePositioned, Circle } from \"./CircleType.js\";\nimport { isCirclePositioned } from \"./Guard.js\";\nimport { fromCenter as RectsFromCenter } from '../rect/FromCenter.js';\n/**\n * Computes a bounding box that encloses circle\n * @param circle\n * @returns \n */\nexport const bbox = (circle: CirclePositioned | Circle): RectPositioned => {\n  return isCirclePositioned(circle) ?\n    RectsFromCenter(circle, circle.radius * 2, circle.radius * 2) :\n    { width: circle.radius * 2, height: circle.radius * 2, x: 0, y: 0 };\n};\n","import type { Point } from '../point/PointType.js';\nimport type { CirclePositioned } from \"./CircleType.js\";\n\n/**\n * Yields the points making up the exterior (ie. circumference) of the circle.\n * Uses [Midpoint Circle Algorithm](http://en.wikipedia.org/wiki/Midpoint_circle_algorithm)\n * \n * @example Draw outline of circle\n * ```js\n * const circle = { x: 100, y: 100, radius: 50 }\n * for (const pt of Circles.exteriorIntegerPoints(circle)) {\n *  // Fill 1x1 pixel\n *  ctx.fillRect(pt.x, pt.y, 1, 1);\n * }\n * ```\n * @param circle \n */\nexport function* exteriorIntegerPoints(circle: CirclePositioned): IterableIterator<Point> {\n  const { x, y, radius } = circle;\n\n  let xx = radius;\n  let yy = 0;\n  let radiusError = 1 - x;\n  while (xx >= yy) {\n    yield { x: xx + x, y: yy + y };\n    yield { x: yy + x, y: xx + y };\n    yield { x: -xx + x, y: yy + y };\n    yield { x: -yy + x, y: xx + y };\n    yield { x: -xx + x, y: -yy + y };\n    yield { x: -yy + x, y: -xx + y };\n    yield { x: xx + x, y: -yy + y };\n    yield { x: yy + x, y: -xx + y }\n    yy++;\n    if (radiusError < 0) {\n      radiusError += 2 * yy + 1;\n    } else {\n      xx--;\n      radiusError += 2 * (yy - xx + 1);\n    }\n  }\n}\n\n","import type { CirclePositioned } from \"./CircleType.js\";\nimport { distance } from \"../point/Distance.js\";\nimport type { Point } from '../point/PointType.js';\n\n/**\n * Returns all integer points contained within `circle`.\n * \n * ```js\n * const c = { x:100, y:100, radius:100 };\n * for (const pt of Circles.interiorIntegerPoints(c)) {\n *   ctx.fillRect(pt.x, pt.y, 1, 1);\n * }\n * ```\n * @param circle \n */\nexport function* interiorIntegerPoints(circle: CirclePositioned): IterableIterator<Point> {\n  const xMin = circle.x - circle.radius;\n  const xMax = circle.x + circle.radius;\n  const yMin = circle.y - circle.radius;\n  const yMax = circle.y + circle.radius;\n  for (let x = xMin; x < xMax; x++) {\n    for (let y = yMin; y < yMax; y++) {\n      const r = Math.abs(distance(circle, x, y));\n      if (r <= circle.radius) yield { x, y };\n    }\n  }\n}","import type { Point } from \"../point/PointType.js\";\nimport type { Circle, CirclePositioned } from \"./CircleType.js\";\nimport { guard, isCirclePositioned } from \"./Guard.js\";\nimport { distance as PointsDistance } from \"../point/Distance.js\";\nimport { minIndex } from \"../../numbers/NumericArrays.js\";\nconst piPi = Math.PI * 2;\n\n/**\n * Returns the nearest point on `circle`'s perimeter closest to `point`.\n * \n * ```js\n * import { Circles } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const pt = Circles.nearest(circle, {x:10,y:10});\n * ```\n * \n * If an array of circles is provided, it will be the closest point amongst all the circles\n * @param circle Circle or array of circles\n * @param point\n * @returns Point `{ x, y }`\n */\nexport const nearest = (circle: CirclePositioned | ReadonlyArray<CirclePositioned>, point: Point): Point => {\n  const n = (a: CirclePositioned): Point => {\n    const l = Math.sqrt(Math.pow(point.x - a.x, 2) + Math.pow(point.y - a.y, 2));\n    const x = a.x + (a.radius * ((point.x - a.x) / l));\n    const y = a.y + (a.radius * ((point.y - a.y) / l));\n    return { x, y };\n  };\n\n  if (Array.isArray(circle)) {\n    const pts = circle.map(l => n(l));\n    const dists = pts.map(p => PointsDistance(p, point));\n    return Object.freeze<Point>(pts[ minIndex(...dists) ]);\n  } else {\n    return Object.freeze<Point>(n(circle as CirclePositioned));\n  }\n};\n\n/**\n * Returns a point on a circle's perimeter at a specified angle in radians\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * \n * // Circle without position\n * const circleA = { radius: 5 };\n * \n * // Get point at angle Math.PI, passing in a origin coordinate\n * const ptA = Circles.pointOnPerimeter(circleA, Math.PI, {x: 10, y: 10 });\n * \n * // Point on circle with position\n * const circleB = { radius: 5, x: 10, y: 10};\n * const ptB = Circles.pointOnPerimeter(circleB, Math.PI);\n * ```\n * @param circle\n * @param angleRadian Angle in radians\n * @param origin or offset of calculated point. By default uses center of circle or 0,0 if undefined\n * @returns Point oo circle\n */\nexport const pointOnPerimeter = (circle: Circle | CirclePositioned, angleRadian: number, origin?: Point): Point => {\n  if (origin === undefined) {\n    origin = isCirclePositioned(circle) ? circle : { x: 0, y: 0 };\n  }\n  return {\n    x: (Math.cos(-angleRadian) * circle.radius) + origin.x,\n    y: (Math.sin(-angleRadian) * circle.radius) + origin.y\n  };\n};\n\n/**\n * Returns circumference of `circle` (alias of {@link length})\n * @param circle \n * @returns \n */\nexport const circumference = (circle: Circle): number => {\n  guard(circle);\n  return piPi * circle.radius;\n};\n\n/**\n * Returns circumference of `circle` (alias of {@link circumference})\n * @param circle \n * @returns \n */\nexport const length = (circle: Circle): number => circumference(circle);\n","import type { Point } from \"../point/PointType.js\";\nimport type { CirclePositioned } from \"./CircleType.js\";\nimport { pointOnPerimeter } from \"./Perimeter.js\";\nconst piPi = Math.PI * 2;\n/**\n * Computes relative position along circle perimeter\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * const circle = { radius: 100, x: 100, y: 100 };\n * \n * // Get a point halfway around circle\n * // Yields { x, y }\n * const pt = Circles.interpolate(circle, 0.5);\n * ```\n * @param circle \n * @param t Position, 0-1\n * @returns \n */\nexport const interpolate = (circle: CirclePositioned, t: number): Point => pointOnPerimeter(circle, t * piPi);\n","import type { CirclePositioned, Circle } from \"./CircleType.js\";\nimport { isCirclePositioned } from \"./Guard.js\";\nimport { multiplyScalar as PointsMultiplyScalar } from '../point/Multiply.js';\n\nexport function multiplyScalar(a: CirclePositioned, value: number): CirclePositioned;\nexport function multiplyScalar(a: Circle, value: number): Circle;\n\n/**\n * Multiplies a circle's radius and position (if provided) by `value`.\n * \n * ```js\n * multiplyScalar({ radius: 5 }, 5);\n * // Yields: { radius: 25 }\n * \n * multiplyScalar({ radius: 5, x: 10, y: 20 }, 5);\n * // Yields: { radius: 25, x: 50, y: 100 }\n * ```\n */\nexport function multiplyScalar(a: Circle | CirclePositioned, value: number): Circle | CirclePositioned {\n  if (isCirclePositioned(a)) {\n    const pt = PointsMultiplyScalar(a, value);\n    return Object.freeze({\n      ...a,\n      ...pt,\n      radius: a.radius * value\n    });\n  } else {\n    return Object.freeze({\n      ...a,\n      radius: a.radius * value\n    });\n  }\n}\n\n","import type { Point } from \"../point/PointType.js\";\nimport type { Circle, CirclePositioned } from \"./CircleType.js\";\nimport { isCircle, isCirclePositioned } from \"./Guard.js\";\n\ntype ToSvg = {\n  (circleOrRadius: Circle | number, sweep: boolean, origin: Point): ReadonlyArray<string>;\n  (circle: CirclePositioned, sweep: boolean): ReadonlyArray<string>;\n};\n\n\n/**\n * Creates a SVG path segment.\n * @param a Circle or radius\n * @param sweep If true, path is 'outward'\n * @param origin Origin of path. Required if first parameter is just a radius or circle is non-positioned\n * @returns \n */\nexport const toSvg: ToSvg = (a: CirclePositioned | number | Circle, sweep: boolean, origin?: Point): ReadonlyArray<string> => {\n  if (isCircle(a)) {\n    if (origin !== undefined) {\n      return toSvgFull(a.radius, origin, sweep);\n    }\n    if (isCirclePositioned(a)) {\n      return toSvgFull(a.radius, a, sweep);\n    } else throw new Error(`origin parameter needed for non-positioned circle`);\n  } else {\n    if (origin === undefined) { throw new Error(`origin parameter needed`); } else {\n      return toSvgFull(a, origin, sweep);\n    }\n  }\n};\n\nconst toSvgFull = (radius: number, origin: Point, sweep: boolean): ReadonlyArray<string> => {\n  // https://stackoverflow.com/questions/5737975/circle-drawing-with-svgs-arc-path\n  const { x, y } = origin;\n  const s = sweep ? `1` : `0`;\n  return `\n    M ${ x }, ${ y }\n    m -${ radius }, 0\n    a ${ radius },${ radius } 0 1,${ s } ${ radius * 2 },0\n    a ${ radius },${ radius } 0 1,${ s } -${ radius * 2 },0\n  `.split(`\\n`);\n};\n","import type { Point } from \"../point/PointType.js\";\nimport { bbox } from \"./Bbox.js\";\nimport type { CirclePositioned } from \"./CircleType.js\";\nimport type { CircularPath } from \"./CircularPath.js\";\nimport { guard } from \"./Guard.js\";\nimport { interpolate } from \"./Interpolate.js\";\nimport { nearest } from \"./Perimeter.js\";\nimport { toSvg } from \"./Svg.js\";\nimport { circumference } from \"./Perimeter.js\";\n/**\n * Returns a `CircularPath` representation of a circle\n *\n * @param {CirclePositioned} circle\n * @returns {CircularPath}\n */\nexport const toPath = (circle: CirclePositioned): CircularPath => {\n  guard(circle);\n\n  return {\n    ...circle,\n    nearest: (point: Point) => nearest(circle, point),\n    /**\n     * Returns a relative (0.0-1.0) point on a circle. 0=3 o'clock, 0.25=6 o'clock, 0.5=9 o'clock, 0.75=12 o'clock etc.\n     * @param {t} Relative (0.0-1.0) point\n     * @returns {Point} X,y\n     */\n    interpolate: (t: number) => interpolate(circle, t),\n    bbox: () => bbox(circle),\n    length: () => circumference(circle),\n    toSvgString: (sweep = true) => toSvg(circle, sweep),\n    relativePosition: (_point: Point, _intersectionThreshold: number) => {\n      throw new Error(`Not implemented`)\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`)\n    },\n    kind: `circular`\n  };\n};","import type { Circle, CirclePositioned } from \"./CircleType.js\";\nimport { isCirclePositioned } from \"./Guard.js\";\nimport type { Point } from '../point/PointType.js';\nimport { getPointParameter } from \"../point/GetPointParameter.js\";\n\n\n/**\n * Returns a positioned version of a circle.\n * If circle is already positioned, it is returned.\n * If no default position is supplied, 0,0 is used.\n * @param circle \n * @param defaultPositionOrX \n * @param y \n * @returns \n */\nexport const toPositioned = (circle: Circle | CirclePositioned, defaultPositionOrX?: Point | number, y?: number): CirclePositioned => {\n  if (isCirclePositioned(circle)) return circle;\n\n  // Returns 0,0 if params are undefined\n  const pt = getPointParameter(defaultPositionOrX, y);\n  return Object.freeze({\n    ...circle,\n    ...pt\n  });\n};","export * from './Area.js';\nexport * from './Apply.js';\nexport * from './Cardinal.js';\nexport * from './Center.js';\nexport * from './Corners.js';\nexport * from './Distance.js';\nexport * from './Edges.js';\nexport * from './Empty.js';\nexport * from './FromCenter.js';\nexport * from './FromElement.js';\nexport * from './FromNumbers.js';\nexport * from './FromTopLeft.js';\nexport * from './GetRectPositionedParameter.js';\nexport * from './Guard.js';\nexport * from './Intersects.js';\nexport * from './IsEqual.js';\nexport * from './Lengths.js';\nexport * from './Max.js';\nexport * from './Multiply.js';\nexport * from './Divide.js';\n//export * from './NormaliseByRect.js';\nexport * from './Random.js';\nexport type * from './RectTypes.js';\nexport * from './Subtract.js';\nexport * from './Sum.js';\nexport * from './ToArray.js';","import { guard } from \"./Guard.js\";\nimport type { Rect } from \"./RectTypes.js\";\n\n/**\n * Returns the area of `rect`\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * Rects.area(rect);\n * ```\n * @param rect\n * @returns\n */\nexport const area = (rect: Rect): number => {\n  guard(rect);\n  return rect.height * rect.width;\n};","import { guard } from \"./Guard.js\";\nimport type { RectPositioned, Rect } from \"./RectTypes.js\";\nimport { isRect, isRectPositioned, isPositioned } from \"./Guard.js\";\n\nexport type ApplyOp = (a: number, b: number) => number\n\nexport function apply(\n  op: ApplyOp,\n  rect: RectPositioned,\n  width: number,\n  height?: number\n): RectPositioned;\nexport function apply(op: ApplyOp, rect: Rect, width: number, height: number): Rect;\nexport function apply(op: ApplyOp, a: RectPositioned, b: Rect): RectPositioned;\nexport function apply(op: ApplyOp, a: Rect, b: Rect): Rect;\nexport function apply(\n  op: ApplyOp,\n  a: RectPositioned | Rect,\n  b: Rect | number,\n  c?: number\n): RectPositioned | Rect {\n  guard(a, `a`);\n\n  if (isRect(b)) {\n    // Math op by another rectangle\n    return isRectPositioned(a) ? Object.freeze({\n      ...a,\n      x: op(a.x, b.width),\n      y: op(a.y, b.height),\n      width: op(a.width, b.width),\n      height: op(a.height, b.height),\n    }) : Object.freeze({\n      ...a,\n      width: op(a.width, b.width),\n      height: op(a.height, b.height),\n    });\n  } else {\n    // Math op with a series of values\n    if (typeof b !== `number`) {\n      throw new TypeError(\n        `Expected second parameter of type Rect or number. Got ${ JSON.stringify(\n          b\n        ) }`\n      );\n    }\n    if (typeof c !== `number`) throw new Error(`Expected third param as height. Got ${ JSON.stringify(c) }`);\n    return isRectPositioned(a) ? Object.freeze({\n      ...a,\n      x: op(a.x, b),\n      y: op(a.y, c),\n      width: op(a.width, b),\n      height: op(a.height, c),\n    }) : Object.freeze({\n      ...a,\n      width: op(a.width, b),\n      height: op(a.height, c),\n    });\n  }\n}\n\n/**\n * Uses `op` with `param` to width and height.\n * @param op \n * @param rect \n * @param param \n */\nexport function applyScalar(op: ApplyOp, rect: Rect, param: number): Rect;\n\n/**\n * Uses `op` to apply with `param` to width, height, x & y.\n * Use `applyDim` to apply just to dimensions.\n * @param op \n * @param rect \n * @param param \n */\nexport function applyScalar(\n  op: ApplyOp,\n  rect: RectPositioned,\n  param: number\n): RectPositioned;\n\nexport function applyScalar(\n  op: ApplyOp,\n  rect: Rect | RectPositioned,\n  param: number\n): Rect | RectPositioned {\n  return isPositioned(rect) ? Object.freeze({\n    ...rect,\n    x: op(rect.x, param),\n    y: op(rect.y, param),\n    width: op(rect.width, param),\n    height: op(rect.height, param),\n  }) : Object.freeze({\n    ...rect,\n    width: op(rect.width, param),\n    height: op(rect.height, param),\n  });\n}\n\n/**\n * Applies `op` with `param` to `rect`'s width and height.\n * @param op \n * @param rect \n * @param param \n * @returns \n */\nexport function applyDim(\n  op: ApplyOp,\n  rect: Rect | RectPositioned,\n  param: number\n): Rect | RectPositioned {\n  return Object.freeze({\n    ...rect,\n    width: op(rect.width, param),\n    height: op(rect.height, param),\n  });\n}","import type { RectPositioned } from \"./RectTypes.js\";\nimport type { CardinalDirection } from '../Grid.js';\nimport type { Point } from \"../point/PointType.js\";\n\n/**\n * Returns a point on cardinal direction, or 'center' for the middle.\n *\n * ```js\n * cardinal({x: 10, y:10, width:100, height: 20}, 'center');\n * ```\n * @param rect Rectangle\n * @param card Cardinal direction or 'center'\n * @returns Point\n */\nexport const cardinal = (\n  rect: RectPositioned,\n  card: CardinalDirection | `center`\n): Point => {\n  const { x, y, width, height } = rect;\n  switch (card) {\n    case `nw`: {\n      return Object.freeze({ x, y });\n    }\n    case `n`: {\n      return Object.freeze({\n        x: x + width / 2,\n        y,\n      });\n    }\n    case `ne`: {\n      return Object.freeze({\n        x: x + width,\n        y,\n      });\n    }\n    case `sw`: {\n      return Object.freeze({ x, y: y + height });\n    }\n    case `s`: {\n      return Object.freeze({\n        x: x + width / 2,\n        y: y + height,\n      });\n    }\n    case `se`: {\n      return Object.freeze({\n        x: x + width,\n        y: y + height,\n      });\n    }\n    case `w`: {\n      return Object.freeze({ x, y: y + height / 2 });\n    }\n    case `e`: {\n      return Object.freeze({ x: x + width, y: y + height / 2 });\n    }\n    case `center`: {\n      return Object.freeze({\n        x: x + width / 2,\n        y: y + height / 2,\n      });\n    }\n    default: {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      throw new Error(`Unknown direction: ${ card }`);\n    }\n  }\n};","import { isPoint } from \"../point/Guard.js\";\nimport { guard } from \"./Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\nimport { joinPointsToLines as LinesJoinPointsToLines } from '../line/JoinPointsToLines.js';\n\nimport type { Point } from '../point/PointType.js';\nimport { corners } from \"./Corners.js\";\nimport type { Line } from \"../line/LineType.js\";\n\n/**\n * Returns four lines based on each corner.\n * Lines are given in order: top, right, bottom, left\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * // Yields: array of length four\n * const lines = Rects.lines(rect);\n * ```\n *\n * @param {(RectPositioned|Rect)} rect\n * @param {Points.Point} [origin]\n * @returns {Lines.Line[]}\n */\nexport const edges = (\n  rect: RectPositioned | Rect,\n  origin?: Point\n): ReadonlyArray<Line> => {\n  const c = corners(rect, origin);\n\n  // Connect all the corners, back to first corner again\n  return LinesJoinPointsToLines(...c, c[ 0 ]);\n};\n\n/**\n * Returns a point on the edge of rectangle\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeX(r1, `right`);  // Yields: 110\n * Rects.getEdgeX(r1, `bottom`); // Yields: 10\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeX(r2, `right`);  // Yields: 100\n * Rects.getEdgeX(r2, `bottom`); // Yields: 0\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport const getEdgeX = (\n  rect: RectPositioned | Rect,\n  edge: `right` | `bottom` | `left` | `top`\n): number => {\n  guard(rect);\n  switch (edge) {\n    case `top`: {\n      return isPoint(rect) ? rect.x : 0;\n    }\n    case `bottom`: {\n      return isPoint(rect) ? rect.x : 0;\n    }\n    case `left`: {\n      return isPoint(rect) ? rect.y : 0;\n    }\n    case `right`: {\n      return isPoint(rect) ? rect.x + rect.width : rect.width;\n    }\n  }\n};\n\n/**\n * Returns a point on the edge of rectangle\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeY(r1, `right`);  // Yields: 10\n * Rects.getEdgeY(r1, `bottom`); // Yields: 60\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeY(r2, `right`);  // Yields: 0\n * Rects.getEdgeY(r2, `bottom`); // Yields: 50\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport const getEdgeY = (\n  rect: RectPositioned | Rect,\n  edge: `right` | `bottom` | `left` | `top`\n): number => {\n  guard(rect);\n  switch (edge) {\n    case `top`: {\n      return (isPoint(rect) ? rect.y : 0);\n    }\n    case `bottom`: {\n      return isPoint(rect) ? rect.y + rect.height : rect.height;\n    }\n    case `left`: {\n      return isPoint(rect) ? rect.y : 0;\n    }\n    case `right`: {\n      return isPoint(rect) ? rect.y : 0;\n    }\n  }\n};","export const Empty = Object.freeze({ width: 0, height: 0 });\nexport const EmptyPositioned = Object.freeze({\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0,\n});","import type { Rect } from \"./RectTypes.js\";\n\n/**\n * Initialise a rectangle based on the width and height of a HTML element.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\"\n * Rects.fromElement(document.querySelector(`body`));\n * ```\n * @param el\n * @returns\n */\nexport const fromElement = (el: HTMLElement): Rect => ({\n  width: el.clientWidth,\n  height: el.clientHeight,\n});","import type { RectPositioned, Rect } from \"./RectTypes.js\";\n/**\n * Returns a rectangle from width, height\n * ```js\n * const r = Rects.fromNumbers(100, 200);\n * // {width: 100, height: 200}\n * ```\n *\n * Use {@link toArray} for the opposite conversion.\n *\n * @param width\n * @param height\n */\nexport function fromNumbers(width: number, height: number): Rect;\n\n/**\n * Returns a rectangle from x,y,width,height\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const r = Rects.fromNumbers(10, 20, 100, 200);\n * // {x: 10, y: 20, width: 100, height: 200}\n * ```\n *\n * Use the spread operator (...) if the source is an array:\n * ```js\n * const r3 = Rects.fromNumbers(...[10, 20, 100, 200]);\n * ```\n *\n * Use {@link toArray} for the opposite conversion.\n *\n * @param x\n * @param y\n * @param width\n * @param height\n */\nexport function fromNumbers(\n  x: number,\n  y: number,\n  width: number,\n  height: number\n): RectPositioned;\n\n/**\n * Returns a rectangle from a series of numbers: x, y, width, height OR width, height\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const r1 = Rects.fromNumbers(100, 200);\n * // {width: 100, height: 200}\n *\n * const r2 = Rects.fromNumbers(10, 20, 100, 200);\n * // {x: 10, y: 20, width: 100, height: 200}\n * ```\n * Use the spread operator (...) if the source is an array:\n *\n * ```js\n * const r3 = Rects.fromNumbers(...[10, 20, 100, 200]);\n * ```\n *\n * Use {@link toArray} for the opposite conversion.\n *\n * @see toArray\n * @param xOrWidth\n * @param yOrHeight\n * @param width\n * @param height\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function fromNumbers(\n  xOrWidth: number,\n  yOrHeight: number,\n  width?: number,\n  height?: number\n): Rect | RectPositioned {\n  if (width === undefined || height === undefined) {\n    if (typeof xOrWidth !== `number`) throw new Error(`width is not an number`);\n    if (typeof yOrHeight !== `number`) {\n      throw new TypeError(`height is not an number`);\n    }\n    return Object.freeze({ width: xOrWidth, height: yOrHeight });\n  }\n  if (typeof xOrWidth !== `number`) throw new Error(`x is not an number`);\n  if (typeof yOrHeight !== `number`) throw new Error(`y is not an number`);\n  if (typeof width !== `number`) throw new Error(`width is not an number`);\n  if (typeof height !== `number`) throw new Error(`height is not an number`);\n\n  return Object.freeze({ x: xOrWidth, y: yOrHeight, width, height });\n}\n","import { isPoint } from \"../point/Guard.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport { isRect, isRectPositioned } from \"./Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\n\n/**\n * Accepts:\n * * x,y,w,h\n * * x,y,rect\n * * point,rect\n * * RectPositioned\n * * Rect, x,y\n * * Rect, Point\n * @param a \n * @param b \n * @param c \n * @param d \n * @returns \n */\nexport function getRectPositionedParameter(a: number | Point | Rect | RectPositioned, b?: Rect | number | Point, c?: number | Rect, d?: number): RectPositioned {\n  if (typeof a === `number`) {\n    if (typeof b === `number`) {\n      if (typeof c === `number` && typeof d === `number`) {\n        return { x: a, y: b, width: c, height: d }\n      } else if (isRect(c)) {\n        return { x: a, y: b, width: c.width, height: c.height }\n      } else {\n        throw new TypeError(`If params 'a' & 'b' are numbers, expect following parameters to be x,y or Rect`);\n      }\n    } else {\n      throw new TypeError(`If parameter 'a' is a number, expect following parameters to be: y,w,h`);\n    }\n  } else if (isRectPositioned(a)) {\n    return a;\n  } else if (isRect(a)) {\n    if (typeof b === `number` && typeof c === `number`) {\n      return { width: a.width, height: a.height, x: b, y: c };\n    } else if (isPoint(b)) {\n      return { width: a.width, height: a.height, x: b.x, y: b.y };\n    } else {\n      throw new TypeError(`If param 'a' is a Rect, expects following parameters to be x,y`);\n    }\n  } else if (isPoint(a)) {\n    if (typeof b === `number` && typeof c === `number`) {\n      return { x: a.x, y: a.y, width: b, height: c };\n    } else if (isRect(b)) {\n      return { x: a.x, y: a.y, width: b.width, height: b.height };\n    } else {\n      throw new TypeError(`If parameter 'a' is a Point, expect following params to be: Rect or width,height`);\n    }\n  }\n  throw new TypeError(`Expect a first parameter to be x,RectPositioned,Rect or Point`);\n}\n\n","import { isPositioned } from \"./Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\nimport { isEqual as PointsIsEqual } from '../point/IsEqual.js';\n/**\n * Returns _true_ if the width & height of the two rectangles is the same.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const isEqualSize = (a: Rect, b: Rect): boolean => {\n  if (a === undefined) throw new Error(`a undefined`);\n  if (b === undefined) throw new Error(`b undefined`);\n  return a.width === b.width && a.height === b.height;\n};\n\n/**\n * Returns _true_ if two rectangles have identical values.\n * Both rectangles must be positioned or not.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (\n  a: Rect | RectPositioned,\n  b: Rect | RectPositioned\n): boolean => {\n  if (isPositioned(a) && isPositioned(b)) {\n    if (!PointsIsEqual(a, b)) return false;\n    return a.width === b.width && a.height === b.height;\n  } else if (!isPositioned(a) && !isPositioned(b)) {\n    return a.width === b.width && a.height === b.height;\n  } else {\n    // One param is positioned, the other is not\n    return false;\n  }\n};","import { length as LinesLength } from '../line/Length.js';\n\nimport { edges } from './Edges.js';\nimport { guardPositioned } from './Guard.js';\nimport type { RectPositioned } from './RectTypes.js';\n/**\n * Returns the length of each side of the rectangle (top, right, bottom, left)\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * // Yields: array of length four\n * const lengths = Rects.lengths(rect);\n * ```\n * @param rect\n * @returns\n */\nexport const lengths = (rect: RectPositioned): ReadonlyArray<number> => {\n  guardPositioned(rect, `rect`);\n  return edges(rect).map((l) => LinesLength(l));\n};\n","import type { RectPositioned, Rect } from \"./RectTypes.js\";\nimport { apply, applyDim, applyScalar } from \"./Apply.js\";\n\nconst multiplyOp = (a: number, b: number) => a * b;\n\n\n/**\n * Multiplies positioned `rect` by width/height. Useful for denormalising a value.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Normalised rectangle\n * const r = { x:0.5, y:0.5, width: 0.5, height: 0.5};\n *\n * // Map to window:\n * const rr = Rects.multiply(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * Multiplication applies to the first parameter's x/y fields.\n */\nexport function multiply(\n  rect: RectPositioned,\n  width: number,\n  height?: number\n): RectPositioned;\n\n/**\n * Multiplies `rect` by width/height. Useful for denormalising a value.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Normalised rectangle of width 50%, height 50%\n * const r = { width: 0.5, height: 0.5 };\n *\n * // Map to window:\n * const rr = Rects.multiply(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * Multiplication applies to the first parameter's x/y fields, if present.\n */\nexport function multiply(rect: Rect, width: number, height: number): Rect;\n\n/**\n * Multiplies positioned rect `a` by width and height of rect `b`.\n * ```js\n * // Returns {width: someRect.width * someOtherRect.width ...}\n * Rects.multiply(someRect, someOtherRect);\n * ```\n *\n * @param a \n * @param b \n */\nexport function multiply(a: RectPositioned, b: Rect): RectPositioned;\n\n/**\n * Multiplies rect `a` by width and height of rect `b`.\n * \n * ```js\n * // Returns {width: someRect.width * someOtherRect.width ...}\n * Rects.multiply(someRect, someOtherRect);\n * ```\n *\n * @param a \n * @param b \n */\nexport function multiply(a: Rect, b: Rect): Rect;\n\n/**\n * @internal\n * @param a \n * @param b \n * @param c \n * @returns \n */\nexport function multiply(\n  a: RectPositioned | Rect,\n  b: Rect | number,\n  c?: number\n): RectPositioned | Rect {\n  // @ts-ignore\n  return apply(multiplyOp, a, b, c) as RectPositioned | Rect;\n}\n\n\n/**\n * Multiplies all components of `rect` by `amount`.\n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * ```\n * @param rect\n * @param amount\n */\nexport function multiplyScalar(rect: Rect, amount: number): Rect;\n\n/**\n * Multiplies all components of `rect` by `amount`.\n * This includes x,y if present.\n * \n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * multiplyScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 2, y: 4, width:20, height: 40 }\n * ```\n * @param rect\n * @param amount\n */\nexport function multiplyScalar(\n  rect: RectPositioned,\n  amount: number\n): RectPositioned;\n\n/**\n * Multiplies all components of `rect` by `amount`.\n * This includes x,y if present.\n * \n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * multiplyScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 2, y: 4, width:20, height: 40 }\n * ```\n * \n * Use {@link multiplyDim} to only multiply width & height.\n * @param rect\n * @param amount\n */\nexport function multiplyScalar(\n  rect: Rect | RectPositioned,\n  amount: number\n): Rect | RectPositioned {\n  return applyScalar(multiplyOp, rect, amount);\n  // return isPositioned(rect) ? Object.freeze({\n  //   ...rect,\n  //   x: rect.x * amount,\n  //   y: rect.y * amount,\n  //   width: rect.width * amount,\n  //   height: rect.height * amount,\n  // }) : Object.freeze({\n  //   ...rect,\n  //   width: rect.width * amount,\n  //   height: rect.height * amount,\n  // });\n}\n\n\n/**\n * Multiplies only the width/height of `rect`, leaving `x` and `y` as they are.\n * ```js\n * multiplyDim({ x:1,y:2,width:3,height:4 }, 2);\n * // Yields: { x:1, y:2, width:6, height: 8 }\n * ```\n * \n * In comparison, {@link multiply} will also include x & y.\n * @param rect Rectangle\n * @param amount Amount to multiply by\n * @returns \n */\nexport function multiplyDim(\n  rect: Rect | RectPositioned,\n  amount: number\n): Rect | RectPositioned {\n  return applyDim(multiplyOp, rect, amount);\n  // return isPositioned(rect) ? Object.freeze({\n  //   ...rect,\n  //   x: rect.x * amount,\n  //   y: rect.y * amount,\n  //   width: rect.width * amount,\n  //   height: rect.height * amount,\n  // }) : Object.freeze({\n  //   ...rect,\n  //   width: rect.width * amount,\n  //   height: rect.height * amount,\n  // });\n}\n","import type { RectPositioned, Rect } from \"./RectTypes.js\";\nimport { apply, applyDim, applyScalar } from \"./Apply.js\";\n\nconst divideOp = (a: number, b: number) => a / b;\n\n/**\n * Divides positioned `rect` by width/height. Useful for normalising a value.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Normalise based on window size\n * const r = { x: 10, y: 200, width: 100, height: 30 };\n * const rr = Rects.divide(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * Division applies to the first parameter's x/y fields. X is affected by `width`, Y is affected by `height`.\n */\nexport function divide(\n  rect: RectPositioned,\n  width: number,\n  height?: number\n): RectPositioned;\n\n/**\n * Divides `rect` by width/height. Useful for denormalising a value.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * // Normalise based on window size\n * const r = { width: 100, height: 30 };\n * const rr = Rects.divide(r, window.innerWidth, window.innerHeight);\n * ```\n *\n */\nexport function divide(rect: Rect, width: number, height: number): Rect;\n\n/**\n * Divides positioned rect `a` by width and height of rect `b`.\n * ```js\n * // Returns { ...a, width: a.width / b.width, height: a.height/b.height, x: a.x / b.width, y: a.y / b.height }\n * Rects.divide(a, b);\n * ```\n *\n * @param a \n * @param b \n */\nexport function divide(a: RectPositioned, b: Rect): RectPositioned;\n\n/**\n * Divides rect `a` by width and height of rect `b`.\n * \n * ```js\n * // Returns {...a, width: a.width / b.width, height: a.height/b.height }\n * Rects.divide(a, b);\n * ```\n *\n * @param a \n * @param b \n */\nexport function divide(a: Rect, b: Rect): Rect;\n\n/**\n * @internal\n * @param a \n * @param b \n * @param c \n * @returns \n */\nexport function divide(\n  a: RectPositioned | Rect,\n  b: Rect | number,\n  c?: number\n): RectPositioned | Rect {\n  // @ts-ignore\n  return apply(divideOp, a, b, c) as RectPositioned | Rect;\n}\n\n\n/**\n * Divides all components of `rect` by `amount`.\n * ```js\n * divideScalar({ width:10, height:20 }, 2); // { width:5, height: 10 }\n * ```\n * @param rect\n * @param amount\n */\nexport function divideScalar(rect: Rect, amount: number): Rect;\n\n/**\n * Divides all components of `rect` by `amount`.\n * This includes x,y if present.\n * \n * ```js\n * divideScalar({ width:10, height:20 }, 2); // { width:5, height: 10 }\n * divideScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 0.5, y: 1, width:5, height: 10 }\n * ```\n * @param rect\n * @param amount\n */\nexport function divideScalar(\n  rect: RectPositioned,\n  amount: number\n): RectPositioned;\n\n/**\n * Divides all components of `rect` by `amount`.\n * This includes x,y if present.\n * \n * ```js\n * divideScalar({ width:10, height:20 }, 2); // { width:5, height: 10 }\n * divideScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 0.5, y: 1, width:5, height: 10 }\n * ```\n * @param rect\n * @param amount\n */\nexport function divideScalar(\n  rect: Rect | RectPositioned,\n  amount: number\n): Rect | RectPositioned {\n  return applyScalar(divideOp, rect, amount);\n}\n\nexport function divideDim(\n  rect: Rect | RectPositioned,\n  amount: number\n): Rect | RectPositioned {\n  return applyDim(divideOp, rect, amount);\n}\n","import { apply } from \"./Apply.js\";\nimport { isPositioned } from \"./Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\n\nconst subtractOp = (a: number, b: number) => a - b;\n\n/**\n * Subtracts width/height of `b` from `a` (ie: a - b), returning result.\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: -100, height: -100 }\n * Rects.subtract(rectA, rectB);\n * ```\n * @param a\n * @param b\n */\nexport function subtract(a: Rect, b: Rect): Rect;\nexport function subtract(a: RectPositioned, b: Rect): RectPositioned;\n\n/**\n * Subtracts a width/height from `a`, returning result.\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100 };\n *\n * // Yields: { width: -100, height: -100 }\n * Rects.subtract(rect, 200, 200);\n * ```\n * @param a\n * @param width\n * @param height\n */\nexport function subtract(a: Rect, width: number, height: number): Rect;\n\nexport function subtract(a: RectPositioned, width: number, height: number): RectPositioned;\n/**\n * Subtracts width/height from `a`.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: -100, height: -100 }\n * Rects.subtract(rectA, rectB);\n * Rects.subtract(rectA, 200, 200);\n * ```\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport function subtract(a: Rect | undefined, b: Rect | number, c?: number): Rect {\n  // @ts-ignore\n  return apply(subtractOp, a, b, c);\n}\n\n/**\n * Subtracts x,y,width,height of a-b.\n * ```js\n * subtractOffset({x:100,y:100,width:100,height:100}, {x:10, y:20, width: 30, height: 40});\n * // Yields: {x: 90, y: 80, width: 70, height: 60 }\n * ```\n * If either `a` or `b` are missing x & y, 0 is used\n * @param a \n * @param b \n * @returns \n */\nexport function subtractOffset(a: RectPositioned | Rect, b: RectPositioned | Rect): RectPositioned {\n  let x = 0;\n  let y = 0;\n  if (isPositioned(a)) {\n    x = a.x;\n    y = a.y;\n  }\n  let xB = 0;\n  let yB = 0;\n  if (isPositioned(b)) {\n    xB = b.x;\n    yB = b.y;\n  }\n  return Object.freeze({\n    ...a,\n    x: x - xB,\n    y: y - yB,\n    width: a.width - b.width,\n    height: a.height - b.height\n  })\n}","import { apply } from \"./Apply.js\";\nimport { getRectPositioned, isPositioned } from \"./Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\n\nconst sumOp = (a: number, b: number) => a + b;\n/**\n * Sums width/height of `b` with `a` (ie: a + b), returning result.\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: 300, height: 300 }\n * Rects.sum(rectA, rectB);\n * ```\n * @param a\n * @param b\n */\nexport function sum(a: Rect, b: Rect): Rect;\n\n/**\n * Sums width/height of `b` with `a`, returning result.\n * \n * Note that width/height of `b` is also added to `a`'s x & y properties\n * ```js\n * // Yields: { x:101, y:202, width: 110, height: 220 }\n * sum({x:1, y:2, width:10, height:20}, {width:100, height: 200});\n * ```\n * \n * x & y values of `b` are ignored. If you want to sum with those, use `sumOffset`\n * @param a \n * @param b \n */\nexport function sum(a: RectPositioned, b: Rect): RectPositioned;\n\n/**\n * Sums width/height of `rect` with given `width` and `height`\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100 };\n *\n * // Yields: { width: 300, height: 300 }\n * Rects.subtract(rect, 200, 200);\n * ```\n * @param rect\n * @param width\n * @param height\n */\nexport function sum(rect: Rect, width: number, height: number): Rect;\n\n/**\n * Sums width/height of `rect` with `width` and `height`\n * \n * `width` and `height` is added to `rect`'s `x` and `y` values.\n * ```js\n * // Yields: { x:101, y:202, width: 110, height: 220 }\n * sum({x:1, y:2, width:10, height:20}, 100, 200);\n * ```\n * @param rect\n * @param width\n * @param height\n */\nexport function sum(rect: RectPositioned, width: number, height: number): RectPositioned;\n\n/**\n * Sums width/height of `b` with `a` (ie: a + b), returning result.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: 300, height: 300 }\n * Rects.sum(rectA, rectB);\n * Rects.sum(rectA, 200, 200);\n * ```\n * @param a\n * @param b\n * @param c\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function sum(a: Rect, b: Rect | number, c?: number): Rect {\n  // @ts-ignore\n  return apply(sumOp, a, b, c);\n}\n\n/**\n * Sums x,y,width,height of a+b.\n * ```js\n * sumOffset({x:100,y:100,width:100,height:100}, {x:10, y:20, width: 30, height: 40});\n * // Yields: {x: 110, y: 120, width: 130, height: 140 }\n * ```\n * If either `a` or `b` are missing x & y, 0 is used\n * @param a \n * @param b \n * @returns \n */\nexport function sumOffset(a: RectPositioned | Rect, b: RectPositioned | Rect): RectPositioned {\n  let x = 0;\n  let y = 0;\n  if (isPositioned(a)) {\n    x = a.x;\n    y = a.y;\n  }\n  let xB = 0;\n  let yB = 0;\n  if (isPositioned(b)) {\n    xB = b.x;\n    yB = b.y;\n  }\n  return Object.freeze({\n    ...a,\n    x: x + xB,\n    y: y + yB,\n    width: a.width + b.width,\n    height: a.height + b.height\n  })\n}","import { isPositioned, isRect } from \"./Guard.js\";\nimport type { Rect, RectArray, RectPositioned, RectPositionedArray } from \"./RectTypes.js\";\n\n/**\n * Converts a rectangle to an array of numbers. See {@link fromNumbers} for the opposite conversion.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const r1 = Rects.toArray({ x: 10, y:20, width: 100, height: 200 });\n * // [10, 20, 100, 200]\n * const r2 = Rects.toArray({ width: 100, height: 200 });\n * // [100, 200]\n * ```\n * @param rect\n * @see fromNumbers\n */\nexport function toArray(rect: Rect): RectArray;\n\n/**\n * Converts a rectangle to an array of numbers. See {@link fromNumbers} for the opposite conversion.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const r1 = Rects.toArray({ x: 10, y:20, width: 100, height: 200 });\n * // [10, 20, 100, 200]\n * const r2 = Rects.toArray({ width: 100, height: 200 });\n * // [100, 200]\n * ```\n * @param rect\n * @see fromNumbers\n */\nexport function toArray(rect: RectPositioned): RectPositionedArray;\n\n/**\n * Converts a rectangle to an array of numbers. See {@link fromNumbers} for the opposite conversion.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const r1 = Rects.toArray({ x: 10, y:20, width: 100, height: 200 });\n * // [10, 20, 100, 200]\n * const r2 = Rects.toArray({ width: 100, height: 200 });\n * // [100, 200]\n * ```\n * @param rect\n * @see fromNumbers\n */\n// eslint-disable-next-line func-style\nexport function toArray(\n  rect: Rect | RectPositioned\n): RectArray | RectPositionedArray {\n  if (isPositioned(rect)) {\n    return [ rect.x, rect.y, rect.width, rect.height ];\n  } else if (isRect(rect)) {\n    return [ rect.width, rect.height ];\n  } else {\n    throw new Error(\n      `Param 'rect' is not a rectangle. Got: ${ JSON.stringify(rect) }`\n    );\n  }\n}\n","import type { Point } from '../point/PointType.js';\nimport { isLine } from '../line/Guard.js';\nimport type { Path } from './PathType.js';\nimport { isQuadraticBezier } from '../bezier/Guard.js';\nexport * from './PathType.js';\n/**\n * Return the start point of a path\n *\n * @param path\n * @return Point\n */\nexport const getStart = function (path: Path): Point {\n  if (isQuadraticBezier(path)) return path.a;\n  else if (isLine(path)) return path.a;\n  else throw new Error(`Unknown path type ${ JSON.stringify(path) }`);\n};\n\n/**\n * Return the end point of a path\n *\n * @param path\n * @return Point\n */\nexport const getEnd = function (path: Path): Point {\n  if (isQuadraticBezier(path)) return path.b;\n  else if (isLine(path)) return path.b;\n  else throw new Error(`Unknown path type ${ JSON.stringify(path) }`);\n};\n\n","import type { Path } from \"../path/PathType.js\";\nimport type { QuadraticBezier, CubicBezier } from \"./BezierType.js\";\n\nexport const isQuadraticBezier = (path: Path | QuadraticBezier | CubicBezier): path is QuadraticBezier => (path as QuadraticBezier).quadratic !== undefined;\n\nexport const isCubicBezier = (path: Path | CubicBezier | QuadraticBezier): path is CubicBezier => (path as CubicBezier).cubic1 !== undefined && (path as CubicBezier).cubic2 !== undefined;\n","import type { Point } from './point/PointType.js';\nimport { fromTopLeft as RectsFromTopLeft } from './rect/FromTopLeft.js';\nimport { throwIntegerTest, throwNumberTest } from '../util/GuardNumbers.js';\nimport { clampIndex } from '../numbers/Clamp.js';\nimport { randomElement } from '../data/arrays/Random.js';\nimport { type ISetMutable, mutable } from '../collections/set/index.js';\nimport { zipKeyValue } from '../data/maps/MapFns.js';\nimport type { RectPositioned } from './rect/RectTypes.js';\n\nexport type GridVisual = Grid & {\n  readonly size: number;\n};\n\nexport type Grid = {\n  readonly rows: number;\n  readonly cols: number;\n};\n\nexport type Cell = {\n  readonly x: number;\n  readonly y: number;\n};\n\nexport type Neighbours = {\n  readonly n: Cell | undefined;\n  readonly e: Cell | undefined;\n  readonly s: Cell | undefined;\n  readonly w: Cell | undefined;\n  readonly ne: Cell | undefined;\n  readonly nw: Cell | undefined;\n  readonly se: Cell | undefined;\n  readonly sw: Cell | undefined;\n};\n\nexport type CardinalDirection =\n  | `n`\n  | `ne`\n  | `e`\n  | `se`\n  | `s`\n  | `sw`\n  | `w`\n  | `nw`;\nexport type CardinalDirectionOptional = CardinalDirection | ``;\n\n/**\n * Bounds logic\n * * Unbounded: attempts to read beyond limits\n * * Undefined: returns _undefined_ when reading beyond limits\n * * Stop: returns cell value at edge of limits\n * * Wrap: Wrap-around cell positions\n * \n */\nexport type BoundsLogic =\n  /**\n   * Unbounded: attempts to read beyond limits\n   */\n  `unbounded` |\n  /**\n   * Undefined: returns _undefined_ when reading beyond limits\n   */\n  `undefined` |\n  /**\n   * Stop: returns cell value at edge of limits\n   */\n  `stop` |\n  /**\n   * Wrap-around cell positions\n   */\n  `wrap`;\n\nexport type VisitorLogic = {\n  readonly options?: IdentifyNeighbours;\n  readonly select: NeighbourSelector;\n};\nexport type VisitGenerator = Generator<Readonly<Cell>, void>;\nexport type VisitorOpts = {\n  readonly visited?: ISetMutable<Cell>;\n  readonly reversed?: boolean;\n  readonly debug?: boolean;\n  readonly boundsWrap?: BoundsLogic;\n};\n\n/**\n * Visitor function.\n *\n * Implementations:\n * * {@link cells}: left-to-right, top-to-bottom. Same as {@link visitorRow}\n * * {@link visitorBreadth}, {@link visitorDepth}\n * * {@link visitorColumn}: top-to-bottom, left-to-right.\n * * {@link visitorRandom}: Any unvisited location\n * * {@link visitorRandomContiguous}: A random direct neighbour of current cell\n */\nexport type Visitor = (\n  grid: Grid,\n  start: Cell,\n  opts?: VisitorOpts\n) => VisitGenerator;\n\nexport type NeighbourMaybe = readonly [ keyof Neighbours, Cell | undefined ];\nexport type Neighbour = readonly [ keyof Neighbours, Cell ];\n\n/**\n * A function that returns a value (or _undefined_) based on a _cell_\n *\n * Implementations:\n * * {@link access1dArray}: For accessing a single-dimension array as a grid\n */\nexport type CellAccessor<V> = (cell: Cell, wrap: BoundsLogic) => V | undefined;\n\n/**\n * Neighbour selector logic. For a given set of `neighbours` pick one to visit next.\n */\nexport type NeighbourSelector = (\n  neighbours: ReadonlyArray<Neighbour>\n) => Neighbour | undefined;\n\n/**\n * Identify neighbours logic. For a given `grid` and `origin`, return a list of neighbours\n */\nexport type IdentifyNeighbours = (\n  grid: Grid,\n  origin: Cell\n) => ReadonlyArray<Neighbour>;\n\n/**\n * Returns true if `cell` parameter is a cell with x,y fields.\n * Does not check validity of fields.\n *\n * @param cell\n * @return True if parameter is a cell\n */\nconst isCell = (cell: Cell | undefined): cell is Cell => {\n  if (cell === undefined) return false;\n  return `x` in cell && `y` in cell;\n};\n\n/**\n * Returns true if `n` is a Neighbour type, eliminating NeighbourMaybe possibility\n *\n * @param n\n * @return\n */\nconst isNeighbour = (\n  n: Neighbour | NeighbourMaybe | undefined\n): n is Neighbour => {\n  if (n === undefined) return false;\n  if (n[ 1 ] === undefined) return false;\n  return true;\n};\n\n/**\n * Returns _true_ if grids `a` and `b` are equal in value.\n * Returns _false_ if either parameter is undefined.\n *\n * @param a\n * @param b\n * @return\n */\nexport const isEqual = (\n  a: Grid | GridVisual,\n  b: Grid | GridVisual\n): boolean => {\n  if (b === undefined) return false;\n  if (a === undefined) return false;\n  if (`rows` in a && `cols` in a) {\n    if (`rows` in b && `cols` in b) {\n      if (a.rows !== b.rows || a.cols !== b.cols) return false;\n    } else return false;\n  }\n  if (`size` in a) {\n    if (`size` in b) {\n      if (a.size !== b.size) return false;\n    } else return false;\n  }\n  return true;\n};\n\n/**\n * Returns a key string for a cell instance\n * A key string allows comparison of instances by value rather than reference\n *\n * ```js\n * cellKeyString({x:10,y:20});\n * // Yields: \"Cell{10,20}\";\n * ```\n * @param v\n * @returns\n */\nexport const cellKeyString = (v: Cell): string => `Cell{${ v.x },${ v.y }}`;\n\n/**\n * Returns _true_ if two cells equal.\n * Returns _false_ if either cell are undefined\n *\n * @param a\n * @param b\n * @returns\n */\nexport const cellEquals = (\n  a: Cell | undefined,\n  b: Cell | undefined\n): boolean => {\n  if (b === undefined) return false;\n  if (a === undefined) return false;\n  return a.x === b.x && a.y === b.y;\n};\n\n/**\n * Throws an exception if any of the cell's parameters are invalid\n * @private\n * @param cell\n * @param parameterName\n * @param grid\n */\nexport const guardCell = (\n  cell: Cell,\n  parameterName = `Param`,\n  grid?: Grid\n) => {\n  if (cell === undefined) {\n    throw new Error(parameterName + ` is undefined. Expecting {x,y}`);\n  }\n  if (cell.x === undefined) throw new Error(parameterName + `.x is undefined`);\n  if (cell.y === undefined) throw new Error(parameterName + `.y is undefined`);\n  if (Number.isNaN(cell.x)) throw new Error(parameterName + `.x is NaN`);\n  if (Number.isNaN(cell.y)) throw new Error(parameterName + `.y is NaN`);\n  if (!Number.isInteger(cell.x)) {\n    throw new TypeError(parameterName + `.x is non-integer`);\n  }\n  if (!Number.isInteger(cell.y)) {\n    throw new TypeError(parameterName + `.y is non-integer`);\n  }\n  if (grid !== undefined && !inside(grid, cell)) {\n    throw new Error(\n      `${ parameterName } is outside of grid. Cell: ${ cell.x },${ cell.y } Grid: ${ grid.cols }, ${ grid.rows }`\n    );\n  }\n};\n\n/**\n * Throws an exception if any of the grid's parameters are invalid\n * @param grid\n * @param parameterName\n */\nconst guardGrid = (grid: Grid, parameterName = `Param`) => {\n  if (grid === undefined) {\n    throw new Error(`${ parameterName } is undefined. Expecting grid.`);\n  }\n  if (!(`rows` in grid)) throw new Error(`${ parameterName }.rows is undefined`);\n  if (!(`cols` in grid)) throw new Error(`${ parameterName }.cols is undefined`);\n\n  if (!Number.isInteger(grid.rows)) {\n    throw new TypeError(`${ parameterName }.rows is not an integer`);\n  }\n  if (!Number.isInteger(grid.cols)) {\n    throw new TypeError(`${ parameterName }.cols is not an integer`);\n  }\n};\n\n/**\n * Returns _true_ if cell coordinates are above zero and within bounds of grid\n *\n * @param grid\n * @param cell\n * @return\n */\nexport const inside = (grid: Grid, cell: Cell): boolean => {\n  if (cell.x < 0 || cell.y < 0) return false;\n  if (cell.x >= grid.cols || cell.y >= grid.rows) return false;\n  return true;\n};\n\n/**\n * Returns a visual rectangle of the cell, positioned from the top-left corner\n *\n * ```js\n * const cell = { x: 1, y: 0 };\n *\n * // 5x5 grid, each cell 5px in size\n * const grid = { rows: 5, cols: 5, size: 5 }\n *\n * const r = rectangleForCell(grid, cell,);\n *\n * // Yields: { x: 5, y: 0, width: 5, height: 5 }\n * ```\n * @param cell\n * @param grid\n * @return\n */\nexport const rectangleForCell = (\n  grid: GridVisual,\n  cell: Cell\n): RectPositioned => {\n  guardCell(cell);\n  const size = grid.size;\n  const x = cell.x * size;\n  const y = cell.y * size;\n  const r = RectsFromTopLeft({ x: x, y: y }, size, size);\n  return r;\n};\n\n/**\n * Generator that returns rectangles for each cell in a grid\n *\n * @example Draw rectangles\n * ```js\n * import { Drawing } from 'visuals.js'\n * const rects = [...Grids.asRectangles(grid)];\n * Drawing.rect(ctx, rects, { strokeStyle: `silver`});\n * ```\n * @param grid\n */\nexport function* asRectangles(\n  grid: GridVisual\n): IterableIterator<RectPositioned> {\n  for (const c of cells(grid)) {\n    yield rectangleForCell(grid, c);\n  }\n}\n\n/**\n * Returns a two-dimensional array according to `grid`\n * size.\n *\n * ```js\n * const a = Grids.toArray({ rows: 3, cols: 2 });\n * Yields:\n * [ [_,_] ]\n * [ [_,_] ]\n * [ [_,_] ]\n * ```\n *\n * `initialValue` can be provided to set the value\n * for all cells.\n * @param grid Grid\n * @param initialValue Initial value\n * @returns\n */\n//eslint-disable-next-line functional/prefer-readonly-type\nexport const toArray = <V>(grid: Grid, initialValue?: V): Array<Array<V>> => {\n  const returnValue = [];\n  //eslint-disable-next-line functional/no-let\n  for (let row = 0; row < grid.rows; row++) {\n    //eslint-disable-next-line functional/immutable-data\n    returnValue[ row ] = Array.from<V>({ length: grid.cols });\n    if (initialValue) {\n      //eslint-disable-next-line functional/no-let\n      for (let col = 0; col < grid.cols; col++) {\n        //eslint-disable-next-line functional/immutable-data\n        returnValue[ row ][ col ] = initialValue;\n      }\n    }\n  }\n  return returnValue;\n};\n\n/**\n * Returns the cell at a specified visual coordinate\n * or _undefined_ if the position is outside of the grid.\n *\n * `position` must be in same coordinate/scale as the grid.\n *\n * @param position Position, eg in pixels\n * @param grid Grid\n * @return Cell at position or undefined if outside of the grid\n */\nexport const cellAtPoint = (\n  grid: GridVisual,\n  position: Point\n): Cell | undefined => {\n  const size = grid.size;\n  throwNumberTest(size, `positive`, `grid.size`);\n  if (position.x < 0 || position.y < 0) return;\n  const x = Math.floor(position.x / size);\n  const y = Math.floor(position.y / size);\n  if (x >= grid.cols) return;\n  if (y >= grid.rows) return;\n  return { x, y };\n};\n\n/**\n * Returns a list of all cardinal directions: n, ne, nw, e, s, se, sw, w\n */\nexport const allDirections = Object.freeze([\n  `n`,\n  `ne`,\n  `nw`,\n  `e`,\n  `s`,\n  `se`,\n  `sw`,\n  `w`,\n]) as ReadonlyArray<CardinalDirection>;\n\n/**\n * Returns a list of + shaped directions: n, e, s, w\n */\nexport const crossDirections = Object.freeze([\n  `n`,\n  `e`,\n  `s`,\n  `w`,\n]) as ReadonlyArray<CardinalDirection>;\n\n/**\n * Returns neighbours for a cell. If no `directions` are provided, it defaults to {@link allDirections}.\n *\n * ```js\n * const grid = { rows: 5, cols: 5 };\n * const cell = { x:2, y:2 };\n *\n * // Get n,ne,nw,e,s,se,sw and w neighbours\n * const n = Grids.neighbours(grid, cell, `wrap`);\n *\n * Yields:\n * {\n *  n: {x: 2, y: 1}\n *  s: {x: 2, y: 3}\n *  ....\n * }\n * ```\n *\n * Returns neighbours without diagonals (ie n, e, s, w):\n * ```js\n * const n = Grids.neighbours(grid, cell, `stop`, Grids.crossDirections);\n * ```\n * @returns Returns a map of cells, keyed by cardinal direction\n * @param grid Grid\n * @param cell Cell\n * @param bounds How to handle edges of grid\n * @param directions Directions to return\n */\nexport const neighbours = (\n  grid: Grid,\n  cell: Cell,\n  bounds: BoundsLogic = `undefined`,\n  directions?: ReadonlyArray<CardinalDirection>\n): Neighbours => {\n  const directories = directions ?? allDirections;\n  const points = directories.map((c) =>\n    offset(grid, cell, getVectorFromCardinal(c), bounds)\n  );\n  return zipKeyValue<Cell>(directories, points) as Neighbours;\n};\n\nexport function* visitNeigbours(\n  grid: Grid,\n  cell: Cell,\n  bounds: BoundsLogic = `undefined`,\n  directions?: ReadonlyArray<CardinalDirection>\n) {\n  const directories = directions ?? allDirections;\n  const points = directories.map((c) =>\n    offset(grid, cell, getVectorFromCardinal(c), bounds)\n  );\n  for (const pt of points) {\n    if (pt !== undefined) yield pt;\n  }\n}\n\n/**\n * Returns the visual midpoint of a cell (eg. pixel coordinate)\n *\n * @param cell\n * @param grid\n * @return\n */\nexport const cellMiddle = (grid: GridVisual, cell: Cell): Point => {\n  guardCell(cell);\n\n  const size = grid.size;\n  const x = cell.x * size; // + (grid.spacing ? cell.x * grid.spacing : 0);\n  const y = cell.y * size; // + (grid.spacing ? cell.y * grid.spacing : 0);\n  return Object.freeze({ x: x + size / 2, y: y + size / 2 });\n};\n\n/**\n * Returns the cells on the line of `start` and `end`, inclusive\n *\n * ```js\n * // Get cells that connect 0,0 and 10,10\n * const cells = Grids.getLine({x:0,y:0}, {x:10,y:10});\n * ```\n *\n * This function does not handle wrapped coordinates.\n * @param start Starting cell\n * @param end End cell\n * @returns\n */\nexport const getLine = (start: Cell, end: Cell): ReadonlyArray<Cell> => {\n  // https://stackoverflow.com/a/4672319\n  guardCell(start);\n  guardCell(end);\n\n  // eslint-disable-next-line functional/no-let\n  let startX = start.x;\n  // eslint-disable-next-line functional/no-let\n  let startY = start.y;\n  const dx = Math.abs(end.x - startX);\n  const dy = Math.abs(end.y - startY);\n  const sx = startX < end.x ? 1 : -1;\n  const sy = startY < end.y ? 1 : -1;\n  // eslint-disable-next-line functional/no-let\n  let error = dx - dy;\n\n  const cells = [];\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    // eslint-disable-next-line functional/immutable-data\n    cells.push(Object.freeze({ x: startX, y: startY }));\n    if (startX === end.x && startY === end.y) break;\n    const error2 = 2 * error;\n    if (error2 > -dy) {\n      error -= dy;\n      startX += sx;\n    }\n    if (error2 < dx) {\n      error += dx;\n      startY += sy;\n    }\n  }\n  return cells;\n};\n\n/**\n * Returns cells that correspond to the cardinal directions at a specified distance\n * i.e. it projects a line from `start` cell in all cardinal directions and returns the cells at `steps` distance.\n * @param grid Grid\n * @param steps Distance\n * @param start Start poiint\n * @param bounds Logic for if bounds of grid are exceeded\n * @returns Cells corresponding to cardinals\n */\nexport const offsetCardinals = (\n  grid: Grid,\n  start: Cell,\n  steps: number,\n  bounds: BoundsLogic = `stop`\n): Neighbours => {\n  guardGrid(grid, `grid`);\n  guardCell(start, `start`);\n  throwIntegerTest(steps, `aboveZero`, `steps`);\n\n  const directions = allDirections;\n  const vectors = directions.map((d) => getVectorFromCardinal(d, steps));\n  const cells = directions.map((d, index) =>\n    offset(grid, start, vectors[ index ], bounds)\n  );\n\n  return zipKeyValue(directions, cells) as Neighbours;\n};\n\n/**\n * Returns an `{ x, y }` signed vector corresponding to the provided cardinal direction.\n * ```js\n * const n = getVectorFromCardinal(`n`); // {x: 0, y: -1}\n * ```\n *\n * Optional `multiplier` can be applied to vector\n * ```js\n * const n = getVectorFromCardinal(`n`, 10); // {x: 0, y: -10}\n * ```\n *\n * Blank direction returns `{ x: 0, y: 0 }`\n * @param cardinal Direction\n * @param multiplier Multipler\n * @returns Signed vector in the form of `{ x, y }`\n */\nexport const getVectorFromCardinal = (\n  cardinal: CardinalDirectionOptional,\n  multiplier = 1\n): Cell => {\n  // eslint-disable-next-line functional/no-let\n  let v;\n  switch (cardinal) {\n    case `n`: {\n      v = { x: 0, y: -1 * multiplier };\n      break;\n    }\n    case `ne`: {\n      v = { x: 1 * multiplier, y: -1 * multiplier };\n      break;\n    }\n    case `e`: {\n      v = { x: 1 * multiplier, y: 0 };\n      break;\n    }\n    case `se`: {\n      v = { x: 1 * multiplier, y: 1 * multiplier };\n      break;\n    }\n    case `s`: {\n      v = { x: 0, y: 1 * multiplier };\n      break;\n    }\n    case `sw`: {\n      v = { x: -1 * multiplier, y: 1 * multiplier };\n      break;\n    }\n    case `w`: {\n      v = { x: -1 * multiplier, y: 0 };\n      break;\n    }\n    case `nw`: {\n      v = { x: -1 * multiplier, y: -1 * multiplier };\n      break;\n    }\n    default: {\n      v = { x: 0, y: 0 };\n    }\n  }\n  return Object.freeze(v);\n};\n\n/**\n * Returns a list of cells from `start` to `end`.\n *\n * Throws an error if start and end are not on same row or column.\n *\n * @param start Start cell\n * @param end end clel\n * @param endInclusive\n * @return Array of cells\n */\nexport const simpleLine = function (\n  start: Cell,\n  end: Cell,\n  endInclusive = false\n): ReadonlyArray<Cell> {\n  // eslint-disable-next-line functional/prefer-readonly-type\n  const cells: Array<Cell> = [];\n  if (start.x === end.x) {\n    // Vertical\n    const lastY = endInclusive ? end.y + 1 : end.y;\n    // eslint-disable-next-line functional/no-let\n    for (let y = start.y; y < lastY; y++) {\n      // eslint-disable-next-line functional/immutable-data\n      cells.push({ x: start.x, y: y });\n    }\n  } else if (start.y === end.y) {\n    // Horizontal\n    const lastX = endInclusive ? end.x + 1 : end.x;\n    // eslint-disable-next-line functional/no-let\n    for (let x = start.x; x < lastX; x++) {\n      // eslint-disable-next-line functional/immutable-data\n      cells.push({ x: x, y: start.y });\n    }\n  } else {\n    throw new Error(\n      `Only does vertical and horizontal: ${ start.x },${ start.y } - ${ end.x },${ end.y }`\n    );\n  }\n  return cells;\n};\n\n/**\n *\n * Returns a coordinate offset from `start` by `vector` amount.\n *\n * Different behaviour can be specified for how to handle when coordinates exceed the bounds of the grid\n *\n *\n * Note: x and y wrapping are calculated independently. A large wrapping of x, for example won't shift up/down a line\n * @param grid Grid to traverse\n * @param vector Offset in x/y\n * @param start Start point\n * @param bounds\n * @returns Cell\n */\nexport const offset = function (\n  grid: Grid,\n  start: Cell,\n  vector: Cell,\n  bounds: BoundsLogic = `undefined`\n): Cell | undefined {\n  guardCell(start, `start`, grid);\n  guardCell(vector);\n  guardGrid(grid, `grid`);\n\n  // eslint-disable-next-line functional/no-let\n  let x = start.x;\n  // eslint-disable-next-line functional/no-let\n  let y = start.y;\n  switch (bounds) {\n    case `wrap`: {\n      x += vector.x % grid.cols;\n      y += vector.y % grid.rows;\n      if (x < 0) x = grid.cols + x;\n      else if (x >= grid.cols) {\n        x -= grid.cols;\n      }\n      if (y < 0) y = grid.rows + y;\n      else if (y >= grid.rows) {\n        y -= grid.rows;\n      }\n      break;\n    }\n    case `stop`: {\n      x += vector.x;\n      y += vector.y;\n      x = clampIndex(x, grid.cols);\n      y = clampIndex(y, grid.rows);\n      break;\n    }\n    case `undefined`: {\n      x += vector.x;\n      y += vector.y;\n      if (x < 0 || y < 0) return;\n      if (x >= grid.cols || y >= grid.rows) return;\n      break;\n    }\n    case `unbounded`: {\n      x += vector.x;\n      y += vector.y;\n      break;\n    }\n    default: {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      throw new Error(`Unknown BoundsLogic case ${ bounds }`);\n    }\n  }\n  return Object.freeze({ x, y });\n};\n\nconst neighbourList = (\n  grid: Grid,\n  cell: Cell,\n  directions: ReadonlyArray<CardinalDirection>,\n  bounds: BoundsLogic\n): ReadonlyArray<NeighbourMaybe> => {\n  // Get neighbours for cell\n  const cellNeighbours = neighbours(grid, cell, bounds, directions);\n\n  // Filter out undefined cells\n  const entries = Object.entries(cellNeighbours);\n  return (entries as Array<NeighbourMaybe>).filter(n => isNeighbour(n));\n};\n\n/**\n * Visits every cell in grid using supplied selection function\n * In-built functions to use: visitorDepth, visitorBreadth, visitorRandom,\n * visitorColumn, visitorRow.\n *\n * Usage example:\n * ```js\n *  let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell);\n *  for (let cell of visitor) {\n *   // do something with cell\n *  }\n * ```\n *\n * If you want to keep tabs on the visitor, pass in a MutableValueSet. This is\n * updated with visited cells (and is used internally anyway)\n * ```js\n *  let visited = new mutableValueSet<Grids.Cell>(c => Grids.cellKeyString(c));\n *  let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell, visited);\n * ```\n *\n * To visit with some delay, try this pattern\n * ```js\n *  const delayMs = 100;\n *  const run = () => {\n *   let cell = visitor.next().value;\n *   if (cell === undefined) return;\n *   // Do something with cell\n *   setTimeout(run, delayMs);\n *  }\n *  setTimeout(run, delayMs);\n * ```\n * @param logic Logic for selecting next cell\n * @param grid Grid to visit\n * @param start Starting cell\n * @param opts Options\n * @returns Cells\n */\nexport const visitor = function* (\n  logic: VisitorLogic,\n  grid: Grid,\n  start: Cell,\n  opts: VisitorOpts = {}\n): VisitGenerator {\n  guardGrid(grid, `grid`);\n  guardCell(start, `start`, grid);\n\n  const v = opts.visited ?? mutable<Cell>(cellKeyString);\n  const possibleNeighbours = logic.options ?? ((g: Grid, c: Cell) => neighbourList(g, c, crossDirections, `undefined`));\n\n  if (!isCell(start)) {\n    throw new Error(`'start' parameter is undefined or not a cell`);\n  }\n\n  let cellQueue: Array<Cell> = [ start ];\n  let moveQueue: Array<Neighbour> = [];\n  let current: Cell | undefined = undefined;\n\n  while (cellQueue.length > 0) {\n    if (current === undefined) {\n      const nv = cellQueue.pop();\n      if (nv === undefined) {\n        break;\n      }\n      current = nv;\n    }\n\n    if (!v.has(current)) {\n      v.add(current);\n      yield current;\n\n      const nextSteps = possibleNeighbours(grid, current).filter(\n        (step) => {\n          if (step[ 1 ] === undefined) return false;\n          return !v.has(step[ 1 ])\n        }\n      );\n\n      if (nextSteps.length === 0) {\n        // No more moves for this cell\n        if (current !== undefined) {\n          cellQueue = cellQueue.filter((cq) => cellEquals(cq, current));\n        }\n      } else {\n        for (const n of nextSteps) {\n          if (n === undefined) continue;\n          if (n[ 1 ] === undefined) continue;\n          // @ts-expect-error\n          moveQueue.push(n);\n        }\n        //moveQueue.push(...nextSteps);\n      }\n    }\n\n    // Remove steps already made\n    moveQueue = moveQueue.filter((step) => !v.has(step[ 1 ]));\n\n    if (moveQueue.length === 0) {\n      current = undefined;\n    } else {\n      // Pick move\n      const potential = logic.select(moveQueue);\n      if (potential !== undefined) {\n        // eslint-disable-next-line functional/immutable-data\n        cellQueue.push(potential[ 1 ]);\n        current = potential[ 1 ];\n      }\n    }\n  }\n};\n\nexport const visitorDepth = (grid: Grid, start: Cell, opts: VisitorOpts = {}) =>\n  visitor(\n    {\n      select: (nbos) => nbos.at(-1),\n    },\n    grid,\n    start,\n    opts\n  );\n\nexport const visitorBreadth = (\n  grid: Grid,\n  start: Cell,\n  opts: VisitorOpts = {}\n) =>\n  visitor(\n    {\n      select: (nbos) => nbos[ 0 ],\n    },\n    grid,\n    start,\n    opts\n  );\n\nconst randomNeighbour = (nbos: ReadonlyArray<Neighbour>) => randomElement(nbos); // .filter(isNeighbour));\n\nexport const visitorRandomContiguous = (\n  grid: Grid,\n  start: Cell,\n  opts: VisitorOpts = {}\n) =>\n  visitor(\n    {\n      select: randomNeighbour,\n    },\n    grid,\n    start,\n    opts\n  );\n\n/**\n * Visit by following rows. Normal order is left-to-right, top-to-bottom.\n * @param grid\n * @param start\n * @param opts\n * @returns\n */\nexport const visitorRandom = (\n  grid: Grid,\n  start: Cell,\n  opts: VisitorOpts = {}\n) =>\n  visitor(\n    {\n      options: (grid, cell) => {\n        const t: Array<Neighbour> = [];\n        for (const c of cells(grid, cell)) {\n          // eslint-disable-next-line functional/immutable-data\n          t.push([ `n`, c ]);\n        }\n        return t;\n      },\n      select: randomNeighbour,\n    },\n    grid,\n    start,\n    opts\n  );\n\nexport const visitorRow = (\n  grid: Grid,\n  start?: Cell,\n  opts: VisitorOpts = {}\n) => {\n  if (!start) start = { x: 0, y: 0 }\n\n  const { reversed = false } = opts;\n\n  const neighbourSelect = (nbos: ReadonlyArray<Neighbour>) =>\n    nbos.find((n) => n[ 0 ] === (reversed ? `w` : `e`));\n\n  const possibleNeighbours = (\n    grid: Grid,\n    cell: Cell\n  ): ReadonlyArray<Neighbour> => {\n    if (reversed) {\n      // WALKING BACKWARD ALONG ROW\n      if (cell.x > 0) {\n        // All fine, step to the left\n        cell = { x: cell.x - 1, y: cell.y };\n      } else {\n        // At the beginning of a row\n        // eslint-disable-next-line unicorn/prefer-ternary\n        if (cell.y > 0) {\n          // Wrap to next row up\n          cell = { x: grid.cols - 1, y: cell.y - 1 };\n        } else {\n          // Wrap to end of grid\n          cell = { x: grid.cols - 1, y: grid.rows - 1 };\n        }\n      }\n    } else {\n      /*\n       * WALKING FORWARD ALONG ROWS\n       */\n      if (cell.x < grid.rows - 1) {\n        // All fine, step to the right\n        cell = { x: cell.x + 1, y: cell.y };\n      } else {\n        // At the end of a row\n        // eslint-disable-next-line unicorn/prefer-ternary\n        if (cell.y < grid.rows - 1) {\n          // More rows available, wrap to next row down\n          cell = { x: 0, y: cell.y + 1 };\n        } else {\n          // No more rows available, wrap to start of the grid\n          cell = { x: 0, y: 0 };\n        }\n      }\n    }\n    return [ [ reversed ? `w` : `e`, cell ] ];\n  };\n\n  const logic: VisitorLogic = {\n    select: neighbourSelect,\n    options: possibleNeighbours,\n  };\n\n  return visitor(logic, grid, start, opts);\n};\n\n/**\n * Runs the provided `visitor` for `steps`, returning the cell we end at\n *\n * ```js\n * // Get a cell 10 steps away (row-wise) from start\n * const cell = visitFor(grid, start, 10, visitorRow);\n * ```\n * @param grid Grid to traverse\n * @param start Start point\n * @param steps Number of steps\n * @param visitor Visitor function\n * @returns\n */\nexport const visitFor = (\n  grid: Grid,\n  start: Cell,\n  steps: number,\n  visitor: Visitor\n): Cell => {\n  throwIntegerTest(steps, ``, `steps`);\n\n  const opts: VisitorOpts = {\n    reversed: steps < 0,\n  };\n  steps = Math.abs(steps);\n\n  // eslint-disable-next-line functional/no-let\n  let c = start;\n  // eslint-disable-next-line functional/no-let\n  let v = visitor(grid, start, opts);\n  v.next(); // Burn up starting cell\n\n  // eslint-disable-next-line functional/no-let\n  let stepsMade = 0;\n\n  while (stepsMade < steps) {\n    stepsMade++;\n    const { value } = v.next();\n    if (value) {\n      c = value;\n      if (opts.debug) {\n        console.log(\n          `stepsMade: ${ stepsMade } cell: ${ c.x }, ${ c.y } reverse: ${ opts.reversed }`\n        );\n      }\n    } else {\n      if (steps >= grid.cols * grid.rows) {\n        steps -= grid.cols * grid.rows;\n        stepsMade = 0;\n        v = visitor(grid, start, opts);\n        v.next();\n        c = start;\n        if (opts.debug) console.log(`resetting visitor to ${ steps }`);\n      } else throw new Error(`Value not received by visitor`);\n    }\n  }\n  return c;\n};\n\n/**\n * Visits cells running down columns, left-to-right.\n * @param grid Grid to traverse\n * @param start Start cell\n * @param opts Options\n * @returns Visitor generator\n */\nexport const visitorColumn = (\n  grid: Grid,\n  start: Cell,\n  opts: VisitorOpts = {}\n): VisitGenerator => {\n  const { reversed = false } = opts;\n  const logic: VisitorLogic = {\n    select: (nbos) => nbos.find((n) => n[ 0 ] === (reversed ? `n` : `s`)),\n    options: (grid, cell): ReadonlyArray<Neighbour> => {\n      if (reversed) {\n        // WALK UP COLUMN, RIGHT-TO-LEFT\n        if (cell.y > 0) {\n          // Easy case\n          cell = { x: cell.x, y: cell.y - 1 };\n        } else {\n          // Top of column\n          // eslint-disable-next-line unicorn/prefer-ternary\n          if (cell.x === 0) {\n            // Top-left corner, need to wrap\n            cell = { x: grid.cols - 1, y: grid.rows - 1 };\n          } else {\n            cell = { x: cell.x - 1, y: grid.rows - 1 };\n          }\n        }\n      } else {\n        // WALK DOWN COLUMNS, LEFT-TO-RIGHT\n        if (cell.y < grid.rows - 1) {\n          // Easy case, move down by one\n          cell = { x: cell.x, y: cell.y + 1 };\n        } else {\n          // End of column\n          // eslint-disable-next-line unicorn/prefer-ternary\n          if (cell.x < grid.cols - 1) {\n            // Move to next column and start at top\n            cell = { x: cell.x + 1, y: 0 };\n          } else {\n            // Move to start of grid\n            cell = { x: 0, y: 0 };\n          }\n        }\n      }\n      return [ [ reversed ? `n` : `s`, cell ] ];\n    },\n  };\n  return visitor(logic, grid, start, opts);\n};\n\n/**\n * Enumerate rows of grid, returning all the cells in the row\n * as an array\n *\n * ```js\n * for (const row of Grid.rows(shape)) {\n *  // row is an array of Cells.\n *  // [ {x:0, y:0}, {x:1, y:0} ... ]\n * }\n * ```\n * @param grid\n * @param start\n */\nexport const rows = function* (grid: Grid, start?: Cell) {\n  if (!start) start = { x: 0, y: 0 }\n  //eslint-disable-next-line functional/no-let\n  let row = start.y;\n  //eslint-disable-next-line functional/no-let\n  let rowCells: Array<Cell> = [];\n\n  for (const c of cells(grid, start)) {\n    if (c.y === row) {\n      //eslint-disable-next-line functional/immutable-data\n      rowCells.push(c);\n    } else {\n      yield rowCells;\n      rowCells = [ c ];\n      row = c.y;\n    }\n  }\n  if (rowCells.length > 0) yield rowCells;\n};\n\n/**\n * Enumerate all cells in an efficient manner. Runs left-to-right, top-to-bottom.\n * If end of grid is reached, iterator will wrap to ensure all are visited.\n *\n * @param grid\n * @param start\n */\nexport const cells = function* (grid: Grid, start?: Cell) {\n  if (!start) start = { x: 0, y: 0 }\n\n  guardGrid(grid, `grid`);\n  guardCell(start, `start`, grid);\n\n  // eslint-disable-next-line functional/no-let\n  let { x, y } = start;\n  // eslint-disable-next-line functional/no-let\n  let canMove = true;\n  do {\n    yield { x, y };\n    x++;\n    if (x === grid.cols) {\n      y++;\n      x = 0;\n    }\n    if (y === grid.rows) {\n      y = 0;\n      x = 0;\n    }\n    if (x === start.x && y === start.y) canMove = false; // Complete\n  } while (canMove);\n};\n\nexport const access1dArray = <V>(\n  array: ReadonlyArray<V>,\n  cols: number\n): CellAccessor<V> => {\n  const grid = { cols, rows: Math.ceil(array.length / cols) };\n  const fn: CellAccessor<V> = (\n    cell: Cell,\n    wrap: BoundsLogic\n  ): V | undefined => {\n    const index = indexFromCell(grid, cell, wrap);\n    if (index === undefined) return undefined;\n    return array[ index ];\n  };\n  return fn;\n};\n\n/**\n * Returns a function that updates a 2D array representation\n * of a grid. Array is mutated.\n *\n * ```js\n * const m = Grids.array2dUpdater(grid, array);\n * m(someValue, { x:2, y:3 });\n * ```\n * @param grid\n * @param array\n * @returns\n */\n//eslint-disable-next-line functional/prefer-readonly-type\nexport const array2dUpdater = <V>(grid: GridVisual, array: Array<Array<V>>) => {\n  const fn = (v: V, position: Point) => {\n    const pos = cellAtPoint(grid, position);\n    if (pos === undefined) {\n      throw new Error(\n        `Position does not exist. Pos: ${ JSON.stringify(\n          position\n        ) } Grid: ${ JSON.stringify(grid) }`\n      );\n    }\n    //eslint-disable-next-line functional/immutable-data\n    array[ pos.y ][ pos.x ] = v;\n  };\n  return fn;\n};\n\n/**\n * Visits a grid packed into an array.\n *\n * @example By default visits left-to-right, top-to-bottom:\n * ```js\n * const data = [1, 2, 3, 4, 5, 6];\n * const cols = 2;\n * for (const [value,index] of visitArray(data, cols)) {\n *  // Yields: 1, 2, 3, 4, 5, 6\n * }\n * ```\n *\n * @example\n * ```js\n * ```\n * @param array Array\n * @param cols Columns\n * @param iteratorFunction Visitor function\n * @param opts Options\n */\nexport function* visitArray<V>(\n  array: ReadonlyArray<V>,\n  cols: number,\n  iteratorFunction?: Visitor,\n  opts?: VisitorOpts\n): IterableIterator<readonly [ data: V, index: number ]> {\n  if (typeof array === `undefined`) {\n    throw new TypeError(`First parameter is undefined, expected an array`);\n  }\n  if (array === null) throw new Error(`First parameter is null, expected an array`);\n  if (!Array.isArray(array)) throw new Error(`First parameter should be an array`);\n\n  throwIntegerTest(cols, `aboveZero`, `cols`);\n  if (array.length === 0) return;\n\n  const wrap = opts?.boundsWrap ?? `stop`;\n  const rows = Math.ceil(array.length / cols);\n  const grid: Grid = {\n    cols,\n    rows,\n  };\n\n  if (iteratorFunction === undefined) iteratorFunction = cells;\n  const iter = iteratorFunction(grid, { x: 0, y: 0 }, opts);\n  for (const cell of iter) {\n    const index = indexFromCell(grid, cell, wrap);\n    if (index === undefined) return undefined;\n    yield [ array[ index ], index ];\n  }\n}\n\n/**\n * Returns the index for a given cell.\n * This is useful if a grid is stored in an array.\n *\n * ```js\n * const data = [\n *  1, 2,\n *  3, 4,\n *  5, 6 ];\n * const cols = 2; // Grid of 2 columns wide\n * const index = indexFromCell(cols, {x: 1, y: 1});\n * // Yields an index of 3\n * console.log(data[index]); // Yields 4\n * ```\n *\n * Bounds logic is applied to cell.x/y separately. Wrapping\n * only ever happens in same col/row.\n * @see cellFromIndex\n * @param grid Grid\n * @param cell Cell to get index for\n * @param wrap Logic for if we hit bounds of grid\n * @returns\n */\nexport const indexFromCell = (\n  grid: Grid,\n  cell: Cell,\n  wrap: BoundsLogic\n): number | undefined => {\n  guardGrid(grid, `grid`);\n\n  //eslint-disable-next-line functional/no-let\n\n  if (cell.x < 0) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, x: 0 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        //cell = { ...cell, x: grid.cols + cell.x };\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        cell = offset(grid, { x: 0, y: cell.y }, { x: cell.x, y: 0 }, `wrap`)!;\n        break;\n      }\n    }\n  }\n  if (cell.y < 0) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, y: 0 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        cell = { ...cell, y: grid.rows + cell.y };\n        break;\n      }\n    }\n  }\n  if (cell.x >= grid.cols) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, x: grid.cols - 1 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        cell = { ...cell, x: cell.x % grid.cols };\n        break;\n      }\n    }\n  }\n  if (cell.y >= grid.rows) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, y: grid.rows - 1 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        cell = { ...cell, y: cell.y % grid.rows };\n        break;\n      }\n    }\n  }\n\n  const index = cell.y * grid.cols + cell.x;\n\n  return index;\n};\n\n/**\n * Returns x,y from an array index.\n *\n * ```js\n *  const data = [\n *   1, 2,\n *   3, 4,\n *   5, 6 ];\n *\n * // Cols of 2, index 2 (ie. data[2] == 3)\n * const cell = cellFromIndex(2, 2);\n * // Yields: {x: 0, y: 1}\n * ```\n * @see indexFromCell\n * @param colsOrGrid\n * @param index\n * @returns\n */\nexport const cellFromIndex = (\n  colsOrGrid: number | Grid,\n  index: number\n): Cell => {\n  //eslint-disable-next-line functional/no-let\n  let cols = 0;\n  cols = typeof colsOrGrid === `number` ? colsOrGrid : colsOrGrid.cols;\n  throwIntegerTest(cols, `aboveZero`, `colsOrGrid`);\n\n  return {\n    x: index % cols,\n    y: Math.floor(index / cols),\n  };\n};\n","import { Bezier as BezierLibrary } from 'bezier-js';\nimport { interpolate as LinesInterpolate } from '../line/Interpolate.js';\nimport { fromTopLeft as RectsFromTopLeft } from '../rect/FromTopLeft.js';\nimport type { Point } from '../point/PointType.js';\nimport type { CubicBezier, CubicBezierPath, QuadraticBezier, QuadraticBezierPath } from './BezierType.js';\nimport { isCubicBezier, isQuadraticBezier } from './Guard.js';\nexport * from './BezierType.js';\nexport * from './Guard.js';\n/**\n * Returns a new quadratic bezier with specified bend amount\n *\n * @param {QuadraticBezier} b Curve\n * @param {number} [bend=0] Bend amount, from -1 to 1\n * @returns {QuadraticBezier}\n */\nexport const quadraticBend = (a: Point, b: Point, bend = 0): QuadraticBezier => quadraticSimple(a, b, bend);\n\n/**\n * Creates a simple quadratic bezier with a specified amount of 'bend'.\n * Bend of -1 will pull curve down, 1 will pull curve up. 0 is no curve\n * @param {Point} start Start of curve\n * @param {Point} end End of curve\n * @param {number} [bend=0] Bend amount, -1 to 1\n * @returns {QuadraticBezier}\n */\nexport const quadraticSimple = (start: Point, end: Point, bend = 0): QuadraticBezier => {\n  if (Number.isNaN(bend)) throw new Error(`bend is NaN`);\n  if (bend < -1 || bend > 1) throw new Error(`Expects bend range of -1 to 1`);\n\n  const middle = LinesInterpolate(0.5, start, end);\n  // eslint-disable-next-line functional/no-let\n  let target = middle;\n  if (end.y < start.y) {\n    // Upward slope\n    target = bend > 0 ? { x: Math.min(start.x, end.x), y: Math.min(start.y, end.y) } :\n      { x: Math.max(start.x, end.x), y: Math.max(start.y, end.y) };\n  } else {\n    // Downward slope\n    target = bend > 0 ? { x: Math.max(start.x, end.x), y: Math.min(start.y, end.y) } :\n      { x: Math.min(start.x, end.x), y: Math.max(start.y, end.y) };\n  }\n\n  const handle = LinesInterpolate(Math.abs(bend), middle, target,);\n  return quadratic(start, end, handle);\n};\n\n/**\n * Returns a relative point on a simple quadratic \n * @param start Start\n * @param end  End\n * @param bend Bend (-1 to 1)\n * @param amt Amount\n * @returns Point\n */\nexport const computeQuadraticSimple = (start: Point, end: Point, bend: number, amt: number): Point => {\n  const q = quadraticSimple(start, end, bend);\n  const bzr = new BezierLibrary(q.a, q.quadratic, q.b);\n  return bzr.compute(amt);\n};\n\n//https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\nexport const quadraticToSvgString = (start: Point, end: Point, handle: Point): ReadonlyArray<string> => [ `M ${ start.x } ${ start.y } Q ${ handle.x } ${ handle.y } ${ end.x } ${ end.y }` ];\n\nexport const toPath = (cubicOrQuadratic: CubicBezier | QuadraticBezier): CubicBezierPath | QuadraticBezierPath => {\n  if (isCubicBezier(cubicOrQuadratic)) {\n    return cubicToPath(cubicOrQuadratic);\n  } else if (isQuadraticBezier(cubicOrQuadratic)) {\n    return quadratictoPath(cubicOrQuadratic);\n  } else {\n    throw new Error(`Unknown bezier type`);\n  }\n};\n\nexport const cubic = (start: Point, end: Point, cubic1: Point, cubic2: Point): CubicBezier => (\n  {\n    a: Object.freeze(start),\n    b: Object.freeze(end),\n    cubic1: Object.freeze(cubic1),\n    cubic2: Object.freeze(cubic2)\n  });\n\nconst cubicToPath = (cubic: CubicBezier): CubicBezierPath => {\n  const { a, cubic1, cubic2, b } = cubic;\n\n  const bzr = new BezierLibrary(a, cubic1, cubic2, b);\n  return Object.freeze({\n    ...cubic,\n    length: () => bzr.length(),\n    interpolate: (t: number) => bzr.compute(t),\n    nearest: (_: Point) => { throw new Error(`not implemented`); },\n    bbox: () => {\n      const { x, y } = bzr.bbox();\n      const xSize = x.size;\n      const ySize = y.size;\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\n\n      return RectsFromTopLeft({ x: x.min, y: y.min }, xSize, ySize);\n    },\n    relativePosition: (_point: Point, _intersectionThreshold: number) => {\n      throw new Error(`Not implemented`);\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`);\n    },\n    toSvgString: () => [ `brrup` ],\n    kind: `bezier/cubic`\n  });\n};\n\nexport const quadratic = (start: Point, end: Point, handle: Point): QuadraticBezier => ({\n  a: Object.freeze(start),\n  b: Object.freeze(end),\n  quadratic: Object.freeze(handle)\n});\n\n\nconst quadratictoPath = (quadraticBezier: QuadraticBezier): QuadraticBezierPath => {\n  const { a, b, quadratic } = quadraticBezier;\n  const bzr = new BezierLibrary(a, quadratic, b);\n  return Object.freeze({\n    ...quadraticBezier,\n    length: () => bzr.length(),\n    interpolate: (t: number) => bzr.compute(t),\n    nearest: (_: Point) => { throw new Error(`not implemented`); },\n    bbox: () => {\n      const { x, y } = bzr.bbox();\n      const xSize = x.size;\n      const ySize = y.size;\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      return RectsFromTopLeft({ x: x.min, y: y.min }, xSize, ySize);\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`);\n\n    },\n    relativePosition: (_point: Point, _intersectionThreshold: number): number => {\n      throw new Error(`Not implemented`);\n\n    },\n    toString: () => bzr.toString(),\n    toSvgString: () => quadraticToSvgString(a, b, quadratic),\n    kind: `bezier/quadratic`\n  });\n};\n\n","import { Bezier } from \"./bezier.js\";\n\n// math-inlining.\nconst { abs, cos, sin, acos, atan2, sqrt, pow } = Math;\n\n// cube root function yielding real roots\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n}\n\n// trig constants\nconst pi = Math.PI,\n  tau = 2 * pi,\n  quart = pi / 2,\n  // float precision significant decimal\n  epsilon = 0.000001,\n  // extremas used in bbox calculation and similar algorithms\n  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n  // a zero coordinate, which is surprisingly useful\n  ZERO = { x: 0, y: 0, z: 0 };\n\n// Bezier utility functions\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [\n    -0.0640568928626056260850430826247450385909,\n    0.0640568928626056260850430826247450385909,\n    -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404,\n    -0.3150426796961633743867932913198102407864,\n    0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524,\n    0.4337935076260451384870842319133497124524,\n    -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107,\n    -0.6480936519369755692524957869107476266696,\n    0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232,\n    0.7401241915785543642438281030999784255232,\n    -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761,\n    -0.8864155270044010342131543419821967550873,\n    0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548,\n    0.9382745520027327585236490017087214496548,\n    -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411,\n    -0.9951872199970213601799974097007368118745,\n    0.9951872199970213601799974097007368118745,\n  ],\n\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [\n    0.1279381953467521569740561652246953718517,\n    0.1279381953467521569740561652246953718517,\n    0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264,\n    0.121670472927803391204463153476262425607,\n    0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622,\n    0.1155056680537256013533444839067835598622,\n    0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946,\n    0.0976186521041138882698806644642471544279,\n    0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185,\n    0.086190161531953275917185202983742667185,\n    0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193,\n    0.0592985849154367807463677585001085845412,\n    0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593,\n    0.0442774388174198061686027482113382288593,\n    0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491,\n    0.0123412297999871995468056670700372915759,\n    0.0123412297999871995468056670700372915759,\n  ],\n\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points;\n\n    // constant?\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    }\n\n    // linear?\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n      return ret;\n    }\n\n    // quadratic/cubic curve?\n    if (order < 4) {\n      let mt2 = mt * mt,\n        t2 = t * t,\n        a,\n        b,\n        c,\n        d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n      return ret;\n    }\n\n    // higher order curves: use de Casteljau's computation\n    const dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,\n        };\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i].z = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n      r = ratios,\n      p = points;\n\n    let f1 = r[0],\n      f2 = r[1],\n      f3 = r[2],\n      f4 = r[3],\n      d;\n\n    // spec for linear\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to quadratic\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to cubic\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d\n          ? false\n          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t,\n      };\n    }\n  },\n\n  derive: function (points, _3d) {\n    const dpoints = [];\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y),\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n        list.push(dpt);\n      }\n      dpoints.push(list);\n      p = list;\n    }\n    return dpoints;\n  },\n\n  between: function (v, m, M) {\n    return (\n      (m <= v && v <= M) ||\n      utils.approximately(v, m) ||\n      utils.approximately(v, M)\n    );\n  },\n\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n\n  length: function (derivativeFn) {\n    const z = 0.5,\n      len = utils.Tvalues.length;\n\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n    return z * sum;\n  },\n\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n      d2 = te - ts,\n      v2 = v - ds,\n      r = v2 / d1;\n    return ts + d2 * r;\n  },\n\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y),\n    };\n    if (v1.z !== undefined && v2.z !== undefined) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n\n  pointToString: function (p) {\n    let s = p.x + \"/\" + p.y;\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n    return s;\n  },\n\n  pointsToString: function (points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n      dy1 = v1.y - o.y,\n      dx2 = v2.x - o.x,\n      dy2 = v2.y - o.y,\n      cross = dx1 * dy2 - dy1 * dx2,\n      dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = \"\" + v;\n    const pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n      dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n      mpos,\n      d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return { mdist: mdist, mpos: mpos };\n  },\n\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const bottom = pow(t, n) + pow(1 - t, n),\n      top = bottom - 1;\n    return abs(top / bottom);\n  },\n\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const top = pow(1 - t, n),\n      bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx =\n        (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d == 0) {\n      return false;\n    }\n    return { x: nx / d, y: ny / d };\n  },\n\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      x3 = p3.x,\n      y3 = p3.y,\n      x4 = p4.x,\n      y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n\n  makeline: function (p1, p2) {\n    return new Bezier(\n      p1.x,\n      p1.y,\n      (p1.x + p2.x) / 2,\n      (p1.y + p2.y) / 2,\n      p2.x,\n      p2.y\n    );\n  },\n\n  findbbox: function (sections) {\n    let mx = nMax,\n      my = nMax,\n      MX = nMin,\n      MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },\n    };\n  },\n\n  shapeintersections: function (\n    s1,\n    bbox1,\n    s2,\n    bbox2,\n    curveIntersectionThreshold\n  ) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end]),\n    };\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(\n        shape,\n        shape.bbox,\n        s2,\n        s2.bbox,\n        curveIntersectionThreshold\n      );\n    };\n    return shape;\n  },\n\n  getminmax: function (curve, d, list) {\n    if (!list) return { min: 0, max: 0 };\n    let min = nMax,\n      max = nMin,\n      t,\n      c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n      if (c[d] < min) {\n        min = c[d];\n      }\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n    return { min: min, mid: (min + max) / 2, max: max, size: max - min };\n  },\n\n  align: function (points, line) {\n    const tx = line.p1.x,\n      ty = line.p1.y,\n      a = -atan2(line.p2.y - ty, line.p2.x - tx),\n      d = function (v) {\n        return {\n          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a),\n        };\n      };\n    return points.map(d);\n  },\n\n  roots: function (points, line) {\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\n\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n        b = aligned[1].y,\n        c = aligned[2].y,\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n      return [];\n    }\n\n    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n    const pa = aligned[0].y,\n      pb = aligned[1].y,\n      pc = aligned[2].y,\n      pd = aligned[3].y;\n\n    let d = -pa + 3 * pb - 3 * pc + pd,\n      a = 3 * pa - 6 * pb + 3 * pc,\n      b = -3 * pa + 3 * pb,\n      c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        }\n        // linear solution:\n        return [-c / b].filter(reduce);\n      }\n      // quadratic solution:\n      const q = sqrt(b * b - 4 * a * c),\n        a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    }\n\n    // at this point, we know we need a cubic solution:\n\n    a /= d;\n    b /= d;\n    c /= d;\n\n    const p = (3 * b - a * a) / 3,\n      p3 = p / 3,\n      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n      q2 = q / 2,\n      discriminant = q2 * q2 + p3 * p3 * p3;\n\n    let u1, v1, x1, x2, x3;\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n        mp33 = mp3 * mp3 * mp3,\n        r = sqrt(mp33),\n        t = -q / (2 * r),\n        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n        phi = acos(cosphi),\n        crtr = crt(r),\n        t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n        b = p[1],\n        c = p[2],\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    }\n\n    // linear roots are even easier\n    if (p.length === 2) {\n      const a = p[0],\n        b = p[1];\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n      return [];\n    }\n\n    return [];\n  },\n\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n      dnm,\n      adk,\n      dk,\n      k = 0,\n      r = 0;\n\n    //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x'² + y'²)^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z')² + (z'x\" - z\"x')² + (x'y\" - x\"y')²)\n    //   k(t) = -------------------------------------------------------\n    //                     (x'² + y'² + z'²)^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(\n        pow(d.y * dd.z - dd.y * d.z, 2) +\n          pow(d.z * dd.x - dd.z * d.x, 2) +\n          pow(d.x * dd.y - dd.x * d.y, 2)\n      );\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return { k: 0, r: 0 };\n    }\n\n    k = num / dnm;\n    r = dnm / num;\n\n    // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return { k: k, r: r, dk: dk, adk: adk };\n  },\n\n  inflections: function (points) {\n    if (points.length < 4) return [];\n\n    // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),\n      a = p[2].x * p[1].y,\n      b = p[3].x * p[1].y,\n      c = p[1].x * p[2].y,\n      d = p[3].x * p[2].y,\n      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n      v2 = 18 * (3 * a - b - 3 * c),\n      v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n      return [];\n    }\n\n    const d2 = 2 * v1;\n\n    if (utils.approximately(d2, 0)) return [];\n\n    const trm = v2 * v2 - 4 * v1 * v3;\n\n    if (trm < 0) return [];\n\n    const sq = Math.sqrt(trm);\n\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n\n  bboxoverlap: function (b1, b2) {\n    const dims = [\"x\", \"y\"],\n      len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n    return true;\n  },\n\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n      c2b = c2.bbox(),\n      r = 100000,\n      threshold = curveIntersectionThreshold || 0.5;\n\n    if (\n      c1b.x.size + c1b.y.size < threshold &&\n      c2b.x.size + c2b.y.size < threshold\n    ) {\n      return [\n        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +\n          \"/\" +\n          (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,\n      ];\n    }\n\n    let cc1 = c1.split(0.5),\n      cc2 = c2.split(0.5),\n      pairs = [\n        { left: cc1.left, right: cc2.left },\n        { left: cc1.left, right: cc2.right },\n        { left: cc1.right, right: cc2.right },\n        { left: cc1.right, right: cc2.left },\n      ];\n\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n\n    let results = [];\n\n    if (pairs.length === 0) return results;\n\n    pairs.forEach(function (pair) {\n      results = results.concat(\n        utils.pairiteration(pair.left, pair.right, threshold)\n      );\n    });\n\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n\n    return results;\n  },\n\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n      dy1 = p2.y - p1.y,\n      dx2 = p3.x - p2.x,\n      dy2 = p3.y - p2.y,\n      dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n      dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n      dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n      dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n      // chord midpoints\n      mx1 = (p1.x + p2.x) / 2,\n      my1 = (p1.y + p2.y) / 2,\n      mx2 = (p2.x + p3.x) / 2,\n      my2 = (p2.y + p3.y) / 2,\n      // midpoint offsets\n      mx1n = mx1 + dx1p,\n      my1n = my1 + dy1p,\n      mx2n = mx2 + dx2p,\n      my2n = my2 + dy2p,\n      // intersection of these lines:\n      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n      r = utils.dist(arc, p1);\n\n    // arc start/end values, over mid point:\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n      m = atan2(p2.y - arc.y, p2.x - arc.x),\n      e = atan2(p3.y - arc.y, p3.x - arc.x),\n      _;\n\n    // determine arc direction (cw/ccw correction)\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    }\n    // assign and done.\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n\n  numberSort: function (a, b) {\n    return a - b;\n  },\n};\n\nexport { utils };\n","import { utils } from \"./utils.js\";\n\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return (\n      \"[\" +\n      this.curves\n        .map(function (curve) {\n          return utils.pointsToString(curve.points);\n        })\n        .join(\", \") +\n      \"]\"\n    );\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves\n      .map(function (v) {\n        return v.length();\n      })\n      .reduce(function (a, b) {\n        return a + b;\n      });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n}\n\nexport { PolyBezier };\n","/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\";\n\n// math-inlining.\nconst { abs, min, max, cos, sin, acos, sqrt } = Math;\nconst pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = [\"x\", \"y\"]);\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    // is this curve, practically speaking, a straight line?\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    const baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce((t, p) => t + abs(p.y), 0) < baselength / 50;\n\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps + 1) {\n      return this._lut;\n    }\n    this._lut = [];\n    // n steps means n+1 points\n    steps++;\n    this._lut = [];\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n    return { t, x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      t,\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs(acos(s)) < pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  translate(v, d1, d2) {\n    d2 = typeof d2 === \"number\" ? d2 : d1;\n\n    // TODO: make this take curves with control points outside\n    //       of the start-end interval into account\n\n    const o = this.order;\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + (i / o) * d2);\n    return new Bezier(\n      this.points.map((p, i) => ({\n        x: p.x + v.x * d[i],\n        y: p.y + v.y * d[i],\n      }))\n    );\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for non-linear degenerate curves.\n\n    const clockwise = this.clockwise;\n    const points = this.points;\n\n    if (this._linear) {\n      return this.translate(\n        this.normal(0),\n        distanceFn ? distanceFn(0) : d,\n        distanceFn ? distanceFn(1) : d\n      );\n    }\n\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n\n    // move all points by distance 'd' wrt the origin 'o',\n    // and move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = d2 === undefined ? d1 : d2;\n\n    if (this._linear) {\n      // TODO: find the actual extrema, because they might\n      //       be before the start, or past the end.\n\n      const n = this.normal(0);\n      const start = this.points[0];\n      const end = this.points[this.points.length - 1];\n      let s, mid, e;\n\n      if (d3 === undefined) {\n        d3 = d1;\n        d4 = d2;\n      }\n\n      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };\n      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const fline = [s, mid, e];\n\n      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };\n      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const bline = [e, mid, s];\n\n      const ls = utils.makeline(bline[2], fline[0]);\n      const le = utils.makeline(fline[2], bline[0]);\n      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];\n      return new PolyBezier(segments);\n    }\n\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\nexport { Bezier };\n","\n//import { Points, Paths } from '../index.js';\nimport * as Paths from '../path/index.js';\nimport { bbox as PointsBbox } from '../point/Bbox.js';\nimport { isEqual as PointsIsEqual } from '../point/IsEqual.js';\nimport type { CompoundPath, Dimensions, Path, RectPositioned } from '../Types.js';\nimport type { Point } from '../point/PointType.js';\nimport { corners as RectsCorners } from '../rect/Corners.js';\nimport { sortByNumericProperty } from '../../data/arrays/Sort.js';\n\n/**\n * Returns a new compoundpath, replacing a path at a given index\n *\n * @param compoundPath Existing compoundpath\n * @param index Index to replace at\n * @param path Path to substitute in\n * @returns New compoundpath\n */\nexport const setSegment = (compoundPath: CompoundPath, index: number, path: Path): CompoundPath => {\n  const existing = [ ...compoundPath.segments ];\n  //eslint-disable-next-line functional/prefer-readonly-type,functional/immutable-data\n  existing[ index ] = path;\n  return fromPaths(...existing);\n};\n\n/**\n * Computes x,y point at a relative position along compoundpath\n *\n * @param paths Combined paths (assumes contiguous)\n * @param t Position (given as a percentage from 0 to 1)\n * @param useWidth If true, widths are used for calulcating. If false, lengths are used\n * @param dimensions Precalculated dimensions of paths, will be computed if omitted\n * @returns\n */\nexport const interpolate = (paths: ReadonlyArray<Path>, t: number, useWidth?: boolean, dimensions?: Dimensions) => {\n  if (dimensions === undefined) {\n    dimensions = computeDimensions(paths);\n  }\n\n  // Expected value to land on\n  const expected = t * (useWidth ? dimensions.totalWidth : dimensions.totalLength);\n  let soFar = 0;\n\n  // Use widths or lengths?\n  const l = useWidth ? dimensions.widths : dimensions.lengths;\n  for (const [ index, element ] of l.entries()) {\n    if (soFar + element >= expected) {\n      const relative = expected - soFar;\n      let amt = relative / element;\n      if (amt > 1) amt = 1;\n      return paths[ index ].interpolate(amt);\n    } else soFar += element;\n  }\n  return { x: 0, y: 0 };\n};\n\n/**\n * Returns the shortest distance of `point` to any point on `paths`.\n * @param paths \n * @param point \n * @returns \n */\nexport const distanceToPoint = (paths: ReadonlyArray<Path>, point: Point): number => {\n  if (paths.length === 0) return 0;\n  let distances = paths.map((p, index) => ({ path: p, index, distance: p.distanceToPoint(point) }));\n  distances = sortByNumericProperty(distances, `distance`);\n  if (distances.length === 0) throw new Error(`Could not look up distances`);\n  return distances[ 0 ].distance;\n}\n\n/**\n * Relative position\n * @param paths Paths\n * @param point Point\n * @param intersectionThreshold Threshold \n * @param dimensions Pre-computed dimensions\n * @returns \n */\nexport const relativePosition = (paths: ReadonlyArray<Path>, point: Point, intersectionThreshold: number, dimensions?: Dimensions): number => {\n  if (dimensions === undefined) {\n    dimensions = computeDimensions(paths);\n  }\n  let distances = paths.map((p, index) => ({ path: p, index, distance: p.distanceToPoint(point) }));\n  distances = sortByNumericProperty(distances, `distance`);\n  if (distances.length < 0) throw new Error(`Point does not intersect with path`);\n  const d = distances[ 0 ];\n  if (d.distance > intersectionThreshold) throw new Error(`Point does not intersect with path. Minimum distance: ${ d.distance }, threshold: ${ intersectionThreshold }`);\n\n  const relativePositionOnPath = d.path.relativePosition(point, intersectionThreshold);\n\n  // Add up distances\n  let accumulated = 0;\n  for (let index = 0; index < d.index; index++) {\n    // Add up length of paths before closest path segment\n    accumulated += dimensions.lengths[ index ];\n  }\n\n  // Add up partial amount of closest path\n  accumulated += dimensions.lengths[ d.index ] * relativePositionOnPath;\n  const accumulatedRel = accumulated / dimensions.totalLength;\n  console.log(`acc: ${ accumulated } rel: ${ accumulatedRel } on path: ${ relativePositionOnPath } path: ${ d.index }`);\n  return accumulatedRel;\n}\n\n/**\n * Computes the widths and lengths of all paths, adding them up as well\n *\n * @param paths\n * @returns\n */\nexport const computeDimensions = (paths: ReadonlyArray<Path>): Dimensions => {\n  const widths = paths.map(l => l.bbox().width);\n  const lengths = paths.map(l => l.length());\n  let totalLength = 0;\n  let totalWidth = 0;\n  for (const length of lengths) {\n    totalLength += length;\n  }\n  for (const width of widths) {\n    totalWidth += width;\n  }\n\n  return { totalLength, totalWidth, widths, lengths };\n};\n\n/**\n * Computes the bounding box that encloses entire compoundpath\n *\n * @param paths\n * @returns\n */\nexport const bbox = (paths: ReadonlyArray<Path>): RectPositioned => {\n  const boxes = paths.map(p => p.bbox());\n  const corners = boxes.flatMap(b => RectsCorners(b));\n\n  return PointsBbox(...corners);\n};\n\n/**\n * Produce a human-friendly representation of paths\n *\n * @param paths\n * @returns\n */\nexport const toString = (paths: ReadonlyArray<Path>): string => paths.map(p => p.toString()).join(`, `);\n\n/**\n * Throws an error if paths are not connected together, in order\n *\n * @param paths\n */\nexport const guardContinuous = (paths: ReadonlyArray<Path>) => {\n  let lastPos = Paths.getEnd(paths[ 0 ]);\n  for (let index = 1; index < paths.length; index++) {\n    const start = Paths.getStart(paths[ index ]);\n    if (!PointsIsEqual(start, lastPos)) throw new Error(`Path index ${ index } does not start at prior path end. Start: ${ start.x },${ start.y } expected: ${ lastPos.x },${ lastPos.y }`);\n    lastPos = Paths.getEnd(paths[ index ]);\n  }\n};\n\nexport const toSvgString = (paths: ReadonlyArray<Path>): ReadonlyArray<string> => paths.flatMap(p => p.toSvgString());\n\n/**\n * Create a compoundpath from an array of paths.\n * All this does is verify they are connected, and precomputes dimensions\n *\n * @param paths\n * @returns\n */\nexport const fromPaths = (...paths: ReadonlyArray<Path>): CompoundPath => {\n  guardContinuous(paths); // Throws an error if paths are not connected\n  const dims = computeDimensions(paths);\n\n  return Object.freeze({\n    segments: paths,\n    length: () => dims.totalLength,\n    nearest: (_: Point) => { throw new Error(`not implemented`); },\n    interpolate: (t: number, useWidth = false) => interpolate(paths, t, useWidth, dims),\n    relativePosition: (point: Point, intersectionThreshold: number) => relativePosition(paths, point, intersectionThreshold, dims),\n    distanceToPoint: (point: Point) => distanceToPoint(paths, point),\n    bbox: () => bbox(paths),\n    toString: () => toString(paths),\n    toSvgString: () => toSvgString(paths),\n    kind: `compound`\n  });\n};\n","\nimport type { Point } from './point/PointType.js';\nimport { degreeToRadian } from './Angles.js';\nimport type { Path } from './path/index.js';\n\n/**\n * An ellipse\n */\nexport type Ellipse = {\n  readonly radiusX: number\n  readonly radiusY: number\n  /**\n   * Rotation, in radians\n   */\n  readonly rotation?: number\n  readonly startAngle?: number\n  readonly endAngle?: number\n}\n\n/**\n * A {@link Ellipse} with position\n */\nexport type EllipsePositioned = Point & Ellipse\n\n\nexport const fromDegrees = (radiusX: number, radiusY: number, rotationDeg = 0, startAngleDeg = 0, endAngleDeg = 360): Ellipse => ({\n  radiusX, radiusY,\n  rotation: degreeToRadian(rotationDeg),\n  startAngle: degreeToRadian(startAngleDeg),\n  endAngle: degreeToRadian(endAngleDeg)\n});\n\nexport type EllipticalPath = Ellipse & Path & {\n  readonly kind: `elliptical`\n};","import type { Point } from \"./point/PointType.js\";\nimport { distance } from \"./point/Distance.js\";\n/**\n * Simplifies a curve by dropping points based on shortest distance.\n * \n * Values of `epsilon` approaching zero keep more of the original points.\n * Making `epsilon` larger will filter out more points, making the curve more lossy and jagged.\n * \n * ```js\n * // Source set of points that define the curve\n * const pts = [ {x:100,y:200}, {x:10, y:20}, ... ];\n * \n * const simplified = rdpShortestDistance(pts, 3); // Yields an array of points\n * ```\n * It is an implementation of the [Ramer Douglas Peucker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)\n * by Marius Karthaus. Try the online playground: https://karthaus.nl/rdp/\n * \n * @param points \n * @param epsilon \n * @returns \n */\nexport const rdpShortestDistance = (points: Array<Point>, epsilon = 0.1): Array<Point> => {\n  const firstPoint = points[ 0 ];\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const lastPoint = points.at(-1)!;\n  if (points.length < 3) {\n    return points;\n  }\n  let index = -1;\n  let distribution = 0;\n  for (let index_ = 1; index_ < points.length - 1; index_++) {\n    const cDistribution = distanceFromPointToLine(points[ index_ ], firstPoint, lastPoint);\n\n    if (cDistribution > distribution) {\n      distribution = cDistribution;\n      index = index_;\n    }\n  }\n  if (distribution > epsilon) {\n    // iterate\n    const l1 = points.slice(0, index + 1);\n    const l2 = points.slice(index);\n    const r1 = rdpShortestDistance(l1, epsilon);\n    const r2 = rdpShortestDistance(l2, epsilon);\n    // concat r2 to r1 minus the end/startpoint that will be the same\n    const rs = [ ...r1.slice(0, - 1), ...r2 ];//concat(r2);\n    return rs;\n  } else {\n    return [ firstPoint, lastPoint ];\n  }\n}\n\n/**\n * Simplifies a curve by dropping points based on perpendicular distance\n * \n * Values of `epsilon` approaching zero keep more of the original points.\n * Making `epsilon` larger will filter out more points, making the curve more lossy and jagged.\n * \n * ```js\n * // Source set of points that define the curve\n * const pts = [ {x:100,y:200}, {x:10, y:20}, ... ];\n * \n * const simplified = rdpShortestDistance(pts, 3); // Yields an array of points\n * ```\n * It is an implementation of the [Ramer Douglas Peucker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)\n * by Marius Karthaus. Try the online playground: https://karthaus.nl/rdp/\n * \n * @param points \n * @param epsilon \n * @returns \n */\nexport const rdpPerpendicularDistance = (points: Array<Point>, epsilon = 0.1): Array<Point> => {\n  const firstPoint = points[ 0 ];\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const lastPoint = points.at(-1)!;\n  if (points.length < 3) {\n    return points;\n  }\n  let index = -1;\n  let distribution = 0;\n  for (let index_ = 1; index_ < points.length - 1; index_++) {\n    const cDistribution = findPerpendicularDistance(points[ index_ ], firstPoint, lastPoint);\n    if (cDistribution > distribution) {\n      distribution = cDistribution;\n      index = index_;\n    }\n  }\n  if (distribution > epsilon) {\n    // iterate\n    const l1 = points.slice(0, index + 1);\n    const l2 = points.slice(index);\n    const r1 = rdpPerpendicularDistance(l1, epsilon);\n    const r2 = rdpPerpendicularDistance(l2, epsilon);\n    // concat r2 to r1 minus the end/startpoint that will be the same\n    const rs = [ ...r1.slice(0, - 1), ...r2 ];\n    return rs;\n  } else {\n    return [ firstPoint, lastPoint ];\n  }\n}\n\n\nfunction findPerpendicularDistance(p: Point, p1: Point, p2: Point) {\n  // if start and end point are on the same x the distance is the difference in X.\n  let result;\n  let slope;\n  let intercept;\n  if (p1.x == p2.x) {\n    result = Math.abs(p.x - p1.x);\n  } else {\n    slope = (p2.y - p1.y) / (p2.x - p1.x);\n    intercept = p1.y - (slope * p1.x);\n    result = Math.abs(slope * p.x - p.y + intercept) / Math.sqrt(Math.pow(slope, 2) + 1);\n  }\n\n  return result;\n}\n\n\nconst distanceFromPointToLine = (p: Point, index: Point, index_: Point) => {\n  const lineLength = distance(index, index_);//First, we need the length of the line segment.\n  if (lineLength == 0) {\t//if it's 0, the line is actually just a point.\n    return distance(p, index);\n  }\n  const t = ((p.x - index.x) * (index_.x - index.x) + (p.y - index.y) * (index_.y - index.y)) / lineLength;\n\n  //t is very important. t is a number that essentially compares the individual coordinates\n  //distances between the point and each point on the line.\n\n  if (t < 0) {\t//if t is less than 0, the point is behind i, and closest to i.\n    return distance(p, index);\n  }\t//if greater than 1, it's closest to j.\n  if (t > 1) {\n    return distance(p, index_);\n  }\n  return distance(p, { x: index.x + t * (index_.x - index.x), y: index.y + t * (index_.y - index.y) });\n}\n\n\n","import { type TraversableTree } from '../collections/tree/Types.js';\nimport * as Shapes from './shape/index.js';\nimport type { Point } from './point/PointType.js';\nimport { fromTopLeft as RectsFromTopLeft } from './rect/FromTopLeft.js';\nimport { intersectsPoint as RectsIntersectsPoint } from './rect/Intersects.js';\nimport { fromNumbers as PointsFromNumbers } from './point/From.js';\nimport type { ShapePositioned } from './shape/index.js';\nimport type { RectPositioned } from './rect/RectTypes.js';\n/**\n * Options for quad tree\n */\nexport type QuadTreeOpts = {\n  /**\n   * Maximum items per node\n   */\n  readonly maxItems: number;\n  /**\n   * Maximum level of sub-division\n   */\n  readonly maxLevels: number;\n};\n\n/**\n * Direction\n */\nexport enum Direction {\n  Nw,\n  Ne,\n  Sw,\n  Se,\n}\n\n/**\n * A Point or ShapePositioned\n */\nexport type QuadTreeItem = Point | ShapePositioned;\n\n/**\n * Creates a QuadTreeNode\n * @param bounds Bounds of region\n * @param initialData Initial items to place in quad tree\n * @param opts Options\n * @returns New quad tree\n */\nexport const quadTree = (bounds: RectPositioned, initialData: ReadonlyArray<QuadTreeItem> = [], opts: Partial<QuadTreeOpts> = {}): QuadTreeNode => {\n  const o: QuadTreeOpts = {\n    maxItems: opts.maxItems ?? 4,\n    maxLevels: opts.maxLevels ?? 4\n  };\n\n  const n = new QuadTreeNode(undefined, bounds, 0, o);\n  for (const d of initialData) {\n    n.add(d);\n  }\n  return n;\n};\n\n/**\n * QuadTreeNode. The values of the node is an array of {@link QuadTreeItem}.\n *\n * To create, you probably want the {@link quadTree} function.\n * \n */\nexport class QuadTreeNode implements TraversableTree<Array<QuadTreeItem>> {\n  #items: Array<QuadTreeItem> = [];\n  #children: Array<QuadTreeNode> = [];\n  #parent: QuadTreeNode | undefined;\n  /**\n   * Constructor\n   * @param boundary\n   * @param level\n   * @param opts\n   */\n  constructor(\n    parent: QuadTreeNode | undefined,\n    readonly boundary: RectPositioned,\n    readonly level: number,\n    readonly opts: QuadTreeOpts\n  ) {\n    this.#parent = parent;\n  }\n\n  getLengthChildren(): number {\n    return this.#children.length;\n  }\n\n  *parents(): IterableIterator<QuadTreeNode> {\n    //eslint-disable-next-line functional/no-let,@typescript-eslint/no-this-alias\n    let n: QuadTreeNode | undefined = this;\n    while (n.#parent !== undefined) {\n      yield n.#parent;\n      n = n.#parent;\n    }\n  }\n\n  getParent() {\n    return this.#parent;\n  }\n\n  /**\n   * Iterates over immediate children\n   */\n  *children(): IterableIterator<QuadTreeNode> {\n    for (const c of this.#children) {\n      yield c;\n    }\n  }\n\n  /**\n   * Array of QuadTreeItem\n   * @returns\n   */\n  getValue() {\n    return this.#items;\n  }\n\n  getIdentity() {\n    return this;\n  }\n  /**\n   * Get a descendant node in a given direction\n   * @param d\n   * @returns\n   */\n  direction(d: Direction): QuadTreeNode | undefined {\n    return this.#children[ d ] as QuadTreeNode | undefined;\n  }\n\n  /**\n   * Add an item to the quadtree\n   * @param p\n   * @returns False if item is outside of boundary, True if item was added\n   */\n  add(p: QuadTreeItem): boolean {\n    if (!Shapes.isIntersecting(this.boundary, p)) return false;\n\n    if (this.#children.length > 0) {\n      for (const d of this.#children) (d).add(p);\n      return true;\n    }\n\n    this.#items.push(p);\n\n    if (\n      this.#items.length > this.opts.maxItems &&\n      this.level < this.opts.maxLevels\n    ) {\n      if (this.#children.length === 0) {\n        this.#subdivide();\n      }\n\n      // Add to child\n      for (const item of this.#items) {\n        for (const d of this.#children) (d).add(item);\n      }\n      //this.descendants.forEach(d => (d as QuadTreeNode).add(p));\n      this.#items = [];\n    }\n    return true;\n  }\n\n  /**\n   * Returns true if point is inside node's boundary\n   * @param p\n   * @returns\n   */\n  couldHold(p: Point) {\n    return RectsIntersectsPoint(this.boundary, p);\n  }\n\n  #subdivide() {\n    const w = this.boundary.width / 2;\n    const h = this.boundary.height / 2;\n    const x = this.boundary.x;\n    const y = this.boundary.y;\n\n    // top-left corners of each of the four new sections\n    const coords = PointsFromNumbers(x + w, y, x, y, x, y + h, x + w, y + h);\n    const rects = coords.map((p) => RectsFromTopLeft(p, w, h));\n    // rects.forEach((r, index) => {\n    //   this.descendants[index] = new QuadTreeNode(r, this.level + 1, this.opts);\n    // });\n    this.#children = rects.map(\n      (r) => new QuadTreeNode(this, r, this.level + 1, this.opts)\n    );\n  }\n}\n","\nimport type { Point } from './point/PointType.js';\nimport type { Rect } from './rect/index.js';\nimport { isPoint } from './point/index.js';\nimport { isRect } from './rect/Guard.js';\nimport { Placeholder as PlaceholderRect } from './rect/Placeholder.js';\n\n/**\n * A scale function that takes an input value to scale.\n * Input can be in the form of `{ x, y }` or two number parameters.\n *\n * ```js\n * scale(10, 20);\n * scale({ x:10, y:20 });\n * ```\n *\n * Output range can be specified as a `{ width, height }` or two number parameters.\n * If omitted, the default range\n * is used.\n *\n * ```js\n * // Scale 10,20 with range w:800 h:600\n * scale(10, 20, 800, 600);\n * scale({x:10, y:20}, 800, 600);\n * scale({x:10, y:20}, {width: 800, height: 600});\n * ```\n */\nexport type Scaler = (\n  a: number | Point,\n  b?: number | Rect,\n  c?: number | Rect,\n  d?: number\n) => Point;\n\n/**\n * A scaler than can convert to a from an output range\n */\nexport type ScalerCombined = {\n  /**\n   * Relative to absolute coordinates\n   */\n  readonly abs: Scaler;\n  /**\n   * Absolute to relative coordintes\n   */\n  readonly rel: Scaler;\n\n  readonly width: number;\n\n  readonly height: number;\n\n  computeScale(): Point\n};\n\nexport type ScaleBy = `both` | `min` | `max` | `width` | `height`;\n\n/**\n * Returns a set of scaler functions, to convert to and from ranges.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`, {width:window.innerWidth, height:window.innerHeight});\n * // Assuming screen of 800x400...\n * scaler.abs(400,200);          // Yields { x:0.5, y:0.5 }\n * scaler.abs({ x:400, y:200 }); // Yields { x:0.5, y:0.5 }\n *\n * scaler.rel(0.5, 0.5);         // Yields: { x:400, y:200 }\n * scaler.rel({ x:0.5, y:0.5 }); // Yields: { x:400, y:200 }\n * ```\n *\n * If no default range is provided, it must be given each time the scale function is used.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`);\n *\n * scaler.abs(400, 200, 800, 400);\n * scaler.abs(400, 200, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, 800, 400);\n * // All are the same, yielding { x:0.5, y:0.5 }\n *\n * scaler.abs(400, 200); // Throws an exception because there is no scale\n * ```\n * @param scaleBy Dimension to scale by\n * @param defaultRect Default range\n * @returns\n */\nexport const scaler = (\n  scaleBy: ScaleBy = `both`,\n  defaultRect?: Rect\n): ScalerCombined => {\n  const defaultBounds = defaultRect ?? PlaceholderRect;\n\n  let sw = 1;\n  let sh = 1;\n  let s = { x: 1, y: 1 };\n\n  const computeScale = () => {\n    switch (scaleBy) {\n      case `height`: {\n        return { x: sh, y: sh };\n      }\n      case `width`: {\n        return { x: sw, y: sw };\n      }\n      case `min`: {\n        return { x: Math.min(sw, sh), y: Math.min(sw, sh) };\n      }\n      case `max`: {\n        return { x: Math.max(sw, sh), y: Math.max(sw, sh) };\n      }\n      default: {\n        return { x: sw, y: sh };\n      }\n    }\n  };\n\n  const normalise = (\n    a: number | Point,\n    b?: number | Rect,\n    c?: number | Rect,\n    d?: number\n  ): [ x: number, y: number, w: number, h: number ] => {\n    let inX = Number.NaN;\n    let inY = Number.NaN;\n    let outW = defaultBounds.width;\n    let outH = defaultBounds.height;\n\n    if (typeof a === `number`) {\n      inX = a;\n      if (typeof b === `number`) {\n        inY = b;\n        if (c === undefined) return [ inX, inY, outW, outH ];\n        if (isRect(c)) {\n          outW = c.width;\n          outH = c.height;\n        } else if (typeof c === `number`) {\n          outW = c;\n          if (typeof d === `number`) {\n            outH = d;\n          } else {\n            throw new TypeError(`Missing final height value`);\n          }\n        } else throw new Error(`Missing valid output range`);\n      } else if (isRect(b)) {\n        outW = b.width;\n        outH = b.height;\n      } else {\n        throw new Error(\n          `Expected input y or output Rect to follow first number parameter`\n        );\n      }\n    } else if (isPoint(a)) {\n      inX = a.x;\n      inY = a.y;\n      if (b === undefined) return [ inX, inY, outW, outH ];\n      if (isRect(b)) {\n        outW = b.width;\n        outH = b.height;\n      } else if (typeof b === `number`) {\n        outW = b;\n        if (typeof c === `number`) {\n          outH = c;\n        } else {\n          throw new TypeError(\n            `Expected height as third parameter after Point and output width`\n          );\n        }\n      } else {\n        throw new TypeError(\n          `Expected Rect or width as second parameter when first parameter is a Point`\n        );\n      }\n    } else {\n      throw new Error(`Expected input Point or x value as first parameter`);\n    }\n    return [ inX, inY, outW, outH ];\n  };\n\n  const scaleAbs = (\n    a: number | Point,\n    b?: number | Rect,\n    c?: number | Rect,\n    d?: number\n  ): Point => {\n    const n = normalise(a, b, c, d);\n    return scaleNormalised(true, ...n);\n  };\n\n  const scaleRel = (\n    a: number | Point,\n    b?: number | Rect,\n    c?: number | Rect,\n    d?: number\n  ): Point => {\n    const n = normalise(a, b, c, d);\n    return scaleNormalised(false, ...n);\n  };\n\n  const scaleNormalised = (\n    abs: boolean,\n    x: number,\n    y: number,\n    w: number,\n    h: number\n  ): Point => {\n    if (Number.isNaN(w)) throw new Error(`Output width range missing`);\n    if (Number.isNaN(h)) throw new Error(`Output height range missing`);\n\n    // If output dimensions has changed since last, create a new scale\n    if (w !== sw || h !== sh) {\n      sw = w;\n      sh = h;\n      s = computeScale();\n    }\n\n    return abs ? {\n      x: x * s.x,\n      y: y * s.y,\n    } : {\n      x: x / s.x,\n      y: y / s.y,\n    };\n  };\n\n  return {\n    computeScale,\n    rel: scaleRel,\n    abs: scaleAbs,\n    width: defaultBounds.width,\n    height: defaultBounds.height\n  };\n};\n\n// export const scalerReactive = (scaleBy: ScaleBy = `both`,\n//   defaultRect?: ReactiveInitial<Rect>) => {\n\n//   const resolve = (a: Point | Rect | RectPositioned | number, b: Rect | number, c: number, d: number) => {\n//     if (typeof a === `number`) {\n//       if (typeof b === `number`) {\n//         return { x: a, y: b, width: undefined, height: undefined }\n//       } else {\n//         throw new TypeError(`Expected 'b' parameter to be the y value?`);\n//       }\n//     } else if (isPoint(a)) {\n//       if (isRect(b)) {\n//         // Positioned rect\n//         return {\n//           x: \n//       }\n//       }\n//     }\n//   }","export const Placeholder = Object.freeze({\n  width: Number.NaN,\n  height: Number.NaN,\n});\nexport const PlaceholderPositioned = Object.freeze({\n  x: Number.NaN,\n  y: Number.NaN,\n  width: Number.NaN,\n  height: Number.NaN,\n});\n","import { type Rgb } from '../visual/Colour.js';\nimport * as ImageDataGrid from '../visual/ImageDataGrid.js';\nimport * as Grids from './Grid.js';\n\nexport type Kernel = ReadonlyArray<ReadonlyArray<number>>;\nexport type CellWithValue<V> = readonly [ cell: Grids.Cell, value: V | undefined ];\nexport type ScalarAndValue<V> = readonly [ scalar: number, v: V | undefined ];\nexport type KernelCompute = <V>(offset: Grids.Cell, value: V) => V;\nexport type KernelReduce<V> = (values: ReadonlyArray<ScalarAndValue<V>>) => V | undefined;\n\n/**\n * Multiply every element of kernel by the same `scalar` value.\n * Returns new result, input is unmodified\n * @param kernel \n * @param scalar \n * @returns \n */\nexport const multiply = (kernel: Kernel, scalar: number): Kernel => {\n  const rows = kernel.length;\n  const cols = kernel[ 0 ].length;\n  const copy: Array<Array<number>> = [];\n  //eslint-disable-next-line functional/no-let\n  for (let row = 0; row < rows; row++) {\n    //eslint-disable-next-line functional/immutable-data\n    copy[ row ] = [];\n    //eslint-disable-next-line functional/no-let\n    for (let col = 0; col < cols; col++) {\n      //eslint-disable-next-line functional/immutable-data\n      copy[ row ][ col ] = kernel[ row ][ col ] * scalar;\n    }\n  }\n  return copy;\n};\n\n\nexport function convolveCell<V>(c: Grids.Cell, kernel: Kernel2dArray, source: Grids.Grid, access: Grids.CellAccessor<V>, reduce: KernelReduce<V>): V | undefined {\n  const valuesAtKernelPos: Array<ScalarAndValue<V>> = kernel.map(o => {\n    const pos = Grids.offset(source, c, o[ 0 ], `stop`); // `stop` avoids fringing at extents of image\n    if (!pos) return [ o[ 1 ], undefined ];\n    return [ o[ 1 ], access(pos, `undefined`) ];\n  });\n  return reduce(valuesAtKernelPos);\n}\n\n/**\n * Performs kernel-based convolution over `image`.\n * @param kernel \n * @param image \n */\nexport function* convolveImage(kernel: Kernel, image: ImageData) {\n  const grid = { rows: image.width, cols: image.height };\n  const imageDataAsGrid = ImageDataGrid.accessor(image);\n\n  yield* convolve(kernel, grid, imageDataAsGrid, Grids.cells(grid), rgbReducer);\n}\n\nexport function* convolve<V>(kernel: Kernel, source: Grids.Grid, access: Grids.CellAccessor<V>, visitor: Grids.VisitGenerator, reduce: KernelReduce<V>, origin?: Grids.Cell): IterableIterator<CellWithValue<V>> {\n\n  //const wrap:Grids.BoundsLogic = `undefined`;\n  // Use middle, eg 3x3 = 1,1\n  if (!origin) {\n    const kernelRows = kernel.length;\n    const kernelCols = kernel[ 0 ].length;\n    origin = { x: Math.floor(kernelRows / 2), y: Math.floor(kernelCols / 2) };\n  }\n\n  const asArray = kernel2dToArray(kernel, origin);\n  for (const c of visitor) {\n    const v = convolveCell<V>(c, asArray, source, access, reduce);\n    yield [ c, v ];\n  }\n}\n\nexport type Kernel2dArray = ReadonlyArray<readonly [ cell: Grids.Cell, value: number ]>;\n\n/**\n * For a given kernel, returns an array of offsets. These\n * consist of a cell offset (eg `{x:-1,y:-1}`) and the value at that kernel position.\n * @param kernel \n * @param origin \n * @returns \n */\nexport const kernel2dToArray = (kernel: Kernel, origin?: Grids.Cell): Kernel2dArray => {\n  const offsets: Kernel2dArray = [];\n  const rows = kernel.length;\n  const cols = kernel[ 0 ].length;\n  if (!origin) origin = { x: Math.floor(rows / 2), y: Math.floor(cols / 2) };\n\n  //eslint-disable-next-line functional/no-let\n  for (let xx = 0; xx < rows; xx++) {\n    //eslint-disable-next-line functional/no-let\n    for (let yy = 0; yy < cols; yy++) {\n      //eslint-disable-next-line functional/immutable-data\n      // @ts-expect-error\n      offsets.push([ { x: xx - origin.x, y: yy - origin.y }, kernel[ xx ][ yy ] ]);\n    }\n  }\n  return offsets;\n};\n\nexport const rgbReducer: KernelReduce<Rgb> = (values: ReadonlyArray<ScalarAndValue<Rgb>>) => {\n  //eslint-disable-next-line functional/no-let\n  let r = 0;\n  //eslint-disable-next-line functional/no-let\n  let g = 0;\n  //eslint-disable-next-line functional/no-let\n  let b = 0;\n  //eslint-disable-next-line functional/no-let\n  const opacity = 0;\n  //eslint-disable-next-line functional/no-let\n  for (const value of values) {\n    const rgb = value[ 1 ];\n    const scale = value[ 0 ];\n    if (rgb === undefined) continue;\n    if (rgb.opacity === 0) continue;\n    if (scale === 0) continue;\n    r += (rgb.r * scale);\n    g += (rgb.g * scale);\n    b += (rgb.b * scale);\n    //opacity += ((rgb.opacity ?? 1) * scale);\n  }\n\n  const result = {\n    r: r,\n    g: g,\n    b: b,\n    opacity: 255,\n    space: `srgb`\n  } as const;\n  return result;\n};\nexport const identityKernel = [\n  [ 0, 0, 0 ],\n  [ 0, 1, 0 ],\n  [ 0, 0, 0 ]\n];\n\n\nexport const edgeDetectionKernel = [\n  [ 0, -1, 0 ],\n  [ -1, 4, -1 ],\n  [ 0, -1, 0 ]\n];\n\nexport const sharpenKernel = [\n  [ 0, -1, 0 ],\n  [ -1, 5, -1 ],\n  [ 0, -1, 0 ]\n];\n\nexport const boxBlurKernel = multiply([\n  [ 1, 1, 1 ],\n  [ 1, 1, 1 ],\n  [ 1, 1, 1 ]\n], 1 / 9);\n\nexport const gaussianBlur3Kernel = multiply([\n  [ 1, 2, 1 ],\n  [ 2, 4, 2 ],\n  [ 1, 2, 1 ]\n], 1 / 16);\n\nexport const gaussianBlur5Kernel = multiply([\n  [ 1, 4, 6, 4, 1 ],\n  [ 4, 16, 24, 16, 4 ],\n  [ 6, 24, 36, 24, 6 ],\n  [ 4, 16, 24, 16, 4 ],\n  [ 1, 4, 6, 4, 1 ],\n], 1 / 256);\n\nexport const unsharpMasking5Kernel = multiply([\n  [ 1, 4, 6, 4, 1 ],\n  [ 4, 16, 24, 16, 4 ],\n  [ 6, 24, -476, 24, 6 ],\n  [ 4, 16, 24, 16, 4 ],\n  [ 1, 4, 6, 4, 1 ],\n], -1 / 256);","import * as Grids from '../geometry/Grid.js';\nimport type { Rgb } from './Colour.js';\n\n/**\n * Returns a function that accesses pixel values by x,y\n * @param image \n * @returns \n */\nexport const accessor = (image: ImageData): Grids.CellAccessor<Rgb> => {\n  const grid = { rows: image.width, cols: image.height };\n  const data = image.data;\n\n  const fn: Grids.CellAccessor<Rgb> = (cell: Grids.Cell, bounds) => {\n    const index = Grids.indexFromCell(grid, cell, bounds);\n    if (index === undefined) {\n      return undefined;\n    }\n    const pxIndex = index * 4;\n    return {\n      r: data[ pxIndex ],\n      g: data[ pxIndex + 1 ],\n      b: data[ pxIndex + 2 ],\n      opacity: data[ pxIndex + 3 ],\n      space: `srgb`\n    };\n  };\n  return fn;\n};\n\n\n/**\n * Yields pixels of an image row by row\n * @param image \n */\nexport function* byRow(image: ImageData) {\n  const a = accessor(image);\n  const grid = { rows: image.width, cols: image.height };\n\n  for (let y = 0; y < grid.rows; y++) {\n    let row: Rgb[] = [];\n    for (let x = 0; x < grid.cols; x++) {\n      const p = a({ x, y }, `undefined`);\n      if (p) row.push(p);\n    }\n    yield row;\n  }\n}\n\n/**\n * Yields pixels of an image column by column\n * @param image \n */\nexport function* byColumn(image: ImageData) {\n  const a = accessor(image);\n  const grid = { rows: image.width, cols: image.height };\n\n  for (let x = 0; x < grid.cols; x++) {\n    let col: Rgb[] = [];\n    for (let y = 0; y < grid.rows; y++) {\n      const p = a({ x, y }, `undefined`);\n      if (p) col.push(p);\n    }\n    yield col;\n  }\n}","import { degreeToRadian } from '../Angles.js';\nimport { guard as guardPoint, isPoint } from '../point/Guard.js';\nimport { distance as pointsDistance } from '../point/Distance.js';\nimport { bbox as pointsBbox } from '../point/Bbox.js';\nimport { toCartesian } from '../Polar.js';\nimport type { Point } from '../point/PointType.js';\nimport type { Line } from '../line/LineType.js';\nimport type { Path } from '../path/index.js';\nimport type { Rect, RectPositioned } from '../rect/index.js';\nimport { fromPoints as LinesFromPoints } from '../line/FromPoints.js';\nimport type { Arc, ArcPositioned } from './ArcType.js';\n\nexport type * from './ArcType.js';\n\n/**\n * Returns true if parameter is an arc\n * @param p Arc or number\n * @returns \n */\nexport const isArc = (p: unknown): p is Arc => (p as Arc).startRadian !== undefined && (p as Arc).endRadian !== undefined;\n\n/**\n * Returns true if parameter has a positioned (x,y) \n * @param p Point, Arc or ArcPositiond\n * @returns \n */\nexport const isPositioned = (p: Point | Arc | ArcPositioned): p is Point => (p as Point).x !== undefined && (p as Point).y !== undefined;\n\nconst piPi = Math.PI * 2;\n\n/**\n * Returns an arc from degrees, rather than radians\n * @param radius Radius of arc\n * @param startDegrees Start angle in degrees\n * @param endDegrees End angle in degrees\n * @returns Arc\n */\nexport function fromDegrees(radius: number, startDegrees: number, endDegrees: number): Arc;\n\n/**\n * Returns an arc from degrees, rather than radians\n * @param radius Radius of arc\n * @param startDegrees Start angle in degrees\n * @param endDegrees End angle in degrees\n * @param origin Optional center of arc\n * @returns Arc\n */export function fromDegrees(radius: number, startDegrees: number, endDegrees: number, origin: Point): ArcPositioned\n\n/**\n * Returns an arc from degrees, rather than radians\n * @param radius Radius of arc\n * @param startDegrees Start angle in degrees\n * @param endDegrees End angle in degrees\n * @param origin Optional center of arc\n * @returns Arc\n */\n//eslint-disable-next-line func-style\nexport function fromDegrees(radius: number, startDegrees: number, endDegrees: number, origin?: Point): Arc | ArcPositioned {\n  const a: Arc = {\n    radius,\n    startRadian: degreeToRadian(startDegrees),\n    endRadian: degreeToRadian(endDegrees)\n  };\n  if (isPoint(origin)) {\n    guardPoint(origin);\n    const ap: ArcPositioned = {\n      ...a,\n      x: origin.x,\n      y: origin.y\n    };\n    return Object.freeze(ap);\n  } else {\n    return Object.freeze(a);\n  }\n}\n\n/**\n * Returns a {@link Geometry.Line} linking the start and end points of an {@link ArcPositioned}.\n *\n * @param arc\n * @returns Line from start to end of arc\n */\nexport const toLine = (arc: ArcPositioned): Line => LinesFromPoints(\n  point(arc, arc.startRadian),\n  point(arc, arc.endRadian)\n);\n\n/**\n * Calculates a coordinate on an arc, based on an angle\n * @param arc Arc\n * @param angleRadian Angle of desired coordinate \n * @param origin Origin of arc (0,0 used by default)\n * @returns Coordinate\n */\nexport const point = (arc: Arc | ArcPositioned, angleRadian: number, origin?: Point): Point => {\n  if (angleRadian > arc.endRadian) throw new Error(`angleRadian beyond end angle of arc`);\n  if (angleRadian < arc.startRadian) throw new Error(`angleRadian beyond start angle of arc`);\n\n  if (origin === undefined) {\n    origin = isPositioned(arc) ? arc : { x: 0, y: 0 };\n  }\n  return {\n    x: (Math.cos(angleRadian) * arc.radius) + origin.x,\n    y: (Math.sin(angleRadian) * arc.radius) + origin.y\n  };\n};\n\n/**\n * Throws an error if arc instance is invalid\n * @param arc \n */\nexport const guard = (arc: Arc | ArcPositioned) => {\n  if (arc === undefined) throw new Error(`Arc is undefined`);\n  if (isPositioned(arc)) {\n    guardPoint(arc, `arc`);\n  }\n  if (arc.radius === undefined) throw new Error(`Arc radius is undefined (${ JSON.stringify(arc) })`);\n  if (typeof arc.radius !== `number`) throw new Error(`Radius must be a number`);\n  if (Number.isNaN(arc.radius)) throw new Error(`Radius is NaN`);\n  if (arc.radius <= 0) throw new Error(`Radius must be greater than zero`);\n\n  if (arc.startRadian === undefined) throw new Error(`Arc is missing 'startRadian' field`);\n  if (arc.endRadian === undefined) throw new Error(`Arc is missing 'startRadian' field`);\n  if (Number.isNaN(arc.endRadian)) throw new Error(`Arc endRadian is NaN`);\n  if (Number.isNaN(arc.startRadian)) throw new Error(`Arc endRadian is NaN`);\n\n  if (arc.startRadian >= arc.endRadian) throw new Error(`startRadian is expected to be les than endRadian`);\n};\n\n\ntype Interpolate = {\n  (amount: number, arc: Arc, origin: Point): Point;\n  (amount: number, arc: ArcPositioned): Point;\n};\n\n/**\n * Compute relative position on arc\n * @param arc Arc\n * @param amount Relative position 0-1\n * @param origin If arc is not positioned, pass in an origin\n * @returns \n */\nexport const interpolate: Interpolate = (amount: number, arc: ArcPositioned | Arc, origin?: Point): Point => {\n  guard(arc);\n  return point(arc, arc.startRadian + ((arc.endRadian - arc.startRadian) * amount), origin);\n};\n\n/**\n * Creates a {@link Geometry.Path} instance from the arc. This wraps up some functions for convienence.\n * @param arc \n * @returns Path\n */\nexport const toPath = (arc: ArcPositioned): Path => {\n  guard(arc);\n\n  return Object.freeze({\n    ...arc,\n    nearest: (point: Point) => { throw new Error(`not implemented`); },\n    interpolate: (amount: number) => interpolate(amount, arc),\n    bbox: () => bbox(arc) as RectPositioned,\n    length: () => length(arc),\n    toSvgString: () => toSvg(arc),\n    relativePosition: (_point: Point, _intersectionThreshold: number) => {\n      throw new Error(`Not implemented`)\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`)\n    },\n    kind: `arc`\n  });\n};\n\n/**\n * Calculates the length of the arc\n * @param arc \n * @returns Length\n */\nexport const length = (arc: Arc): number => piPi * arc.radius * ((arc.startRadian - arc.endRadian) / piPi);\n\n/**\n * Calculates a {@link Geometry.Rect | Rect} bounding box for arc.\n * @param arc \n * @returns Rectangle encompassing arc.\n */\nexport const bbox = (arc: ArcPositioned | Arc): RectPositioned | Rect => {\n  if (isPositioned(arc)) {\n    const middle = interpolate(0.5, arc);\n    const asLine = toLine(arc);\n    return pointsBbox(middle, asLine.a, asLine.b);\n  } else {\n    return {\n      width: arc.radius * 2,\n      height: arc.radius * 2\n    };\n  }\n};\n\n\ntype ToSvg = {\n  /**\n   * SVG path for arc description\n   * @param origin Origin of arc\n   * @param radius Radius\n   * @param startRadian Start\n   * @param endRadian End\n   */\n  (origin: Point, radius: number, startRadian: number, endRadian: number, opts?: SvgOpts): ReadonlyArray<string>;\n  /**\n   * SVG path for non-positioned arc\n   */\n  (arc: Arc, origin: Point, opts?: SvgOpts): ReadonlyArray<string>;\n  /**\n   * SVG path for positioned arc\n   */\n  (arc: ArcPositioned, opts?: SvgOpts): ReadonlyArray<string>;\n};\n\n\n/**\n * Creates an SV path snippet for arc\n * @returns \n */\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport const toSvg: ToSvg = (a: Point | Arc | ArcPositioned, b?: number | Point | SvgOpts, c?: number | SvgOpts, d?: number, e?: SvgOpts) => {\n  if (isArc(a)) {\n    if (isPositioned(a)) {\n      return toSvgFull(a, a.radius, a.startRadian, a.endRadian, b as SvgOpts);\n    } else {\n      return isPoint(b) ? toSvgFull(b, a.radius, a.startRadian, a.endRadian, c as SvgOpts) : toSvgFull({ x: 0, y: 0 }, a.radius, a.startRadian, a.endRadian);\n    }\n  } else {\n    if (c === undefined) throw new Error(`startAngle undefined`);\n    if (d === undefined) throw new Error(`endAngle undefined`);\n\n    if (isPoint(a)) {\n      if (typeof b === `number` && typeof c === `number` && typeof d === `number`) {\n        return toSvgFull(a, b, c, d, e);\n      } else {\n        throw new TypeError(`Expected (point, number, number, number). Missing a number param.`);\n      }\n    } else {\n      throw new Error(`Expected (point, number, number, number). Missing first point.`);\n    }\n  }\n};\n\nexport type SvgOpts = {\n\n  /**\n   * \"If the arc should be greater or less than 180 degrees\"\n   * ie. tries to maximise arc length\n   */\n  readonly largeArc?: boolean\n\n  /**\n   * \"If the arc should begin moving at positive angles\"\n   * ie. the kind of bend it makes to reach end point\n   */\n  readonly sweep?: boolean\n}\n\nconst toSvgFull = (origin: Point, radius: number, startRadian: number, endRadian: number, opts?: SvgOpts): ReadonlyArray<string> => {\n  // https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\n  // A rx ry x-axis-rotation large-arc-flag sweep-flag x y\n  // a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy\n\n  if (opts === undefined || typeof opts !== `object`) opts = {};\n\n  const isFullCircle = endRadian - startRadian === 360;\n  const start = toCartesian(radius, endRadian - 0.01, origin);\n  const end = toCartesian(radius, startRadian, origin);\n\n  const { largeArc = false, sweep = false } = opts;\n\n  const d = [ `\n    M ${ start.x } ${ start.y }\n    A ${ radius } ${ radius } 0 ${ largeArc ? `1` : `0` } ${ sweep ? `1` : `0` } ${ end.x } ${ end.y },\n  `];\n\n  //eslint-disable-next-line functional/immutable-data\n  if (isFullCircle) d.push(`z`);\n\n  return d;\n};\n\n/**\n * Calculates the distance between the centers of two arcs\n * @param a\n * @param b \n * @returns Distance \n */\nexport const distanceCenter = (a: ArcPositioned, b: ArcPositioned): number => pointsDistance(a, b);\n\n/**\n * Returns true if the two arcs have the same values\n *\n * ```js\n * const arcA = { radius: 5, endRadian: 0, startRadian: 1 };\n * const arcA = { radius: 5, endRadian: 0, startRadian: 1 };\n * arcA === arcB; // false, because object identities are different\n * Arcs.isEqual(arcA, arcB); // true, because values are identical\n * ```\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport const isEqual = (a: Arc | ArcPositioned, b: Arc | ArcPositioned): boolean => {\n  if (a.radius !== b.radius) return false;\n\n  if (isPositioned(a) && isPositioned(b)) {\n    if (a.x !== b.x) return false;\n    if (a.y !== b.y) return false;\n    if (a.z !== b.z) return false;\n    return true;\n  } else if (!isPositioned(a) && !isPositioned(b)) {\n    // no-op\n  } else return false; // one is positioned one not\n\n  if (a.endRadian !== b.endRadian) return false;\n  if (a.startRadian !== b.startRadian) return false;\n  return true;\n};","import type { Line } from './line/LineType.js';\nimport type { Point } from './point/PointType.js';\nimport { normalise as PointsNormalise } from './point/Normalise.js';\nimport { isPoint } from './point/Guard.js';\n//import * as Points from './point/index.js'\nimport * as Polar from './Polar.js';\nimport type { Vector } from './Types.js';\nimport { divide as PointDivide } from './point/Divider.js';\nimport { guard as LinesGuard } from './line/Guard.js';\nimport { sum as PointsSum } from './point/Sum.js';\nimport { subtract as PointsSubtract } from './point/index.js';\nimport { multiply as PointsMultiply } from './point/Multiply.js';\nimport { dotProduct as PointsDotProduct } from './point/DotProduct.js';\nimport { toString as PointsToString } from './point/To.js';\nimport { clampMagnitude as PointsClampMagnitude } from './point/Magnitude.js';\nimport { distance as PointsDistance } from './point/Distance.js';\nimport { Empty as PointEmpty } from './point/Empty.js';\n//eslint-disable-next-line @typescript-eslint/naming-convention\nconst EmptyCartesian = Object.freeze({ x: 0, y: 0 });\n\nconst piPi = Math.PI * 2;\nconst pi = Math.PI;\n\n// const Q1 = Math.PI / 2;\n// const Q2 = Math.PI;\n// const Q3 = Q1 + Q2;\n// const Q4 = Math.PI * 2;\n\nexport const fromRadians = (radians: number) => {\n  return Object.freeze({\n    x: Math.cos(radians),\n    y: Math.sin(radians)\n  });\n}\n\nexport const toRadians = (point: Point) => {\n  return Math.atan2(point.y, point.x);\n}\n/**\n * Create a vector from a point\n *\n * If `unipolar` normalisation is used, direction will be fixed to 0..2π\n * if `bipolar` normalisation is used, direction will be fixed to -π...π\n * @param pt Point\n * @param angleNormalisation Technique to normalise angle\n * @param origin Origin to calculate vector from or 0,0 if left empty\n * @returns\n */\nexport const fromPointPolar = (\n  pt: Point,\n  angleNormalisation: `` | `unipolar` | `bipolar` = ``,\n  origin: Point = EmptyCartesian\n): Polar.Coord => {\n  pt = PointsSubtract(pt, origin);\n\n  //eslint-disable-next-line functional/no-let\n  let direction = Math.atan2(pt.y, pt.x);\n  if (angleNormalisation === `unipolar` && direction < 0) direction += piPi;\n  else if (angleNormalisation === `bipolar`) {\n    if (direction > pi) direction -= piPi;\n    else if (direction <= -pi) direction += piPi;\n  }\n\n  return Object.freeze({\n    distance: PointsDistance(pt),\n    angleRadian: direction,\n  });\n};\n\n/**\n * Returns a Cartesian-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport const fromLineCartesian = (line: Line): Point =>\n  PointsSubtract(line.b, line.a);\n\n/**\n * Returns a polar-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport const fromLinePolar = (line: Line): Polar.Coord => {\n  LinesGuard(line, `line`);\n  const pt = PointsSubtract(line.b, line.a);\n  return fromPointPolar(pt);\n};\n\nconst isPolar = (v: Vector): v is Polar.Coord => {\n  if (Polar.isPolarCoord(v)) return true;\n  return false;\n};\n\nconst isCartesian = (v: Vector): v is Point => {\n  if (isPoint(v)) return true;\n  return false;\n};\n\n/**\n * Returns the normalised vector (aka unit vector). This is where\n * direction is kept, but magnitude set to 1. This then just\n * suggests direction.\n * @param v\n * @returns\n */\nexport const normalise = (v: Vector): Vector => {\n  if (isPolar(v)) {\n    return Polar.normalise(v);\n  } else if (isCartesian(v)) {\n    return PointsNormalise(v);\n  }\n  // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\nexport const quadrantOffsetAngle = (p: Point): number => {\n  if (p.x >= 0 && p.y >= 0) return 0; // Q1\n  if (p.x < 0 && p.y >= 0) return pi; // Q2\n  if (p.x < 0 && p.y < 0) return pi; // Q3\n  return piPi; // Q4\n};\n\n/**\n * Converts a vector to a polar coordinate. If the provided\n * value is already Polar, it is returned.\n * @param v\n * @param origin\n * @returns Polar vector\n */\nexport const toPolar = (v: Vector, origin = PointEmpty): Polar.Coord => {\n  if (isPolar(v)) {\n    return v;\n  } else if (isCartesian(v)) {\n    return Polar.fromCartesian(v, origin);\n  }\n  // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\n/**\n * Converts a Vector to a Cartesian coordinate. If the provided\n * value is already Cartesian, it is returned.\n * @param v\n * @returns Cartestian vector\n */\nexport const toCartesian = (v: Vector): Point => {\n  if (isPolar(v)) {\n    return Polar.toPoint(v);\n  } else if (isCartesian(v)) {\n    return v;\n  }\n  // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\n/**\n * Return a human-friendly representation of vector\n * @param v\n * @param digits\n * @returns\n */\nexport const toString = (v: Vector, digits?: number) => {\n  if (isPolar(v)) {\n    return Polar.toString(v, digits);\n  } else if (isCartesian(v)) {\n    return PointsToString(v, digits);\n  }\n  // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\n/**\n * Calculate dot product of a vector\n * @param a\n * @param b\n * @returns\n */\nexport const dotProduct = (a: Vector, b: Vector) => {\n  if (isPolar(a) && isPolar(b)) {\n    return Polar.dotProduct(a, b);\n  } else if (isCartesian(a) && isCartesian(b)) {\n    return PointsDotProduct(a, b);\n  }\n  throw new Error(`Expected two polar/Cartesian vectors.`);\n};\n\n/**\n * Clamps the magnitude of a vector\n * @param v Vector to clamp\n * @param max Maximum magnitude\n * @param min Minium magnitude\n * @returns\n */\nexport const clampMagnitude = (v: Vector, max = 1, min = 0) => {\n  if (isPolar(v)) {\n    return Polar.clampMagnitude(v, max, min);\n  } else if (isCartesian(v)) {\n    return PointsClampMagnitude(v, max, min);\n  }\n  throw new Error(`Expected either polar or Cartesian vector`);\n};\n\n/**\n * Returns `a + b`.\n *\n * Vector is returned in the same type as `a`.\n * @param a\n * @param b\n * @returns\n */\nexport const sum = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointsSum(a, b);\n  return polar ? toPolar(c) : c;\n};\n\n/**\n * Returns `a - b`.\n *\n * Vector is returned in the same type as `a`\n * @param a\n * @param b\n */\nexport const subtract = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointsSubtract(a, b);\n  return polar ? toPolar(c) : c;\n};\n\n/**\n * Returns `a * b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport const multiply = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointsMultiply(a, b);\n  return polar ? toPolar(c) : c;\n};\n\n/**\n * Returns `a / b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport const divide = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointDivide(a, b);\n  return polar ? toPolar(c) : c;\n};\n","import type { Point, Point3d } from './point/PointType.js';\nimport type { Circle, CirclePositioned } from './circle/CircleType.js';\nimport type { Sphere } from './shape/index.js';\n\nimport { toPositioned as circleToPositioned } from './circle/ToPositioned.js';\nimport { scale } from '../numbers/Scale.js';\nimport { linearSpace } from '../numbers/LinearSpace.js';\nconst cos = Math.cos;\nconst sin = Math.sin;\nconst asin = Math.asin;\nconst sqrt = Math.sqrt;\nconst pow = Math.pow;\nconst pi = Math.PI;\nconst piPi = Math.PI * 2;\nconst goldenAngle = pi * (3 - sqrt(5));\nconst goldenSection = (1 + sqrt(5)) / 2;\n\n/**\n * Options for a Vogel spiral\n */\nexport type VogelSpiralOpts = {\n  /**\n   * Upper limit of points to produce.\n   * By default, 5000.\n   */\n  readonly maxPoints?: number;\n  /**\n   * Density value (0..1) which determines spacing of points.\n   * This is useful because it scales with whatever circle radius is given\n   * Use this parameter OR the `spacing` parameter.\n   */\n  readonly density?: number;\n  /**\n   * Spacing between points.\n   * Use this option OR the density value.\n   */\n  readonly spacing?: number;\n  /**\n   * Rotation offset to apply, in radians. 0 by default\n   */\n  readonly rotation?: number;\n};\n\n/**\n * Generates points on a Vogel spiral - a sunflower-like arrangement of points.\n *\n * @example With no arguments, assumes a unit circle\n * ```js\n * for (const pt of circleVogelSpiral()) {\n *  // Generate points on a unit circle, with 95% density\n * }\n * ```\n *\n *\n * @example Specifying a circle and options\n * ```js\n * const circle = { radius: 100, x: 100, y: 100 };\n * const opts = {\n *  maxPoints: 50,\n *  density: 0.99\n * };\n * for (const pt of circleVogelSpiral(circle, opts)) {\n *  // Do something with point...\n * }\n * ```\n *\n * @example Array format\n * ```js\n * const ptsArray = [...circleVogelSpiral(circle, opts)];\n * ```\n * @param circle\n * @param opts\n */\nexport function* circleVogelSpiral(\n  circle?: Circle,\n  opts: VogelSpiralOpts = {}\n): IterableIterator<Point> {\n  const maxPoints = opts.maxPoints ?? 5000;\n  const density = opts.density ?? 0.95;\n  const rotationOffset = opts.rotation ?? 0;\n\n  const c = circleToPositioned(circle ?? { radius: 1, x: 0, y: 0 });\n  const max = c.radius;\n  //eslint-disable-next-line functional/no-let\n  let spacing = c.radius * scale(density, 0, 1, 0.3, 0.01);\n  if (opts.spacing) spacing = opts.spacing;\n\n  //eslint-disable-next-line functional/no-let\n  let radius = 0;\n  //eslint-disable-next-line functional/no-let\n  let count = 0;\n  //eslint-disable-next-line functional/no-let\n  let angle = 0;\n  while (count < maxPoints && radius < max) {\n    radius = spacing * count ** 0.5;\n    angle = rotationOffset + (count * 2 * pi) / goldenSection;\n    yield Object.freeze({\n      x: c.x + radius * cos(angle),\n      y: c.y + radius * sin(angle),\n    });\n    count++;\n  }\n}\n\nexport type CircleRingsOpts = {\n  readonly rings?: number;\n  /**\n   * Rotation offset, in radians\n   */\n  readonly rotation?: number;\n};\n/**\n * Generates points spaced out on the given number of rings.\n *\n * Get points as array\n * ```js\n * const circle = { radius: 5, x: 100, y: 100 };\n * const opts = { rings: 5 };\n * const points = [...circleRings(circle, rings)];\n * ```\n *\n * Or iterate over them\n * ```js\n * for (const point of circleRings(circle, opts)) {\n * }\n * ```\n * Source: http://www.holoborodko.com/pavel/2015/07/23/generating-equidistant-points-on-unit-disk/#more-3453\n * @param circle\n */\nexport function* circleRings(\n  circle?: Circle | CirclePositioned,\n  opts: CircleRingsOpts = {}\n): IterableIterator<Point> {\n  const rings = opts.rings ?? 5;\n  const c = circleToPositioned(circle ?? { radius: 1, x: 0, y: 0 });\n  const ringR = 1 / rings;\n  const rotationOffset = opts.rotation ?? 0;\n\n  //eslint-disable-next-line functional/no-let\n  let ringCount = 1;\n\n  // Origin\n  yield Object.freeze({ x: c.x, y: c.y });\n\n  //eslint-disable-next-line functional/no-let\n  for (let r = ringR; r <= 1; r += ringR) {\n    const n = Math.round(pi / asin(1 / (2 * ringCount)));\n    for (const theta of linearSpace(0, piPi, n + 1)) {\n      yield Object.freeze({\n        x: c.x + r * cos(theta + rotationOffset) * c.radius,\n        y: c.y + r * sin(theta + rotationOffset) * c.radius,\n      });\n    }\n    ringCount++;\n  }\n}\n/**\n * Fibonacci sphere algorithm. Generates points\n * distributed on a sphere.\n *\n * @example Generate points of a unit sphere\n * ```js\n * for (const pt of sphereFibonacci(100)) {\n *  // pt.x, pt.y, pt.z\n * }\n * ```\n *\n * @example Generate points into an array\n * ```js\n * const sphere = { radius: 10, x: 10, y: 200 }\n * const pts = [...sphereFibonacci(100, 0, sphere)];\n * ```\n *\n * Source: https://codepen.io/elchininet/pen/vXeRyL\n *\n * @param samples\n * @returns\n */\nexport function* sphereFibonacci(\n  samples = 100,\n  rotationRadians = 0,\n  sphere?: Sphere\n): IterableIterator<Point3d> {\n  const offset = 2 / samples;\n  const s = sphere ?? { x: 0, y: 0, z: 0, radius: 1 };\n\n  for (let index = 0; index < samples; index++) {\n    const y = index * offset - 1 + offset / 2;\n    const r = sqrt(1 - pow(y, 2));\n    const a = ((index + 1) % samples) * goldenAngle + rotationRadians;\n    const x = cos(a) * r;\n    const z = sin(a) * r;\n    //eslint-disable-next-line functional/immutable-data\n    yield Object.freeze({\n      x: s.x + x * s.radius,\n      y: s.y + y * s.radius,\n      z: s.z + z * s.radius,\n    });\n  }\n}\n","import * as Polar from '../Polar.js';\nimport * as Points from '../point/index.js';\nimport { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport { radianToDegree } from '../Angles.js';\nimport { guard } from './Guard.js';\nimport { intersectsPoint as RectsIntersectsPoint } from '../rect/Intersects.js';\nimport type { RectPositioned } from '../Types.js';\nimport type { Point } from '../point/PointType.js';\nimport { getPointParameter } from '../point/GetPointParameter.js';\nimport type { Triangle } from './TriangleType.js';\n\nexport * from './Area.js';\nexport * from './Centroid.js';\nexport * from './Edges.js';\nexport * from './InnerCircle.js';\nexport * from './Guard.js';\nexport * from './OuterCircle.js';\nexport * from './Perimeter.js';\nexport * from './Rotate.js';\n/**\n * Functions for working with equilateral triangles, defined by length\n */\nexport * as Equilateral from './Equilateral.js';\n\n/**\n * Functions for working with right-angled triangles, defined by two of three edges\n */\nexport * as Right from './Right.js';\n\nexport * as Isosceles from './Isosceles.js';\n\n/**\n* Triangle.\n*\n* Helpers for creating:\n*  - {@link Triangles.fromFlatArray}: Create from [x1, y1, x2, y2, x3, y3]\n*  - {@link Triangles.fromPoints}: Create from three `{x,y}` sets\n*  - {@link Triangles.fromRadius}: Equilateral triangle of a given radius and center\n*/\n\n\nconst piPi = Math.PI * 2;\n\n/**\n * A triangle consisting of three empty points (Points.Empty)\n */\n//eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Empty = Object.freeze({\n  a: { x: 0, y: 0 },\n  b: { x: 0, y: 0 },\n  c: { x: 0, y: 0 },\n});\n\n/**\n * A triangle consisting of three placeholder points (Points.Placeholder)\n */\n//eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Placeholder = Object.freeze({\n  a: { x: Number.NaN, y: Number.NaN },\n  b: { x: Number.NaN, y: Number.NaN },\n  c: { x: Number.NaN, y: Number.NaN },\n});\n\n/**\n * Returns true if triangle is empty\n * @param t\n * @returns\n */\nexport const isEmpty = (t: Triangle): boolean =>\n  Points.isEmpty(t.a) && Points.isEmpty(t.b) && Points.isEmpty(t.c);\n\n/**\n * Returns true if triangle is a placeholder\n * @param t\n * @returns\n */\nexport const isPlaceholder = (t: Triangle): boolean =>\n  Points.isPlaceholder(t.a) &&\n  Points.isPlaceholder(t.b) &&\n  Points.isPlaceholder(t.c);\n\n/**\n * Applies `fn` to each of a triangle's corner points, returning the result.\n *\n * @example Add some random to the x of each corner\n * ```\n * const t = apply(tri, p => {\n *  const r = 10;\n *  return {\n *    x: p.x + (Math.random()*r*2) - r,\n *    y: p.y\n *  }\n * });\n * ```\n * @param t\n * @param fn\n * @returns\n */\nexport const apply = (\n  t: Triangle,\n  fn: (p: Point, label?: string) => Point\n) =>\n  Object.freeze<Triangle>({\n    ...t,\n    a: fn(t.a, `a`),\n    b: fn(t.b, `b`),\n    c: fn(t.c, `c`),\n  });\n\n\n\n/**\n * Returns true if the parameter appears to be a valid triangle\n * @param p\n * @returns\n */\nexport const isTriangle = (p: unknown): p is Triangle => {\n  if (p === undefined) return false;\n  const tri = p as Triangle;\n  if (!Points.isPoint(tri.a)) return false;\n  if (!Points.isPoint(tri.b)) return false;\n  if (!Points.isPoint(tri.c)) return false;\n  return true;\n};\n\n/**\n * Returns true if the two parameters have equal values\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (a: Triangle, b: Triangle): boolean =>\n  Points.isEqual(a.a, b.a) &&\n  Points.isEqual(a.b, b.b) &&\n  Points.isEqual(a.c, b.c);\n\n/**\n * Returns the corners (vertices) of the triangle as an array of points\n * @param t\n * @returns Array of length three\n */\nexport const corners = (t: Triangle): ReadonlyArray<Point> => {\n  guard(t);\n  return [ t.a, t.b, t.c ];\n};\n\n\n\n/**\n * Returns the lengths of the triangle sides\n * @param t\n * @returns Array of length three\n */\nexport const lengths = (t: Triangle): ReadonlyArray<number> => {\n  guard(t);\n  return [\n    Points.distance(t.a, t.b),\n    Points.distance(t.b, t.c),\n    Points.distance(t.c, t.a),\n  ];\n};\n\n/**\n * Return the three interior angles of the triangle, in radians.\n * @param t\n * @returns\n */\nexport const angles = (t: Triangle): ReadonlyArray<number> => {\n  guard(t);\n  return [\n    Points.angleRadian(t.a, t.b),\n    Points.angleRadian(t.b, t.c),\n    Points.angleRadian(t.c, t.a),\n  ];\n};\n\n/**\n * Returns the three interior angles of the triangle, in degrees\n * @param t\n * @returns\n */\nexport const anglesDegrees = (t: Triangle): ReadonlyArray<number> => {\n  guard(t);\n  return radianToDegree(angles(t));\n};\n\n/**\n * Returns true if it is an equilateral triangle\n * @param t\n * @returns\n */\nexport const isEquilateral = (t: Triangle): boolean => {\n  guard(t);\n  const [ a, b, c ] = lengths(t);\n  return a === b && b === c;\n};\n\n/**\n * Returns true if it is an isosceles triangle\n * @param t\n * @returns\n */\nexport const isIsosceles = (t: Triangle): boolean => {\n  const [ a, b, c ] = lengths(t);\n  if (a === b) return true;\n  if (b === c) return true;\n  if (c === a) return true;\n  return false;\n};\n\n/**\n * Returns true if at least one interior angle is 90 degrees\n * @param t\n * @returns\n */\nexport const isRightAngle = (t: Triangle): boolean =>\n  angles(t).includes(Math.PI / 2);\n\n/**\n * Returns true if triangle is oblique: No interior angle is 90 degrees\n * @param t\n * @returns\n */\nexport const isOblique = (t: Triangle): boolean => !isRightAngle(t);\n\n/**\n * Returns true if triangle is actue: all interior angles less than 90 degrees\n * @param t\n * @returns\n */\nexport const isAcute = (t: Triangle): boolean =>\n  !angles(t).some((v) => v >= Math.PI / 2);\n\n/**\n * Returns true if triangle is obtuse: at least one interior angle is greater than 90 degrees\n * @param t\n * @returns\n */\nexport const isObtuse = (t: Triangle): boolean =>\n  angles(t).some((v) => v > Math.PI / 2);\n\n\n/**\n * Returns an equilateral triangle centered at the origin.\n *\n * ```js\n * // Create a triangle at 100,100 with radius of 60\n * const tri = fromRadius({x:100,y:100}, 60);\n *\n * // Triangle with point A upwards, B to the right, C to the left\n * constr tri2 = fromRadius({x:100,y:100}, 60, {initialAngleRadian: -Math.PI / 2});\n * ```\n *\n *\n * @param origin Origin\n * @param radius Radius of triangle\n * @param opts Options\n */\nexport const fromRadius = (\n  origin: Point,\n  radius: number,\n  opts: { readonly initialAngleRadian?: number } = {}\n): Triangle => {\n  throwNumberTest(radius, `positive`, `radius`);\n  Points.guard(origin, `origin`);\n\n  const initialAngleRadian = opts.initialAngleRadian ?? 0;\n\n  const angles = [\n    initialAngleRadian,\n    initialAngleRadian + (piPi * 1) / 3,\n    initialAngleRadian + (piPi * 2) / 3,\n  ];\n  const points = angles.map((a) => Polar.toCartesian(radius, a, origin));\n  return fromPoints(points);\n};\n\n/**\n * Rotates the vertices of the triangle around one point (by default, `b`).\n * @param triangle Triangle\n * @param vertex Name of vertex: a, b or c.\n */\nexport const rotateByVertex = (\n  triangle: Triangle,\n  amountRadian: number,\n  vertex: `a` | `b` | `c` = `b`\n): Triangle => {\n  const origin =\n    vertex === `a` ? triangle.a : (vertex === `b` ? triangle.b : triangle.c);\n  return Object.freeze({\n    a: Points.rotate(triangle.a, amountRadian, origin),\n    b: Points.rotate(triangle.b, amountRadian, origin),\n    c: Points.rotate(triangle.c, amountRadian, origin),\n  });\n};\n\n/**\n * Returns a triangle anchored at `origin` with a given `length` and `angleRadian`.\n * The origin will be point `b` of the triangle, and the angle will be the angle for b.\n * @param origin Origin\n * @param length Length\n * @param angleRadian Angle\n * @returns\n */\nexport const equilateralFromVertex = (\n  origin?: Point,\n  length = 10,\n  angleRadian: number = Math.PI / 2\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const a = Points.project(origin, length, Math.PI - -angleRadian / 2);\n  const c = Points.project(origin, length, Math.PI - angleRadian / 2);\n  return { a, b: origin, c };\n};\n\n/**\n * Returns the coordinates of triangle in a flat array form:\n * [xA, yA, xB, yB, xC, yC]\n * @param t\n * @returns\n */\nexport const toFlatArray = (t: Triangle): ReadonlyArray<number> => {\n  guard(t);\n  return [ t.a.x, t.a.y, t.b.x, t.b.y, t.c.x, t.c.y ];\n};\n\n/**\n * Returns a triangle from a set of coordinates in a flat array form:\n * [xA, yA, xB, yB, xC, yC]\n * @param coords\n * @returns\n */\nexport const fromFlatArray = (coords: ReadonlyArray<number>): Triangle => {\n  if (!Array.isArray(coords)) throw new Error(`coords expected as array`);\n  if (coords.length !== 6) {\n    throw new Error(\n      `coords array expected with 6 elements. Got ${ coords.length }`\n    );\n  }\n  return fromPoints(Points.fromNumbers(...coords));\n};\n\n/**\n * Returns a triangle from an array of three points\n * @param points\n * @returns\n */\nexport const fromPoints = (points: ReadonlyArray<Point>): Triangle => {\n  if (!Array.isArray(points)) throw new Error(`points expected as array`);\n  if (points.length !== 3) {\n    throw new Error(\n      `points array expected with 3 elements. Got ${ points.length }`\n    );\n  }\n  const t: Triangle = {\n    a: points[ 0 ],\n    b: points[ 1 ],\n    c: points[ 2 ],\n  };\n  return t;\n};\n\n/**\n * Returns the bounding box that encloses the triangle.\n * @param t\n * @param inflation If specified, box will be inflated by this much. Default: 0.\n * @returns\n */\nexport const bbox = (t: Triangle, inflation = 0): RectPositioned => {\n  const { a, b, c } = t;\n  const xMin = Math.min(a.x, b.x, c.x) - inflation;\n  const xMax = Math.max(a.x, b.x, c.x) + inflation;\n  const yMin = Math.min(a.y, b.y, c.y) - inflation;\n  const yMax = Math.max(a.y, b.y, c.y) + inflation;\n\n  const r: RectPositioned = {\n    x: xMin,\n    y: yMin,\n    width: xMax - xMin,\n    height: yMax - yMin,\n  };\n  return r;\n};\n\nexport type BarycentricCoord = {\n  readonly a: number;\n  readonly b: number;\n  readonly c: number;\n};\n\n/**\n * Returns the [Barycentric coordinate](https://en.wikipedia.org/wiki/Barycentric_coordinate_system) of a point within a triangle\n *\n * @param t\n * @param a\n * @param b\n * @returns\n */\nexport const barycentricCoord = (\n  t: Triangle,\n  a: Point | number,\n  b?: number\n): BarycentricCoord => {\n  const pt = getPointParameter(a, b);\n\n  const ab = (x: number, y: number, pa: Point, pb: Point) =>\n    (pa.y - pb.y) * x + (pb.x - pa.x) * y + pa.x * pb.y - pb.x * pa.y;\n\n  const alpha = ab(pt.x, pt.y, t.b, t.c) / ab(t.a.x, t.a.y, t.b, t.c);\n  const theta = ab(pt.x, pt.y, t.c, t.a) / ab(t.b.x, t.b.y, t.c, t.a);\n  const gamma = ab(pt.x, pt.y, t.a, t.b) / ab(t.c.x, t.c.y, t.a, t.b);\n\n  return {\n    a: alpha,\n    b: theta,\n    c: gamma,\n  };\n};\n\n/**\n * Convert Barycentric coordinate to Cartesian\n * @param t\n * @param bc\n * @returns\n */\nexport const barycentricToCartestian = (\n  t: Triangle,\n  bc: BarycentricCoord\n): Point => {\n  guard(t);\n  const { a, b, c } = t;\n\n  const x = a.x * bc.a + b.x * bc.b + c.x * bc.c;\n  const y = a.y * bc.a + b.y * bc.b + c.y * bc.c;\n\n  if (a.z && b.z && c.z) {\n    const z = a.z * bc.a + b.z * bc.b + c.z * bc.c;\n    return Object.freeze({ x, y, z });\n  } else {\n    return Object.freeze({ x, y });\n  }\n};\n\n/**\n * Returns true if point is within or on the boundary of triangle\n * @param t\n * @param a\n * @param b\n */\nexport const intersectsPoint = (\n  t: Triangle,\n  a: Point | number,\n  b?: number\n): boolean => {\n  const box = bbox(t);\n\n  const pt = getPointParameter(a, b);\n\n  // If it's not in the bounding box, can return false straight away\n  if (!RectsIntersectsPoint(box, pt)) return false;\n\n  const bc = barycentricCoord(t, pt);\n\n  return (\n    0 <= bc.a && bc.a <= 1 && 0 <= bc.b && bc.b <= 1 && 0 <= bc.c && bc.c <= 1\n  );\n};\n","import type { Triangle } from \"./TriangleType.js\";\nimport { guard as PointsGuard } from '../point/Guard.js'\n\n/**\n * Throws an exception if the triangle is invalid\n * @param t\n * @param name\n */\nexport const guard = (t: Triangle, name = `t`) => {\n  if (t === undefined) throw new Error(`{$name} undefined`);\n  PointsGuard(t.a, name + `.a`);\n  PointsGuard(t.b, name + `.b`);\n  PointsGuard(t.c, name + `.c`);\n};","\nimport type { Triangle } from \"../Types.js\";\nimport type { PolyLine } from \"../line/LineType.js\";\nimport { joinPointsToLines } from \"../line/JoinPointsToLines.js\";\nimport { guard } from \"./Guard.js\";\n/**\n * Returns the edges (ie sides) of the triangle as an array of lines\n * @param t\n * @returns Array of length three\n */\nexport const edges = (t: Triangle): PolyLine => {\n  guard(t);\n  return joinPointsToLines(t.a, t.b, t.c, t.a);\n};","import { guard } from \"./Guard.js\";\nimport { length as LinesLength } from '../line/Length.js';\nimport { edges } from \"./Edges.js\";\nimport type { Triangle } from \"./TriangleType.js\";\n\n/**\n * Calculates the area of a triangle\n * @param t\n * @returns\n */\nexport const area = (t: Triangle): number => {\n  guard(t, `t`);\n\n  // Get length of edges\n  const lengths = edges(t).map((l) => LinesLength(l));\n\n  // Add up length of edges, halve\n  const p = (lengths[ 0 ] + lengths[ 1 ] + lengths[ 2 ]) / 2;\n  return Math.sqrt(p * (p - lengths[ 0 ]) * (p - lengths[ 1 ]) * (p - lengths[ 2 ]));\n};","import type { Point } from \"../point/PointType.js\";\nimport { guard } from \"./Guard.js\";\nimport type { Triangle } from \"./TriangleType.js\";\nimport { reduce as PointsReduce } from '../point/index.js';\n\n/**\n * Returns simple centroid of triangle\n * @param t\n * @returns\n */\nexport const centroid = (t: Triangle): Point => {\n  guard(t);\n  const total = PointsReduce(\n    [ t.a, t.b, t.c ],\n    (p: Point, accumulator: Point) => ({\n      x: p.x + accumulator.x,\n      y: p.y + accumulator.y,\n    })\n  );\n  const div = {\n    x: total.x / 3,\n    y: total.y / 3,\n  };\n  return div;\n};","import { guard } from \"./Guard.js\";\nimport type { Triangle } from \"./TriangleType.js\";\nimport { length as LinesLength } from '../line/Length.js';\nimport { edges } from \"./Edges.js\";\n\n/**\n * Calculates perimeter of a triangle\n * @param t\n * @returns\n */\nexport const perimeter = (t: Triangle): number => {\n  guard(t);\n  return edges(t).reduce((accumulator, v) => accumulator + LinesLength(v), 0);\n};","import type { CirclePositioned } from \"../circle/CircleType.js\";\nimport { area } from \"./Area.js\";\nimport { centroid } from \"./Centroid.js\";\nimport { perimeter } from \"./Perimeter.js\";\nimport type { Triangle } from \"./TriangleType.js\";\n\n/**\n * Returns the largest circle enclosed by triangle `t`.\n * @param t\n */\nexport const innerCircle = (t: Triangle): CirclePositioned => {\n  const c = centroid(t);\n  const p = perimeter(t) / 2;\n  const a = area(t);\n  const radius = a / p;\n  return { radius, ...c };\n};","import { length as LinesLength } from '../line/Length.js';\nimport { edges } from \"./Edges.js\";\nimport { centroid } from './Centroid.js';\nimport type { Triangle } from \"./TriangleType.js\";\nimport type { CirclePositioned } from '../circle/CircleType.js';\n\n/**\n * Returns the largest circle touching the corners of triangle `t`.\n * @param t\n * @returns\n */\nexport const outerCircle = (t: Triangle): CirclePositioned => {\n  const [ a, b, c ] = edges(t).map((l) => LinesLength(l));\n  const cent = centroid(t);\n  const radius =\n    (a * b * c) /\n    Math.sqrt((a + b + c) * (-a + b + c) * (a - b + c) * (a + b - c));\n  return {\n    radius,\n    ...cent,\n  };\n};","import type { Point } from \"../point/PointType.js\";\nimport { centroid } from \"./Centroid.js\";\nimport type { Triangle } from \"./TriangleType.js\";\nimport { rotate as PointsRotate } from \"../point/index.js\";\n/**\n * Returns a triangle that is rotated by `angleRad`. By default it rotates\n * around its center but an arbitrary `origin` point can be provided.\n *\n * ```js\n * // Rotate triangle by 5 degrees\n * rotate(triangle, degreeToRadian(5));\n *\n * // Rotate by 90 degrees\n * rotate(triangle, Math.PI / 2);\n * ```\n * @param triangle Triangle to rotate\n * @param amountRadian Angle in radians to rotate by\n * @param origin Point to rotate around. If undefined, middle of triangle will be used\n * @returns\n */\nexport const rotate = (\n  triangle: Triangle,\n  amountRadian?: number,\n  origin?: Point\n): Triangle => {\n  if (amountRadian === undefined || amountRadian === 0) return triangle;\n  if (origin === undefined) origin = centroid(triangle);\n  return Object.freeze({\n    ...triangle,\n    a: PointsRotate(triangle.a, amountRadian, origin),\n    b: PointsRotate(triangle.b, amountRadian, origin),\n    c: PointsRotate(triangle.c, amountRadian, origin),\n  });\n};\n","import type { Circle } from \"../circle/CircleType.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport type { Triangle } from \"./TriangleType.js\";\n\nconst pi4over3 = (Math.PI * 4) / 3;\nconst pi2over3 = (Math.PI * 2) / 3;\n\nexport type TriangleEquilateral =\n  | {\n    readonly length: number;\n  }\n  | number;\n\nconst resolveLength = (t: TriangleEquilateral): number => {\n  if (typeof t === `number`) return t;\n  return t.length;\n};\n\n/**\n * Returns a positioned `Triangle` from an equilateral triangle definition.\n * By default the rotation is such that point `a` and `c` are lying on the horizontal,\n * and `b` is the upward-facing tip.\n *\n * Default is a triangle pointing upwards with b at the top, c to the left and b to right on the baseline.\n *\n * Example rotation values in radians:\n * * ▶️ 0: a and c on vertical, b at the tip\n * * ◀️ Math.PI: `c`and `a` are on vertical, with `b` at the tip.\n * * 🔽 Math.PI/2: `c` and `a` are on horizontal, `c` to the left. `b` at the bottom.\n * * 🔼 Math.PI*1.5: `c` and `a` are on horizontal, `c` to the right. `b` at the top. (default)\n * @param t\n * @param origin\n * @param rotationRad\n * @returns\n */\nexport const fromCenter = (\n  t: TriangleEquilateral,\n  origin?: Point,\n  rotationRad?: number\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const r = resolveLength(t) / Math.sqrt(3);\n  const rot = rotationRad ?? Math.PI * 1.5;\n  const b = {\n    x: r * Math.cos(rot) + origin.x,\n    y: r * Math.sin(rot) + origin.y,\n  };\n  const a = {\n    x: r * Math.cos(rot + pi4over3) + origin.x,\n    y: r * Math.sin(rot + pi4over3) + origin.y,\n  };\n  const c = {\n    x: r * Math.cos(rot + pi2over3) + origin.x,\n    y: r * Math.sin(rot + pi2over3) + origin.y,\n  };\n\n  return Object.freeze({ a, b, c });\n};\n\n/**\n * Calculate center from the given point A\n * @param t\n * @param ptA\n * @returns\n */\nexport const centerFromA = (\n  t: TriangleEquilateral,\n  ptA?: Point\n): Point => {\n  if (!ptA) ptA = Object.freeze({ x: 0, y: 0 })\n\n  const r = resolveLength(t);\n  const { radius } = incircle(t);\n  return {\n    x: ptA.x + r / 2,\n    y: ptA.y - radius,\n  };\n};\n\n/**\n * Calculate center from the given point B\n * @param t\n * @param ptB\n * @returns\n */\nexport const centerFromB = (\n  t: TriangleEquilateral,\n  ptB?: Point\n): Point => {\n  if (!ptB) ptB = Object.freeze({ x: 0, y: 0 })\n\n  const { radius } = incircle(t);\n  return {\n    x: ptB.x,\n    y: ptB.y + radius * 2,\n  };\n};\n\n/**\n * Calculate center from the given point C\n * @param t\n * @param ptC\n * @returns\n */\nexport const centerFromC = (\n  t: TriangleEquilateral,\n  ptC?: Point\n): Point => {\n  if (!ptC) ptC = Object.freeze({ x: 0, y: 0 })\n\n  const r = resolveLength(t);\n  const { radius } = incircle(t);\n\n  return {\n    x: ptC.x - r / 2,\n    y: ptC.y - radius,\n  };\n};\n\n/**\n * Returns the height (or rise) of an equilateral triangle.\n * Ie. from one vertex to the perpendicular edge.\n * (line marked x in the diagram below)\n *\n * ```\n *      .\n *     .x .\n *    . x  .\n *   .  x   .\n *  ..........\n * ```\n * @param t\n */\nexport const height = (t: TriangleEquilateral): number =>\n  (Math.sqrt(3) / 2) * resolveLength(t);\n\nexport const perimeter = (t: TriangleEquilateral): number =>\n  resolveLength(t) * 3;\n\nexport const area = (t: TriangleEquilateral): number =>\n  (Math.pow(resolveLength(t), 2) * Math.sqrt(3)) / 4;\n\n/**\n * Circle that encompasses all points of triangle\n * @param t\n */\nexport const circumcircle = (t: TriangleEquilateral): Circle => ({\n  radius: (Math.sqrt(3) / 3) * resolveLength(t),\n});\n\n/**\n * Circle that is inside the edges of the triangle\n * @param t\n * @returns\n */\nexport const incircle = (t: TriangleEquilateral): Circle => ({\n  radius: (Math.sqrt(3) / 6) * resolveLength(t),\n});\n","import type { Circle } from \"../circle/CircleType.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport type { Triangle } from \"./TriangleType.js\";\nexport type Right = {\n  readonly adjacent?: number;\n  readonly hypotenuse?: number;\n  readonly opposite?: number;\n};\n\nexport type DefinedRight = {\n  readonly adjacent: number;\n  readonly hypotenuse: number;\n  readonly opposite: number;\n};\n\n/**\n * Returns a positioned triangle from a point for A.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport const fromA = (\n  t: Right,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n  const tt = resolveLengths(t);\n  const seg = hypotenuseSegments(t);\n  const h = height(t);\n  const a = { x: origin.x, y: origin.y };\n  const b = { x: origin.x + tt.hypotenuse, y: origin.y };\n  const c = { x: origin.x + seg[ 1 ], y: origin.y - h };\n  return { a, b, c };\n};\n\n/**\n * Returns a positioned triangle from a point for B.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport const fromB = (\n  t: Right,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const tt = resolveLengths(t);\n  const seg = hypotenuseSegments(t);\n  const h = height(t);\n  const b = { x: origin.x, y: origin.y };\n  const a = { x: origin.x - tt.hypotenuse, y: origin.y };\n  const c = { x: origin.x - seg[ 0 ], y: origin.y - h };\n  return { a, b, c };\n};\n\n/**\n * Returns a positioned triangle from a point for C.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n *\n *\n * ```js\n * // Triangle pointing up to 0,0 with sides of 15\n * Triangles.Right.fromC({ adjacent: 15, opposite:15 }, { x: 0, y: 0 });\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport const fromC = (\n  t: Right,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const seg = hypotenuseSegments(t);\n  const h = height(t);\n  const c = { x: origin.x, y: origin.y };\n  const a = { x: origin.x - seg[ 1 ], y: origin.y + h };\n  const b = { x: origin.x + seg[ 0 ], y: origin.y + h };\n  return { a, b, c };\n};\n\n/**\n * Returns a right triangle with all lengths defined.\n * At least two lengths must already exist\n * @param t\n * @returns\n */\nexport const resolveLengths = (t: Right): DefinedRight => {\n  const a = t.adjacent;\n  const o = t.opposite;\n  const h = t.hypotenuse;\n\n  if (a !== undefined && o !== undefined) {\n    return {\n      ...t,\n      adjacent: a,\n      opposite: o,\n      hypotenuse: Math.hypot(a, o),\n    };\n  } else if (a && h) {\n    return {\n      ...t,\n      adjacent: a,\n      hypotenuse: h,\n      opposite: h * h - a * a,\n    };\n  } else if (o && h) {\n    return {\n      ...t,\n      hypotenuse: h,\n      opposite: o,\n      adjacent: h * h - o * o,\n    };\n  } else if (t.opposite && t.hypotenuse && t.adjacent) {\n    return t as DefinedRight;\n  }\n  throw new Error(`Missing at least two edges`);\n};\n\n/**\n * Height of right-triangle\n * @param t\n * @returns\n */\nexport const height = (t: Right): number => {\n  const tt = resolveLengths(t);\n  const p = (tt.opposite * tt.opposite) / tt.hypotenuse;\n  const q = (tt.adjacent * tt.adjacent) / tt.hypotenuse;\n  return Math.sqrt(p * q);\n};\n\n/**\n * Returns the lengths of the hypotenuse split into p and q segments.\n * In other words, if one makes a line from the right-angle vertex down to hypotenuse.\n *\n * [See here](https://rechneronline.de/pi/right-triangle.php)\n * @param t\n * @returns\n */\nexport const hypotenuseSegments = (\n  t: Right\n): readonly [ p: number, q: number ] => {\n  const tt = resolveLengths(t);\n  const p = (tt.opposite * tt.opposite) / tt.hypotenuse;\n  const q = (tt.adjacent * tt.adjacent) / tt.hypotenuse;\n  return [ p, q ];\n};\n\nexport const perimeter = (t: Right): number => {\n  const tt = resolveLengths(t);\n  return tt.adjacent + tt.hypotenuse + tt.opposite;\n};\n\nexport const area = (t: Right): number => {\n  const tt = resolveLengths(t);\n  return (tt.opposite * tt.adjacent) / 2;\n};\n\n/**\n * Angle (in radians) between hypotenuse and adjacent edge\n * @param t\n * @returns\n */\nexport const angleAtPointA = (t: Right): number => {\n  const tt = resolveLengths(t);\n  return Math.acos(\n    (tt.adjacent * tt.adjacent +\n      tt.hypotenuse * tt.hypotenuse -\n      tt.opposite * tt.opposite) /\n    (2 * tt.adjacent * tt.hypotenuse)\n  );\n};\n\n/**\n * Angle (in radians) between opposite edge and hypotenuse\n * @param t\n * @returns\n */\nexport const angleAtPointB = (t: Right): number => {\n  const tt = resolveLengths(t);\n  return Math.acos(\n    (tt.opposite * tt.opposite +\n      tt.hypotenuse * tt.hypotenuse -\n      tt.adjacent * tt.adjacent) /\n    (2 * tt.opposite * tt.hypotenuse)\n  );\n};\n\n/**\n * Returns the median line lengths a, b and c in an array.\n *\n * The median lines are the lines from each vertex to the center.\n *\n * @param t\n * @returns\n */\nexport const medians = (\n  t: Right\n): readonly [ a: number, b: number, c: number ] => {\n  const tt = resolveLengths(t);\n  const b = tt.adjacent * tt.adjacent;\n  const c = tt.hypotenuse * tt.hypotenuse;\n  const a = tt.opposite * tt.opposite;\n\n  return [\n    Math.sqrt(2 * (b + c) - a) / 2,\n    Math.sqrt(2 * (c + a) - b) / 2,\n    Math.sqrt(2 * (a + b) - c) / 2,\n  ];\n};\n\n/**\n * The circle which passes through the points of the triangle\n * @param t\n * @returns\n */\nexport const circumcircle = (t: Right): Circle => {\n  const tt = resolveLengths(t);\n  return { radius: tt.hypotenuse / 2 };\n};\n\n/**\n * Circle enclosed by triangle\n * @param t\n * @returns\n */\nexport const incircle = (t: Right): Circle => {\n  const tt = resolveLengths(t);\n  return {\n    radius: (tt.adjacent + tt.opposite - tt.hypotenuse) / 2,\n  };\n};\n\n/**\n * Returns the opposite length of a right-angle triangle,\n * marked here\n *\n * ```\n *    .  <\n *   ..  <\n * ....  <\n * ```\n *\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param adjacent\n * @returns\n */\nexport const oppositeFromAdjacent = (\n  angleRad: number,\n  adjacent: number\n): number => Math.tan(angleRad) * adjacent;\n\n/**\n * Returns the opposite length of a right-angle triangle,\n * marked here\n *\n * ```\n *    .  <\n *   ..  <\n * ....  <\n * ```\n *\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param hypotenuse\n * @returns\n */\nexport const oppositeFromHypotenuse = (\n  angleRad: number,\n  hypotenuse: number\n): number => Math.sin(angleRad) * hypotenuse;\n\n/**\n * Returns the adjecent length of a right-angle triangle,\n * marked here\n * ```\n *    .\n *   ..  o\n * ....\n * ^^^^\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param hypotenuse\n * @returns\n */\nexport const adjacentFromHypotenuse = (\n  angleRadian: number,\n  hypotenuse: number\n): number => Math.cos(angleRadian) * hypotenuse;\n\n/**\n * Returns the adjecent length of a right-angle triangle,\n * marked here\n * ```\n *    .\n *   ..  o\n * ....\n * ^^^^\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param opposite\n * @returns\n */\nexport const adjacentFromOpposite = (\n  angleRadian: number,\n  opposite: number\n): number => opposite / Math.tan(angleRadian);\n\n/**\n * Returns the hypotenuse length of a right-angle triangle,\n * marked here\n * ```\n *      .\n * >   ..\n * >  ...\n * > ....  opp\n *  .....\n *   adj\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param opposite\n * @returns\n */\nexport const hypotenuseFromOpposite = (\n  angleRadian: number,\n  opposite: number\n): number => opposite / Math.sin(angleRadian);\n\n/**\n * Returns the hypotenuse length of a right-angle triangle,\n * marked here\n * ```\n *      .\n * >   ..\n * >  ...\n * > ....  opp\n *  .....\n *   adj\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param adjacent\n * @returns\n */\nexport const hypotenuseFromAdjacent = (\n  angleRadian: number,\n  adjacent: number\n): number => adjacent / Math.cos(angleRadian);\n","\nimport type { Circle } from \"../circle/CircleType.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport type { Triangle } from \"./TriangleType.js\";\nexport type Isosceles = {\n  readonly legs: number;\n  readonly base: number;\n};\n\nexport const baseAngle = (t: Isosceles): number =>\n  Math.acos(t.base / (2 * t.legs));\n\nexport const apexAngle = (t: Isosceles): number => {\n  const aa = t.legs * t.legs;\n  const cc = t.base * t.base;\n  return Math.acos((2 * aa - cc) / (2 * aa));\n};\n\nexport const height = (t: Isosceles): number => {\n  const aa = t.legs * t.legs;\n  const cc = t.base * t.base;\n  return Math.sqrt((4 * aa - cc) / 4);\n};\n\nexport const legHeights = (t: Isosceles): number => {\n  const b = baseAngle(t);\n  return t.base * Math.sin(b);\n};\n\nexport const perimeter = (t: Isosceles): number => 2 * t.legs + t.base;\n\nexport const area = (t: Isosceles): number => {\n  const h = height(t);\n  return (h * t.base) / 2;\n};\n\nexport const circumcircle = (t: Isosceles): Circle => {\n  const h = height(t);\n  const hh = h * h;\n  const cc = t.base * t.base;\n  return { radius: (4 * hh + cc) / (8 * h) };\n};\n\nexport const incircle = (t: Isosceles): Circle => {\n  const h = height(t);\n  return { radius: (t.base * h) / (2 * t.legs + t.base) };\n};\n\nexport const medians = (\n  t: Isosceles\n): readonly [ a: number, b: number, c: number ] => {\n  const aa = t.legs * t.legs;\n  const cc = t.base * t.base;\n  const medianAB = Math.sqrt(aa + 2 * cc) / 2;\n  const medianC = Math.sqrt(4 * aa - cc) / 2;\n  return [ medianAB, medianAB, medianC ];\n};\n\n/**\n * Returns a positioned `Triangle` based on a center origin.\n * Center is determined by the intesecting of the medians.\n *\n * See: https://rechneronline.de/pi/isosceles-triangle.php\n * @param t\n * @param origin\n * @returns\n */\nexport const fromCenter = (\n  t: Isosceles,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n  const h = height(t);\n  const incircleR = incircle(t).radius;\n  const verticalToApex = h - incircleR;\n\n  const a = { x: origin.x - t.base / 2, y: origin.y + incircleR };\n  const b = { x: origin.x + t.base / 2, y: origin.y + incircleR };\n  const c = { x: origin.x, y: origin.y - verticalToApex };\n  return { a, b, c };\n};\n\nexport const fromA = (\n  t: Isosceles,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const h = height(t);\n  const a = { x: origin.x, y: origin.y };\n  const b = { x: origin.x + t.base, y: origin.y };\n  const c = { x: origin.x + t.base / 2, y: origin.y - h };\n  return { a, b, c };\n};\n\nexport const fromB = (\n  t: Isosceles,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const h = height(t);\n  const b = { x: origin.x, y: origin.y };\n  const a = { x: origin.x - t.base, y: origin.y };\n  const c = { x: origin.x - t.base / 2, y: origin.y - h };\n  return { a, b, c };\n};\n\nexport const fromC = (\n  t: Isosceles,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n  const h = height(t);\n  const c = { x: origin.x, y: origin.y };\n  const a = { x: origin.x - t.base / 2, y: origin.y + h };\n  const b = { x: origin.x + t.base / 2, y: origin.y + h };\n  return { a, b, c };\n};\n","import { guardArray } from \"./GuardArray.js\";\n\n/**\n * Combines values in pairwise fashion.\n * Throws an error if there are less than two entries.\n * \n * ```js\n * pairwise([1, 2, 3, 4, 5]);\n * Yields:\n * [[1,2],[2,3],[3,4],[4,5] ]\n * \n * pairwise([ 1, 2, 3, 4 ]);\n * Yields:\n * [1,2],[2,3],[3,4]\n * ```\n * @param values \n */\nexport function* pairwise<T>(values: Array<T>) {\n  guardArray(values, `values`);\n\n  if (values.length < 2) throw new Error(`Array needs to have at least two entries. Length: ${ values.length }`);\n\n  for (let index = 1; index < values.length; index++) {\n    yield [ values[ index - 1 ], values[ index ] ];\n  }\n}\n\n/**\n * Reduces in a pairwise fashion.\n *\n * Eg, if we have input array of [1, 2, 3, 4, 5], the\n * `reducer` fn will run with 1,2 as parameters, then 2,3, then 3,4 etc.\n * ```js\n * const values = [1, 2, 3, 4, 5]\n * reducePairwise(values, (acc, a, b) => {\n *  return acc + (b - a);\n * }, 0);\n * ```\n *\n * If input array has less than two elements, the initial value is returned.\n *\n * ```js\n * const reducer = (acc:string, a:string, b:string) => acc + `[${a}-${b}]`;\n * const result = reducePairwise(`a b c d e f g`.split(` `), reducer, `!`);\n * Yields: `![a-b][b-c][c-d][d-e][e-f][f-g]`\n * ```\n * @param array\n * @param reducer\n * @param initial\n * @returns\n */\nexport const pairwiseReduce = <V, X>(\n  array: ReadonlyArray<V>,\n  reducer: (accumulator: X, a: V, b: V) => X,\n  initial: X\n) => {\n  guardArray(array, `arr`);\n  if (array.length < 2) return initial;\n  //eslint-disable-next-line functional/no-let\n  for (let index = 0; index < array.length - 1; index++) {\n    initial = reducer(initial, array[ index ], array[ index + 1 ]);\n  }\n  return initial;\n};\n","import Color, { type Range } from 'colorjs.io';\n\nimport { defaultRandom, type RandomSource } from '../random/Types.js';\nimport { throwNumberTest } from '../util/GuardNumbers.js';\nimport { pairwise } from '../data/arrays/Pairwise.js';\nimport { scale as scaleNumber } from '../numbers/Scale.js';\nimport { clamp } from '../numbers/Clamp.js';\n\nexport type Hsl = { h: number; s: number; l: number; opacity: number, space?: `hsl` };\nexport type Rgb = { r: number; g: number; b: number; opacity: number, space?: `srgb` };\nexport type Spaces = `hsl` | `hsluv` | `rgb` | `srgb` | `lch` | `oklch` | `oklab` | `okhsl` | `p3` | `lab` | `hcl` | `cubehelix`;\n\nexport type OkLch = { l: number, c: number, h: number, opacity: number, space: `oklch` }\n\n/**\n * A representation of colour. Eg: `blue`, `rgb(255,0,0)`, `hsl(20,100%,50%)`\n */\nexport type Colourish = Color | Hsl | OkLch | Rgb | string;\n\n// export type ColourRgb = {\n//   space:`rgb`\n//   coords: Rgba\n// }\n// export type ColourHsl = {\n//   space:`hsl`;\n//   coords: Hsla;\n// }\n\n// export type Colour = ColourHsl|ColourRgb;\n\n/**\n * Options for interpolation\n */\nexport type InterpolationOpts = {\n  space: Spaces,\n  hue: `longer` | `shorter` | `increasing` | `decreasing` | `raw`\n};\n\n// export const toHsl = (colour: Colourish): Hsla => {\n//   const hsl = toHsl(colour);\n//   if (`opacity` in hsl) return hsl as Hsla;\n//   else return {\n//     ...hsl,\n//     opacity: 1\n//   }\n// }\n\n/**\n * Parses colour to `{ h, s, l }`, each field being on 0..1 scale.\n * \n * Note that some colours will return NaN for h,s or l. This is because they have\n * indeterminate hue. For example white, black and transparent. Use 'safe = true'\n * to ensure a safe colour is returned.\n * @param colour\n * @param safe When true, returned colour will not include NaN. Default: false\n * @returns\n */\nexport const toHsl = (colour: Colourish, safe = false): Hsl => {\n  if (typeof colour === `string` && colour === `transparent`) return { h: 0, s: 0, l: 0, opacity: 0, space: `hsl` };\n  const c = resolve(colour);\n  const hsl = c.hsl;\n  //console.log(hsl);\n  let hue = hsl[ 0 ];\n  if (Number.isNaN(hue) && safe) hue = 0;\n\n  let sat = hsl[ 1 ];\n  if (Number.isNaN(sat) && safe) sat = 0;\n  const parsedHsl = {\n    h: hue / 360,\n    s: sat / 100,\n    l: hsl[ 2 ] / 100,\n    opacity: 1,\n    space: `hsl`\n  } as const\n  if (c.alpha !== 1) {\n    if (`type` in (c.alpha as any)) {\n      //const alphaType = (c.alpha as any).type;\n      const alphaRaw = Number.parseFloat((c.alpha as any).raw);\n      return { ...parsedHsl, opacity: alphaRaw }\n    }\n    return { ...parsedHsl, opacity: c.alpha / 100 };\n  }\n  return parsedHsl;\n\n  // if (isHsl(colour)) return colour;\n  // const c = resolveColour(colour);\n  // // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  // if (c === null) throw new Error(`Could not resolve colour ${ colour }`);\n\n  // if (isHsl(c)) {\n  //   if (Number.isNaN(c.h) && Number.isNaN(c.s)) {\n  //     return { h: Number.NaN, s: Number.NaN, l: c.l, opacity: c.opacity }\n  //   }\n  //   return c;\n  // }\n  // if (isRgb(c)) {\n  //   const asHsl = d3Colour.hsl(c);\n  //   if (c.opacity) return { ...asHsl, opacity: c.opacity };\n  //   return asHsl;\n  // }\n  // // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  // throw new Error(`Could not resolve colour ${ colour }`);\n};\n\nconst hslToColorJs = (hsl: Hsl, safe: boolean): Color => {\n  let h = hsl.h === null ? (safe ? 0 : null) : hsl.h;\n  let opacity = hsl.opacity === undefined ? 1 : hsl.opacity;\n  throwNumberTest(h, `percentage`, `hsl.h`);\n  throwNumberTest(hsl.s, `percentage`, `hsl.s`);\n  throwNumberTest(hsl.l, `percentage`, `hsl.l`);\n  throwNumberTest(opacity, `percentage`, `hsl.opacity`);\n\n  const coords: [ number, number, number ] = [\n    h! * 360,\n    hsl.s * 100,\n    hsl.l * 100\n  ];\n  return new Color(`hsl`, coords, opacity);\n}\n\nconst oklchToColorJs = (oklch: OkLch) => {\n  throwNumberTest(oklch.l, `percentage`, `oklch.l`);\n  throwNumberTest(oklch.c, `percentage`, `oklch.c`);\n  throwNumberTest(oklch.h, `percentage`, `oklch.h`);\n  throwNumberTest(oklch.opacity, `percentage`, `oklch.opacity`);\n  const coords: [ number, number, number ] = [\n    oklch.l,\n    oklch.c * 0.4,\n    oklch.h * 360\n  ]\n  return new Color(`oklch`, coords, oklch.opacity);\n}\n\nconst rgbToColorJs = (rgb: Rgb): Color => {\n  const coords: [ number, number, number ] = [\n    rgb.r,\n    rgb.g,\n    rgb.b\n  ];\n  return `opacity` in rgb ?\n    new Color(`srgb`, coords, rgb.opacity) :\n    new Color(`srgb`, coords);\n}\n\n/**\n * Returns a colour in the best-possible CSS colour form.\n * The return value can be used setting colours in the canvas or DOM manipulations.\n * @param colour \n */\nexport const toString = (colour: Colourish): string => {\n  const c = resolve(colour);\n  return c.display();\n}\n\n\n/**\n * Returns a full HSL colour string (eg `hsl(20,50%,75%)`) based on a index.\n * It's useful for generating perceptually different shades as the index increments.\n *\n * ```\n * el.style.backgroundColor = goldenAgeColour(10);\n * ```\n *\n * Saturation and lightness can be specified, as numeric ranges of 0-1.\n *\n * @param saturation Saturation (0-1), defaults to 0.5\n * @param lightness Lightness (0-1), defaults to 0.75\n * @param alpha Opacity (0-1), defaults to 1.0\n * @returns HSL colour string eg `hsl(20,50%,75%)`\n */\nexport const goldenAngleColour = (\n  index: number,\n  saturation = 0.5,\n  lightness = 0.75,\n  alpha = 1\n) => {\n  throwNumberTest(index, `positive`, `index`);\n  throwNumberTest(saturation, `percentage`, `saturation`);\n  throwNumberTest(lightness, `percentage`, `lightness`);\n  throwNumberTest(alpha, `percentage`, `alpha`);\n\n  // Via Stackoverflow\n  const hue = index * 137.508; // use golden angle approximation\n  return alpha === 1 ? `hsl(${ hue },${ saturation * 100 }%,${ lightness * 100 }%)` : `hsl(${ hue },${ saturation * 100 }%,${ lightness * 100 }%,${ alpha * 100 }%)`;\n};\n\n/**\n * Returns a random hue component (0..359)\n * ```\n * // Generate hue\n * const h =randomHue(); // 0-359\n *\n * // Generate hue and assign as part of a HSL string\n * el.style.backgroundColor = `hsl(${randomHue(), 50%, 75%})`;\n * ```\n * @param rand\n * @returns\n */\nexport const randomHue = (rand: RandomSource = defaultRandom): number => {\n  const r = rand();\n  return r * 360;\n};\n\n/**\n * Returns a Colorjs 'Color' object based on relative hue, saturation, lightness\n * and opacity.\n * @param h Hue (0..1)\n * @param s Saturation (0..1) Default: 1\n * @param l Lightness (0..1) Default: 0.5\n * @param opacity Opacity (0..1) Default: 1\n * @returns \n */\nexport const fromHsl = (h: number, s = 1, l = 0.5, opacity = 1): Color => {\n  throwNumberTest(h, `percentage`, `h`);\n  throwNumberTest(s, `percentage`, `s`);\n  throwNumberTest(l, `percentage`, `l`);\n\n  return resolve({ h, s, l, opacity, space: `hsl` });\n}\n\n/**\n * Parses colour to `{ r, g, b }` where each field is on 0..1 scale.\n * `opacity` field is added if opacity is not 1.\n * [Named colours](https://html-color-codes.info/color-names/)\n * @param colour\n * @returns\n */\nexport const toRgb = (colour: Colourish): Rgb => {\n  const c = resolve(colour);\n  const rgb = c.srgb;\n  return c.alpha < 1 ?\n    { r: rgb.r, g: rgb.g, b: rgb.b, opacity: c.alpha, space: `srgb` } :\n    { r: rgb.r, g: rgb.g, b: rgb.b, opacity: 1, space: `srgb` };\n};\n\n/**\n * Parses a string representation of colour, or a Rgb/Hsl object.\n * If the string starts with '--' it's assumed to be a CSS variable\n * \n * See also {@link resolveToString} to resolve to a CSS colour string.\n * @param colour Colour to resolve\n * @returns Color.js Color object\n */\nexport const resolve = (colour: Colourish, safe: boolean = false): Color => {\n  if (typeof colour === `string`) {\n    if (colour.startsWith(`--`)) {\n      // Resolve CSS variable\n      colour = getComputedStyle(document.body).getPropertyValue(colour);\n    }\n    return new Color(colour);\n  } else {\n    if (isHsl(colour)) return new Color(hslToColorJs(colour, safe));\n    if (isRgb(colour)) return new Color(rgbToColorJs(colour));\n    if (isOklch(colour)) return new Color(oklchToColorJs(colour));\n  }\n\n  return colour;\n};\n\n/**\n * Like {@link resolve}, but returns a CSS-ready string\n * representation.\n * ```js\n * element.style.backgroundColor = resolveToString(`red`);\n * ```\n * \n * Tries each parameter in turn, returning the value\n * for the first that resolves. This can be useful for\n * having fallback values.\n * \n * ```js\n * // Try a CSS variable, a object property or finally fallback to red.\n * element.style.backgroundColor = resolveToString('--some-var', opts.background, `red`);\n * ```\n * @param colours Array of colours to resolve\n * @returns \n */\nexport const resolveToString = (...colours: Array<Colourish | undefined>): string => {\n  for (const colour of colours) {\n    if (colour === undefined) continue;\n    if (colour === null) continue;\n    const c = resolve(colour);\n    try {\n      return c.display();\n    } catch (ex) {\n      if (typeof colour === `string`) return colour\n      throw ex;\n    }\n  }\n  return `rebeccapurple`;\n}\n\n/**\n * Returns a colour in hex format `#000000`. \n * ```js\n * canvas.fillStyle = Colour.toHex(`blue`);\n * canvas.fillStyle = Colour.toHex({ h:0.5, s:0.1, l:1 });\n * canvas.fillStyle = Colour.toHex({ r: 1, g: 0.3, b: 0 });\n * ```\n * \n * Input colour can be a human-friendly colour name (\"blue\"), a HSL\n * colour (eg. \"hsl(0, 50%, 50%)\")\", an object {h,s,l} or {r,g,b}.\n * '#' is included in the return string.\n * \n * Transparent colour is returned as #00000000\n * @param colour\n * @returns Hex format, including #\n */\nexport const toHex = (colour: Colourish, safe = false): string => {\n  if (typeof colour === `string` && colour === `transparent`) return `#00000000`;\n  return resolve(colour, safe).to(`srgb`).toString({ format: `hex`, collapse: false });\n};\n\n/**\n * Returns a variation of colour with its opacity multiplied by `amt`.\n *\n * ```js\n * // Return a colour string for blue that is 50% opaque\n * opacity(`blue`, 0.5);\n * // eg: `rgba(0,0,255,0.5)`\n *\n * // Returns a colour string that is 50% more opaque\n * opacity(`hsla(200,100%,50%,50%`, 0.5);\n * // eg: `hsla(200,100%,50%,25%)`\n * ```\n *\n * [Named colours](https://html-color-codes.info/color-names/)\n * @param colour A valid CSS colour\n * @param amt Amount to multiply opacity by\n * @returns String representation of colour\n */\nexport const opacity = (colour: Colourish, amt: number): string => {\n  const c = resolve(colour);\n  c.alpha *= amt;\n  return c.toString();\n};\n\n/**\n * Gets a CSS variable.\n * ```\n * // Fetch --accent variable, or use `yellow` if not found.\n * getCssVariable(`accent`, `yellow`);\n * ```\n * @param name Name of variable. Leading '--' is unnecessary\n * @param fallbackColour Fallback colour if not found\n * @param root  Element to search variable from\n * @returns Colour or fallback.\n */\nexport const getCssVariable = (\n  name: string,\n  fallbackColour = `black`,\n  root?: HTMLElement\n): string => {\n  if (root === undefined) root = document.body;\n  if (name.startsWith(`--`)) name = name.substring(2);\n  const fromCss = getComputedStyle(root).getPropertyValue(`--${ name }`).trim();\n  if (fromCss === undefined || fromCss.length === 0) return fallbackColour;\n  return fromCss;\n};\n\n\n// export const interpolate = (\n//   amount: number,\n//   from: Colourish,\n//   to: Colourish,\n//   optsOrSpace?: string | InterpolationOpts\n// ): string => {\n//   throwNumberTest(amount, `percentage`, `amount`);\n//   if (typeof from !== `string`)\n//     throw new Error(`Expected string for 'from' param`);\n//   if (typeof to !== `string`) throw new Error(`Expected string for 'to' param`);\n\n//   let opts: InterpolationOpts;\n//   if (typeof optsOrSpace === `undefined`) opts = {};\n//   else if (typeof optsOrSpace === `string`)\n//     opts = { space: optsOrSpace as Spaces };\n//   else opts = optsOrSpace;\n\n//   const inter = getInterpolator(opts, [ from, to ]);\n//   if (inter === undefined) throw new Error(`Could not handle colour/space`);\n//   return inter(amount);\n// };\n\n\n/**\n * Returns a function to interpolate between colours\n * ```js\n * import { Colour } from 'https://unpkg.com/ixfx/dist/visual.js'\n * const i = interpolator([`orange`, `yellow`, `red`]);\n * \n * // Get a random colour on the above spectrum\n * i(Math.random());\n * ```\n * \n * Results will vary depending on the colour space used, play with the options.\n * When using a hue-based colour space, the `hue` option sets the logic for how hue values wrap.\n * \n * ```js\n * interpolator([`orange`, `yellow`, `red`], { space: `hsl`, hue: `longer })\n * ```\n * @param colours Colours to interpolate between\n * @param opts Options for interpolation\n * @returns \n */\nexport const interpolator = (colours: Array<Colourish>, opts: Partial<InterpolationOpts> = {}) => {\n  const space = opts.space ?? `lch`;\n  const hue = opts.hue ?? `shorter`;\n  const pieces = interpolatorInit(colours);\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call\n  const ranges = pieces.map(piece => (piece[ 0 ] as any).range(piece[ 1 ], { space, hue })) as Array<Range>;\n\n  return (amt: number) => {\n    amt = clamp(amt);\n\n    // Scale to 0..1 to 0...ranges.length\n    const s = scaleNumber(amt, 0, 1, 0, ranges.length);\n    const index = Math.floor(s);\n    const amtAdjusted = s - index;\n    return ranges[ index ](amtAdjusted);\n  }\n}\n\nconst interpolatorInit = (colours: Array<Colourish>) => {\n  if (!Array.isArray(colours)) throw new Error(`Param 'colours' is not an array as expected. Got: ${ typeof colours }`);\n  if (colours.length < 2) throw new Error(`Param 'colours' should be at least two in length. Got: ${ colours.length }`);\n  const c = colours.map(colour => resolve(colour));\n  return [ ...pairwise(c) ];\n}\n\n/**\n * Produces a stepped scale of colours.\n * \n * Return result is an array of Color.js 'Colour' objects.\n * ```js\n * import { Colour } from 'ixfx/visual'\n * const steps = Colour.scale(['red','green'], 10);\n * for (const step of steps) {\n *  // Get a 'hsla(...)' string representation of colour\n *  // This can be used with the canvas, setting DOM properties etc.\n *  const css = Colour.toString(step);\n * }\n * ```\n * \n * {@link cssLinearGradient} can produce a smooth gradient in CSS on the basis\n * of the stepped colours.\n * @param colours \n * @param numberOfSteps \n * @param opts \n * @returns \n */\nexport const scale = (colours: Array<Colourish>, numberOfSteps: number, opts: Partial<InterpolationOpts> = {}) => {\n  const space = opts.space ?? `lch`;\n  const hue = opts.hue ?? `shorter`;\n  const pieces = interpolatorInit(colours);\n  const stepsPerPair = Math.floor(numberOfSteps / pieces.length);\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call\n  const steps = pieces.map(piece => (piece[ 0 ] as any).steps(piece[ 1 ],\n    { space, hue, steps: stepsPerPair, outputSpace: `srgb` }\n  )) as Array<Color>;\n\n  return steps.flat();\n}\n\n/**\n * Returns a CSS `linear-gradient` with stops corresponding to the given list of `colours`.\n * ```js\n * element.style.background = Colour.cssLinearGradient(['red','green','blue']);\n * ```\n * \n *\n * @param colours \n * @returns \n */\nexport const cssLinearGradient = (colours: Array<Colourish>) => {\n  const c = colours.map(c => resolve(c));\n  return `linear-gradient(to right, ${ c.map(v => v.display()).join(`, `) })`;\n}\n\nconst isHsl = (p: Colourish): p is Hsl => {\n  if (p === undefined || p === null) return false;\n  if (typeof p !== `object`) return false;\n\n  // Check if Colourjs\n  if ((p as Color).spaceId !== undefined) return false;\n  if ((p as Color).coords !== undefined) return false;\n\n  const space = p.space;\n  if (space !== `hsl` && space !== undefined) return false;\n  const pp = p as Hsl;\n  if (pp.h === undefined) return false;\n  if (pp.s === undefined) return false;\n  if (pp.l === undefined) return false;\n  return true;\n};\n\nconst isOklch = (p: Colourish): p is OkLch => {\n  if (p === undefined || p === null) return false;\n  if (typeof p !== `object`) return false;\n\n  // Check if Colourjs\n  if ((p as Color).spaceId !== undefined) return false;\n  if ((p as Color).coords !== undefined) return false;\n  if (p.space !== `oklch`) return false;\n  if (p.l === undefined) return false;\n  if (p.c === undefined) return false;\n  if (p.h === undefined) return false;\n  return true;\n}\n\nconst isRgb = (p: Colourish): p is Rgb => {\n  if (p === undefined || p === null) return false;\n  if (typeof p !== `object`) return false;\n  if (p.space !== `srgb` && p.space !== undefined) return false;\n  if ((p as Rgb).r === undefined) return false;\n  if ((p as Rgb).g === undefined) return false;\n  if ((p as Rgb).b === undefined) return false;\n  return true;\n};\n","// A is m x n. B is n x p. product is m x p.\nexport default function multiplyMatrices (A, B) {\n\tlet m = A.length;\n\n\tif (!Array.isArray(A[0])) {\n\t\t// A is vector, convert to [[a, b, c, ...]]\n\t\tA = [A];\n\t}\n\n\tif (!Array.isArray(B[0])) {\n\t\t// B is vector, convert to [[a], [b], [c], ...]]\n\t\tB = B.map(x => [x]);\n\t}\n\n\tlet p = B[0].length;\n\tlet B_cols = B[0].map((_, i) => B.map(x => x[i])); // transpose B\n\tlet product = A.map(row => B_cols.map(col => {\n\t\tlet ret = 0;\n\n\t\tif (!Array.isArray(row)) {\n\t\t\tfor (let c of col) {\n\t\t\t\tret += row * c;\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (let i = 0; i < row.length; i++) {\n\t\t\tret += row[i] * (col[i] || 0);\n\t\t}\n\n\t\treturn ret;\n\t}));\n\n\tif (m === 1) {\n\t\tproduct = product[0]; // Avoid [[a, b, c, ...]]\n\t}\n\n\tif (p === 1) {\n\t\treturn product.map(x => x[0]); // Avoid [[a], [b], [c], ...]]\n\t}\n\n\treturn product;\n}\n","/**\n * Various utility functions\n */\n\nexport {default as multiplyMatrices} from \"./multiply-matrices.js\";\n\n/**\n * Check if a value is a string (including a String object)\n * @param {*} str - Value to check\n * @returns {boolean}\n */\nexport function isString (str) {\n\treturn type(str) === \"string\";\n}\n\n/**\n * Determine the internal JavaScript [[Class]] of an object.\n * @param {*} o - Value to check\n * @returns {string}\n */\nexport function type (o) {\n\tlet str = Object.prototype.toString.call(o);\n\n\treturn (str.match(/^\\[object\\s+(.*?)\\]$/)[1] || \"\").toLowerCase();\n}\n\nexport function serializeNumber (n, {precision, unit }) {\n\tif (isNone(n)) {\n\t\treturn \"none\";\n\t}\n\n\treturn toPrecision(n, precision) + (unit ?? \"\");\n}\n\n/**\n * Check if a value corresponds to a none argument\n * @param {*} n - Value to check\n * @returns {boolean}\n */\nexport function isNone (n) {\n\treturn Number.isNaN(n) || (n instanceof Number && n?.none);\n}\n\n/**\n * Replace none values with 0\n */\nexport function skipNone (n) {\n\treturn isNone(n) ? 0 : n;\n}\n\n/**\n * Round a number to a certain number of significant digits\n * @param {number} n - The number to round\n * @param {number} precision - Number of significant digits\n */\nexport function toPrecision (n, precision) {\n\tif (n === 0) {\n\t\treturn 0;\n\t}\n\tlet integer = ~~n;\n\tlet digits = 0;\n\tif (integer && precision) {\n\t\tdigits = ~~Math.log10(Math.abs(integer)) + 1;\n\t}\n\tconst multiplier = 10.0 ** (precision - digits);\n\treturn Math.floor(n * multiplier + 0.5) / multiplier;\n}\n\nconst angleFactor = {\n\tdeg: 1,\n\tgrad: 0.9,\n\trad: 180 / Math.PI,\n\tturn: 360,\n};\n\n/**\n* Parse a CSS function, regardless of its name and arguments\n* @param String str String to parse\n* @return {{name, args, rawArgs}}\n*/\nexport function parseFunction (str) {\n\tif (!str) {\n\t\treturn;\n\t}\n\n\tstr = str.trim();\n\n\tconst isFunctionRegex = /^([a-z]+)\\((.+?)\\)$/i;\n\tconst isNumberRegex = /^-?[\\d.]+$/;\n\tconst unitValueRegex = /%|deg|g?rad|turn$/;\n\tconst singleArgument = /\\/?\\s*(none|[-\\w.]+(?:%|deg|g?rad|turn)?)/g;\n\tlet parts = str.match(isFunctionRegex);\n\n\tif (parts) {\n\t\t// It is a function, parse args\n\t\tlet args = [];\n\t\tparts[2].replace(singleArgument, ($0, rawArg) => {\n\t\t\tlet match = rawArg.match(unitValueRegex);\n\t\t\tlet arg = rawArg;\n\n\t\t\tif (match) {\n\t\t\t\tlet unit = match[0];\n\t\t\t\t// Drop unit from value\n\t\t\t\tlet unitlessArg = arg.slice(0, -unit.length);\n\n\t\t\t\tif (unit === \"%\") {\n\t\t\t\t\t// Convert percentages to 0-1 numbers\n\t\t\t\t\targ = new Number(unitlessArg / 100);\n\t\t\t\t\targ.type = \"<percentage>\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Multiply angle by appropriate factor for its unit\n\t\t\t\t\targ = new Number(unitlessArg * angleFactor[unit]);\n\t\t\t\t\targ.type = \"<angle>\";\n\t\t\t\t\targ.unit = unit;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (isNumberRegex.test(arg)) {\n\t\t\t\t// Convert numerical args to numbers\n\t\t\t\targ = new Number(arg);\n\t\t\t\targ.type = \"<number>\";\n\t\t\t}\n\t\t\telse if (arg === \"none\") {\n\t\t\t\targ = new Number(NaN);\n\t\t\t\targ.none = true;\n\t\t\t}\n\n\t\t\tif ($0.startsWith(\"/\")) {\n\t\t\t\t// It's alpha\n\t\t\t\targ = arg instanceof Number ? arg : new Number(arg);\n\t\t\t\targ.alpha = true;\n\t\t\t}\n\n\t\t\tif (typeof arg === \"object\" && arg instanceof Number) {\n\t\t\t\targ.raw = rawArg;\n\t\t\t}\n\n\t\t\targs.push(arg);\n\t\t});\n\n\t\treturn {\n\t\t\tname: parts[1].toLowerCase(),\n\t\t\trawName: parts[1],\n\t\t\trawArgs: parts[2],\n\t\t\t// An argument could be (as of css-color-4):\n\t\t\t// a number, percentage, degrees (hue), ident (in color())\n\t\t\targs,\n\t\t};\n\t}\n}\n\nexport function last (arr) {\n\treturn arr[arr.length - 1];\n}\n\nexport function interpolate (start, end, p) {\n\tif (isNaN(start)) {\n\t\treturn end;\n\t}\n\n\tif (isNaN(end)) {\n\t\treturn start;\n\t}\n\n\treturn start + (end - start) * p;\n}\n\nexport function interpolateInv (start, end, value) {\n\treturn (value - start) / (end - start);\n}\n\nexport function mapRange (from, to, value) {\n\treturn interpolate(to[0], to[1], interpolateInv(from[0], from[1], value));\n}\n\nexport function parseCoordGrammar (coordGrammars) {\n\treturn coordGrammars.map(coordGrammar => {\n\t\treturn coordGrammar.split(\"|\").map(type => {\n\t\t\ttype = type.trim();\n\t\t\tlet range = type.match(/^(<[a-z]+>)\\[(-?[.\\d]+),\\s*(-?[.\\d]+)\\]?$/);\n\n\t\t\tif (range) {\n\t\t\t\tlet ret = new String(range[1]);\n\t\t\t\tret.range = [+range[2], +range[3]];\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn type;\n\t\t});\n\t});\n}\n\n/**\n * Clamp value between the minimum and maximum\n * @param {number} min minimum value to return\n * @param {number} val the value to return if it is between min and max\n * @param {number} max maximum value to return\n * @returns number\n */\nexport function clamp (min, val, max) {\n\treturn Math.max(Math.min(max, val), min);\n}\n\n/**\n * Copy sign of one value to another.\n * @param {number} - to number to copy sign to\n * @param {number} - from number to copy sign from\n * @returns number\n */\nexport function copySign (to, from) {\n\treturn Math.sign(to) === Math.sign(from) ? to : -to;\n}\n\n/**\n * Perform pow on a signed number and copy sign to result\n * @param {number} - base the base number\n * @param {number} - exp the exponent\n * @returns number\n */\nexport function spow (base, exp) {\n\treturn copySign(Math.abs(base) ** exp, base);\n}\n\n/**\n * Perform a divide, but return zero if the numerator is zero\n * @param {number} n - the numerator\n * @param {number} d - the denominator\n * @returns number\n */\nexport function zdiv (n, d) {\n\treturn (d === 0) ? 0 : n / d;\n}\n\n/**\n * Perform a bisect on a sorted list and locate the insertion point for\n * a value in arr to maintain sorted order.\n * @param {number[]} arr - array of sorted numbers\n * @param {number} value - value to find insertion point for\n * @param {number} lo - used to specify a the low end of a subset of the list\n * @param {number} hi - used to specify a the high end of a subset of the list\n * @returns number\n */\nexport function bisectLeft (arr, value, lo = 0, hi = arr.length) {\n\twhile (lo < hi) {\n\t\tconst mid = (lo + hi) >> 1;\n\t\tif (arr[mid] < value) {\n\t\t\tlo = mid + 1;\n\t\t}\n\t\telse {\n\t\t\thi = mid;\n\t\t}\n\t}\n\treturn lo;\n}\n","/**\n * A class for adding deep extensibility to any piece of JS code\n */\nexport class Hooks {\n\tadd (name, callback, first) {\n\t\tif (typeof arguments[0] != \"string\") {\n\t\t\t// Multiple hooks\n\t\t\tfor (var name in arguments[0]) {\n\t\t\t\tthis.add(name, arguments[0][name], arguments[1]);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t(Array.isArray(name) ? name : [name]).forEach(function (name) {\n\t\t\tthis[name] = this[name] || [];\n\n\t\t\tif (callback) {\n\t\t\t\tthis[name][first ? \"unshift\" : \"push\"](callback);\n\t\t\t}\n\t\t}, this);\n\t}\n\n\trun (name, env) {\n\t\tthis[name] = this[name] || [];\n\t\tthis[name].forEach(function (callback) {\n\t\t\tcallback.call(env && env.context ? env.context : env, env);\n\t\t});\n\t}\n}\n\n/**\n * The instance of {@link Hooks} used throughout Color.js\n */\nconst hooks = new Hooks();\n\nexport default hooks;\n","// Global defaults one may want to configure\nexport default {\n\tgamut_mapping: \"css\",\n\tprecision: 5,\n\tdeltaE: \"76\", // Default deltaE method\n\tverbose: globalThis?.process?.env?.NODE_ENV?.toLowerCase() !== \"test\",\n\twarn: function warn (msg) {\n\t\tif (this.verbose) {\n\t\t\tglobalThis?.console?.warn?.(msg);\n\t\t}\n\t},\n};\n","import hooks from \"./hooks.js\";\nimport {multiplyMatrices} from \"./util.js\";\n\nexport const WHITES = {\n\t// for compatibility, the four-digit chromaticity-derived ones everyone else uses\n\tD50: [0.3457 / 0.3585, 1.00000, (1.0 - 0.3457 - 0.3585) / 0.3585],\n\tD65: [0.3127 / 0.3290, 1.00000, (1.0 - 0.3127 - 0.3290) / 0.3290],\n};\n\nexport function getWhite (name) {\n\tif (Array.isArray(name)) {\n\t\treturn name;\n\t}\n\n\treturn WHITES[name];\n}\n\n// Adapt XYZ from white point W1 to W2\nexport default function adapt (W1, W2, XYZ, options = {}) {\n\tW1 = getWhite(W1);\n\tW2 = getWhite(W2);\n\n\tif (!W1 || !W2) {\n\t\tthrow new TypeError(`Missing white point to convert ${!W1 ? \"from\" : \"\"}${!W1 && !W2 ? \"/\" : \"\"}${!W2 ? \"to\" : \"\"}`);\n\t}\n\n\tif (W1 === W2) {\n\t\t// Same whitepoints, no conversion needed\n\t\treturn XYZ;\n\t}\n\n\tlet env = {W1, W2, XYZ, options};\n\n\thooks.run(\"chromatic-adaptation-start\", env);\n\n\tif (!env.M) {\n\t\tif (env.W1 === WHITES.D65 && env.W2 === WHITES.D50) {\n\t\t\tenv.M = [\n\t\t\t\t[ 1.0479297925449969, 0.022946870601609652, -0.05019226628920524 ],\n\t\t\t\t[ 0.02962780877005599, 0.9904344267538799, -0.017073799063418826 ],\n\t\t\t\t[ -0.009243040646204504, 0.015055191490298152, 0.7518742814281371 ],\n\t\t\t];\n\t\t}\n\t\telse if (env.W1 === WHITES.D50 && env.W2 === WHITES.D65) {\n\n\t\t\tenv.M = [\n\t\t\t\t[ 0.955473421488075, -0.02309845494876471, 0.06325924320057072 ],\n\t\t\t\t[ -0.0283697093338637, 1.0099953980813041, 0.021041441191917323 ],\n\t\t\t\t[ 0.012314014864481998, -0.020507649298898964, 1.330365926242124 ],\n\t\t\t];\n\t\t}\n\t}\n\n\thooks.run(\"chromatic-adaptation-end\", env);\n\n\tif (env.M) {\n\t\treturn multiplyMatrices(env.M, env.XYZ);\n\t}\n\telse {\n\t\tthrow new TypeError(\"Only Bradford CAT with white points D50 and D65 supported for now.\");\n\t}\n}\n","import * as util from \"./util.js\";\nimport hooks from \"./hooks.js\";\nimport ColorSpace from \"./space.js\";\nimport defaults from \"./defaults.js\";\n\nconst noneTypes = new Set([\"<number>\", \"<percentage>\", \"<angle>\"]);\n\n/**\n * Validates the coordinates of a color against a format's coord grammar and\n * maps the coordinates to the range or refRange of the coordinates.\n * @param {ColorSpace} space - Colorspace the coords are in\n * @param {object} format - the format object to validate against\n * @param {string} name - the name of the color function. e.g. \"oklab\" or \"color\"\n * @returns {object[]} - an array of type metadata for each coordinate\n */\nfunction coerceCoords (space, format, name, coords) {\n\tlet types = Object.entries(space.coords).map(([id, coordMeta], i) => {\n\t\tlet coordGrammar = format.coordGrammar[i];\n\t\tlet arg = coords[i];\n\t\tlet providedType = arg?.type;\n\n\t\t// Find grammar alternative that matches the provided type\n\t\t// Non-strict equals is intentional because we are comparing w/ string objects\n\t\tlet type;\n\t\tif (arg.none) {\n\t\t\ttype = coordGrammar.find(c => noneTypes.has(c));\n\t\t}\n\t\telse {\n\t\t\ttype = coordGrammar.find(c => c == providedType);\n\t\t}\n\n\t\t// Check that each coord conforms to its grammar\n\t\tif (!type) {\n\t\t\t// Type does not exist in the grammar, throw\n\t\t\tlet coordName = coordMeta.name || id;\n\t\t\tthrow new TypeError(`${providedType ?? arg.raw} not allowed for ${coordName} in ${name}()`);\n\t\t}\n\n\t\tlet fromRange = type.range;\n\n\t\tif (providedType === \"<percentage>\") {\n\t\t\tfromRange ||= [0, 1];\n\t\t}\n\n\t\tlet toRange = coordMeta.range || coordMeta.refRange;\n\n\t\tif (fromRange && toRange) {\n\t\t\tcoords[i] = util.mapRange(fromRange, toRange, coords[i]);\n\t\t}\n\n\t\treturn type;\n\t});\n\n\treturn types;\n}\n\n\n/**\n * Convert a CSS Color string to a color object\n * @param {string} str\n * @param {object} [options]\n * @param {object} [options.meta] - Object for additional information about the parsing\n * @returns {Color}\n */\nexport default function parse (str, {meta} = {}) {\n\tlet env = {\"str\": String(str)?.trim()};\n\thooks.run(\"parse-start\", env);\n\n\tif (env.color) {\n\t\treturn env.color;\n\t}\n\n\tenv.parsed = util.parseFunction(env.str);\n\n\tif (env.parsed) {\n\t\t// Is a functional syntax\n\t\tlet name = env.parsed.name;\n\n\t\tif (name === \"color\") {\n\t\t\t// color() function\n\t\t\tlet id = env.parsed.args.shift();\n\t\t\t// Check against both <dashed-ident> and <ident> versions\n\t\t\tlet alternateId = id.startsWith(\"--\") ? id.substring(2) : `--${id}`;\n\t\t\tlet ids = [id, alternateId];\n\t\t\tlet alpha = env.parsed.rawArgs.indexOf(\"/\") > 0 ? env.parsed.args.pop() : 1;\n\n\t\t\tfor (let space of ColorSpace.all) {\n\t\t\t\tlet colorSpec = space.getFormat(\"color\");\n\n\t\t\t\tif (colorSpec) {\n\t\t\t\t\tif (ids.includes(colorSpec.id) || colorSpec.ids?.filter((specId) => ids.includes(specId)).length) {\n\t\t\t\t\t\t// From https://drafts.csswg.org/css-color-4/#color-function\n\t\t\t\t\t\t// If more <number>s or <percentage>s are provided than parameters that the colorspace takes, the excess <number>s at the end are ignored.\n\t\t\t\t\t\t// If less <number>s or <percentage>s are provided than parameters that the colorspace takes, the missing parameters default to 0. (This is particularly convenient for multichannel printers where the additional inks are spot colors or varnishes that most colors on the page won’t use.)\n\t\t\t\t\t\tconst coords = Object.keys(space.coords).map((_, i) => env.parsed.args[i] || 0);\n\n\t\t\t\t\t\tlet types;\n\n\t\t\t\t\t\tif (colorSpec.coordGrammar) {\n\t\t\t\t\t\t\ttypes = coerceCoords(space, colorSpec, \"color\", coords);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (meta) {\n\t\t\t\t\t\t\tObject.assign(meta, {formatId: \"color\", types});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (colorSpec.id.startsWith(\"--\") && !id.startsWith(\"--\")) {\n\t\t\t\t\t\t\tdefaults.warn(`${space.name} is a non-standard space and not currently supported in the CSS spec. ` +\n\t\t\t\t\t\t\t              `Use prefixed color(${colorSpec.id}) instead of color(${id}).`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (id.startsWith(\"--\") && !colorSpec.id.startsWith(\"--\")) {\n\t\t\t\t\t\t\tdefaults.warn(`${space.name} is a standard space and supported in the CSS spec. ` +\n\t\t\t\t\t\t\t              `Use color(${colorSpec.id}) instead of prefixed color(${id}).`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn {spaceId: space.id, coords, alpha};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Not found\n\t\t\tlet didYouMean = \"\";\n\t\t\tlet registryId = id in ColorSpace.registry ? id : alternateId;\n\t\t\tif (registryId in ColorSpace.registry) {\n\t\t\t\t// Used color space id instead of color() id, these are often different\n\t\t\t\tlet cssId = ColorSpace.registry[registryId].formats?.color?.id;\n\n\t\t\t\tif (cssId) {\n\t\t\t\t\tdidYouMean = `Did you mean color(${cssId})?`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new TypeError(`Cannot parse color(${id}). ` + (didYouMean || \"Missing a plugin?\"));\n\t\t}\n\t\telse {\n\t\t\tfor (let space of ColorSpace.all) {\n\t\t\t\t// color space specific function\n\t\t\t\tlet format = space.getFormat(name);\n\t\t\t\tif (format && format.type === \"function\") {\n\t\t\t\t\tlet alpha = 1;\n\n\t\t\t\t\tif (format.lastAlpha || util.last(env.parsed.args).alpha) {\n\t\t\t\t\t\talpha = env.parsed.args.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\tlet coords = env.parsed.args;\n\n\t\t\t\t\tlet types;\n\n\t\t\t\t\tif (format.coordGrammar) {\n\t\t\t\t\t\ttypes = coerceCoords(space, format, name, coords);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (meta) {\n\t\t\t\t\t\tObject.assign(meta, {formatId: format.name, types});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tspaceId: space.id,\n\t\t\t\t\t\tcoords, alpha,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t// Custom, colorspace-specific format\n\t\tfor (let space of ColorSpace.all) {\n\t\t\tfor (let formatId in space.formats) {\n\t\t\t\tlet format = space.formats[formatId];\n\n\t\t\t\tif (format.type !== \"custom\") {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (format.test && !format.test(env.str)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet color = format.parse(env.str);\n\n\t\t\t\tif (color) {\n\t\t\t\t\tcolor.alpha ??= 1;\n\n\t\t\t\t\tif (meta) {\n\t\t\t\t\t\tmeta.formatId = formatId;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn color;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// If we're here, we couldn't parse\n\tthrow new TypeError(`Could not parse ${str} as a color. Missing a plugin?`);\n}\n","import ColorSpace from \"./space.js\";\nimport {isString} from \"./util.js\";\nimport parse from \"./parse.js\";\n\n/**\n * Resolves a color reference (object or string) to a plain color object\n * @param {Color | {space, coords, alpha} | string | Array<Color | {space, coords, alpha} | string> } color\n * @returns {{space, coords, alpha} | Array<{space, coords, alpha}}>\n */\nexport default function getColor (color) {\n\tif (Array.isArray(color)) {\n\t\treturn color.map(getColor);\n\t}\n\n\tif (!color) {\n\t\tthrow new TypeError(\"Empty color reference\");\n\t}\n\n\tif (isString(color)) {\n\t\tcolor = parse(color);\n\t}\n\n\t// Object fixup\n\tlet space = color.space || color.spaceId;\n\n\tif (!(space instanceof ColorSpace)) {\n\t\t// Convert string id to color space object\n\t\tcolor.space = ColorSpace.get(space);\n\t}\n\n\tif (color.alpha === undefined) {\n\t\tcolor.alpha = 1;\n\t}\n\n\treturn color;\n}\n","import {type, parseCoordGrammar, serializeNumber, mapRange} from \"./util.js\";\nimport {getWhite} from \"./adapt.js\";\nimport hooks from \"./hooks.js\";\nimport getColor from \"./getColor.js\";\n\nconst ε = .000075;\n\n/**\n * Class to represent a color space\n */\nexport default class ColorSpace {\n\tconstructor (options) {\n\t\tthis.id = options.id;\n\t\tthis.name = options.name;\n\t\tthis.base = options.base ? ColorSpace.get(options.base) : null;\n\t\tthis.aliases = options.aliases;\n\n\t\tif (this.base) {\n\t\t\tthis.fromBase = options.fromBase;\n\t\t\tthis.toBase = options.toBase;\n\t\t}\n\n\t\t// Coordinate metadata\n\n\t\tlet coords = options.coords ?? this.base.coords;\n\n\t\tfor (let name in coords) {\n\t\t\tif (!(\"name\" in coords[name])) {\n\t\t\t\tcoords[name].name = name;\n\t\t\t}\n\t\t}\n\t\tthis.coords = coords;\n\n\t\t// White point\n\n\t\tlet white = options.white ?? this.base.white ?? \"D65\";\n\t\tthis.white = getWhite(white);\n\n\t\t// Sort out formats\n\n\t\tthis.formats = options.formats ?? {};\n\n\t\tfor (let name in this.formats) {\n\t\t\tlet format = this.formats[name];\n\t\t\tformat.type ||= \"function\";\n\t\t\tformat.name ||= name;\n\t\t}\n\n\t\tif (!this.formats.color?.id) {\n\t\t\tthis.formats.color = {\n\t\t\t\t...this.formats.color ?? {},\n\t\t\t\tid: options.cssId || this.id,\n\t\t\t};\n\t\t}\n\n\t\t// Gamut space\n\n\t\tif (options.gamutSpace) {\n\t\t\t// Gamut space explicitly specified\n\t\t\tthis.gamutSpace = options.gamutSpace === \"self\" ? this : ColorSpace.get(options.gamutSpace);\n\t\t}\n\t\telse {\n\t\t\t// No gamut space specified, calculate a sensible default\n\t\t\tif (this.isPolar) {\n\t\t\t\t// Do not check gamut through polar coordinates\n\t\t\t\tthis.gamutSpace = this.base;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.gamutSpace =  this;\n\t\t\t}\n\t\t}\n\n\t\t// Optimize inGamut for unbounded spaces\n\t\tif (this.gamutSpace.isUnbounded) {\n\t\t\tthis.inGamut = (coords, options) => {\n\t\t\t\treturn true;\n\t\t\t};\n\t\t}\n\n\t\t// Other stuff\n\t\tthis.referred = options.referred;\n\n\t\t// Compute ancestors and store them, since they will never change\n\t\tObject.defineProperty(this, \"path\", {\n\t\t\tvalue: getPath(this).reverse(),\n\t\t\twritable: false,\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t});\n\n\t\thooks.run(\"colorspace-init-end\", this);\n\t}\n\n\tinGamut (coords, {epsilon = ε} = {}) {\n\t\tif (!this.equals(this.gamutSpace)) {\n\t\t\tcoords = this.to(this.gamutSpace, coords);\n\t\t\treturn this.gamutSpace.inGamut(coords, {epsilon});\n\t\t}\n\n\t\tlet coordMeta = Object.values(this.coords);\n\n\t\treturn coords.every((c, i) => {\n\t\t\tlet meta = coordMeta[i];\n\n\t\t\tif (meta.type !== \"angle\" && meta.range) {\n\t\t\t\tif (Number.isNaN(c)) {\n\t\t\t\t\t// NaN is always in gamut\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tlet [min, max] = meta.range;\n\t\t\t\treturn (min === undefined || c >= min - epsilon)\n\t\t\t\t    && (max === undefined || c <= max + epsilon);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t});\n\t}\n\n\tget isUnbounded () {\n\t\treturn Object.values(this.coords).every(coord => !(\"range\" in coord));\n\t}\n\n\tget cssId () {\n\t\treturn this.formats?.color?.id || this.id;\n\t}\n\n\tget isPolar () {\n\t\tfor (let id in this.coords) {\n\t\t\tif (this.coords[id].type === \"angle\") {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tgetFormat (format) {\n\t\tif (typeof format === \"object\") {\n\t\t\tformat = processFormat(format, this);\n\t\t\treturn format;\n\t\t}\n\n\t\tlet ret;\n\t\tif (format === \"default\") {\n\t\t\t// Get first format\n\t\t\tret = Object.values(this.formats)[0];\n\t\t}\n\t\telse {\n\t\t\tret = this.formats[format];\n\t\t}\n\n\t\tif (ret) {\n\t\t\tret = processFormat(ret, this);\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Check if this color space is the same as another color space reference.\n\t * Allows proxying color space objects and comparing color spaces with ids.\n\t * @param {string | ColorSpace} space ColorSpace object or id to compare to\n\t * @returns {boolean}\n\t */\n\tequals (space) {\n\t\tif (!space) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this === space || this.id === space || this.id === space.id;\n\t}\n\n\tto (space, coords) {\n\t\tif (arguments.length === 1) {\n\t\t\tconst color = getColor(space);\n\t\t\t[space, coords] = [color.space, color.coords];\n\t\t}\n\n\t\tspace = ColorSpace.get(space);\n\n\t\tif (this.equals(space)) {\n\t\t\t// Same space, no change needed\n\t\t\treturn coords;\n\t\t}\n\n\t\t// Convert NaN to 0, which seems to be valid in every coordinate of every color space\n\t\tcoords = coords.map(c => Number.isNaN(c) ? 0 : c);\n\n\t\t// Find connection space = lowest common ancestor in the base tree\n\t\tlet myPath = this.path;\n\t\tlet otherPath = space.path;\n\n\t\tlet connectionSpace, connectionSpaceIndex;\n\n\t\tfor (let i = 0; i < myPath.length; i++) {\n\t\t\tif (myPath[i].equals(otherPath[i])) {\n\t\t\t\tconnectionSpace = myPath[i];\n\t\t\t\tconnectionSpaceIndex = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!connectionSpace) {\n\t\t\t// This should never happen\n\t\t\tthrow new Error(`Cannot convert between color spaces ${this} and ${space}: no connection space was found`);\n\t\t}\n\n\t\t// Go up from current space to connection space\n\t\tfor (let i = myPath.length - 1; i > connectionSpaceIndex; i--) {\n\t\t\tcoords = myPath[i].toBase(coords);\n\t\t}\n\n\t\t// Go down from connection space to target space\n\t\tfor (let i = connectionSpaceIndex + 1; i < otherPath.length; i++) {\n\t\t\tcoords = otherPath[i].fromBase(coords);\n\t\t}\n\n\t\treturn coords;\n\t}\n\n\tfrom (space, coords) {\n\t\tif (arguments.length === 1) {\n\t\t\tconst color = getColor(space);\n\t\t\t[space, coords] = [color.space, color.coords];\n\t\t}\n\n\t\tspace = ColorSpace.get(space);\n\n\t\treturn space.to(this, coords);\n\t}\n\n\ttoString () {\n\t\treturn `${this.name} (${this.id})`;\n\t}\n\n\tgetMinCoords () {\n\t\tlet ret = [];\n\n\t\tfor (let id in this.coords) {\n\t\t\tlet meta = this.coords[id];\n\t\t\tlet range = meta.range || meta.refRange;\n\t\t\tret.push(range?.min ?? 0);\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tstatic registry = {};\n\n\t// Returns array of unique color spaces\n\tstatic get all () {\n\t\treturn [...new Set(Object.values(ColorSpace.registry))];\n\t}\n\n\tstatic register (id, space) {\n\t\tif (arguments.length === 1) {\n\t\t\tspace = arguments[0];\n\t\t\tid = space.id;\n\t\t}\n\n\t\tspace = this.get(space);\n\n\t\tif (this.registry[id] && this.registry[id] !== space) {\n\t\t\tthrow new Error(`Duplicate color space registration: '${id}'`);\n\t\t}\n\t\tthis.registry[id] = space;\n\n\t\t// Register aliases when called without an explicit ID.\n\t\tif (arguments.length === 1 && space.aliases) {\n\t\t\tfor (let alias of space.aliases) {\n\t\t\t\tthis.register(alias, space);\n\t\t\t}\n\t\t}\n\n\t\treturn space;\n\t}\n\n\t/**\n\t * Lookup ColorSpace object by name\n\t * @param {ColorSpace | string} name\n\t */\n\tstatic get (space, ...alternatives) {\n\t\tif (!space || space instanceof ColorSpace) {\n\t\t\treturn space;\n\t\t}\n\n\t\tlet argType = type(space);\n\n\t\tif (argType === \"string\") {\n\t\t\t// It's a color space id\n\t\t\tlet ret = ColorSpace.registry[space.toLowerCase()];\n\n\t\t\tif (!ret) {\n\t\t\t\tthrow new TypeError(`No color space found with id = \"${space}\"`);\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (alternatives.length) {\n\t\t\treturn ColorSpace.get(...alternatives);\n\t\t}\n\n\t\tthrow new TypeError(`${space} is not a valid color space`);\n\t}\n\n\t/**\n\t * Get metadata about a coordinate of a color space\n\t *\n\t * @static\n\t * @param {Array | string} ref\n\t * @param {ColorSpace | string} [workingSpace]\n\t * @return {Object}\n\t */\n\tstatic resolveCoord (ref, workingSpace) {\n\t\tlet coordType = type(ref);\n\t\tlet space, coord;\n\n\t\tif (coordType === \"string\") {\n\t\t\tif (ref.includes(\".\")) {\n\t\t\t\t// Absolute coordinate\n\t\t\t\t[space, coord] = ref.split(\".\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Relative coordinate\n\t\t\t\t[space, coord] = [, ref];\n\t\t\t}\n\t\t}\n\t\telse if (Array.isArray(ref)) {\n\t\t\t[space, coord] = ref;\n\t\t}\n\t\telse {\n\t\t\t// Object\n\t\t\tspace = ref.space;\n\t\t\tcoord = ref.coordId;\n\t\t}\n\n\t\tspace = ColorSpace.get(space);\n\n\t\tif (!space) {\n\t\t\tspace = workingSpace;\n\t\t}\n\n\t\tif (!space) {\n\t\t\tthrow new TypeError(`Cannot resolve coordinate reference ${ref}: No color space specified and relative references are not allowed here`);\n\t\t}\n\n\t\tcoordType = type(coord);\n\n\t\tif (coordType === \"number\" || coordType === \"string\" && coord >= 0) {\n\t\t\t// Resolve numerical coord\n\t\t\tlet meta = Object.entries(space.coords)[coord];\n\n\t\t\tif (meta) {\n\t\t\t\treturn {space, id: meta[0], index: coord, ...meta[1]};\n\t\t\t}\n\t\t}\n\n\t\tspace = ColorSpace.get(space);\n\n\t\tlet normalizedCoord = coord.toLowerCase();\n\n\t\tlet i = 0;\n\t\tfor (let id in space.coords) {\n\t\t\tlet meta = space.coords[id];\n\n\t\t\tif (id.toLowerCase() === normalizedCoord || meta.name?.toLowerCase() === normalizedCoord) {\n\t\t\t\treturn {space, id, index: i, ...meta};\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\n\t\tthrow new TypeError(`No \"${coord}\" coordinate found in ${space.name}. Its coordinates are: ${Object.keys(space.coords).join(\", \")}`);\n\t}\n\n\tstatic DEFAULT_FORMAT = {\n\t\ttype: \"functions\",\n\t\tname: \"color\",\n\t};\n}\n\nfunction getPath (space) {\n\tlet ret = [space];\n\n\tfor (let s = space; s = s.base;) {\n\t\tret.push(s);\n\t}\n\n\treturn ret;\n}\n\nfunction processFormat (format, {coords} = {}) {\n\tif (format.coords && !format.coordGrammar) {\n\t\tformat.type ||= \"function\";\n\t\tformat.name ||= \"color\";\n\n\t\t// Format has not been processed\n\t\tformat.coordGrammar = parseCoordGrammar(format.coords);\n\n\t\tlet coordFormats = Object.entries(coords).map(([id, coordMeta], i) => {\n\t\t\t// Preferred format for each coord is the first one\n\t\t\tlet outputType = format.coordGrammar[i][0];\n\n\t\t\tlet fromRange = coordMeta.range || coordMeta.refRange;\n\t\t\tlet toRange = outputType.range, suffix = \"\";\n\n\t\t\t// Non-strict equals intentional since outputType could be a string object\n\t\t\tif (outputType == \"<percentage>\") {\n\t\t\t\ttoRange = [0, 100];\n\t\t\t\tsuffix = \"%\";\n\t\t\t}\n\t\t\telse if (outputType == \"<angle>\") {\n\t\t\t\tsuffix = \"deg\";\n\t\t\t}\n\n\t\t\treturn  {fromRange, toRange, suffix};\n\t\t});\n\n\t\tformat.serializeCoords = (coords, precision) => {\n\t\t\treturn coords.map((c, i) => {\n\t\t\t\tlet {fromRange, toRange, suffix} = coordFormats[i];\n\n\t\t\t\tif (fromRange && toRange) {\n\t\t\t\t\tc = mapRange(fromRange, toRange, c);\n\t\t\t\t}\n\n\t\t\t\tc = serializeNumber(c, {precision, unit: suffix});\n\n\t\t\t\treturn c;\n\t\t\t});\n\t\t};\n\t}\n\n\treturn format;\n}\n","import ColorSpace from \"../space.js\";\n\nexport default new ColorSpace({\n\tid: \"xyz-d65\",\n\tname: \"XYZ D65\",\n\tcoords: {\n\t\tx: {name: \"X\"},\n\t\ty: {name: \"Y\"},\n\t\tz: {name: \"Z\"},\n\t},\n\twhite: \"D65\",\n\tformats: {\n\t\tcolor: {\n\t\t\tids: [\"xyz-d65\", \"xyz\"],\n\t\t},\n\t},\n\taliases: [\"xyz\"],\n});\n","import ColorSpace from \"./space.js\";\nimport {multiplyMatrices} from \"./util.js\";\nimport adapt from \"./adapt.js\";\nimport XYZ_D65 from \"./spaces/xyz-d65.js\";\n\n/**\n * Convenience class for RGB color spaces\n * @extends {ColorSpace}\n */\nexport default class RGBColorSpace extends ColorSpace {\n\t/**\n\t * Creates a new RGB ColorSpace.\n\t * If coords are not specified, they will use the default RGB coords.\n\t * Instead of `fromBase()` and `toBase()` functions,\n\t * you can specify to/from XYZ matrices and have `toBase()` and `fromBase()` automatically generated.\n\t * @param {*} options - Same options as {@link ColorSpace} plus:\n\t * @param {number[][]} options.toXYZ_M - Matrix to convert to XYZ\n\t * @param {number[][]} options.fromXYZ_M - Matrix to convert from XYZ\n\t */\n\tconstructor (options) {\n\t\tif (!options.coords) {\n\t\t\toptions.coords = {\n\t\t\t\tr: {\n\t\t\t\t\trange: [0, 1],\n\t\t\t\t\tname: \"Red\",\n\t\t\t\t},\n\t\t\t\tg: {\n\t\t\t\t\trange: [0, 1],\n\t\t\t\t\tname: \"Green\",\n\t\t\t\t},\n\t\t\t\tb: {\n\t\t\t\t\trange: [0, 1],\n\t\t\t\t\tname: \"Blue\",\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tif (!options.base) {\n\t\t\toptions.base = XYZ_D65;\n\t\t}\n\n\t\tif (options.toXYZ_M && options.fromXYZ_M) {\n\t\t\toptions.toBase ??= rgb => {\n\t\t\t\tlet xyz = multiplyMatrices(options.toXYZ_M, rgb);\n\n\t\t\t\tif (this.white !== this.base.white) {\n\t\t\t\t\t// Perform chromatic adaptation\n\t\t\t\t\txyz = adapt(this.white, this.base.white, xyz);\n\t\t\t\t}\n\n\t\t\t\treturn xyz;\n\t\t\t};\n\n\t\t\toptions.fromBase ??= xyz => {\n\t\t\t\txyz = adapt(this.base.white, this.white, xyz);\n\t\t\t\treturn multiplyMatrices(options.fromXYZ_M, xyz);\n\t\t\t};\n\t\t}\n\n\t\toptions.referred ??= \"display\";\n\n\t\tsuper(options);\n\t}\n}\n","import ColorSpace from \"./space.js\";\nimport getColor from \"./getColor.js\";\n\n/**\n * Get the coordinates of a color in any color space\n * @param {Color} color\n * @param {string | ColorSpace} [space = color.space] The color space to convert to. Defaults to the color's current space\n * @returns {number[]} The color coordinates in the given color space\n */\nexport default function getAll (color, space) {\n\tcolor = getColor(color);\n\n\tif (!space || color.space.equals(space)) {\n\t\t// No conversion needed\n\t\treturn color.coords.slice();\n\t}\n\n\tspace = ColorSpace.get(space);\n\treturn space.from(color);\n}\n","import ColorSpace from \"./space.js\";\nimport getAll from \"./getAll.js\";\nimport getColor from \"./getColor.js\";\n\nexport default function get (color, prop) {\n\tcolor = getColor(color);\n\n\tlet {space, index} = ColorSpace.resolveCoord(prop, color.space);\n\tlet coords = getAll(color, space);\n\treturn coords[index];\n}\n","import ColorSpace from \"./space.js\";\nimport getColor from \"./getColor.js\";\n\nexport default function setAll (color, space, coords) {\n\tcolor = getColor(color);\n\n\tspace = ColorSpace.get(space);\n\tcolor.coords = space.to(color.space, coords);\n\treturn color;\n}\n\nsetAll.returns = \"color\";\n","import ColorSpace from \"./space.js\";\nimport getColor from \"./getColor.js\";\nimport get from \"./get.js\";\nimport getAll from \"./getAll.js\";\nimport setAll from \"./setAll.js\";\nimport {type} from \"./util.js\";\n\n// Set properties and return current instance\nexport default function set (color, prop, value) {\n\tcolor = getColor(color);\n\n\tif (arguments.length === 2 && type(arguments[1]) === \"object\") {\n\t\t// Argument is an object literal\n\t\tlet object = arguments[1];\n\t\tfor (let p in object) {\n\t\t\tset(color, p, object[p]);\n\t\t}\n\t}\n\telse {\n\t\tif (typeof value === \"function\") {\n\t\t\tvalue = value(get(color, prop));\n\t\t}\n\n\t\tlet {space, index} = ColorSpace.resolveCoord(prop, color.space);\n\t\tlet coords = getAll(color, space);\n\t\tcoords[index] = value;\n\t\tsetAll(color, space, coords);\n\t}\n\n\treturn color;\n}\n\nset.returns = \"color\";\n","import ColorSpace from \"../space.js\";\nimport adapt from \"../adapt.js\";\nimport XYZ_D65 from \"./xyz-d65.js\";\n\nexport default new ColorSpace({\n\tid: \"xyz-d50\",\n\tname: \"XYZ D50\",\n\twhite: \"D50\",\n\tbase: XYZ_D65,\n\tfromBase: coords => adapt(XYZ_D65.white, \"D50\", coords),\n\ttoBase: coords => adapt(\"D50\", XYZ_D65.white, coords),\n});\n","import ColorSpace from \"../space.js\";\nimport {WHITES} from \"../adapt.js\";\nimport xyz_d50 from \"./xyz-d50.js\";\n\n// κ * ε  = 2^3 = 8\nconst ε = 216 / 24389;  // 6^3/29^3 == (24/116)^3\nconst ε3 = 24 / 116;\nconst κ = 24389 / 27;   // 29^3/3^3\n\nlet white = WHITES.D50;\n\nexport default new ColorSpace({\n\tid: \"lab\",\n\tname: \"Lab\",\n\tcoords: {\n\t\tl: {\n\t\t\trefRange: [0, 100],\n\t\t\tname: \"Lightness\",\n\t\t},\n\t\ta: {\n\t\t\trefRange: [-125, 125],\n\t\t},\n\t\tb: {\n\t\t\trefRange: [-125, 125],\n\t\t},\n\t},\n\n\t// Assuming XYZ is relative to D50, convert to CIE Lab\n\t// from CIE standard, which now defines these as a rational fraction\n\twhite,\n\n\tbase: xyz_d50,\n\t// Convert D50-adapted XYX to Lab\n\t//  CIE 15.3:2004 section 8.2.1.1\n\tfromBase (XYZ) {\n\t\t// compute xyz, which is XYZ scaled relative to reference white\n\t\tlet xyz = XYZ.map((value, i) => value / white[i]);\n\n\t\t// now compute f\n\t\tlet f = xyz.map(value => value > ε ? Math.cbrt(value) : (κ * value + 16) / 116);\n\n\t\treturn [\n\t\t\t(116 * f[1]) - 16,   // L\n\t\t\t500 * (f[0] - f[1]), // a\n\t\t\t200 * (f[1] - f[2]),  // b\n\t\t];\n\t},\n\t// Convert Lab to D50-adapted XYZ\n\t// Same result as CIE 15.3:2004 Appendix D although the derivation is different\n\t// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\ttoBase (Lab) {\n\t\t// compute f, starting with the luminance-related term\n\t\tlet f = [];\n\t\tf[1] = (Lab[0] + 16) / 116;\n\t\tf[0] = Lab[1] / 500 + f[1];\n\t\tf[2] = f[1] - Lab[2] / 200;\n\n\t\t// compute xyz\n\t\tlet xyz = [\n\t\t\tf[0]   > ε3 ? Math.pow(f[0], 3)                : (116 * f[0] - 16) / κ,\n\t\t\tLab[0] > 8  ? Math.pow((Lab[0] + 16) / 116, 3) : Lab[0] / κ,\n\t\t\tf[2]   > ε3 ? Math.pow(f[2], 3)                : (116 * f[2] - 16) / κ,\n\t\t];\n\n\t\t// Compute XYZ by scaling xyz by reference white\n\t\treturn xyz.map((value, i) => value * white[i]);\n\t},\n\n\tformats: {\n\t\t\"lab\": {\n\t\t\tcoords: [\"<number> | <percentage>\", \"<number> | <percentage>[-1,1]\", \"<number> | <percentage>[-1,1]\"],\n\t\t},\n\t},\n});\n","export function constrain (angle) {\n\treturn ((angle % 360) + 360) % 360;\n}\n\nexport function adjust (arc, angles) {\n\tif (arc === \"raw\") {\n\t\treturn angles;\n\t}\n\n\tlet [a1, a2] = angles.map(constrain);\n\n\tlet angleDiff = a2 - a1;\n\n\tif (arc === \"increasing\") {\n\t\tif (angleDiff < 0) {\n\t\t\ta2 += 360;\n\t\t}\n\t}\n\telse if (arc === \"decreasing\") {\n\t\tif (angleDiff > 0) {\n\t\t\ta1 += 360;\n\t\t}\n\t}\n\telse if (arc === \"longer\") {\n\t\tif (-180 < angleDiff && angleDiff < 180) {\n\t\t\tif (angleDiff > 0) {\n\t\t\t\ta1 += 360;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta2 += 360;\n\t\t\t}\n\t\t}\n\t}\n\telse if (arc === \"shorter\") {\n\t\tif (angleDiff > 180) {\n\t\t\ta1 += 360;\n\t\t}\n\t\telse if (angleDiff < -180) {\n\t\t\ta2 += 360;\n\t\t}\n\t}\n\n\treturn [a1, a2];\n}\n","import ColorSpace from \"../space.js\";\nimport Lab from \"./lab.js\";\nimport {constrain as constrainAngle} from \"../angles.js\";\n\nexport default new ColorSpace({\n\tid: \"lch\",\n\tname: \"LCH\",\n\tcoords: {\n\t\tl: {\n\t\t\trefRange: [0, 100],\n\t\t\tname: \"Lightness\",\n\t\t},\n\t\tc: {\n\t\t\trefRange: [0, 150],\n\t\t\tname: \"Chroma\",\n\t\t},\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t},\n\t},\n\n\tbase: Lab,\n\tfromBase (Lab) {\n\t\t// Convert to polar form\n\t\tlet [L, a, b] = Lab;\n\t\tlet hue;\n\t\tconst ε = 0.02;\n\n\t\tif (Math.abs(a) < ε && Math.abs(b) < ε) {\n\t\t\thue = NaN;\n\t\t}\n\t\telse {\n\t\t\thue = Math.atan2(b, a) * 180 / Math.PI;\n\t\t}\n\n\t\treturn [\n\t\t\tL, // L is still L\n\t\t\tMath.sqrt(a ** 2 + b ** 2), // Chroma\n\t\t\tconstrainAngle(hue), // Hue, in degrees [0 to 360)\n\t\t];\n\t},\n\ttoBase (LCH) {\n\t\t// Convert from polar form\n\t\tlet [Lightness, Chroma, Hue] = LCH;\n\t\t// Clamp any negative Chroma\n\t\tif (Chroma < 0) {\n\t\t\tChroma = 0;\n\t\t}\n\t\t// Deal with NaN Hue\n\t\tif (isNaN(Hue)) {\n\t\t\tHue = 0;\n\t\t}\n\t\treturn [\n\t\t\tLightness, // L is still L\n\t\t\tChroma * Math.cos(Hue * Math.PI / 180), // a\n\t\t\tChroma * Math.sin(Hue * Math.PI / 180),  // b\n\t\t];\n\t},\n\n\tformats: {\n\t\t\"lch\": {\n\t\t\tcoords: [\"<number> | <percentage>\", \"<number> | <percentage>\", \"<number> | <angle>\"],\n\t\t},\n\t},\n});\n","import defaults from \"../defaults.js\";\nimport lab from \"../spaces/lab.js\";\nimport lch from \"../spaces/lch.js\";\nimport getColor from \"../getColor.js\";\n\n// deltaE2000 is a statistically significant improvement\n// and is recommended by the CIE and Idealliance\n// especially for color differences less than 10 deltaE76\n// but is wicked complicated\n// and many implementations have small errors!\n// DeltaE2000 is also discontinuous; in case this\n// matters to you, use deltaECMC instead.\n\nconst Gfactor = 25 ** 7;\nconst π = Math.PI;\nconst r2d = 180 / π;\nconst d2r = π / 180;\n\nfunction pow7 (x) {\n\t// Faster than x ** 7 or Math.pow(x, 7)\n\n\tconst x2 = x * x;\n\tconst x7 = x2 * x2 * x2 * x;\n\n\treturn x7;\n}\n\nexport default function (color, sample, {kL = 1, kC = 1, kH = 1} = {}) {\n\t[color, sample] = getColor([color, sample]);\n\n\t// Given this color as the reference\n\t// and the function parameter as the sample,\n\t// calculate deltaE 2000.\n\n\t// This implementation assumes the parametric\n\t// weighting factors kL, kC and kH\n\t// for the influence of viewing conditions\n\t// are all 1, as sadly seems typical.\n\t// kL should be increased for lightness texture or noise\n\t// and kC increased for chroma noise\n\n\tlet [L1, a1, b1] = lab.from(color);\n\tlet C1 = lch.from(lab, [L1, a1, b1])[1];\n\tlet [L2, a2, b2] = lab.from(sample);\n\tlet C2 = lch.from(lab, [L2, a2, b2])[1];\n\n\t// Check for negative Chroma,\n\t// which might happen through\n\t// direct user input of LCH values\n\n\tif (C1 < 0) {\n\t\tC1 = 0;\n\t}\n\tif (C2 < 0) {\n\t\tC2 = 0;\n\t}\n\n\tlet Cbar = (C1 + C2) / 2; // mean Chroma\n\n\t// calculate a-axis asymmetry factor from mean Chroma\n\t// this turns JND ellipses for near-neutral colors back into circles\n\tlet C7 = pow7(Cbar);\n\n\tlet G = 0.5 * (1 - Math.sqrt(C7 / (C7 + Gfactor)));\n\n\t// scale a axes by asymmetry factor\n\t// this by the way is why there is no Lab2000 colorspace\n\tlet adash1 = (1 + G) * a1;\n\tlet adash2 = (1 + G) * a2;\n\n\t// calculate new Chroma from scaled a and original b axes\n\tlet Cdash1 = Math.sqrt(adash1 ** 2 + b1 ** 2);\n\tlet Cdash2 = Math.sqrt(adash2 ** 2 + b2 ** 2);\n\n\t// calculate new hues, with zero hue for true neutrals\n\t// and in degrees, not radians\n\n\tlet h1 = (adash1 === 0 && b1 === 0) ? 0 : Math.atan2(b1, adash1);\n\tlet h2 = (adash2 === 0 && b2 === 0) ? 0 : Math.atan2(b2, adash2);\n\n\tif (h1 < 0) {\n\t\th1 += 2 * π;\n\t}\n\tif (h2 < 0) {\n\t\th2 += 2 * π;\n\t}\n\n\th1 *= r2d;\n\th2 *= r2d;\n\n\t// Lightness and Chroma differences; sign matters\n\tlet ΔL = L2 - L1;\n\tlet ΔC = Cdash2 - Cdash1;\n\n\t// Hue difference, getting the sign correct\n\tlet hdiff = h2 - h1;\n\tlet hsum = h1 + h2;\n\tlet habs = Math.abs(hdiff);\n\tlet Δh;\n\n\tif (Cdash1 * Cdash2 === 0) {\n\t\tΔh = 0;\n\t}\n\telse if (habs <= 180) {\n\t\tΔh = hdiff;\n\t}\n\telse if (hdiff > 180) {\n\t\tΔh = hdiff - 360;\n\t}\n\telse if (hdiff < -180) {\n\t\tΔh = hdiff + 360;\n\t}\n\telse {\n\t\tdefaults.warn(\"the unthinkable has happened\");\n\t}\n\n\t// weighted Hue difference, more for larger Chroma\n\tlet ΔH = 2 * Math.sqrt(Cdash2 * Cdash1) * Math.sin(Δh * d2r / 2);\n\n\t// calculate mean Lightness and Chroma\n\tlet Ldash = (L1 + L2) / 2;\n\tlet Cdash = (Cdash1 + Cdash2) / 2;\n\tlet Cdash7 = pow7(Cdash);\n\n\t// Compensate for non-linearity in the blue region of Lab.\n\t// Four possibilities for hue weighting factor,\n\t// depending on the angles, to get the correct sign\n\tlet hdash;\n\tif (Cdash1 * Cdash2 === 0) {\n\t\thdash = hsum;   // which should be zero\n\t}\n\telse if (habs <= 180) {\n\t\thdash = hsum / 2;\n\t}\n\telse if (hsum < 360) {\n\t\thdash = (hsum + 360) / 2;\n\t}\n\telse {\n\t\thdash = (hsum - 360) / 2;\n\t}\n\n\t// positional corrections to the lack of uniformity of CIELAB\n\t// These are all trying to make JND ellipsoids more like spheres\n\n\t// SL Lightness crispening factor\n\t// a background with L=50 is assumed\n\tlet lsq = (Ldash - 50) ** 2;\n\tlet SL = 1 + ((0.015 * lsq) / Math.sqrt(20 + lsq));\n\n\t// SC Chroma factor, similar to those in CMC and deltaE 94 formulae\n\tlet SC = 1 + 0.045 * Cdash;\n\n\t// Cross term T for blue non-linearity\n\tlet T = 1;\n\tT -= (0.17 * Math.cos((     hdash - 30)  * d2r));\n\tT += (0.24 * Math.cos(  2 * hdash        * d2r));\n\tT += (0.32 * Math.cos(((3 * hdash) + 6)  * d2r));\n\tT -= (0.20 * Math.cos(((4 * hdash) - 63) * d2r));\n\n\t// SH Hue factor depends on Chroma,\n\t// as well as adjusted hue angle like deltaE94.\n\tlet SH = 1 + 0.015 * Cdash * T;\n\n\t// RT Hue rotation term compensates for rotation of JND ellipses\n\t// and Munsell constant hue lines\n\t// in the medium-high Chroma blue region\n\t// (Hue 225 to 315)\n\tlet Δθ = 30 * Math.exp(-1 * (((hdash - 275) / 25) ** 2));\n\tlet RC = 2 * Math.sqrt(Cdash7 / (Cdash7 + Gfactor));\n\tlet RT = -1 * Math.sin(2 * Δθ * d2r) * RC;\n\n\t// Finally calculate the deltaE, term by term as root sume of squares\n\tlet dE = (ΔL / (kL * SL)) ** 2;\n\tdE += (ΔC / (kC * SC)) ** 2;\n\tdE += (ΔH / (kH * SH)) ** 2;\n\tdE += RT * (ΔC / (kC * SC)) * (ΔH / (kH * SH));\n\treturn Math.sqrt(dE);\n\t// Yay!!!\n}\n","import ColorSpace from \"../space.js\";\nimport {multiplyMatrices} from \"../util.js\";\nimport XYZ_D65 from \"./xyz-d65.js\";\n\n// Recalculated for consistent reference white\n// see https://github.com/w3c/csswg-drafts/issues/6642#issuecomment-943521484\nconst XYZtoLMS_M = [\n\t[ 0.8190224379967030, 0.3619062600528904, -0.1288737815209879 ],\n\t[ 0.0329836539323885, 0.9292868615863434,  0.0361446663506424 ],\n\t[ 0.0481771893596242, 0.2642395317527308,  0.6335478284694309 ],\n];\n// inverse of XYZtoLMS_M\nconst LMStoXYZ_M = [\n\t[  1.2268798758459243, -0.5578149944602171,  0.2813910456659647 ],\n\t[ -0.0405757452148008,  1.1122868032803170, -0.0717110580655164 ],\n\t[ -0.0763729366746601, -0.4214933324022432,  1.5869240198367816 ],\n];\nconst LMStoLab_M = [\n\t[ 0.2104542683093140,  0.7936177747023054, -0.0040720430116193 ],\n\t[ 1.9779985324311684, -2.4285922420485799,  0.4505937096174110 ],\n\t[ 0.0259040424655478,  0.7827717124575296, -0.8086757549230774 ],\n];\n// LMStoIab_M inverted\nconst LabtoLMS_M = [\n\t[ 1.0000000000000000,  0.3963377773761749,  0.2158037573099136 ],\n\t[ 1.0000000000000000, -0.1055613458156586, -0.0638541728258133 ],\n\t[ 1.0000000000000000, -0.0894841775298119, -1.2914855480194092 ],\n];\n\nexport default new ColorSpace({\n\tid: \"oklab\",\n\tname: \"Oklab\",\n\tcoords: {\n\t\tl: {\n\t\t\trefRange: [0, 1],\n\t\t\tname: \"Lightness\",\n\t\t},\n\t\ta: {\n\t\t\trefRange: [-0.4, 0.4],\n\t\t},\n\t\tb: {\n\t\t\trefRange: [-0.4, 0.4],\n\t\t},\n\t},\n\n\t// Note that XYZ is relative to D65\n\twhite: \"D65\",\n\tbase: XYZ_D65,\n\tfromBase (XYZ) {\n\t\t// move to LMS cone domain\n\t\tlet LMS = multiplyMatrices(XYZtoLMS_M, XYZ);\n\n\t\t// non-linearity\n\t\tlet LMSg = LMS.map(val => Math.cbrt(val));\n\n\t\treturn multiplyMatrices(LMStoLab_M, LMSg);\n\n\t},\n\ttoBase (OKLab) {\n\t\t// move to LMS cone domain\n\t\tlet LMSg = multiplyMatrices(LabtoLMS_M, OKLab);\n\n\t\t// restore linearity\n\t\tlet LMS = LMSg.map(val => val ** 3);\n\n\t\treturn multiplyMatrices(LMStoXYZ_M, LMS);\n\t},\n\n\tformats: {\n\t\t\"oklab\": {\n\t\t\tcoords: [\"<percentage> | <number>\", \"<number> | <percentage>[-1,1]\", \"<number> | <percentage>[-1,1]\"],\n\t\t},\n\t},\n});\n","// More accurate color-difference formulae\n// than the simple 1976 Euclidean distance in CIE Lab\n\nimport oklab from \"../spaces/oklab.js\";\nimport getColor from \"../getColor.js\";\n\nexport default function (color, sample) {\n\t[color, sample] = getColor([color, sample]);\n\n\t// Given this color as the reference\n\t// and a sample,\n\t// calculate deltaEOK, term by term as root sum of squares\n\tlet [L1, a1, b1] = oklab.from(color);\n\tlet [L2, a2, b2] = oklab.from(sample);\n\tlet ΔL = L1 - L2;\n\tlet Δa = a1 - a2;\n\tlet Δb = b1 - b2;\n\treturn Math.sqrt(ΔL ** 2 + Δa ** 2 + Δb ** 2);\n}\n","import ColorSpace from \"./space.js\";\nimport getColor from \"./getColor.js\";\n\nconst ε = .000075;\n\n/**\n * Check if a color is in gamut of either its own or another color space\n * @return {Boolean} Is the color in gamut?\n */\nexport default function inGamut (color, space, {epsilon = ε} = {}) {\n\tcolor = getColor(color);\n\n\tif (!space) {\n\t\tspace = color.space;\n\t}\n\n\tspace = ColorSpace.get(space);\n\tlet coords = color.coords;\n\n\tif (space !== color.space) {\n\t\tcoords = space.from(color);\n\t}\n\n\treturn space.inGamut(coords, {epsilon});\n}\n","export default function clone (color) {\n\treturn {\n\t\tspace: color.space,\n\t\tcoords: color.coords.slice(),\n\t\talpha: color.alpha,\n\t};\n}\n","import ColorSpace from \"./space.js\";\n\n/**\n * Euclidean distance of colors in an arbitrary color space\n */\nexport default function distance (color1, color2, space = \"lab\") {\n\tspace = ColorSpace.get(space);\n\n\t// Assume getColor() is called on color in space.from()\n\tlet coords1 = space.from(color1);\n\tlet coords2 = space.from(color2);\n\n\treturn Math.sqrt(coords1.reduce((acc, c1, i) => {\n\t\tlet c2 = coords2[i];\n\t\tif (isNaN(c1) || isNaN(c2)) {\n\t\t\treturn acc;\n\t\t}\n\n\t\treturn acc + (c2 - c1) ** 2;\n\t}, 0));\n}\n","import distance from \"../distance.js\";\nimport getColor from \"../getColor.js\";\n\nexport default function deltaE76 (color, sample) {\n\t// Assume getColor() is called in the distance function\n\treturn distance(color, sample, \"lab\");\n}\n","import lab from \"../spaces/lab.js\";\nimport lch from \"../spaces/lch.js\";\nimport getColor from \"../getColor.js\";\n\n// More accurate color-difference formulae\n// than the simple 1976 Euclidean distance in Lab\n\n// CMC by the Color Measurement Committee of the\n// Bradford Society of Dyeists and Colorsts, 1994.\n// Uses LCH rather than Lab,\n// with different weights for L, C and H differences\n// A nice increase in accuracy for modest increase in complexity\nconst π = Math.PI;\nconst d2r = π / 180;\n\nexport default function (color, sample, {l = 2, c = 1} = {}) {\n\t[color, sample] = getColor([color, sample]);\n\n\t// Given this color as the reference\n\t// and a sample,\n\t// calculate deltaE CMC.\n\n\t// This implementation assumes the parametric\n\t// weighting factors l:c are 2:1\n\t// which is typical for non-textile uses.\n\n\tlet [L1, a1, b1] = lab.from(color);\n\tlet [, C1, H1] = lch.from(lab, [L1, a1, b1]);\n\tlet [L2, a2, b2] = lab.from(sample);\n\tlet C2 = lch.from(lab, [L2, a2, b2])[1];\n\n\t// let [L1, a1, b1] = color.getAll(lab);\n\t// let C1 = color.get(\"lch.c\");\n\t// let H1 = color.get(\"lch.h\");\n\t// let [L2, a2, b2] = sample.getAll(lab);\n\t// let C2 = sample.get(\"lch.c\");\n\n\t// Check for negative Chroma,\n\t// which might happen through\n\t// direct user input of LCH values\n\n\tif (C1 < 0) {\n\t\tC1 = 0;\n\t}\n\tif (C2 < 0) {\n\t\tC2 = 0;\n\t}\n\n\t// we don't need H2 as ΔH is calculated from Δa, Δb and ΔC\n\n\t// Lightness and Chroma differences\n\t// These are (color - sample), unlike deltaE2000\n\tlet ΔL = L1 - L2;\n\tlet ΔC = C1 - C2;\n\n\tlet Δa = a1 - a2;\n\tlet Δb = b1 - b2;\n\n\t// weighted Hue difference, less for larger Chroma difference\n\n\tlet H2 = (Δa ** 2) + (Δb ** 2) - (ΔC ** 2);\n\t// due to roundoff error it is possible that, for zero a and b,\n\t// ΔC > Δa + Δb is 0, resulting in attempting\n\t// to take the square root of a negative number\n\n\t// trying instead the equation from Industrial Color Physics\n\t// By Georg A. Klein\n\n\t// let ΔH = ((a1 * b2) - (a2 * b1)) / Math.sqrt(0.5 * ((C2 * C1) + (a2 * a1) + (b2 * b1)));\n\t// console.log({ΔH});\n\t// This gives the same result to 12 decimal places\n\t// except it sometimes NaNs when trying to root a negative number\n\n\t// let ΔH = Math.sqrt(H2); we never actually use the root, it gets squared again!!\n\n\t// positional corrections to the lack of uniformity of CIELAB\n\t// These are all trying to make JND ellipsoids more like spheres\n\n\t// SL Lightness crispening factor, depends entirely on L1 not L2\n\tlet SL = 0.511;\t// linear portion of the Y to L transfer function\n\tif (L1 >= 16) {\t// cubic portion\n\t\tSL = (0.040975 * L1) / (1 + 0.01765 * L1);\n\t}\n\n\t// SC Chroma factor\n\tlet SC = ((0.0638 * C1) / (1 + 0.0131 * C1)) + 0.638;\n\n\t// Cross term T for blue non-linearity\n\tlet T;\n\tif (Number.isNaN(H1)) {\n\t\tH1 = 0;\n\t}\n\n\tif (H1 >= 164 && H1 <= 345) {\n\t\tT = 0.56 + Math.abs(0.2 * Math.cos((H1 + 168) * d2r));\n\t}\n\telse {\n\t\tT = 0.36 + Math.abs(0.4 * Math.cos((H1 + 35) * d2r));\n\t}\n\t// console.log({T});\n\n\t// SH Hue factor also depends on C1,\n\tlet C4 = Math.pow(C1, 4);\n\tlet F = Math.sqrt(C4 / (C4 + 1900));\n\tlet SH = SC * ((F * T) + 1 - F);\n\n\t// Finally calculate the deltaE, term by term as root sume of squares\n\tlet dE = (ΔL / (l * SL)) ** 2;\n\tdE += (ΔC / (c * SC)) ** 2;\n\tdE += (H2 / (SH ** 2));\n\t// dE += (ΔH / SH)  ** 2;\n\treturn Math.sqrt(dE);\n\t// Yay!!!\n}\n","import ColorSpace from \"../space.js\";\nimport XYZ_D65 from \"./xyz-d65.js\";\n\nconst Yw = 203;\t// absolute luminance of media white\n\nexport default new ColorSpace({\n// Absolute CIE XYZ, with a D65 whitepoint,\n// as used in most HDR colorspaces as a starting point.\n// SDR spaces are converted per BT.2048\n// so that diffuse, media white is 203 cd/m²\n\tid: \"xyz-abs-d65\",\n\tcssId: \"--xyz-abs-d65\",\n\tname: \"Absolute XYZ D65\",\n\tcoords: {\n\t\tx: {\n\t\t\trefRange: [0, 9504.7],\n\t\t\tname: \"Xa\",\n\t\t},\n\t\ty: {\n\t\t\trefRange: [0, 10000],\n\t\t\tname: \"Ya\",\n\t\t},\n\t\tz: {\n\t\t\trefRange: [0, 10888.3],\n\t\t\tname: \"Za\",\n\t\t},\n\t},\n\n\tbase: XYZ_D65,\n\tfromBase (XYZ) {\n\t\t// Make XYZ absolute, not relative to media white\n\t\t// Maximum luminance in PQ is 10,000 cd/m²\n\t\t// Relative XYZ has Y=1 for media white\n\t\treturn XYZ.map (v => Math.max(v * Yw, 0));\n\t},\n\ttoBase (AbsXYZ) {\n\t\t// Convert to media-white relative XYZ\n\t\treturn AbsXYZ.map(v => Math.max(v / Yw, 0));\n\t},\n});\n","import ColorSpace from \"../space.js\";\nimport {multiplyMatrices} from \"../util.js\";\nimport XYZ_Abs_D65 from \"./xyz-abs-d65.js\";\n\nconst b = 1.15;\nconst g = 0.66;\nconst n = 2610 / (2 ** 14);\nconst ninv = (2 ** 14) / 2610;\nconst c1 = 3424 / (2 ** 12);\nconst c2 = 2413 / (2 ** 7);\nconst c3 = 2392 / (2 ** 7);\nconst p = 1.7 * 2523 / (2 ** 5);\nconst pinv = (2 ** 5) / (1.7 * 2523);\nconst d = -0.56;\nconst d0 = 1.6295499532821566E-11;\n\nconst XYZtoCone_M = [\n\t[  0.41478972, 0.579999,  0.0146480 ],\n\t[ -0.2015100,  1.120649,  0.0531008 ],\n\t[ -0.0166008,  0.264800,  0.6684799 ],\n];\n// XYZtoCone_M inverted\nconst ConetoXYZ_M = [\n\t[  1.9242264357876067,  -1.0047923125953657,  0.037651404030618   ],\n\t[  0.35031676209499907,  0.7264811939316552, -0.06538442294808501 ],\n\t[ -0.09098281098284752, -0.3127282905230739,  1.5227665613052603  ],\n];\nconst ConetoIab_M = [\n\t[  0.5,       0.5,       0        ],\n\t[  3.524000, -4.066708,  0.542708 ],\n\t[  0.199076,  1.096799, -1.295875 ],\n];\n// ConetoIab_M inverted\nconst IabtoCone_M = [\n\t[ 1,                   0.1386050432715393,   0.05804731615611886 ],\n\t[ 0.9999999999999999, -0.1386050432715393,  -0.05804731615611886 ],\n\t[ 0.9999999999999998, -0.09601924202631895, -0.8118918960560388  ],\n];\n\nexport default new ColorSpace({\n\tid: \"jzazbz\",\n\tname: \"Jzazbz\",\n\tcoords: {\n\t\tjz: {\n\t\t\trefRange: [0, 1],\n\t\t\tname: \"Jz\",\n\t\t},\n\t\taz: {\n\t\t\trefRange: [-0.5, 0.5],\n\t\t},\n\t\tbz: {\n\t\t\trefRange: [-0.5, 0.5],\n\t\t},\n\t},\n\n\tbase: XYZ_Abs_D65,\n\tfromBase (XYZ) {\n\t\t// First make XYZ absolute, not relative to media white\n\t\t// Maximum luminance in PQ is 10,000 cd/m²\n\t\t// Relative XYZ has Y=1 for media white\n\t\t// BT.2048 says media white Y=203 at PQ 58\n\n\t\tlet [ Xa, Ya, Za ] = XYZ;\n\n\t\t// modify X and Y\n\t\tlet Xm = (b * Xa) - ((b - 1) * Za);\n\t\tlet Ym = (g * Ya) - ((g - 1) * Xa);\n\n\t\t// move to LMS cone domain\n\t\tlet LMS = multiplyMatrices(XYZtoCone_M, [ Xm, Ym, Za ]);\n\n\t\t// PQ-encode LMS\n\t\tlet PQLMS = LMS.map (function (val) {\n\t\t\tlet num = c1 + (c2 * ((val / 10000) ** n));\n\t\t\tlet denom = 1 + (c3 * ((val / 10000) ** n));\n\n\t\t\treturn (num / denom)  ** p;\n\t\t});\n\n\t\t// almost there, calculate Iz az bz\n\t\tlet [ Iz, az, bz] = multiplyMatrices(ConetoIab_M, PQLMS);\n\t\t// console.log({Iz, az, bz});\n\n\t\tlet Jz = ((1 + d) * Iz) / (1 + (d * Iz)) - d0;\n\t\treturn [Jz, az, bz];\n\t},\n\ttoBase (Jzazbz) {\n\t\tlet [Jz, az, bz] = Jzazbz;\n\t\tlet Iz = (Jz + d0) / (1 + d - d * (Jz + d0));\n\n\t\t// bring into LMS cone domain\n\t\tlet PQLMS = multiplyMatrices(IabtoCone_M, [ Iz, az, bz ]);\n\n\t\t// convert from PQ-coded to linear-light\n\t\tlet LMS = PQLMS.map(function (val) {\n\t\t\tlet num = (c1 - (val ** pinv));\n\t\t\tlet denom = (c3 * (val ** pinv)) - c2;\n\t\t\tlet x = 10000 * ((num / denom) ** ninv);\n\n\t\t\treturn (x); \t// luminance relative to diffuse white, [0, 70 or so].\n\t\t});\n\n\t\t// modified abs XYZ\n\t\tlet [ Xm, Ym, Za ] = multiplyMatrices(ConetoXYZ_M, LMS);\n\n\t\t// restore standard D50 relative XYZ, relative to media white\n\t\tlet Xa = (Xm + ((b - 1) * Za)) / b;\n\t\tlet Ya = (Ym + ((g - 1) * Xa)) / g;\n\t\treturn [ Xa, Ya, Za ];\n\t},\n\n\tformats: {\n\t\t// https://drafts.csswg.org/css-color-hdr/#Jzazbz\n\t\t\"color\": {\n\t\t\tcoords: [\"<number> | <percentage>\", \"<number> | <percentage>[-1,1]\", \"<number> | <percentage>[-1,1]\"],\n\t\t},\n\t},\n});\n","import ColorSpace from \"../space.js\";\nimport Jzazbz from \"./jzazbz.js\";\nimport {constrain as constrainAngle} from \"../angles.js\";\n\nexport default new ColorSpace({\n\tid: \"jzczhz\",\n\tname: \"JzCzHz\",\n\tcoords: {\n\t\tjz: {\n\t\t\trefRange: [0, 1],\n\t\t\tname: \"Jz\",\n\t\t},\n\t\tcz: {\n\t\t\trefRange: [0, 1],\n\t\t\tname: \"Chroma\",\n\t\t},\n\t\thz: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t},\n\t},\n\n\tbase: Jzazbz,\n\tfromBase (jzazbz) {\n\t\t// Convert to polar form\n\t\tlet [Jz, az, bz] = jzazbz;\n\t\tlet hue;\n\t\tconst ε = 0.0002; // chromatic components much smaller than a,b\n\n\t\tif (Math.abs(az) < ε && Math.abs(bz) < ε) {\n\t\t\thue = NaN;\n\t\t}\n\t\telse {\n\t\t\thue = Math.atan2(bz, az) * 180 / Math.PI;\n\t\t}\n\n\t\treturn [\n\t\t\tJz, // Jz is still Jz\n\t\t\tMath.sqrt(az ** 2 + bz ** 2), // Chroma\n\t\t\tconstrainAngle(hue), // Hue, in degrees [0 to 360)\n\t\t];\n\t},\n\ttoBase (jzczhz) {\n\t\t// Convert from polar form\n\t\t// debugger;\n\t\treturn [\n\t\t\tjzczhz[0], // Jz is still Jz\n\t\t\tjzczhz[1] * Math.cos(jzczhz[2] * Math.PI / 180), // az\n\t\t\tjzczhz[1] * Math.sin(jzczhz[2] * Math.PI / 180),  // bz\n\t\t];\n\t},\n});\n","import jzczhz from \"../spaces/jzczhz.js\";\nimport getColor from \"../getColor.js\";\n\n// More accurate color-difference formulae\n// than the simple 1976 Euclidean distance in Lab\n\n// Uses JzCzHz, which has improved perceptual uniformity\n// and thus a simple Euclidean root-sum of ΔL² ΔC² ΔH²\n// gives good results.\n\nexport default function (color, sample) {\n\t[color, sample] = getColor([color, sample]);\n\n\t// Given this color as the reference\n\t// and a sample,\n\t// calculate deltaE in JzCzHz.\n\tlet [Jz1, Cz1, Hz1] = jzczhz.from(color);\n\tlet [Jz2, Cz2, Hz2] = jzczhz.from(sample);\n\n\t// Lightness and Chroma differences\n\t// sign does not matter as they are squared.\n\tlet ΔJ = Jz1 - Jz2;\n\tlet ΔC = Cz1 - Cz2;\n\n\t// length of chord for ΔH\n\tif ((Number.isNaN(Hz1)) && (Number.isNaN(Hz2))) {\n\t\t// both undefined hues\n\t\tHz1 = 0;\n\t\tHz2 = 0;\n\t}\n\telse if (Number.isNaN(Hz1)) {\n\t\t// one undefined, set to the defined hue\n\t\tHz1 = Hz2;\n\t}\n\telse if (Number.isNaN(Hz2)) {\n\t\tHz2 = Hz1;\n\t}\n\n\tlet Δh = Hz1 - Hz2;\n\tlet ΔH = 2 * Math.sqrt(Cz1 * Cz2) * Math.sin((Δh / 2) * (Math.PI / 180));\n\n\treturn Math.sqrt(ΔJ ** 2 + ΔC ** 2 + ΔH ** 2);\n}\n","import ColorSpace from \"../space.js\";\nimport {multiplyMatrices} from \"../util.js\";\nimport XYZ_Abs_D65 from \"./xyz-abs-d65.js\";\n\nconst c1 = 3424 / 4096;\nconst c2 = 2413 / 128;\nconst c3 = 2392 / 128;\nconst m1 = 2610 / 16384;\nconst m2 = 2523 / 32;\nconst im1 = 16384 / 2610;\nconst im2 = 32 / 2523;\n\n// The matrix below includes the 4% crosstalk components\n// and is from the Dolby \"What is ICtCp\" paper\"\nconst XYZtoLMS_M = [\n\t[  0.3592832590121217,  0.6976051147779502, -0.0358915932320290 ],\n\t[ -0.1920808463704993,  1.1004767970374321,  0.0753748658519118 ],\n\t[  0.0070797844607479,  0.0748396662186362,  0.8433265453898765 ],\n];\n// linear-light Rec.2020 to LMS, again with crosstalk\n// rational terms from Jan Fröhlich,\n// Encoding High Dynamic Range andWide Color Gamut Imagery, p.97\n// and ITU-R BT.2124-0 p.2\n/*\nconst Rec2020toLMS_M = [\n\t[ 1688 / 4096,  2146 / 4096,   262 / 4096 ],\n\t[  683 / 4096,  2951 / 4096,   462 / 4096 ],\n\t[   99 / 4096,   309 / 4096,  3688 / 4096 ]\n];\n*/\n// this includes the Ebner LMS coefficients,\n// the rotation, and the scaling to [-0.5,0.5] range\n// rational terms from Fröhlich p.97\n// and ITU-R BT.2124-0 pp.2-3\nconst LMStoIPT_M = [\n\t[  2048 / 4096,   2048 / 4096,       0      ],\n\t[  6610 / 4096, -13613 / 4096,  7003 / 4096 ],\n\t[ 17933 / 4096, -17390 / 4096,  -543 / 4096 ],\n];\n\n// inverted matrices, calculated from the above\nconst IPTtoLMS_M = [\n\t[ 0.9999999999999998,  0.0086090370379328,  0.1110296250030260 ],\n\t[ 0.9999999999999998, -0.0086090370379328, -0.1110296250030259 ],\n\t[ 0.9999999999999998,  0.5600313357106791, -0.3206271749873188 ],\n];\n/*\nconst LMStoRec2020_M = [\n\t[ 3.4375568932814012112,   -2.5072112125095058195,   0.069654319228104608382],\n\t[-0.79142868665644156125,   1.9838372198740089874,  -0.19240853321756742626 ],\n\t[-0.025646662911506476363, -0.099240248643945566751, 1.1248869115554520431  ]\n];\n*/\nconst LMStoXYZ_M = [\n\t[  2.0701522183894223, -1.3263473389671563,  0.2066510476294053 ],\n\t[  0.3647385209748072,  0.6805660249472273, -0.0453045459220347 ],\n\t[ -0.0497472075358123, -0.0492609666966131,  1.1880659249923042 ],\n];\n\n// Only the PQ form of ICtCp is implemented here. There is also an HLG form.\n// from Dolby, \"WHAT IS ICTCP?\"\n// https://professional.dolby.com/siteassets/pdfs/ictcp_dolbywhitepaper_v071.pdf\n// and\n// Dolby, \"Perceptual Color Volume\n// Measuring the Distinguishable Colors of HDR and WCG Displays\"\n// https://professional.dolby.com/siteassets/pdfs/dolby-vision-measuring-perceptual-color-volume-v7.1.pdf\nexport default new ColorSpace({\n\tid: \"ictcp\",\n\tname: \"ICTCP\",\n\t// From BT.2100-2 page 7:\n\t// During production, signal values are expected to exceed the\n\t// range E′ = [0.0 : 1.0]. This provides processing headroom and avoids\n\t// signal degradation during cascaded processing. Such values of E′,\n\t// below 0.0 or exceeding 1.0, should not be clipped during production\n\t// and exchange.\n\t// Values below 0.0 should not be clipped in reference displays (even\n\t// though they represent “negative” light) to allow the black level of\n\t// the signal (LB) to be properly set using test signals known as “PLUGE”\n\tcoords: {\n\t\ti: {\n\t\t\trefRange: [0, 1],\t// Constant luminance,\n\t\t\tname: \"I\",\n\t\t},\n\t\tct: {\n\t\t\trefRange: [-0.5, 0.5],\t// Full BT.2020 gamut in range [-0.5, 0.5]\n\t\t\tname: \"CT\",\n\t\t},\n\t\tcp: {\n\t\t\trefRange: [-0.5, 0.5],\n\t\t\tname: \"CP\",\n\t\t},\n\t},\n\n\tbase: XYZ_Abs_D65,\n\tfromBase (XYZ) {\n\t\t// move to LMS cone domain\n\t\tlet LMS = multiplyMatrices(XYZtoLMS_M, XYZ);\n\n\t\treturn LMStoICtCp(LMS);\n\t},\n\ttoBase (ICtCp) {\n\t\tlet LMS = ICtCptoLMS(ICtCp);\n\n\t\treturn multiplyMatrices(LMStoXYZ_M, LMS);\n\t},\n});\n\nfunction LMStoICtCp (LMS) {\n\t// apply the PQ EOTF\n\t// we can't ever be dividing by zero because of the \"1 +\" in the denominator\n\tlet PQLMS = LMS.map (function (val) {\n\t\tlet num = c1 + (c2 * ((val / 10000) ** m1));\n\t\tlet denom = 1 + (c3 * ((val / 10000) ** m1));\n\n\t\treturn (num / denom)  ** m2;\n\t});\n\n\t// LMS to IPT, with rotation for Y'C'bC'r compatibility\n\treturn multiplyMatrices(LMStoIPT_M, PQLMS);\n}\n\nfunction ICtCptoLMS (ICtCp) {\n\tlet PQLMS = multiplyMatrices(IPTtoLMS_M, ICtCp);\n\n\t// From BT.2124-0 Annex 2 Conversion 3\n\tlet LMS = PQLMS.map (function (val) {\n\t\tlet num  = Math.max((val ** im2) - c1, 0);\n\t\tlet denom = (c2 - (c3 * (val ** im2)));\n\t\treturn 10000 * ((num / denom) ** im1);\n\t});\n\n\treturn LMS;\n}\n","import ictcp from \"../spaces/ictcp.js\";\nimport getColor from \"../getColor.js\";\n\n// Delta E in ICtCp space,\n// which the ITU calls Delta E ITP, which is shorter\n// formulae from ITU Rec. ITU-R BT.2124-0\n\nexport default function (color, sample) {\n\t[color, sample] = getColor([color, sample]);\n\n\t// Given this color as the reference\n\t// and a sample,\n\t// calculate deltaE in ICtCp\n\t// which is simply the Euclidean distance\n\n\tlet [ I1, T1, P1 ] = ictcp.from(color);\n\tlet [ I2, T2, P2 ] = ictcp.from(sample);\n\n\t// the 0.25 factor is to undo the encoding scaling in Ct\n\t// the 720 is so that 1 deltaE = 1 JND\n\t// per  ITU-R BT.2124-0 p.3\n\n\treturn 720 * Math.sqrt((I1 - I2) ** 2 + (0.25 * (T1 - T2) ** 2) + (P1 - P2) ** 2);\n}\n","import ColorSpace from \"../space.js\";\nimport {multiplyMatrices, interpolate, copySign, spow, zdiv, bisectLeft} from \"../util.js\";\nimport {constrain} from \"../angles.js\";\nimport xyz_d65 from \"./xyz-d65.js\";\nimport {WHITES} from \"../adapt.js\";\n\nconst white = WHITES.D65;\nconst adaptedCoef = 0.42;\nconst adaptedCoefInv = 1 / adaptedCoef;\nconst tau = 2 * Math.PI;\n\nconst cat16 = [\n\t[  0.401288,  0.650173, -0.051461 ],\n\t[ -0.250268,  1.204414,  0.045854 ],\n\t[ -0.002079,  0.048952,  0.953127 ],\n];\n\nconst cat16Inv = [\n\t[1.8620678550872327, -1.0112546305316843, 0.14918677544445175],\n\t[0.38752654323613717, 0.6214474419314753, -0.008973985167612518],\n\t[-0.015841498849333856, -0.03412293802851557, 1.0499644368778496],\n];\n\nconst m1 = [\n\t[460.0, 451.0, 288.0],\n\t[460.0, -891.0, -261.0],\n\t[460.0, -220.0, -6300.0],\n];\n\nconst surroundMap = {\n\tdark: [0.8, 0.525, 0.8],\n\tdim: [0.9, 0.59, 0.9],\n\taverage: [1, 0.69, 1],\n};\n\nconst hueQuadMap = {\n\t// Red, Yellow, Green, Blue, Red\n\th: [20.14, 90.00, 164.25, 237.53, 380.14],\n\te: [0.8, 0.7, 1.0, 1.2, 0.8],\n\tH: [0.0, 100.0, 200.0, 300.0, 400.0],\n};\n\nconst rad2deg = 180 / Math.PI;\nconst deg2rad = Math.PI / 180;\n\nexport function adapt (coords, fl) {\n\tconst temp = coords.map(c => {\n\t\tconst x = spow(fl * Math.abs(c) * 0.01, adaptedCoef);\n\t\treturn 400 * copySign(x, c) / (x + 27.13);\n\t});\n\treturn temp;\n}\n\nexport function unadapt (adapted, fl) {\n\tconst constant = 100 / fl * (27.13 ** adaptedCoefInv);\n\treturn adapted.map(c => {\n\t\tconst cabs = Math.abs(c);\n\t\treturn copySign(constant * spow(cabs / (400 - cabs), adaptedCoefInv), c);\n\t});\n}\n\nexport function hueQuadrature (h) {\n\tlet hp = constrain(h);\n\tif (hp <= hueQuadMap.h[0]) {\n\t\thp += 360;\n\t}\n\n\tconst i = bisectLeft(hueQuadMap.h, hp) - 1;\n\tconst [hi, hii] = hueQuadMap.h.slice(i, i + 2);\n\tconst [ei, eii] = hueQuadMap.e.slice(i, i + 2);\n\tconst Hi = hueQuadMap.H[i];\n\n\tconst t = (hp - hi) / ei;\n\treturn Hi + (100 * t) / (t + (hii - hp) / eii);\n}\n\nexport function invHueQuadrature (H) {\n\tlet Hp = ((H % 400 + 400) % 400);\n\tconst i = Math.floor(0.01 * Hp);\n\tHp = Hp % 100;\n\tconst [hi, hii] = hueQuadMap.h.slice(i, i + 2);\n\tconst [ei, eii] = hueQuadMap.e.slice(i, i + 2);\n\n\treturn constrain(\n\t\t(Hp * (eii * hi - ei * hii) - 100 * hi * eii) /\n\t\t(Hp * (eii - ei) - 100 * eii),\n\t);\n}\n\nexport function environment (\n\trefWhite,\n\tadaptingLuminance,\n\tbackgroundLuminance,\n\tsurround,\n\tdiscounting,\n) {\n\n\tconst env = {};\n\n\tenv.discounting = discounting;\n\tenv.refWhite = refWhite;\n\tenv.surround = surround;\n\tconst xyzW = refWhite.map(c => {\n\t\treturn c * 100;\n\t});\n\n\t// The average luminance of the environment in `cd/m^2cd/m` (a.k.a. nits)\n\tenv.la = adaptingLuminance;\n\t// The relative luminance of the nearby background\n\tenv.yb = backgroundLuminance;\n\t// Absolute luminance of the reference white.\n\tconst yw = xyzW[1];\n\n\t// Cone response for reference white\n\tconst rgbW = multiplyMatrices(cat16, xyzW);\n\n\t// Surround: dark, dim, and average\n\tsurround = surroundMap[env.surround];\n\tconst f = surround[0];\n\tenv.c = surround[1];\n\tenv.nc = surround[2];\n\n\tconst k = 1 / (5 * env.la + 1);\n\tconst k4 = k ** 4;\n\n\t// Factor of luminance level adaptation\n\tenv.fl = (k4 * env.la + 0.1 * (1 - k4) * (1 - k4) * Math.cbrt(5 * env.la));\n\tenv.flRoot = env.fl ** 0.25;\n\n\tenv.n = env.yb / yw;\n\tenv.z = 1.48 + Math.sqrt(env.n);\n\tenv.nbb = 0.725 * (env.n ** -0.2);\n\tenv.ncb = env.nbb;\n\n\t// Degree of adaptation calculating if not discounting\n\t// illuminant (assumed eye is fully adapted)\n\tconst d = (discounting) ?\n\t\t1 :\n\t\tMath.max(\n\t\t\tMath.min(f * (1 - 1 / 3.6 * Math.exp((-env.la - 42) / 92)), 1),\n\t\t\t0,\n\t\t);\n\tenv.dRgb = rgbW.map(c => {\n\t\treturn interpolate(1, yw / c, d);\n\t});\n\tenv.dRgbInv = env.dRgb.map(c => {\n\t\treturn 1 / c;\n\t});\n\n\t// Achromatic response\n\tconst rgbCW = rgbW.map((c, i) => {\n\t\treturn c * env.dRgb[i];\n\t});\n\tconst rgbAW = adapt(rgbCW, env.fl);\n\tenv.aW = env.nbb * (2 * rgbAW[0] + rgbAW[1] + 0.05 * rgbAW[2]);\n\n\t// console.log(env);\n\n\treturn env;\n}\n\n// Pre-calculate everything we can with the viewing conditions\nconst viewingConditions = environment(\n\twhite,\n\t64 / Math.PI * 0.2, 20,\n\t\"average\",\n\tfalse,\n);\n\nexport function fromCam16 (cam16, env) {\n\n\t// These check ensure one, and only one attribute for a\n\t// given category is provided.\n\tif (!((cam16.J !== undefined) ^ (cam16.Q !== undefined))) {\n\t\tthrow new Error(\"Conversion requires one and only one: 'J' or 'Q'\");\n\t}\n\n\tif (!((cam16.C !== undefined) ^ (cam16.M !== undefined) ^ (cam16.s !== undefined))) {\n\t\tthrow new Error(\"Conversion requires one and only one: 'C', 'M' or 's'\");\n\t}\n\n\t// Hue is absolutely required\n\tif (!((cam16.h !== undefined) ^ (cam16.H !== undefined))) {\n\t\tthrow new Error(\"Conversion requires one and only one: 'h' or 'H'\");\n\t}\n\n\t// Black\n\tif (cam16.J === 0.0 || cam16.Q === 0.0) {\n\t\treturn [0.0, 0.0, 0.0];\n\t}\n\n\t// Break hue into Cartesian components\n\tlet hRad = 0.0;\n\tif (cam16.h !== undefined) {\n\t\thRad = constrain(cam16.h) * deg2rad;\n\t}\n\telse {\n\t\thRad = invHueQuadrature(cam16.H) * deg2rad;\n\t}\n\n\tconst cosh = Math.cos(hRad);\n\tconst sinh = Math.sin(hRad);\n\n\t// Calculate `Jroot` from one of the lightness derived coordinates.\n\tlet Jroot = 0.0;\n\tif (cam16.J !== undefined) {\n\t\tJroot = spow(cam16.J, 1 / 2) * 0.1;\n\t}\n\telse if (cam16.Q !== undefined) {\n\t\tJroot = 0.25 * env.c * cam16.Q / ((env.aW + 4) * env.flRoot);\n\t}\n\n\t// Calculate the `t` value from one of the chroma derived coordinates\n\tlet alpha = 0.0;\n\tif (cam16.C !== undefined) {\n\t\talpha = cam16.C / Jroot;\n\t}\n\telse if (cam16.M !== undefined) {\n\t\talpha = (cam16.M / env.flRoot) / Jroot;\n\t}\n\telse if (cam16.s !== undefined) {\n\t\talpha = 0.0004 * (cam16.s ** 2) * (env.aW + 4) / env.c;\n\t}\n\tconst t = spow(\n\t\talpha * Math.pow(1.64 - Math.pow(0.29, env.n), -0.73),\n\t\t10 / 9,\n\t);\n\n\t// Eccentricity\n\tconst et = 0.25 * (Math.cos(hRad + 2) + 3.8);\n\n\t// Achromatic response\n\tconst A = env.aW * spow(Jroot, 2 / env.c / env.z);\n\n\t// Calculate red-green and yellow-blue components\n\tconst p1 = 5e4 / 13 * env.nc * env.ncb * et;\n\tconst p2 = A / env.nbb;\n\tconst r = (\n\t\t23 * (p2 + 0.305) *\n\t\tzdiv(t, 23 * p1 + t * (11 * cosh + 108 * sinh))\n\t);\n\tconst a = r * cosh;\n\tconst b = r * sinh;\n\n\t// Calculate back from cone response to XYZ\n\tconst rgb_c = unadapt(\n\t\tmultiplyMatrices(m1, [p2, a, b]).map(c => {\n\t\t\treturn c * 1 / 1403;\n\t\t}),\n\t\tenv.fl,\n\t);\n\treturn multiplyMatrices(\n\t\tcat16Inv,\n\t\trgb_c.map((c, i) => {\n\t\t\treturn c * env.dRgbInv[i];\n\t\t}),\n\t).map(c => {\n\t\treturn c / 100;\n\t});\n}\n\n\nexport function toCam16 (xyzd65, env) {\n\t// Cone response\n\tconst xyz100 = xyzd65.map(c => {\n\t\treturn c * 100;\n\t});\n\tconst rgbA = adapt(\n\t\tmultiplyMatrices(cat16, xyz100).map((c, i) => {\n\t\t\treturn c * env.dRgb[i];\n\t\t}),\n\t\tenv.fl,\n\t);\n\n\t// Calculate hue from red-green and yellow-blue components\n\tconst a = rgbA[0] + (-12 * rgbA[1] + rgbA[2]) / 11;\n\tconst b = (rgbA[0] + rgbA[1] - 2 * rgbA[2]) / 9;\n\tconst hRad = ((Math.atan2(b, a) % tau) + tau) % tau;\n\n\t// Eccentricity\n\tconst et = 0.25 * (Math.cos(hRad + 2) + 3.8);\n\n\tconst t = (\n\t\t5e4 / 13 * env.nc * env.ncb *\n\t\tzdiv(\n\t\t\tet * Math.sqrt(a ** 2 + b ** 2),\n\t\t\trgbA[0] + rgbA[1] + 1.05 * rgbA[2] + 0.305,\n\t\t)\n\t);\n\tconst alpha = spow(t, 0.9) * Math.pow(1.64 - Math.pow(0.29, env.n), 0.73);\n\n\t// Achromatic response\n\tconst A = env.nbb * (2 * rgbA[0] + rgbA[1] + 0.05 * rgbA[2]);\n\n\tconst Jroot = spow(A / env.aW, 0.5 * env.c * env.z);\n\n\t// Lightness\n\tconst J = 100 * spow(Jroot, 2);\n\n\t// Brightness\n\tconst Q = (4 / env.c * Jroot * (env.aW + 4) * env.flRoot);\n\n\t// Chroma\n\tconst C = alpha * Jroot;\n\n\t// Colorfulness\n\tconst M = C * env.flRoot;\n\n\t// Hue\n\tconst h = constrain(hRad * rad2deg);\n\n\t// Hue quadrature\n\tconst H = hueQuadrature(h);\n\n\t// Saturation\n\tconst s = 50 * spow(env.c * alpha / (env.aW + 4), 1 / 2);\n\n\t// console.log({J: J, C: C, h: h, s: s, Q: Q, M: M, H: H});\n\n\treturn {J: J, C: C, h: h, s: s, Q: Q, M: M, H: H};\n}\n\n\n// Provided as a way to directly evaluate the CAM16 model\n// https://observablehq.com/@jrus/cam16: reference implementation\n// https://arxiv.org/pdf/1802.06067.pdf: Nico Schlömer\n// https://onlinelibrary.wiley.com/doi/pdf/10.1002/col.22324: hue quadrature\n// https://www.researchgate.net/publication/318152296_Comprehensive_color_solutions_CAM16_CAT16_and_CAM16-UCS\n// Results compared against: https://github.com/colour-science/colour\nexport default new ColorSpace({\n\tid: \"cam16-jmh\",\n\tcssId: \"--cam16-jmh\",\n\tname: \"CAM16-JMh\",\n\tcoords: {\n\t\tj: {\n\t\t\trefRange: [0, 100],\n\t\t\tname: \"J\",\n\t\t},\n\t\tm: {\n\t\t\trefRange: [0, 105.0],\n\t\t\tname: \"Colorfulness\",\n\t\t},\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t},\n\t},\n\n\tbase: xyz_d65,\n\n\tfromBase (xyz) {\n\t\tconst cam16 = toCam16(xyz, viewingConditions);\n\t\treturn [cam16.J, cam16.M, cam16.h];\n\t},\n\ttoBase (cam16) {\n\t\treturn fromCam16(\n\t\t\t{J: cam16[0], M: cam16[1], h: cam16[2]},\n\t\t\tviewingConditions,\n\t\t);\n\t},\n});\n","import ColorSpace from \"../space.js\";\nimport {constrain} from \"../angles.js\";\nimport xyz_d65 from \"./xyz-d65.js\";\nimport {fromCam16, toCam16, environment} from \"./cam16.js\";\nimport {WHITES} from \"../adapt.js\";\n\nconst white = WHITES.D65;\nconst ε = 216 / 24389;  // 6^3/29^3 == (24/116)^3\nconst κ = 24389 / 27;   // 29^3/3^3\n\nfunction toLstar (y) {\n\t// Convert XYZ Y to L*\n\n\tconst fy = (y > ε) ? Math.cbrt(y) : (κ * y + 16) / 116;\n\treturn (116.0 * fy) - 16.0;\n}\n\nfunction fromLstar (lstar) {\n\t// Convert L* back to XYZ Y\n\n\treturn (lstar > 8) ?  Math.pow((lstar + 16) / 116, 3) : lstar / κ;\n}\n\nfunction fromHct (coords, env) {\n\t// Use Newton's method to try and converge as quick as possible or\n\t// converge as close as we can. While the requested precision is achieved\n\t// most of the time, it may not always be achievable. Especially past the\n\t// visible spectrum, the algorithm will likely struggle to get the same\n\t// precision. If, for whatever reason, we cannot achieve the accuracy we\n\t// seek in the allotted iterations, just return the closest we were able to\n\t// get.\n\n\tlet [h, c, t] = coords;\n\tlet xyz = [];\n\tlet j = 0;\n\n\t// Shortcut out for black\n\tif (t === 0) {\n\t\treturn [0.0, 0.0, 0.0];\n\t}\n\n\t// Calculate the Y we need to target\n\tlet y = fromLstar(t);\n\n\t// A better initial guess yields better results. Polynomials come from\n\t// curve fitting the T vs J response.\n\tif (t > 0) {\n\t\tj = 0.00379058511492914 * t ** 2 + 0.608983189401032 * t + 0.9155088574762233;\n\t}\n\telse {\n\t\tj = 9.514440756550361e-06 * t ** 2 + 0.08693057439788597 * t - 21.928975842194614;\n\t}\n\n\t// Threshold of how close is close enough, and max number of attempts.\n\t// More precision and more attempts means more time spent iterating. Higher\n\t// required precision gives more accuracy but also increases the chance of\n\t// not hitting the goal. 2e-12 allows us to convert round trip with\n\t// reasonable accuracy of six decimal places or more.\n\tconst threshold = 2e-12;\n\tconst max_attempts = 15;\n\n\tlet attempt = 0;\n\tlet last = Infinity;\n\tlet best = j;\n\n\t// Try to find a J such that the returned y matches the returned y of the L*\n\twhile (attempt <= max_attempts) {\n\t\txyz = fromCam16({J: j, C: c, h: h}, env);\n\n\t\t// If we are within range, return XYZ\n\t\t// If we are closer than last time, save the values\n\t\tconst delta = Math.abs(xyz[1] - y);\n\t\tif (delta < last) {\n\t\t\tif (delta <= threshold) {\n\t\t\t\treturn xyz;\n\t\t\t}\n\t\t\tbest = j;\n\t\t\tlast = delta;\n\t\t}\n\n\t\t// f(j_root) = (j ** (1 / 2)) * 0.1\n\t\t// f(j) = ((f(j_root) * 100) ** 2) / j - 1 = 0\n\t\t// f(j_root) = Y = y / 100\n\t\t// f(j) = (y ** 2) / j - 1\n\t\t// f'(j) = (2 * y) / j\n\t\tj = j - (xyz[1] - y) * j / (2 * xyz[1]);\n\n\t\tattempt += 1;\n\t}\n\n\t// We could not acquire the precision we desired,\n\t// return our closest attempt.\n\treturn fromCam16({J: j, C: c, h: h}, env);\n}\n\nfunction toHct (xyz, env) {\n\t// Calculate HCT by taking the L* of CIE LCh D65 and CAM16 chroma and hue.\n\n\tconst t = toLstar(xyz[1]);\n\tif (t === 0.0) {\n\t\treturn [0.0, 0.0, 0.0];\n\t}\n\tconst cam16 = toCam16(xyz, viewingConditions);\n\treturn [constrain(cam16.h), cam16.C, t];\n}\n\n// Pre-calculate everything we can with the viewing conditions\nexport const viewingConditions = environment(\n\twhite, 200 / Math.PI * fromLstar(50.0),\n\tfromLstar(50.0) * 100,\n\t\"average\",\n\tfalse,\n);\n\n// https://material.io/blog/science-of-color-design\n// This is not a port of the material-color-utilities,\n// but instead implements the full color space as described,\n// combining CAM16 JCh and Lab D65. This does not clamp conversion\n// to HCT to specific chroma bands and provides support for wider\n// gamuts than Google currently supports and does so at a greater\n// precision (> 8 bits back to sRGB).\n// This implementation comes from https://github.com/facelessuser/coloraide\n// which is licensed under MIT.\nexport default new ColorSpace({\n\tid: \"hct\",\n\tname: \"HCT\",\n\tcoords: {\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t},\n\t\tc: {\n\t\t\trefRange: [0, 145],\n\t\t\tname: \"Colorfulness\",\n\t\t},\n\t\tt: {\n\t\t\trefRange: [0, 100],\n\t\t\tname: \"Tone\",\n\t\t},\n\t},\n\n\tbase: xyz_d65,\n\n\tfromBase (xyz) {\n\t\treturn toHct(xyz, viewingConditions);\n\t},\n\ttoBase (hct) {\n\t\treturn fromHct(hct, viewingConditions);\n\t},\n\tformats: {\n\t\tcolor: {\n\t\t\tid: \"--hct\",\n\t\t\tcoords: [\"<number> | <angle>\", \"<percentage> | <number>\", \"<percentage> | <number>\"],\n\t\t},\n\t},\n});\n","import hct from \"../spaces/hct.js\";\nimport {viewingConditions} from \"../spaces/hct.js\";\nimport getColor from \"../getColor.js\";\n\nconst rad2deg = 180 / Math.PI;\nconst deg2rad = Math.PI / 180;\nconst ucsCoeff = [1.00, 0.007, 0.0228];\n\n/**\n* Convert HCT chroma and hue (CAM16 JMh colorfulness and hue) using UCS logic for a and b.\n* @param {number[]} coords - HCT coordinates.\n* @return {number[]}\n*/\nfunction convertUcsAb (coords) {\n\t// We want the distance between the actual color.\n\t// If chroma is negative, it will throw off our calculations.\n\t// Normally, converting back to the base and forward will correct it.\n\t// If we have a negative chroma after this, then we have a color that\n\t// cannot resolve to positive chroma.\n\tif (coords[1] < 0) {\n\t\tcoords = hct.fromBase(hct.toBase(coords));\n\t}\n\n\t// Only in extreme cases (usually outside the visible spectrum)\n\t// can the input value for log become negative.\n\t// Avoid domain error by forcing a zero result via \"max\" if necessary.\n\tconst M = Math.log(Math.max(1 + ucsCoeff[2] * coords[1] * viewingConditions.flRoot, 1.0)) / ucsCoeff[2];\n\tconst hrad = coords[0] * deg2rad;\n\tconst a = M * Math.cos(hrad);\n\tconst b = M * Math.sin(hrad);\n\n\treturn [coords[2], a, b];\n}\n\n\n/**\n* Color distance using HCT.\n* @param {Color} color - Color to compare.\n* @param {Color} sample - Color to compare.\n* @return {number[]}\n*/\nexport default function (color, sample) {\n\t[color, sample] = getColor([color, sample]);\n\n\tlet [ t1, a1, b1 ] = convertUcsAb(hct.from(color));\n\tlet [ t2, a2, b2 ] = convertUcsAb(hct.from(sample));\n\n\t// Use simple euclidean distance with a and b using UCS conversion\n\t// and LCh lightness (HCT tone).\n\treturn Math.sqrt((t1 - t2) ** 2 + (a1 - a2) ** 2 + (b1 - b2) ** 2);\n}\n","import deltaE76 from \"./deltaE76.js\";\nimport deltaECMC from \"./deltaECMC.js\";\nimport deltaE2000 from \"./deltaE2000.js\";\nimport deltaEJz from \"./deltaEJz.js\";\nimport deltaEITP from \"./deltaEITP.js\";\nimport deltaEOK from \"./deltaEOK.js\";\nimport deltaEHCT from \"./deltaEHCT.js\";\n\nexport {\n\tdeltaE76,\n\tdeltaECMC,\n\tdeltaE2000,\n\tdeltaEJz,\n\tdeltaEITP,\n\tdeltaEOK,\n\tdeltaEHCT,\n};\n\nexport default {\n\tdeltaE76,\n\tdeltaECMC,\n\tdeltaE2000,\n\tdeltaEJz,\n\tdeltaEITP,\n\tdeltaEOK,\n\tdeltaEHCT,\n};\n","import * as util from \"./util.js\";\nimport ColorSpace from \"./space.js\";\nimport defaults from \"./defaults.js\";\nimport deltaE2000 from \"./deltaE/deltaE2000.js\";\nimport deltaEOK from \"./deltaE/deltaEOK.js\";\nimport inGamut from \"./inGamut.js\";\nimport to from \"./to.js\";\nimport get from \"./get.js\";\nimport oklab from \"./spaces/oklab.js\";\nimport set from \"./set.js\";\nimport clone from \"./clone.js\";\nimport getColor from \"./getColor.js\";\nimport deltaEMethods from \"./deltaE/index.js\";\nimport {WHITES} from \"./adapt.js\";\n\n/**\n * Calculate the epsilon to 2 degrees smaller than the specified JND.\n * @param {Number} jnd - The target \"just noticeable difference\".\n * @returns {Number}\n */\nfunction calcEpsilon (jnd) {\n\t// Calculate the epsilon to 2 degrees smaller than the specified JND.\n\n\tconst order = (!jnd) ? 0 : Math.floor(Math.log10(Math.abs(jnd)));\n\t// Limit to an arbitrary value to ensure value is never too small and causes infinite loops.\n\treturn Math.max(parseFloat(`1e${order - 2}`), 1e-6);\n}\n\nconst GMAPPRESET = {\n\t\"hct\": {\n\t\tmethod: \"hct.c\",\n\t\tjnd: 2,\n\t\tdeltaEMethod: \"hct\",\n\t\tblackWhiteClamp: {},\n\t},\n\t\"hct-tonal\": {\n\t\tmethod: \"hct.c\",\n\t\tjnd: 0,\n\t\tdeltaEMethod: \"hct\",\n\t\tblackWhiteClamp: { channel: \"hct.t\", min: 0, max: 100 },\n\t},\n};\n\n/**\n * Force coordinates to be in gamut of a certain color space.\n * Mutates the color it is passed.\n * @param {Object|string} options object or spaceId string\n * @param {string} options.method - How to force into gamut.\n *        If \"clip\", coordinates are just clipped to their reference range.\n *        If \"css\", coordinates are reduced according to the CSS 4 Gamut Mapping Algorithm.\n *        If in the form [colorSpaceId].[coordName], that coordinate is reduced\n *        until the color is in gamut. Please note that this may produce nonsensical\n *        results for certain coordinates (e.g. hue) or infinite loops if reducing the coordinate never brings the color in gamut.\n * @param {ColorSpace|string} options.space - The space whose gamut we want to map to\n * @param {string} options.deltaEMethod - The delta E method to use while performing gamut mapping.\n *        If no method is specified, delta E 2000 is used.\n * @param {Number} options.jnd - The \"just noticeable difference\" to target.\n * @param {Object} options.blackWhiteClamp - Used to configure SDR black and clamping.\n *        \"channel\" indicates the \"space.channel\" to use for determining when to clamp.\n *        \"min\" indicates the lower limit for black clamping and \"max\" indicates the upper\n *        limit for white clamping.\n */\n\nexport default function toGamut (\n\tcolor,\n\t{\n\t\tmethod = defaults.gamut_mapping,\n\t\tspace = undefined,\n\t\tdeltaEMethod = \"\",\n\t\tjnd = 2,\n\t\tblackWhiteClamp = {},\n\t} = {},\n) {\n\tcolor = getColor(color);\n\n\tif (util.isString(arguments[1])) {\n\t\tspace = arguments[1];\n\t}\n\telse if (!space) {\n\t\tspace = color.space;\n\t}\n\n\tspace = ColorSpace.get(space);\n\n\t// 3 spaces:\n\t// color.space: current color space\n\t// space: space whose gamut we are mapping to\n\t// mapSpace: space with the coord we're reducing\n\n\tif (inGamut(color, space, { epsilon: 0 })) {\n\t\treturn color;\n\t}\n\n\tlet spaceColor;\n\tif (method === \"css\") {\n\t\tspaceColor = toGamutCSS(color, { space });\n\t}\n\telse {\n\t\tif (method !== \"clip\" && !inGamut(color, space)) {\n\n\t\t\tif (Object.prototype.hasOwnProperty.call(GMAPPRESET, method)) {\n\t\t\t\t({method, jnd, deltaEMethod, blackWhiteClamp} = GMAPPRESET[method]);\n\t\t\t}\n\n\t\t\t// Get the correct delta E method\n\t\t\tlet de = deltaE2000;\n\t\t\tif (deltaEMethod !== \"\") {\n\t\t\t\tfor (let m in deltaEMethods) {\n\t\t\t\t\tif (\"deltae\" + deltaEMethod.toLowerCase() === m.toLowerCase()) {\n\t\t\t\t\t\tde = deltaEMethods[m];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet clipped = toGamut(to(color, space), { method: \"clip\", space });\n\t\t\tif (de(color, clipped) > jnd) {\n\n\t\t\t\t// Clamp to SDR white and black if required\n\t\t\t\tif (Object.keys(blackWhiteClamp).length === 3) {\n\t\t\t\t\tlet channelMeta = ColorSpace.resolveCoord(blackWhiteClamp.channel);\n\t\t\t\t\tlet channel = get(to(color, channelMeta.space), channelMeta.id);\n\t\t\t\t\tif (util.isNone(channel)) {\n\t\t\t\t\t\tchannel = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (channel >= blackWhiteClamp.max) {\n\t\t\t\t\t\treturn to({ space: \"xyz-d65\", coords: WHITES[\"D65\"] }, color.space);\n\t\t\t\t\t}\n\t\t\t\t\telse if (channel <= blackWhiteClamp.min) {\n\t\t\t\t\t\treturn to({ space: \"xyz-d65\", coords: [0, 0, 0] }, color.space);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Reduce a coordinate of a certain color space until the color is in gamut\n\t\t\t\tlet coordMeta = ColorSpace.resolveCoord(method);\n\t\t\t\tlet mapSpace = coordMeta.space;\n\t\t\t\tlet coordId = coordMeta.id;\n\n\t\t\t\tlet mappedColor = to(color, mapSpace);\n\t\t\t\t// If we were already in the mapped color space, we need to resolve undefined channels\n\t\t\t\tmappedColor.coords.forEach((c, i) => {\n\t\t\t\t\tif (util.isNone(c)) {\n\t\t\t\t\t\tmappedColor.coords[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tlet bounds = coordMeta.range || coordMeta.refRange;\n\t\t\t\tlet min = bounds[0];\n\t\t\t\tlet ε = calcEpsilon(jnd);\n\t\t\t\tlet low = min;\n\t\t\t\tlet high = get(mappedColor, coordId);\n\n\t\t\t\twhile (high - low > ε) {\n\t\t\t\t\tlet clipped = clone(mappedColor);\n\t\t\t\t\tclipped = toGamut(clipped, { space, method: \"clip\" });\n\t\t\t\t\tlet deltaE = de(mappedColor, clipped);\n\n\t\t\t\t\tif (deltaE - jnd < ε) {\n\t\t\t\t\t\tlow = get(mappedColor, coordId);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\thigh = get(mappedColor, coordId);\n\t\t\t\t\t}\n\n\t\t\t\t\tset(mappedColor, coordId, (low + high) / 2);\n\t\t\t\t}\n\n\t\t\t\tspaceColor = to(mappedColor, space);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tspaceColor = clipped;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tspaceColor = to(color, space);\n\t\t}\n\n\t\tif (method === \"clip\" // Dumb coord clipping\n\t\t\t// finish off smarter gamut mapping with clip to get rid of ε, see #17\n\t\t\t|| !inGamut(spaceColor, space, { epsilon: 0 })\n\t\t) {\n\t\t\tlet bounds = Object.values(space.coords).map(c => c.range || []);\n\n\t\t\tspaceColor.coords = spaceColor.coords.map((c, i) => {\n\t\t\t\tlet [min, max] = bounds[i];\n\n\t\t\t\tif (min !== undefined) {\n\t\t\t\t\tc = Math.max(min, c);\n\t\t\t\t}\n\n\t\t\t\tif (max !== undefined) {\n\t\t\t\t\tc = Math.min(c, max);\n\t\t\t\t}\n\n\t\t\t\treturn c;\n\t\t\t});\n\t\t}\n\t}\n\n\tif (space !== color.space) {\n\t\tspaceColor = to(spaceColor, color.space);\n\t}\n\n\tcolor.coords = spaceColor.coords;\n\treturn color;\n}\n\ntoGamut.returns = \"color\";\n\n// The reference colors to be used if lightness is out of the range 0-1 in the\n// `Oklch` space. These are created in the `Oklab` space, as it is used by the\n// DeltaEOK calculation, so it is guaranteed to be imported.\nconst COLORS = {\n\tWHITE: { space: oklab, coords: [1, 0, 0] },\n\tBLACK: { space: oklab, coords: [0, 0, 0] },\n};\n\n/**\n * Given a color `origin`, returns a new color that is in gamut using\n * the CSS Gamut Mapping Algorithm. If `space` is specified, it will be in gamut\n * in `space`, and returned in `space`. Otherwise, it will be in gamut and\n * returned in the color space of `origin`.\n * @param {Object} origin\n * @param {Object} options\n * @param {ColorSpace|string} options.space\n * @returns {Color}\n */\nexport function toGamutCSS (origin, {space} = {}) {\n\tconst JND = 0.02;\n\tconst ε = 0.0001;\n\n\torigin = getColor(origin);\n\n\tif (!space) {\n\t\tspace = origin.space;\n\t}\n\n\tspace = ColorSpace.get(space);\n\tconst oklchSpace = ColorSpace.get(\"oklch\");\n\n\tif (space.isUnbounded) {\n\t\treturn to(origin, space);\n\t}\n\n\tconst origin_OKLCH = to(origin, oklchSpace);\n\tlet L = origin_OKLCH.coords[0];\n\n\t// return media white or black, if lightness is out of range\n\tif (L >= 1) {\n\t\tconst white = to(COLORS.WHITE, space);\n\t\twhite.alpha = origin.alpha;\n\t\treturn to(white, space);\n\t}\n\tif (L <= 0) {\n\t\tconst black = to(COLORS.BLACK, space);\n\t\tblack.alpha = origin.alpha;\n\t\treturn to(black, space);\n\t}\n\n\tif (inGamut(origin_OKLCH, space, {epsilon: 0})) {\n\t\treturn to(origin_OKLCH, space);\n\t}\n\n\tfunction clip (_color) {\n\t\tconst destColor = to(_color, space);\n\t\tconst spaceCoords = Object.values(space.coords);\n\t\tdestColor.coords = destColor.coords.map((coord, index) => {\n\t\t\tif (\"range\" in spaceCoords[index]) {\n\t\t\t\tconst [min, max] =  spaceCoords[index].range;\n\t\t\t\treturn util.clamp(min, coord, max);\n\t\t\t}\n\t\t\treturn coord;\n\t\t});\n\t\treturn destColor;\n\t}\n\tlet min = 0;\n\tlet max = origin_OKLCH.coords[1];\n\tlet min_inGamut = true;\n\tlet current = clone(origin_OKLCH);\n\tlet clipped = clip(current);\n\n\tlet E = deltaEOK(clipped, current);\n\tif (E < JND) {\n\t\treturn clipped;\n\t}\n\n\twhile ((max - min) > ε) {\n\t\tconst chroma = (min + max) / 2;\n\t\tcurrent.coords[1] = chroma;\n\t\tif (min_inGamut && inGamut(current, space, {epsilon: 0})) {\n\t\t\tmin = chroma;\n\t\t}\n\t\telse {\n\t\t\tclipped = clip(current);\n\t\t\tE = deltaEOK(clipped, current);\n\t\t\tif (E < JND) {\n\t\t\t\tif ((JND - E < ε)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmin_inGamut = false;\n\t\t\t\t\tmin = chroma;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmax = chroma;\n\t\t\t}\n\t\t}\n\t}\n\treturn clipped;\n}\n","import getColor from \"./getColor.js\";\nimport ColorSpace from \"./space.js\";\nimport toGamut from \"./toGamut.js\";\n\n/**\n * Convert to color space and return a new color\n * @param {Object|string} space - Color space object or id\n * @param {Object} options\n * @param {boolean} options.inGamut - Whether to force resulting color in gamut\n * @returns {Color}\n */\nexport default function to (color, space, {inGamut} = {}) {\n\tcolor = getColor(color);\n\tspace = ColorSpace.get(space);\n\n\tlet coords = space.from(color);\n\tlet ret = {space, coords, alpha: color.alpha};\n\n\tif (inGamut) {\n\t\tret = toGamut(ret, inGamut === true ? undefined : inGamut);\n\t}\n\n\treturn ret;\n}\n\nto.returns = \"color\";\n","import * as util from \"./util.js\";\nimport ColorSpace from \"./space.js\";\nimport defaults from \"./defaults.js\";\nimport getColor from \"./getColor.js\";\nimport checkInGamut from \"./inGamut.js\";\nimport toGamut from \"./toGamut.js\";\nimport clone from \"./clone.js\";\n\n/**\n * Generic toString() method, outputs a color(spaceId ...coords) function, a functional syntax, or custom formats defined by the color space\n * @param {Object} options\n * @param {number} options.precision - Significant digits\n * @param {boolean} options.inGamut - Adjust coordinates to fit in gamut first? [default: false]\n */\nexport default function serialize (color, {\n\tprecision = defaults.precision,\n\tformat = \"default\",\n\tinGamut = true,\n\t...customOptions\n} = {}) {\n\tlet ret;\n\n\tcolor = getColor(color);\n\n\tlet formatId = format;\n\tformat = color.space.getFormat(format)\n\t       ?? color.space.getFormat(\"default\")\n\t       ?? ColorSpace.DEFAULT_FORMAT;\n\n\t// The assignment to coords and inGamut needs to stay in the order they are now\n\t// The order of the assignment was changed as a workaround for a bug in Next.js\n\t// See this issue for details: https://github.com/color-js/color.js/issues/260\n\n\tlet coords = color.coords.slice(); // clone so we can manipulate it\n\n\tinGamut ||= format.toGamut;\n\n\tif (inGamut && !checkInGamut(color)) {\n\t\t// FIXME what happens if the color contains NaNs?\n\t\tcoords = toGamut(clone(color), inGamut === true ? undefined : inGamut).coords;\n\t}\n\n\tif (format.type === \"custom\") {\n\t\tcustomOptions.precision = precision;\n\n\t\tif (format.serialize) {\n\t\t\tret = format.serialize(coords, color.alpha, customOptions);\n\t\t}\n\t\telse {\n\t\t\tthrow new TypeError(`format ${formatId} can only be used to parse colors, not for serialization`);\n\t\t}\n\t}\n\telse {\n\t\t// Functional syntax\n\t\tlet name = format.name || \"color\";\n\n\t\tif (format.serializeCoords) {\n\t\t\tcoords = format.serializeCoords(coords, precision);\n\t\t}\n\t\telse {\n\t\t\tif (precision !== null) {\n\t\t\t\tcoords = coords.map(c => {\n\t\t\t\t\treturn util.serializeNumber(c, {precision});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tlet args = [...coords];\n\n\t\tif (name === \"color\") {\n\t\t\t// If output is a color() function, add colorspace id as first argument\n\t\t\tlet cssId = format.id || format.ids?.[0] || color.space.id;\n\t\t\targs.unshift(cssId);\n\t\t}\n\n\t\tlet alpha = color.alpha;\n\t\tif (precision !== null) {\n\t\t\talpha = util.serializeNumber(alpha, {precision});\n\t\t}\n\n\t\tlet strAlpha = color.alpha >= 1 || format.noAlpha ? \"\" : `${format.commas ? \",\" : \" /\"} ${alpha}`;\n\t\tret = `${name}(${args.join(format.commas ? \", \" : \" \")}${strAlpha})`;\n\t}\n\n\treturn ret;\n}\n","import RGBColorSpace from \"../rgbspace.js\";\n\n// convert an array of linear-light rec2020 values to CIE XYZ\n// using  D65 (no chromatic adaptation)\n// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n// 0 is actually calculated as  4.994106574466076e-17\nconst toXYZ_M = [\n\t[ 0.6369580483012914, 0.14461690358620832,  0.1688809751641721  ],\n\t[ 0.2627002120112671, 0.6779980715188708,   0.05930171646986196 ],\n\t[ 0.000000000000000,  0.028072693049087428, 1.060985057710791   ],\n];\n\n// from ITU-R BT.2124-0 Annex 2 p.3\nconst fromXYZ_M = [\n\t[  1.716651187971268,  -0.355670783776392, -0.253366281373660  ],\n\t[ -0.666684351832489,   1.616481236634939,  0.0157685458139111 ],\n\t[  0.017639857445311,  -0.042770613257809,  0.942103121235474  ],\n];\n\nexport default new RGBColorSpace({\n\tid: \"rec2020-linear\",\n\tcssId: \"--rec2020-linear\",\n\tname: \"Linear REC.2020\",\n\twhite: \"D65\",\n\ttoXYZ_M,\n\tfromXYZ_M,\n});\n","import RGBColorSpace from \"../rgbspace.js\";\nimport REC2020Linear from \"./rec2020-linear.js\";\n// import sRGB from \"./srgb.js\";\n\nconst α = 1.09929682680944;\nconst β = 0.018053968510807;\n\nexport default new RGBColorSpace({\n\tid: \"rec2020\",\n\tname: \"REC.2020\",\n\tbase: REC2020Linear,\n\t// Non-linear transfer function from Rec. ITU-R BT.2020-2 table 4\n\ttoBase (RGB) {\n\t\treturn RGB.map(function (val) {\n\t\t\tif (val < β * 4.5) {\n\t\t\t\treturn val / 4.5;\n\t\t\t}\n\n\t\t\treturn Math.pow((val + α - 1) / α, 1 / 0.45);\n\t\t});\n\t},\n\tfromBase (RGB) {\n\t\treturn RGB.map(function (val) {\n\t\t\tif (val >= β) {\n\t\t\t\treturn α * Math.pow(val, 0.45) - (α - 1);\n\t\t\t}\n\n\t\t\treturn 4.5 * val;\n\t\t});\n\t},\n});\n","import RGBColorSpace from \"../rgbspace.js\";\n\nconst toXYZ_M = [\n\t[0.4865709486482162, 0.26566769316909306, 0.1982172852343625],\n\t[0.2289745640697488, 0.6917385218365064,  0.079286914093745],\n\t[0.0000000000000000, 0.04511338185890264, 1.043944368900976],\n];\n\nconst fromXYZ_M = [\n\t[ 2.493496911941425,   -0.9313836179191239, -0.40271078445071684],\n\t[-0.8294889695615747,   1.7626640603183463,  0.023624685841943577],\n\t[ 0.03584583024378447, -0.07617238926804182, 0.9568845240076872],\n];\n\nexport default new RGBColorSpace({\n\tid: \"p3-linear\",\n\tcssId: \"--display-p3-linear\",\n\tname: \"Linear P3\",\n\twhite: \"D65\",\n\ttoXYZ_M,\n\tfromXYZ_M,\n});\n","import RGBColorSpace from \"../rgbspace.js\";\n\n// This is the linear-light version of sRGB\n// as used for example in SVG filters\n// or in Canvas\n\n// This matrix was calculated directly from the RGB and white chromaticities\n// when rounded to 8 decimal places, it agrees completely with the official matrix\n// see https://github.com/w3c/csswg-drafts/issues/5922\nconst toXYZ_M = [\n\t[ 0.41239079926595934, 0.357584339383878,   0.1804807884018343  ],\n\t[ 0.21263900587151027, 0.715168678767756,   0.07219231536073371 ],\n\t[ 0.01933081871559182, 0.11919477979462598, 0.9505321522496607  ],\n];\n\n// This matrix is the inverse of the above;\n// again it agrees with the official definition when rounded to 8 decimal places\nexport const fromXYZ_M = [\n\t[  3.2409699419045226,  -1.537383177570094,   -0.4986107602930034  ],\n\t[ -0.9692436362808796,   1.8759675015077202,   0.04155505740717559 ],\n\t[  0.05563007969699366, -0.20397695888897652,  1.0569715142428786  ],\n];\n\nexport default new RGBColorSpace({\n\tid: \"srgb-linear\",\n\tname: \"Linear sRGB\",\n\twhite: \"D65\",\n\ttoXYZ_M,\n\tfromXYZ_M,\n});\n","/* List of CSS color keywords\n * Note that this does not include currentColor, transparent,\n * or system colors\n */\n\n// To produce: Visit https://www.w3.org/TR/css-color-4/#named-colors\n// and run in the console:\n// copy($$(\"tr\", $(\".named-color-table tbody\")).map(tr => `\"${tr.cells[2].textContent.trim()}\": [${tr.cells[4].textContent.trim().split(/\\s+/).map(c => c === \"0\"? \"0\" : c === \"255\"? \"1\" : c + \" / 255\").join(\", \")}]`).join(\",\\n\"))\nexport default {\n\t\"aliceblue\": [240 / 255, 248 / 255, 1],\n\t\"antiquewhite\": [250 / 255, 235 / 255, 215 / 255],\n\t\"aqua\": [0, 1, 1],\n\t\"aquamarine\": [127 / 255, 1, 212 / 255],\n\t\"azure\": [240 / 255, 1, 1],\n\t\"beige\": [245 / 255, 245 / 255, 220 / 255],\n\t\"bisque\": [1, 228 / 255, 196 / 255],\n\t\"black\": [0, 0, 0],\n\t\"blanchedalmond\": [1, 235 / 255, 205 / 255],\n\t\"blue\": [0, 0, 1],\n\t\"blueviolet\": [138 / 255, 43 / 255, 226 / 255],\n\t\"brown\": [165 / 255, 42 / 255, 42 / 255],\n\t\"burlywood\": [222 / 255, 184 / 255, 135 / 255],\n\t\"cadetblue\": [95 / 255, 158 / 255, 160 / 255],\n\t\"chartreuse\": [127 / 255, 1, 0],\n\t\"chocolate\": [210 / 255, 105 / 255, 30 / 255],\n\t\"coral\": [1, 127 / 255, 80 / 255],\n\t\"cornflowerblue\": [100 / 255, 149 / 255, 237 / 255],\n\t\"cornsilk\": [1, 248 / 255, 220 / 255],\n\t\"crimson\": [220 / 255, 20 / 255, 60 / 255],\n\t\"cyan\": [0, 1, 1],\n\t\"darkblue\": [0, 0, 139 / 255],\n\t\"darkcyan\": [0, 139 / 255, 139 / 255],\n\t\"darkgoldenrod\": [184 / 255, 134 / 255, 11 / 255],\n\t\"darkgray\": [169 / 255, 169 / 255, 169 / 255],\n\t\"darkgreen\": [0, 100 / 255, 0],\n\t\"darkgrey\": [169 / 255, 169 / 255, 169 / 255],\n\t\"darkkhaki\": [189 / 255, 183 / 255, 107 / 255],\n\t\"darkmagenta\": [139 / 255, 0, 139 / 255],\n\t\"darkolivegreen\": [85 / 255, 107 / 255, 47 / 255],\n\t\"darkorange\": [1, 140 / 255, 0],\n\t\"darkorchid\": [153 / 255, 50 / 255, 204 / 255],\n\t\"darkred\": [139 / 255, 0, 0],\n\t\"darksalmon\": [233 / 255, 150 / 255, 122 / 255],\n\t\"darkseagreen\": [143 / 255, 188 / 255, 143 / 255],\n\t\"darkslateblue\": [72 / 255, 61 / 255, 139 / 255],\n\t\"darkslategray\": [47 / 255, 79 / 255, 79 / 255],\n\t\"darkslategrey\": [47 / 255, 79 / 255, 79 / 255],\n\t\"darkturquoise\": [0, 206 / 255, 209 / 255],\n\t\"darkviolet\": [148 / 255, 0, 211 / 255],\n\t\"deeppink\": [1, 20 / 255, 147 / 255],\n\t\"deepskyblue\": [0, 191 / 255, 1],\n\t\"dimgray\": [105 / 255, 105 / 255, 105 / 255],\n\t\"dimgrey\": [105 / 255, 105 / 255, 105 / 255],\n\t\"dodgerblue\": [30 / 255, 144 / 255, 1],\n\t\"firebrick\": [178 / 255, 34 / 255, 34 / 255],\n\t\"floralwhite\": [1, 250 / 255, 240 / 255],\n\t\"forestgreen\": [34 / 255, 139 / 255, 34 / 255],\n\t\"fuchsia\": [1, 0, 1],\n\t\"gainsboro\": [220 / 255, 220 / 255, 220 / 255],\n\t\"ghostwhite\": [248 / 255, 248 / 255, 1],\n\t\"gold\": [1, 215 / 255, 0],\n\t\"goldenrod\": [218 / 255, 165 / 255, 32 / 255],\n\t\"gray\": [128 / 255, 128 / 255, 128 / 255],\n\t\"green\": [0, 128 / 255, 0],\n\t\"greenyellow\": [173 / 255, 1, 47 / 255],\n\t\"grey\": [128 / 255, 128 / 255, 128 / 255],\n\t\"honeydew\": [240 / 255, 1, 240 / 255],\n\t\"hotpink\": [1, 105 / 255, 180 / 255],\n\t\"indianred\": [205 / 255, 92 / 255, 92 / 255],\n\t\"indigo\": [75 / 255, 0, 130 / 255],\n\t\"ivory\": [1, 1, 240 / 255],\n\t\"khaki\": [240 / 255, 230 / 255, 140 / 255],\n\t\"lavender\": [230 / 255, 230 / 255, 250 / 255],\n\t\"lavenderblush\": [1, 240 / 255, 245 / 255],\n\t\"lawngreen\": [124 / 255, 252 / 255, 0],\n\t\"lemonchiffon\": [1, 250 / 255, 205 / 255],\n\t\"lightblue\": [173 / 255, 216 / 255, 230 / 255],\n\t\"lightcoral\": [240 / 255, 128 / 255, 128 / 255],\n\t\"lightcyan\": [224 / 255, 1, 1],\n\t\"lightgoldenrodyellow\": [250 / 255, 250 / 255, 210 / 255],\n\t\"lightgray\": [211 / 255, 211 / 255, 211 / 255],\n\t\"lightgreen\": [144 / 255, 238 / 255, 144 / 255],\n\t\"lightgrey\": [211 / 255, 211 / 255, 211 / 255],\n\t\"lightpink\": [1, 182 / 255, 193 / 255],\n\t\"lightsalmon\": [1, 160 / 255, 122 / 255],\n\t\"lightseagreen\": [32 / 255, 178 / 255, 170 / 255],\n\t\"lightskyblue\": [135 / 255, 206 / 255, 250 / 255],\n\t\"lightslategray\": [119 / 255, 136 / 255, 153 / 255],\n\t\"lightslategrey\": [119 / 255, 136 / 255, 153 / 255],\n\t\"lightsteelblue\": [176 / 255, 196 / 255, 222 / 255],\n\t\"lightyellow\": [1, 1, 224 / 255],\n\t\"lime\": [0, 1, 0],\n\t\"limegreen\": [50 / 255, 205 / 255, 50 / 255],\n\t\"linen\": [250 / 255, 240 / 255, 230 / 255],\n\t\"magenta\": [1, 0, 1],\n\t\"maroon\": [128 / 255, 0, 0],\n\t\"mediumaquamarine\": [102 / 255, 205 / 255, 170 / 255],\n\t\"mediumblue\": [0, 0, 205 / 255],\n\t\"mediumorchid\": [186 / 255, 85 / 255, 211 / 255],\n\t\"mediumpurple\": [147 / 255, 112 / 255, 219 / 255],\n\t\"mediumseagreen\": [60 / 255, 179 / 255, 113 / 255],\n\t\"mediumslateblue\": [123 / 255, 104 / 255, 238 / 255],\n\t\"mediumspringgreen\": [0, 250 / 255, 154 / 255],\n\t\"mediumturquoise\": [72 / 255, 209 / 255, 204 / 255],\n\t\"mediumvioletred\": [199 / 255, 21 / 255, 133 / 255],\n\t\"midnightblue\": [25 / 255, 25 / 255, 112 / 255],\n\t\"mintcream\": [245 / 255, 1, 250 / 255],\n\t\"mistyrose\": [1, 228 / 255, 225 / 255],\n\t\"moccasin\": [1, 228 / 255, 181 / 255],\n\t\"navajowhite\": [1, 222 / 255, 173 / 255],\n\t\"navy\": [0, 0, 128 / 255],\n\t\"oldlace\": [253 / 255, 245 / 255, 230 / 255],\n\t\"olive\": [128 / 255, 128 / 255, 0],\n\t\"olivedrab\": [107 / 255, 142 / 255, 35 / 255],\n\t\"orange\": [1, 165 / 255, 0],\n\t\"orangered\": [1, 69 / 255, 0],\n\t\"orchid\": [218 / 255, 112 / 255, 214 / 255],\n\t\"palegoldenrod\": [238 / 255, 232 / 255, 170 / 255],\n\t\"palegreen\": [152 / 255, 251 / 255, 152 / 255],\n\t\"paleturquoise\": [175 / 255, 238 / 255, 238 / 255],\n\t\"palevioletred\": [219 / 255, 112 / 255, 147 / 255],\n\t\"papayawhip\": [1, 239 / 255, 213 / 255],\n\t\"peachpuff\": [1, 218 / 255, 185 / 255],\n\t\"peru\": [205 / 255, 133 / 255, 63 / 255],\n\t\"pink\": [1, 192 / 255, 203 / 255],\n\t\"plum\": [221 / 255, 160 / 255, 221 / 255],\n\t\"powderblue\": [176 / 255, 224 / 255, 230 / 255],\n\t\"purple\": [128 / 255, 0, 128 / 255],\n\t\"rebeccapurple\": [102 / 255, 51 / 255, 153 / 255],\n\t\"red\": [1, 0, 0],\n\t\"rosybrown\": [188 / 255, 143 / 255, 143 / 255],\n\t\"royalblue\": [65 / 255, 105 / 255, 225 / 255],\n\t\"saddlebrown\": [139 / 255, 69 / 255, 19 / 255],\n\t\"salmon\": [250 / 255, 128 / 255, 114 / 255],\n\t\"sandybrown\": [244 / 255, 164 / 255, 96 / 255],\n\t\"seagreen\": [46 / 255, 139 / 255, 87 / 255],\n\t\"seashell\": [1, 245 / 255, 238 / 255],\n\t\"sienna\": [160 / 255, 82 / 255, 45 / 255],\n\t\"silver\": [192 / 255, 192 / 255, 192 / 255],\n\t\"skyblue\": [135 / 255, 206 / 255, 235 / 255],\n\t\"slateblue\": [106 / 255, 90 / 255, 205 / 255],\n\t\"slategray\": [112 / 255, 128 / 255, 144 / 255],\n\t\"slategrey\": [112 / 255, 128 / 255, 144 / 255],\n\t\"snow\": [1, 250 / 255, 250 / 255],\n\t\"springgreen\": [0, 1, 127 / 255],\n\t\"steelblue\": [70 / 255, 130 / 255, 180 / 255],\n\t\"tan\": [210 / 255, 180 / 255, 140 / 255],\n\t\"teal\": [0, 128 / 255, 128 / 255],\n\t\"thistle\": [216 / 255, 191 / 255, 216 / 255],\n\t\"tomato\": [1, 99 / 255, 71 / 255],\n\t\"turquoise\": [64 / 255, 224 / 255, 208 / 255],\n\t\"violet\": [238 / 255, 130 / 255, 238 / 255],\n\t\"wheat\": [245 / 255, 222 / 255, 179 / 255],\n\t\"white\": [1, 1, 1],\n\t\"whitesmoke\": [245 / 255, 245 / 255, 245 / 255],\n\t\"yellow\": [1, 1, 0],\n\t\"yellowgreen\": [154 / 255, 205 / 255, 50 / 255],\n};\n","import RGBColorSpace from \"../rgbspace.js\";\nimport sRGBLinear from \"./srgb-linear.js\";\nimport KEYWORDS from \"../keywords.js\";\n\nlet coordGrammar = Array(3).fill(\"<percentage> | <number>[0, 255]\");\nlet coordGrammarNumber = Array(3).fill(\"<number>[0, 255]\");\n\nexport default new RGBColorSpace({\n\tid: \"srgb\",\n\tname: \"sRGB\",\n\tbase: sRGBLinear,\n\tfromBase: rgb => {\n\t\t// convert an array of linear-light sRGB values in the range 0.0-1.0\n\t\t// to gamma corrected form\n\t\t// https://en.wikipedia.org/wiki/SRGB\n\t\treturn rgb.map(val => {\n\t\t\tlet sign = val < 0 ? -1 : 1;\n\t\t\tlet abs = val * sign;\n\n\t\t\tif (abs > 0.0031308) {\n\t\t\t\treturn sign * (1.055 * (abs ** (1 / 2.4)) - 0.055);\n\t\t\t}\n\n\t\t\treturn 12.92 * val;\n\t\t});\n\t},\n\ttoBase: rgb => {\n\t\t// convert an array of sRGB values in the range 0.0 - 1.0\n\t\t// to linear light (un-companded) form.\n\t\t// https://en.wikipedia.org/wiki/SRGB\n\t\treturn rgb.map(val => {\n\t\t\tlet sign = val < 0 ? -1 : 1;\n\t\t\tlet abs = val * sign;\n\n\t\t\tif (abs <= 0.04045) {\n\t\t\t\treturn val / 12.92;\n\t\t\t}\n\n\t\t\treturn sign * (((abs + 0.055) / 1.055) ** 2.4);\n\t\t});\n\t},\n\tformats: {\n\t\t\"rgb\": {\n\t\t\tcoords: coordGrammar,\n\t\t},\n\t\t\"rgb_number\": {\n\t\t\tname: \"rgb\",\n\t\t\tcommas: true,\n\t\t\tcoords: coordGrammarNumber,\n\t\t\tnoAlpha: true,\n\t\t},\n\t\t\"color\": { /* use defaults */ },\n\t\t\"rgba\": {\n\t\t\tcoords: coordGrammar,\n\t\t\tcommas: true,\n\t\t\tlastAlpha: true,\n\t\t},\n\t\t\"rgba_number\": {\n\t\t\tname: \"rgba\",\n\t\t\tcommas: true,\n\t\t\tcoords: coordGrammarNumber,\n\t\t},\n\t\t\"hex\": {\n\t\t\ttype: \"custom\",\n\t\t\ttoGamut: true,\n\t\t\ttest: str => /^#([a-f0-9]{3,4}){1,2}$/i.test(str),\n\t\t\tparse (str) {\n\t\t\t\tif (str.length <= 5) {\n\t\t\t\t\t// #rgb or #rgba, duplicate digits\n\t\t\t\t\tstr = str.replace(/[a-f0-9]/gi, \"$&$&\");\n\t\t\t\t}\n\n\t\t\t\tlet rgba = [];\n\t\t\t\tstr.replace(/[a-f0-9]{2}/gi, component => {\n\t\t\t\t\trgba.push(parseInt(component, 16) / 255);\n\t\t\t\t});\n\n\t\t\t\treturn {\n\t\t\t\t\tspaceId: \"srgb\",\n\t\t\t\t\tcoords: rgba.slice(0, 3),\n\t\t\t\t\talpha: rgba.slice(3)[0],\n\t\t\t\t};\n\t\t\t},\n\t\t\tserialize: (coords, alpha, {\n\t\t\t\tcollapse = true, // collapse to 3-4 digit hex when possible?\n\t\t\t} = {}) => {\n\t\t\t\tif (alpha < 1) {\n\t\t\t\t\tcoords.push(alpha);\n\t\t\t\t}\n\n\t\t\t\tcoords = coords.map(c => Math.round(c * 255));\n\n\t\t\t\tlet collapsible = collapse && coords.every(c => c % 17 === 0);\n\n\t\t\t\tlet hex = coords.map(c => {\n\t\t\t\t\tif (collapsible) {\n\t\t\t\t\t\treturn (c / 17).toString(16);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn c.toString(16).padStart(2, \"0\");\n\t\t\t\t}).join(\"\");\n\n\t\t\t\treturn \"#\" + hex;\n\t\t\t},\n\t\t},\n\t\t\"keyword\": {\n\t\t\ttype: \"custom\",\n\t\t\ttest: str => /^[a-z]+$/i.test(str),\n\t\t\tparse (str) {\n\t\t\t\tstr = str.toLowerCase();\n\t\t\t\tlet ret = {spaceId: \"srgb\", coords: null, alpha: 1};\n\n\t\t\t\tif (str === \"transparent\") {\n\t\t\t\t\tret.coords = KEYWORDS.black;\n\t\t\t\t\tret.alpha = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret.coords = KEYWORDS[str];\n\t\t\t\t}\n\n\t\t\t\tif (ret.coords) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t},\n});\n","import RGBColorSpace from \"../rgbspace.js\";\nimport P3Linear from \"./p3-linear.js\";\nimport sRGB from \"./srgb.js\";\n\nexport default new RGBColorSpace({\n\tid: \"p3\",\n\tcssId: \"display-p3\",\n\tname: \"P3\",\n\tbase: P3Linear,\n\t// Gamma encoding/decoding is the same as sRGB\n\tfromBase: sRGB.fromBase,\n\ttoBase: sRGB.toBase,\n});\n","import { isNone, skipNone } from \"./util.js\";\nimport defaults from \"./defaults.js\";\nimport to from \"./to.js\";\nimport serialize from \"./serialize.js\";\nimport clone from \"./clone.js\";\nimport REC2020 from \"./spaces/rec2020.js\";\nimport P3 from \"./spaces/p3.js\";\nimport Lab from \"./spaces/lab.js\";\nimport sRGB from \"./spaces/srgb.js\";\n\n// Default space for CSS output. Code in Color.js makes this wider if there's a DOM available\ndefaults.display_space = sRGB;\n\nlet supportsNone;\n\nif (typeof CSS !== \"undefined\" && CSS.supports) {\n\t// Find widest supported color space for CSS\n\tfor (let space of [Lab, REC2020, P3]) {\n\t\tlet coords = space.getMinCoords();\n\t\tlet color = {space, coords, alpha: 1};\n\t\tlet str = serialize(color);\n\n\t\tif (CSS.supports(\"color\", str)) {\n\t\t\tdefaults.display_space = space;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * Returns a serialization of the color that can actually be displayed in the browser.\n * If the default serialization can be displayed, it is returned.\n * Otherwise, the color is converted to Lab, REC2020, or P3, whichever is the widest supported.\n * In Node.js, this is basically equivalent to `serialize()` but returns a `String` object instead.\n *\n * @export\n * @param {{space, coords} | Color | string} color\n * @param {*} [options={}] Options to be passed to serialize()\n * @param {ColorSpace | string} [options.space = defaults.display_space] Color space to use for serialization if default is not supported\n * @returns {String} String object containing the serialized color with a color property containing the converted color (or the original, if no conversion was necessary)\n */\nexport default function display (color, {space = defaults.display_space, ...options} = {}) {\n\tlet ret = serialize(color, options);\n\n\tif (typeof CSS === \"undefined\" || CSS.supports(\"color\", ret) || !defaults.display_space) {\n\t\tret = new String(ret);\n\t\tret.color = color;\n\t}\n\telse {\n\t\t// If we're here, what we were about to output is not supported\n\t\tlet fallbackColor = color;\n\n\t\t// First, check if the culprit is none values\n\t\tlet hasNone = color.coords.some(isNone) || isNone(color.alpha);\n\n\t\tif (hasNone) {\n\t\t\t// Does the browser support none values?\n\t\t\tif (!(supportsNone ??= CSS.supports(\"color\", \"hsl(none 50% 50%)\"))) {\n\t\t\t\t// Nope, try again without none\n\t\t\t\tfallbackColor = clone(color);\n\t\t\t\tfallbackColor.coords = fallbackColor.coords.map(skipNone);\n\t\t\t\tfallbackColor.alpha = skipNone(fallbackColor.alpha);\n\n\t\t\t\tret = serialize(fallbackColor, options);\n\n\t\t\t\tif (CSS.supports(\"color\", ret)) {\n\t\t\t\t\t// We're done, now it's supported\n\t\t\t\t\tret = new String(ret);\n\t\t\t\t\tret.color = fallbackColor;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we're here, the color function is not supported\n\t\t// Fall back to fallback space\n\t\tfallbackColor = to(fallbackColor, space);\n\t\tret = new String(serialize(fallbackColor, options));\n\t\tret.color = fallbackColor;\n\t}\n\n\treturn ret;\n}\n","import getColor from \"./getColor.js\";\n\nexport default function equals (color1, color2) {\n\tcolor1 = getColor(color1);\n\tcolor2 = getColor(color2);\n\n\treturn color1.space === color2.space\n\t       && color1.alpha === color2.alpha\n\t       && color1.coords.every((c, i) => c === color2.coords[i]);\n}\n","/**\n * Relative luminance\n */\nimport get from \"./get.js\";\nimport set from \"./set.js\";\nimport xyz_d65 from \"./spaces/xyz-d65.js\";\n\nexport function getLuminance (color) {\n\t// Assume getColor() is called on color in get()\n\treturn get(color, [xyz_d65, \"y\"]);\n}\n\nexport function setLuminance (color, value) {\n\t// Assume getColor() is called on color in set()\n\tset(color, [xyz_d65, \"y\"], value);\n}\n\nexport function register (Color) {\n\tObject.defineProperty(Color.prototype, \"luminance\", {\n\t\tget () {\n\t\t\treturn getLuminance(this);\n\t\t},\n\t\tset (value) {\n\t\t\tsetLuminance(this, value);\n\t\t},\n\t});\n}\n","// WCAG 2.0 contrast https://www.w3.org/TR/WCAG20-TECHS/G18.html\n// Simple contrast, with fixed 5% viewing flare contribution\n// Symmetric, does not matter which is foreground and which is background\n\nimport getColor from \"../getColor.js\";\nimport {getLuminance} from \"../luminance.js\";\n\nexport default function contrastWCAG21 (color1, color2) {\n\tcolor1 = getColor(color1);\n\tcolor2 = getColor(color2);\n\n\tlet Y1 = Math.max(getLuminance(color1), 0);\n\tlet Y2 = Math.max(getLuminance(color2), 0);\n\n\tif (Y2 > Y1) {\n\t\t[Y1, Y2] = [Y2, Y1];\n\t}\n\n\treturn (Y1 + .05) / (Y2 + .05);\n}\n","// APCA 0.0.98G\n// https://github.com/Myndex/apca-w3\n// see also https://github.com/w3c/silver/issues/643\n\nimport getColor from \"../getColor.js\";\nimport to from \"../to.js\";\n\n// exponents\nconst normBG = 0.56;\nconst normTXT = 0.57;\nconst revTXT = 0.62;\nconst revBG = 0.65;\n\n// clamps\nconst blkThrs = 0.022;\nconst blkClmp = 1.414;\nconst loClip = 0.1;\nconst deltaYmin = 0.0005;\n\n// scalers\n// see https://github.com/w3c/silver/issues/645\nconst scaleBoW = 1.14;\nconst loBoWoffset = 0.027;\nconst scaleWoB = 1.14;\nconst loWoBoffset = 0.027;\n\nfunction fclamp (Y) {\n\tif (Y >= blkThrs) {\n\t\treturn Y;\n\t}\n\treturn Y + (blkThrs - Y) ** blkClmp;\n}\n\nfunction linearize (val) {\n\tlet sign = val < 0 ? -1 : 1;\n\tlet abs = Math.abs(val);\n\treturn sign * Math.pow(abs, 2.4);\n}\n\n// Not symmetric, requires a foreground (text) color, and a background color\nexport default function contrastAPCA (background, foreground) {\n\tforeground = getColor(foreground);\n\tbackground = getColor(background);\n\n\tlet S;\n\tlet C;\n\tlet Sapc;\n\n\t// Myndex as-published, assumes sRGB inputs\n\tlet R, G, B;\n\n\tforeground = to(foreground, \"srgb\");\n\t// Should these be clamped to in-gamut values?\n\n\t// Calculates \"screen luminance\" with non-standard simple gamma EOTF\n\t// weights should be from CSS Color 4, not the ones here which are via Myndex and copied from Lindbloom\n\t[R, G, B] = foreground.coords;\n\tlet lumTxt = linearize(R) * 0.2126729 + linearize(G) * 0.7151522 + linearize(B) * 0.0721750;\n\n\tbackground = to(background, \"srgb\");\n\t[R, G, B] = background.coords;\n\tlet lumBg = linearize(R) * 0.2126729 + linearize(G) * 0.7151522 + linearize(B) * 0.0721750;\n\n\t// toe clamping of very dark values to account for flare\n\tlet Ytxt = fclamp(lumTxt);\n\tlet Ybg = fclamp(lumBg);\n\n\t// are we \"Black on White\" (dark on light), or light on dark?\n\tlet BoW = Ybg > Ytxt;\n\n\t// why is this a delta, when Y is not perceptually uniform?\n\t// Answer: it is a noise gate, see\n\t// https://github.com/LeaVerou/color.js/issues/208\n\tif (Math.abs(Ybg - Ytxt) < deltaYmin) {\n\t\tC = 0;\n\t}\n\telse {\n\t\tif (BoW) {\n\t\t\t// dark text on light background\n\t\t\tS = Ybg ** normBG - Ytxt ** normTXT;\n\t\t\tC = S * scaleBoW;\n\t\t}\n\t\telse {\n\t\t\t// light text on dark background\n\t\t\tS = Ybg ** revBG - Ytxt ** revTXT;\n\t\t\tC = S * scaleWoB;\n\t\t}\n\t}\n\tif (Math.abs(C) < loClip) {\n\t\tSapc = 0;\n\t}\n\telse if (C > 0) {\n\t\t// not clear whether Woffset is loBoWoffset or loWoBoffset\n\t\t// but they have the same value\n\t\tSapc = C - loBoWoffset;\n\t}\n\telse {\n\t\tSapc = C + loBoWoffset;\n\t}\n\n\treturn Sapc * 100;\n}\n","// Michelson  luminance contrast\n// the relation between the spread and the sum of the two luminances\n// Symmetric, does not matter which is foreground and which is background\n// No black level compensation for flare.\n\nimport getColor from \"../getColor.js\";\nimport {getLuminance} from \"../luminance.js\";\n\nexport default function contrastMichelson (color1, color2) {\n\tcolor1 = getColor(color1);\n\tcolor2 = getColor(color2);\n\n\tlet Y1 = Math.max(getLuminance(color1), 0);\n\tlet Y2 = Math.max(getLuminance(color2), 0);\n\n\tif (Y2 > Y1) {\n\t\t[Y1, Y2] = [Y2, Y1];\n\t}\n\n\tlet denom = (Y1 + Y2);\n\treturn denom === 0 ? 0 : (Y1 - Y2) / denom;\n}\n","// Weber luminance contrast\n// The difference between the two luminances divided by the lower luminance\n// Symmetric, does not matter which is foreground and which is background\n// No black level compensation for flare.\n\nimport getColor from \"../getColor.js\";\nimport {getLuminance} from \"../luminance.js\";\n\n// the darkest sRGB color above black is #000001 and this produces\n// a plain Weber contrast of ~45647.\n// So, setting the divide-by-zero result at 50000 is a reasonable\n// max clamp for the plain Weber\nconst max = 50000;\n\nexport default function contrastWeber (color1, color2) {\n\tcolor1 = getColor(color1);\n\tcolor2 = getColor(color2);\n\n\tlet Y1 = Math.max(getLuminance(color1), 0);\n\tlet Y2 = Math.max(getLuminance(color2), 0);\n\n\tif (Y2 > Y1) {\n\t\t[Y1, Y2] = [Y2, Y1];\n\t}\n\n\treturn Y2 === 0 ? max : (Y1 - Y2) / Y2;\n}\n","// CIE Lightness difference, as used by Google Material Design\n// Google HCT Tone is the same as CIE Lightness\n// https://material.io/blog/science-of-color-design\n\nimport getColor from \"../getColor.js\";\nimport get from \"../get.js\";\nimport lab from \"../spaces/lab.js\";\n\nexport default function contrastLstar (color1, color2) {\n\tcolor1 = getColor(color1);\n\tcolor2 = getColor(color2);\n\n\tlet L1 = get(color1, [lab, \"l\"]);\n\tlet L2 = get(color2, [lab, \"l\"]);\n\n\treturn Math.abs(L1 - L2);\n}\n","import ColorSpace from \"../space.js\";\nimport {WHITES} from \"../adapt.js\";\nimport xyz_d65 from \"./xyz-d65.js\";\n\n// κ * ε  = 2^3 = 8\nconst ε = 216 / 24389;  // 6^3/29^3 == (24/116)^3\nconst ε3 = 24 / 116;\nconst κ = 24389 / 27;   // 29^3/3^3\n\nlet white = WHITES.D65;\n\nexport default new ColorSpace({\n\tid: \"lab-d65\",\n\tname: \"Lab D65\",\n\tcoords: {\n\t\tl: {\n\t\t\trefRange: [0, 100],\n\t\t\tname: \"Lightness\",\n\t\t},\n\t\ta: {\n\t\t\trefRange: [-125, 125],\n\t\t},\n\t\tb: {\n\t\t\trefRange: [-125, 125],\n\t\t},\n\t},\n\n\t// Assuming XYZ is relative to D65, convert to CIE Lab\n\t// from CIE standard, which now defines these as a rational fraction\n\twhite,\n\n\tbase: xyz_d65,\n\t// Convert D65-adapted XYZ to Lab\n\t//  CIE 15.3:2004 section 8.2.1.1\n\tfromBase (XYZ) {\n\t\t// compute xyz, which is XYZ scaled relative to reference white\n\t\tlet xyz = XYZ.map((value, i) => value / white[i]);\n\n\t\t// now compute f\n\t\tlet f = xyz.map(value => value > ε ? Math.cbrt(value) : (κ * value + 16) / 116);\n\n\t\treturn [\n\t\t\t(116 * f[1]) - 16,   // L\n\t\t\t500 * (f[0] - f[1]), // a\n\t\t\t200 * (f[1] - f[2]),  // b\n\t\t];\n\t},\n\t// Convert Lab to D65-adapted XYZ\n\t// Same result as CIE 15.3:2004 Appendix D although the derivation is different\n\t// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\ttoBase (Lab) {\n\t\t// compute f, starting with the luminance-related term\n\t\tlet f = [];\n\t\tf[1] = (Lab[0] + 16) / 116;\n\t\tf[0] = Lab[1] / 500 + f[1];\n\t\tf[2] = f[1] - Lab[2] / 200;\n\n\t\t// compute xyz\n\t\tlet xyz = [\n\t\t\tf[0]   > ε3 ? Math.pow(f[0], 3)                : (116 * f[0] - 16) / κ,\n\t\t\tLab[0] > 8  ? Math.pow((Lab[0] + 16) / 116, 3) : Lab[0] / κ,\n\t\t\tf[2]   > ε3 ? Math.pow(f[2], 3)                : (116 * f[2] - 16) / κ,\n\t\t];\n\n\t\t// Compute XYZ by scaling xyz by reference white\n\t\treturn xyz.map((value, i) => value * white[i]);\n\t},\n\n\tformats: {\n\t\t\"lab-d65\": {\n\t\t\tcoords: [\"<number> | <percentage>\", \"<number> | <percentage>[-1,1]\", \"<number> | <percentage>[-1,1]\"],\n\t\t},\n\t},\n});\n","// Delta Phi Star perceptual lightness contrast\n// See https://github.com/Myndex/deltaphistar\n// The (difference between two Lstars each raised to phi) raised to (1/phi)\n// Symmetric, does not matter which is foreground and which is background\n\n\nimport getColor from \"../getColor.js\";\nimport get from \"../get.js\";\nimport lab_d65 from \"../spaces/lab-d65.js\";\n\nconst phi = Math.pow(5, 0.5) * 0.5 + 0.5; // Math.phi can be used if Math.js\n\nexport default function contrastDeltaPhi (color1, color2) {\n\tcolor1 = getColor(color1);\n\tcolor2 = getColor(color2);\n\n\tlet Lstr1 = get(color1, [lab_d65, \"l\"]);\n\tlet Lstr2 = get(color2, [lab_d65, \"l\"]);\n\n\tlet deltaPhiStar = Math.abs(Math.pow(Lstr1, phi) - Math.pow(Lstr2, phi));\n\n\tlet contrast = Math.pow(deltaPhiStar, (1 / phi)) * Math.SQRT2 - 40;\n\n\treturn (contrast < 7.5) ? 0.0 : contrast ;\n}\n","import getColor from \"./getColor.js\";\n// import defaults from \"./defaults.js\";\nimport {isString} from \"./util.js\";\nimport * as contrastAlgorithms from \"./contrast/index.js\";\n\nexport default function contrast (background, foreground, o = {}) {\n\tif (isString(o)) {\n\t\to = {algorithm: o};\n\t}\n\n\tlet {algorithm, ...rest} = o;\n\n\tif (!algorithm) {\n\t\tlet algorithms = Object.keys(contrastAlgorithms).map(a => a.replace(/^contrast/, \"\")).join(\", \");\n\t\tthrow new TypeError(`contrast() function needs a contrast algorithm. Please specify one of: ${algorithms}`);\n\t}\n\n\tbackground = getColor(background);\n\tforeground = getColor(foreground);\n\n\tfor (let a in contrastAlgorithms) {\n\t\tif (\"contrast\" + algorithm.toLowerCase() === a.toLowerCase()) {\n\t\t\treturn contrastAlgorithms[a](background, foreground, rest);\n\t\t}\n\t}\n\n\tthrow new TypeError(`Unknown contrast algorithm: ${algorithm}`);\n}\n","import xyz_d65 from \"./spaces/xyz-d65.js\";\nimport getAll from \"./getAll.js\";\n\n// Chromaticity coordinates\nexport function uv (color) {\n\t// Assumes getAll() calls getColor() on color\n\tlet [X, Y, Z] = getAll(color, xyz_d65);\n\tlet denom = X + 15 * Y + 3 * Z;\n\treturn [4 * X / denom, 9 * Y / denom];\n}\n\nexport function xy (color) {\n\t// Assumes getAll() calls getColor() on color\n\tlet [X, Y, Z] = getAll(color, xyz_d65);\n\tlet  sum = X + Y + Z;\n\treturn [X / sum, Y / sum];\n}\n\nexport function register (Color) {\n\t// no setters, as lightness information is lost\n\t// when converting color to chromaticity\n\tObject.defineProperty(Color.prototype, \"uv\", {\n\t\tget () {\n\t\t\treturn uv(this);\n\t\t},\n\t});\n\n\tObject.defineProperty(Color.prototype, \"xy\", {\n\t\tget () {\n\t\t\treturn xy(this);\n\t\t},\n\t});\n}\n","import defaults from \"./defaults.js\";\nimport {isString} from \"./util.js\";\nimport deltaEMethods from \"./deltaE/index.js\";\n\nexport default function deltaE (c1, c2, o = {}) {\n\tif (isString(o)) {\n\t\to = {method: o};\n\t}\n\n\tlet {method = defaults.deltaE, ...rest} = o;\n\n\tfor (let m in deltaEMethods) {\n\t\tif (\"deltae\" + method.toLowerCase() === m.toLowerCase()) {\n\t\t\treturn deltaEMethods[m](c1, c2, rest);\n\t\t}\n\t}\n\n\tthrow new TypeError(`Unknown deltaE method: ${method}`);\n}\n","import ColorSpace from \"./space.js\";\nimport set from \"./set.js\";\n\nexport function lighten (color, amount = .25) {\n\tlet space = ColorSpace.get(\"oklch\", \"lch\");\n\tlet lightness = [space, \"l\"];\n\treturn set(color, lightness, l => l * (1 + amount));\n}\n\nexport function darken (color, amount = .25) {\n\tlet space = ColorSpace.get(\"oklch\", \"lch\");\n\tlet lightness = [space, \"l\"];\n\treturn set(color, lightness, l => l * (1 - amount));\n}\n","/**\n * Functions related to color interpolation\n */\nimport ColorSpace from \"./space.js\";\nimport {type, interpolate} from \"./util.js\";\nimport getColor from \"./getColor.js\";\nimport clone from \"./clone.js\";\nimport to from \"./to.js\";\nimport toGamut from \"./toGamut.js\";\nimport get from \"./get.js\";\nimport set from \"./set.js\";\nimport defaults from \"./defaults.js\";\nimport * as angles from \"./angles.js\";\nimport deltaE from \"./deltaE.js\";\n\n/**\n * Return an intermediate color between two colors\n * Signatures: mix(c1, c2, p, options)\n *             mix(c1, c2, options)\n *             mix(color)\n * @param {Color | string} c1 The first color\n * @param {Color | string} [c2] The second color\n * @param {number} [p=.5] A 0-1 percentage where 0 is c1 and 1 is c2\n * @param {Object} [o={}]\n * @return {Color}\n */\nexport function mix (c1, c2, p = .5, o = {}) {\n\t[c1, c2] = [getColor(c1), getColor(c2)];\n\n\tif (type(p) === \"object\") {\n\t\t[p, o] = [.5, p];\n\t}\n\n\tlet r = range(c1, c2, o);\n\treturn r(p);\n}\n\n/**\n *\n * @param {Color | string | Function} c1 The first color or a range\n * @param {Color | string} [c2] The second color if c1 is not a range\n * @param {Object} [options={}]\n * @return {Color[]}\n */\nexport function steps (c1, c2, options = {}) {\n\tlet colorRange;\n\n\tif (isRange(c1)) {\n\t\t// Tweaking existing range\n\t\t[colorRange, options] = [c1, c2];\n\t\t[c1, c2] = colorRange.rangeArgs.colors;\n\t}\n\n\tlet {\n\t\tmaxDeltaE, deltaEMethod,\n\t\tsteps = 2, maxSteps = 1000,\n\t\t...rangeOptions\n\t} = options;\n\n\tif (!colorRange) {\n\t\t[c1, c2] = [getColor(c1), getColor(c2)];\n\t\tcolorRange = range(c1, c2, rangeOptions);\n\t}\n\n\tlet totalDelta = deltaE(c1, c2);\n\tlet actualSteps = maxDeltaE > 0 ? Math.max(steps, Math.ceil(totalDelta / maxDeltaE) + 1) : steps;\n\tlet ret = [];\n\n\tif (maxSteps !== undefined) {\n\t\tactualSteps = Math.min(actualSteps, maxSteps);\n\t}\n\n\tif (actualSteps === 1) {\n\t\tret = [{p: .5, color: colorRange(.5)}];\n\t}\n\telse {\n\t\tlet step = 1 / (actualSteps - 1);\n\t\tret = Array.from({length: actualSteps}, (_, i) => {\n\t\t\tlet p = i * step;\n\t\t\treturn {p, color: colorRange(p)};\n\t\t});\n\t}\n\n\tif (maxDeltaE > 0) {\n\t\t// Iterate over all stops and find max deltaE\n\t\tlet maxDelta = ret.reduce((acc, cur, i) => {\n\t\t\tif (i === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tlet ΔΕ = deltaE(cur.color, ret[i - 1].color, deltaEMethod);\n\t\t\treturn Math.max(acc, ΔΕ);\n\t\t}, 0);\n\n\t\twhile (maxDelta > maxDeltaE) {\n\t\t\t// Insert intermediate stops and measure maxDelta again\n\t\t\t// We need to do this for all pairs, otherwise the midpoint shifts\n\t\t\tmaxDelta = 0;\n\n\t\t\tfor (let i = 1; (i < ret.length) && (ret.length < maxSteps); i++) {\n\t\t\t\tlet prev = ret[i - 1];\n\t\t\t\tlet cur = ret[i];\n\n\t\t\t\tlet p = (cur.p + prev.p) / 2;\n\t\t\t\tlet color = colorRange(p);\n\t\t\t\tmaxDelta = Math.max(maxDelta, deltaE(color, prev.color), deltaE(color, cur.color));\n\t\t\t\tret.splice(i, 0, {p, color: colorRange(p)});\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = ret.map(a => a.color);\n\n\treturn ret;\n}\n\n/**\n * Interpolate to color2 and return a function that takes a 0-1 percentage\n * @param {Color | string | Function} color1 The first color or an existing range\n * @param {Color | string} [color2] If color1 is a color, this is the second color\n * @param {Object} [options={}]\n * @returns {Function} A function that takes a 0-1 percentage and returns a color\n */\nexport function range (color1, color2, options = {}) {\n\tif (isRange(color1)) {\n\t\t// Tweaking existing range\n\t\tlet [r, options] = [color1, color2];\n\n\t\treturn range(...r.rangeArgs.colors, {...r.rangeArgs.options, ...options});\n\t}\n\n\tlet {space, outputSpace, progression, premultiplied} = options;\n\n\tcolor1 = getColor(color1);\n\tcolor2 = getColor(color2);\n\n\t// Make sure we're working on copies of these colors\n\tcolor1 = clone(color1);\n\tcolor2 = clone(color2);\n\n\tlet rangeArgs = {colors: [color1, color2], options};\n\n\tif (space) {\n\t\tspace = ColorSpace.get(space);\n\t}\n\telse {\n\t\tspace = ColorSpace.registry[defaults.interpolationSpace] || color1.space;\n\t}\n\n\toutputSpace = outputSpace ? ColorSpace.get(outputSpace) : space;\n\n\tcolor1 = to(color1, space);\n\tcolor2 = to(color2, space);\n\n\t// Gamut map to avoid areas of flat color\n\tcolor1 = toGamut(color1);\n\tcolor2 = toGamut(color2);\n\n\t// Handle hue interpolation\n\t// See https://github.com/w3c/csswg-drafts/issues/4735#issuecomment-635741840\n\tif (space.coords.h && space.coords.h.type === \"angle\") {\n\t\tlet arc = options.hue = options.hue || \"shorter\";\n\n\t\tlet hue = [space, \"h\"];\n\t\tlet [θ1, θ2] = [get(color1, hue), get(color2, hue)];\n\t\t// Undefined hues must be evaluated before hue fix-up to properly\n\t\t// calculate hue arcs between undefined and defined hues.\n\t\t// See https://github.com/w3c/csswg-drafts/issues/9436#issuecomment-1746957545\n\t\tif (isNaN(θ1) && !isNaN(θ2)) {\n\t\t\tθ1 = θ2;\n\t\t}\n\t\telse if (isNaN(θ2) && !isNaN(θ1)) {\n\t\t\tθ2 = θ1;\n\t\t}\n\t\t[θ1, θ2] = angles.adjust(arc, [θ1, θ2]);\n\t\tset(color1, hue, θ1);\n\t\tset(color2, hue, θ2);\n\t}\n\n\tif (premultiplied) {\n\t\t// not coping with polar spaces yet\n\t\tcolor1.coords = color1.coords.map(c => c * color1.alpha);\n\t\tcolor2.coords = color2.coords.map(c => c * color2.alpha);\n\t}\n\n\treturn Object.assign(p => {\n\t\tp = progression ? progression(p) : p;\n\t\tlet coords = color1.coords.map((start, i) => {\n\t\t\tlet end = color2.coords[i];\n\t\t\treturn interpolate(start, end, p);\n\t\t});\n\n\t\tlet alpha = interpolate(color1.alpha, color2.alpha, p);\n\t\tlet ret = {space, coords, alpha};\n\n\t\tif (premultiplied) {\n\t\t\t// undo premultiplication\n\t\t\tret.coords = ret.coords.map(c => c / alpha);\n\t\t}\n\n\t\tif (outputSpace !== space) {\n\t\t\tret = to(ret, outputSpace);\n\t\t}\n\n\t\treturn ret;\n\t}, {\n\t\trangeArgs,\n\t});\n}\n\nexport function isRange (val) {\n\treturn type(val) === \"function\" && !!val.rangeArgs;\n}\n\ndefaults.interpolationSpace = \"lab\";\n\nexport function register (Color) {\n\tColor.defineFunction(\"mix\", mix, {returns: \"color\"});\n\tColor.defineFunction(\"range\", range, {returns: \"function<color>\"});\n\tColor.defineFunction(\"steps\", steps, {returns: \"array<color>\"});\n}\n","import ColorSpace from \"../space.js\";\nimport sRGB from \"./srgb.js\";\n\nexport default new ColorSpace({\n\tid: \"hsl\",\n\tname: \"HSL\",\n\tcoords: {\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t},\n\t\ts: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Saturation\",\n\t\t},\n\t\tl: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Lightness\",\n\t\t},\n\t},\n\n\tbase: sRGB,\n\n\t// Adapted from https://drafts.csswg.org/css-color-4/better-rgbToHsl.js\n\tfromBase: rgb => {\n\t\tlet max = Math.max(...rgb);\n\t\tlet min = Math.min(...rgb);\n\t\tlet [r, g, b] = rgb;\n\t\tlet [h, s, l] = [NaN, 0, (min + max) / 2];\n\t\tlet d = max - min;\n\n\t\tif (d !== 0) {\n\t\t\ts = (l === 0 || l === 1) ? 0 : (max - l) / Math.min(l, 1 - l);\n\n\t\t\tswitch (max) {\n\t\t\t\tcase r: h = (g - b) / d + (g < b ? 6 : 0); break;\n\t\t\t\tcase g: h = (b - r) / d + 2; break;\n\t\t\t\tcase b: h = (r - g) / d + 4;\n\t\t\t}\n\n\t\t\th = h * 60;\n\t\t}\n\n\t\t// Very out of gamut colors can produce negative saturation\n\t\t// If so, just rotate the hue by 180 and use a positive saturation\n\t\t// see https://github.com/w3c/csswg-drafts/issues/9222\n\t\tif (s < 0) {\n\t\t\th += 180;\n\t\t\ts = Math.abs(s);\n\t\t}\n\n\t\tif (h >= 360) {\n\t\t\th -= 360;\n\t\t}\n\n\t\treturn [h, s * 100, l * 100];\n\t},\n\n\t// Adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative\n\ttoBase: hsl => {\n\t\tlet [h, s, l] = hsl;\n\t\th = h % 360;\n\n\t\tif (h < 0) {\n\t\t\th += 360;\n\t\t}\n\n\t\ts /= 100;\n\t\tl /= 100;\n\n\t\tfunction f (n) {\n\t\t\tlet k = (n + h / 30) % 12;\n\t\t\tlet a = s * Math.min(l, 1 - l);\n\t\t\treturn l - a * Math.max(-1, Math.min(k - 3, 9 - k, 1));\n\t\t}\n\n\t\treturn [f(0), f(8), f(4)];\n\t},\n\n\tformats: {\n\t\t\"hsl\": {\n\t\t\tcoords: [\"<number> | <angle>\", \"<percentage>\", \"<percentage>\"],\n\t\t},\n\t\t\"hsla\": {\n\t\t\tcoords: [\"<number> | <angle>\", \"<percentage>\", \"<percentage>\"],\n\t\t\tcommas: true,\n\t\t\tlastAlpha: true,\n\t\t},\n\t},\n});\n","import ColorSpace from \"../space.js\";\nimport HSL from \"./hsl.js\";\n\n// The Hue, Whiteness Blackness (HWB) colorspace\n// See https://drafts.csswg.org/css-color-4/#the-hwb-notation\n// Note that, like HSL, calculations are done directly on\n// gamma-corrected sRGB values rather than linearising them first.\n\nexport default new ColorSpace({\n\tid: \"hsv\",\n\tname: \"HSV\",\n\tcoords: {\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t},\n\t\ts: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Saturation\",\n\t\t},\n\t\tv: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Value\",\n\t\t},\n\t},\n\n\tbase: HSL,\n\t// https://en.wikipedia.org/wiki/HSL_and_HSV#Interconversion\n\tfromBase (hsl) {\n\t\tlet [h, s, l] = hsl;\n\t\ts /= 100;\n\t\tl /= 100;\n\n\t\tlet v = l + s * Math.min(l, 1 - l);\n\n\t\treturn [\n\t\t\th, // h is the same\n\t\t\tv === 0 ? 0 : 200 * (1 - l / v), // s\n\t\t\t100 * v,\n\t\t];\n\t},\n\t// https://en.wikipedia.org/wiki/HSL_and_HSV#Interconversion\n\ttoBase (hsv) {\n\t\tlet [h, s, v] = hsv;\n\n\t\ts /= 100;\n\t\tv /= 100;\n\n\t\tlet l = v * (1 - s / 2);\n\n\t\treturn [\n\t\t\th, // h is the same\n\t\t\t(l === 0 || l === 1) ? 0 : ((v - l) / Math.min(l, 1 - l)) * 100,\n\t\t\tl * 100,\n\t\t];\n\t},\n\n\tformats: {\n\t\tcolor: {\n\t\t\tid: \"--hsv\",\n\t\t\tcoords: [\"<number> | <angle>\", \"<percentage> | <number>\", \"<percentage> | <number>\"],\n\t\t},\n\t},\n});\n","import ColorSpace from \"../space.js\";\nimport HSV from \"./hsv.js\";\n\n// The Hue, Whiteness Blackness (HWB) colorspace\n// See https://drafts.csswg.org/css-color-4/#the-hwb-notation\n// Note that, like HSL, calculations are done directly on\n// gamma-corrected sRGB values rather than linearising them first.\n\nexport default new ColorSpace({\n\tid: \"hwb\",\n\tname: \"HWB\",\n\tcoords: {\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t},\n\t\tw: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Whiteness\",\n\t\t},\n\t\tb: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Blackness\",\n\t\t},\n\t},\n\n\tbase: HSV,\n\tfromBase (hsv) {\n\t\tlet [h, s, v] = hsv;\n\n\t\treturn [h, v * (100 - s) / 100, 100 - v];\n\t},\n\ttoBase (hwb) {\n\t\tlet [h, w, b] = hwb;\n\n\t\t// Now convert percentages to [0..1]\n\t\tw /= 100;\n\t\tb /= 100;\n\n\t\t// Achromatic check (white plus black >= 1)\n\t\tlet sum = w + b;\n\t\tif (sum >= 1) {\n\t\t\tlet gray = w / sum;\n\t\t\treturn [h, 0, gray * 100];\n\t\t}\n\n\t\tlet v = (1 - b);\n\t\tlet s = (v === 0) ? 0 : 1 - w / v;\n\t\treturn [h, s * 100, v * 100];\n\t},\n\n\tformats: {\n\t\t\"hwb\": {\n\t\t\tcoords: [\"<number> | <angle>\", \"<percentage> | <number>\", \"<percentage> | <number>\"],\n\t\t},\n\t},\n});\n","import RGBColorSpace from \"../rgbspace.js\";\n\n// convert an array of linear-light a98-rgb values to CIE XYZ\n// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n// has greater numerical precision than section 4.3.5.3 of\n// https://www.adobe.com/digitalimag/pdfs/AdobeRGB1998.pdf\n// but the values below were calculated from first principles\n// from the chromaticity coordinates of R G B W\nconst toXYZ_M = [\n\t[ 0.5766690429101305,   0.1855582379065463,   0.1882286462349947  ],\n\t[ 0.29734497525053605,  0.6273635662554661,   0.07529145849399788 ],\n\t[ 0.02703136138641234,  0.07068885253582723,  0.9913375368376388  ],\n];\n\nconst fromXYZ_M = [\n\t[  2.0415879038107465,    -0.5650069742788596,   -0.34473135077832956 ],\n\t[ -0.9692436362808795,     1.8759675015077202,    0.04155505740717557 ],\n\t[  0.013444280632031142,  -0.11836239223101838,   1.0151749943912054  ],\n];\n\nexport default new RGBColorSpace({\n\tid: \"a98rgb-linear\",\n\tcssId: \"--a98-rgb-linear\",\n\tname: \"Linear Adobe® 98 RGB compatible\",\n\twhite: \"D65\",\n\ttoXYZ_M,\n\tfromXYZ_M,\n});\n","import RGBColorSpace from \"../rgbspace.js\";\nimport A98Linear from \"./a98rgb-linear.js\";\n\nexport default new RGBColorSpace({\n\tid: \"a98rgb\",\n\tcssId: \"a98-rgb\",\n\tname: \"Adobe® 98 RGB compatible\",\n\tbase: A98Linear,\n\ttoBase: RGB => RGB.map(val => Math.pow(Math.abs(val), 563 / 256) * Math.sign(val)),\n\tfromBase: RGB => RGB.map(val => Math.pow(Math.abs(val), 256 / 563) * Math.sign(val)),\n});\n","import RGBColorSpace from \"../rgbspace.js\";\nimport XYZ_D50 from \"./xyz-d50.js\";\n\n// convert an array of  prophoto-rgb values to CIE XYZ\n// using  D50 (so no chromatic adaptation needed afterwards)\n// matrix cannot be expressed in rational form, but is calculated to 64 bit accuracy\n// see https://github.com/w3c/csswg-drafts/issues/7675\nconst toXYZ_M = [\n\t[ 0.79776664490064230,  0.13518129740053308,  0.03134773412839220 ],\n\t[ 0.28807482881940130,  0.71183523424187300,  0.00008993693872564 ],\n\t[ 0.00000000000000000,  0.00000000000000000,  0.82510460251046020 ],\n];\n\nconst fromXYZ_M = [\n\t[  1.34578688164715830, -0.25557208737979464, -0.05110186497554526 ],\n\t[ -0.54463070512490190,  1.50824774284514680,  0.02052744743642139 ],\n\t[  0.00000000000000000,  0.00000000000000000,  1.21196754563894520 ],\n];\n\nexport default new RGBColorSpace({\n\tid: \"prophoto-linear\",\n\tcssId: \"--prophoto-rgb-linear\",\n\tname: \"Linear ProPhoto\",\n\twhite: \"D50\",\n\tbase: XYZ_D50,\n\ttoXYZ_M,\n\tfromXYZ_M,\n});\n","import RGBColorSpace from \"../rgbspace.js\";\nimport ProPhotoLinear from \"./prophoto-linear.js\";\n\nconst Et = 1 / 512;\nconst Et2 = 16 / 512;\n\nexport default new RGBColorSpace({\n\tid: \"prophoto\",\n\tcssId: \"prophoto-rgb\",\n\tname: \"ProPhoto\",\n\tbase: ProPhotoLinear,\n\ttoBase (RGB) {\n\t\t// Transfer curve is gamma 1.8 with a small linear portion\n\t\treturn RGB.map(v => v < Et2 ? v / 16 : v ** 1.8);\n\t},\n\tfromBase (RGB) {\n\t\treturn RGB.map(v => v >= Et ? v ** (1 / 1.8) : 16 * v);\n\t},\n});\n","import ColorSpace from \"../space.js\";\nimport OKLab from \"./oklab.js\";\nimport {constrain as constrainAngle} from \"../angles.js\";\n\nexport default new ColorSpace({\n\tid: \"oklch\",\n\tname: \"Oklch\",\n\tcoords: {\n\t\tl: {\n\t\t\trefRange: [0, 1],\n\t\t\tname: \"Lightness\",\n\t\t},\n\t\tc: {\n\t\t\trefRange: [0, 0.4],\n\t\t\tname: \"Chroma\",\n\t\t},\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t},\n\t},\n\twhite: \"D65\",\n\n\tbase: OKLab,\n\tfromBase (oklab) {\n\t\t// Convert to polar form\n\t\tlet [L, a, b] = oklab;\n\t\tlet h;\n\t\tconst ε = 0.0002; // chromatic components much smaller than a,b\n\n\t\tif (Math.abs(a) < ε && Math.abs(b) < ε) {\n\t\t\th = NaN;\n\t\t}\n\t\telse {\n\t\t\th = Math.atan2(b, a) * 180 / Math.PI;\n\t\t}\n\n\t\treturn [\n\t\t\tL, // OKLab L is still L\n\t\t\tMath.sqrt(a ** 2 + b ** 2), // Chroma\n\t\t\tconstrainAngle(h), // Hue, in degrees [0 to 360)\n\t\t];\n\t},\n\t// Convert from polar form\n\ttoBase (oklch) {\n\t\tlet [L, C, h] = oklch;\n\t\tlet a, b;\n\n\t\t// check for NaN hue\n\t\tif (isNaN(h)) {\n\t\t\ta = 0;\n\t\t\tb = 0;\n\t\t}\n\t\telse {\n\t\t\ta = C * Math.cos(h * Math.PI / 180);\n\t\t\tb = C * Math.sin(h * Math.PI / 180);\n\t\t}\n\n\t\treturn [ L, a, b ];\n\t},\n\n\tformats: {\n\t\t\"oklch\": {\n\t\t\tcoords: [\"<percentage> | <number>\", \"<number> | <percentage>[0,1]\", \"<number> | <angle>\"],\n\t\t},\n\t},\n});\n","import ColorSpace from \"../space.js\";\nimport {WHITES} from \"../adapt.js\";\nimport xyz_d65 from \"./xyz-d65.js\";\nimport {uv} from \"../chromaticity.js\";\nimport {isNone, skipNone} from \"../util.js\";\n\nlet white = WHITES.D65;\n\nconst ε = 216 / 24389;  // 6^3/29^3 == (24/116)^3\nconst κ = 24389 / 27;   // 29^3/3^3\nconst [U_PRIME_WHITE, V_PRIME_WHITE] = uv({space: xyz_d65, coords: white});\n\nexport default new ColorSpace({\n\tid: \"luv\",\n\tname: \"Luv\",\n\tcoords: {\n\t\tl: {\n\t\t\trefRange: [0, 100],\n\t\t\tname: \"Lightness\",\n\t\t},\n\t\t// Reference ranges from https://facelessuser.github.io/coloraide/colors/luv/\n\t\tu: {\n\t\t\trefRange: [-215, 215],\n\t\t},\n\t\tv: {\n\t\t\trefRange: [-215, 215],\n\t\t},\n\t},\n\n\twhite: white,\n\tbase: xyz_d65,\n\n\t// Convert D65-adapted XYZ to Luv\n\t// https://en.wikipedia.org/wiki/CIELUV#The_forward_transformation\n\tfromBase (XYZ) {\n\t\tlet xyz = [skipNone(XYZ[0]), skipNone(XYZ[1]), skipNone(XYZ[2])];\n\t\tlet y = xyz[1];\n\n\t\tlet [up, vp] = uv({space: xyz_d65, coords: xyz});\n\n\t\t// Protect against XYZ of [0, 0, 0]\n\t\tif (!Number.isFinite(up) || !Number.isFinite(vp)) {\n\t\t\treturn [0, 0, 0];\n\t\t}\n\n\t\tlet L = y <= ε ? κ * y : 116 * Math.cbrt(y) - 16;\n\t\treturn [\n\t\t\tL,\n\t\t\t13 * L * (up - U_PRIME_WHITE),\n\t\t\t13 * L * (vp - V_PRIME_WHITE),\n\t\t ];\n\t},\n\n\t// Convert Luv to D65-adapted XYZ\n\t// https://en.wikipedia.org/wiki/CIELUV#The_reverse_transformation\n\ttoBase (Luv) {\n\t\tlet [L, u, v] = Luv;\n\n\t\t// Protect against division by zero and NaN Lightness\n\t\tif (L === 0 || isNone(L)) {\n\t\t\treturn [0, 0, 0];\n\t\t}\n\n\t\tu = skipNone(u);\n\t\tv = skipNone(v);\n\n\t\tlet up = (u / (13 * L)) + U_PRIME_WHITE;\n\t\tlet vp = (v / (13 * L)) + V_PRIME_WHITE;\n\n\t\tlet y = L <= 8 ? L / κ : Math.pow((L + 16) / 116, 3);\n\n\t\treturn [\n\t\t\ty * ((9 * up) / (4 * vp)),\n\t\t\ty,\n\t\t\ty * ((12 - 3 * up - 20 * vp) / (4 * vp)),\n\t\t];\n\t},\n\n\tformats: {\n\t\tcolor: {\n\t\t\tid: \"--luv\",\n\t\t\tcoords: [\"<number> | <percentage>\", \"<number> | <percentage>[-1,1]\", \"<number> | <percentage>[-1,1]\"],\n\t\t},\n\t},\n});\n","import ColorSpace from \"../space.js\";\nimport Luv from \"./luv.js\";\nimport {constrain as constrainAngle} from \"../angles.js\";\n\nexport default new ColorSpace({\n\tid: \"lchuv\",\n\tname: \"LChuv\",\n\tcoords: {\n\t\tl: {\n\t\t\trefRange: [0, 100],\n\t\t\tname: \"Lightness\",\n\t\t},\n\t\tc: {\n\t\t\trefRange: [0, 220],\n\t\t\tname: \"Chroma\",\n\t\t},\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t},\n\t},\n\n\tbase: Luv,\n\tfromBase (Luv) {\n\t\t// Convert to polar form\n\t\tlet [L, u, v] = Luv;\n\t\tlet hue;\n\t\tconst ε = 0.02;\n\n\t\tif (Math.abs(u) < ε && Math.abs(v) < ε) {\n\t\t\thue = NaN;\n\t\t}\n\t\telse {\n\t\t\thue = Math.atan2(v, u) * 180 / Math.PI;\n\t\t}\n\n\t\treturn [\n\t\t\tL, // L is still L\n\t\t\tMath.sqrt(u ** 2 + v ** 2), // Chroma\n\t\t\tconstrainAngle(hue), // Hue, in degrees [0 to 360)\n\t\t];\n\t},\n\ttoBase (LCH) {\n\t\t// Convert from polar form\n\t\tlet [Lightness, Chroma, Hue] = LCH;\n\t\t// Clamp any negative Chroma\n\t\tif (Chroma < 0) {\n\t\t\tChroma = 0;\n\t\t}\n\t\t// Deal with NaN Hue\n\t\tif (isNaN(Hue)) {\n\t\t\tHue = 0;\n\t\t}\n\t\treturn [\n\t\t\tLightness, // L is still L\n\t\t\tChroma * Math.cos(Hue * Math.PI / 180), // u\n\t\t\tChroma * Math.sin(Hue * Math.PI / 180),  // v\n\t\t];\n\t},\n\n\tformats: {\n\t\tcolor: {\n\t\t\tid: \"--lchuv\",\n\t\t\tcoords: [\"<number> | <percentage>\", \"<number> | <percentage>\", \"<number> | <angle>\"],\n\t\t},\n\t},\n});\n","/*\nAdapted from: https://github.com/hsluv/hsluv-javascript/blob/14b49e6cf9a9137916096b8487a5372626b57ba4/src/hsluv.ts\n\nCopyright (c) 2012-2022 Alexei Boronine\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\nimport ColorSpace from \"../space.js\";\nimport LCHuv from \"./lchuv.js\";\nimport sRGB from \"./srgb.js\";\nimport {fromXYZ_M} from \"./srgb-linear.js\";\nimport {skipNone} from \"../util.js\";\n\nconst ε = 216 / 24389;  // 6^3/29^3 == (24/116)^3\nconst κ = 24389 / 27;   // 29^3/3^3\n\nconst m_r0 = fromXYZ_M[0][0];\nconst m_r1 = fromXYZ_M[0][1];\nconst m_r2 = fromXYZ_M[0][2];\nconst m_g0 = fromXYZ_M[1][0];\nconst m_g1 = fromXYZ_M[1][1];\nconst m_g2 = fromXYZ_M[1][2];\nconst m_b0 = fromXYZ_M[2][0];\nconst m_b1 = fromXYZ_M[2][1];\nconst m_b2 = fromXYZ_M[2][2];\n\nfunction distanceFromOriginAngle (slope, intercept, angle) {\n\tconst d = intercept / (Math.sin(angle) - slope * Math.cos(angle));\n\treturn d < 0 ? Infinity : d;\n}\n\nexport function calculateBoundingLines (l) {\n\tconst sub1 = Math.pow(l + 16, 3) / 1560896;\n\tconst sub2 = sub1 > ε ? sub1 : l / κ;\n\tconst s1r = sub2 * (284517 * m_r0 - 94839 * m_r2);\n\tconst s2r = sub2 * (838422 * m_r2 + 769860 * m_r1 + 731718 * m_r0);\n\tconst s3r = sub2 * (632260 * m_r2 - 126452 * m_r1);\n\tconst s1g = sub2 * (284517 * m_g0 - 94839 * m_g2);\n\tconst s2g = sub2 * (838422 * m_g2 + 769860 * m_g1 + 731718 * m_g0);\n\tconst s3g = sub2 * (632260 * m_g2 - 126452 * m_g1);\n\tconst s1b = sub2 * (284517 * m_b0 - 94839 * m_b2);\n\tconst s2b = sub2 * (838422 * m_b2 + 769860 * m_b1 + 731718 * m_b0);\n\tconst s3b = sub2 * (632260 * m_b2 - 126452 * m_b1);\n\n\treturn {\n\t\tr0s: s1r / s3r,\n\t\tr0i: s2r * l / s3r,\n\t\tr1s: s1r / (s3r + 126452),\n\t\tr1i: (s2r - 769860) * l / (s3r + 126452),\n\t\tg0s: s1g / s3g,\n\t\tg0i: s2g * l / s3g,\n\t\tg1s: s1g / (s3g + 126452),\n\t\tg1i: (s2g - 769860) * l / (s3g + 126452),\n\t\tb0s: s1b / s3b,\n\t\tb0i: s2b * l / s3b,\n\t\tb1s: s1b / (s3b + 126452),\n\t\tb1i: (s2b - 769860) * l / (s3b + 126452),\n\t};\n}\n\nfunction calcMaxChromaHsluv (lines, h) {\n\tconst hueRad = h / 360 * Math.PI * 2;\n\tconst r0 = distanceFromOriginAngle(lines.r0s, lines.r0i, hueRad);\n\tconst r1 = distanceFromOriginAngle(lines.r1s, lines.r1i, hueRad);\n\tconst g0 = distanceFromOriginAngle(lines.g0s, lines.g0i, hueRad);\n\tconst g1 = distanceFromOriginAngle(lines.g1s, lines.g1i, hueRad);\n\tconst b0 = distanceFromOriginAngle(lines.b0s, lines.b0i, hueRad);\n\tconst b1 = distanceFromOriginAngle(lines.b1s, lines.b1i, hueRad);\n\n\treturn Math.min(r0, r1, g0, g1, b0, b1);\n}\n\nexport default new ColorSpace({\n\tid: \"hsluv\",\n\tname: \"HSLuv\",\n\tcoords: {\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t},\n\t\ts: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Saturation\",\n\t\t},\n\t\tl: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Lightness\",\n\t\t},\n\t},\n\n\tbase: LCHuv,\n\tgamutSpace: sRGB,\n\n\t// Convert LCHuv to HSLuv\n\tfromBase (lch) {\n\t\tlet [l, c, h] = [skipNone(lch[0]), skipNone(lch[1]), skipNone(lch[2])];\n\t\tlet s;\n\n\t\tif (l > 99.9999999) {\n\t\t\ts = 0;\n\t\t\tl = 100;\n\t\t}\n\t\telse if (l < 0.00000001) {\n\t\t\ts = 0;\n\t\t\tl = 0;\n\t\t}\n\t\telse {\n\t\t\tlet lines = calculateBoundingLines(l);\n\t\t\tlet max = calcMaxChromaHsluv(lines, h);\n\t\t\ts = c / max * 100;\n\t\t}\n\n\t\treturn [h, s, l];\n\t},\n\n\t// Convert HSLuv to LCHuv\n\ttoBase (hsl) {\n\t\tlet [h, s, l] = [skipNone(hsl[0]), skipNone(hsl[1]), skipNone(hsl[2])];\n\t\tlet c;\n\n\t\tif (l > 99.9999999) {\n\t\t\tl = 100;\n\t\t\tc = 0;\n\t\t}\n\t\telse if (l < 0.00000001) {\n\t\t\tl = 0;\n\t\t\tc = 0;\n\t\t}\n\t\telse {\n\t\t\tlet lines = calculateBoundingLines(l);\n\t\t\tlet max = calcMaxChromaHsluv(lines, h);\n\t\t\tc = max / 100 * s;\n\t\t}\n\n\t\treturn [l, c, h];\n\t},\n\n\tformats: {\n\t\tcolor: {\n\t\t\tid: \"--hsluv\",\n\t\t\tcoords: [\"<number> | <angle>\", \"<percentage> | <number>\", \"<percentage> | <number>\"],\n\t\t},\n\t},\n});\n","/*\nAdapted from: https://github.com/hsluv/hsluv-javascript/blob/14b49e6cf9a9137916096b8487a5372626b57ba4/src/hsluv.ts\n\nCopyright (c) 2012-2022 Alexei Boronine\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\nimport ColorSpace from \"../space.js\";\nimport LCHuv from \"./lchuv.js\";\nimport {fromXYZ_M} from \"./srgb-linear.js\";\nimport {skipNone} from \"../util.js\";\nimport {calculateBoundingLines} from \"./hsluv.js\";\n\nconst ε = 216 / 24389;  // 6^3/29^3 == (24/116)^3\nconst κ = 24389 / 27;   // 29^3/3^3\n\nconst m_r0 = fromXYZ_M[0][0];\nconst m_r1 = fromXYZ_M[0][1];\nconst m_r2 = fromXYZ_M[0][2];\nconst m_g0 = fromXYZ_M[1][0];\nconst m_g1 = fromXYZ_M[1][1];\nconst m_g2 = fromXYZ_M[1][2];\nconst m_b0 = fromXYZ_M[2][0];\nconst m_b1 = fromXYZ_M[2][1];\nconst m_b2 = fromXYZ_M[2][2];\n\nfunction distanceFromOrigin (slope, intercept) {\n\treturn Math.abs(intercept) / Math.sqrt(Math.pow(slope, 2) + 1);\n}\n\nfunction calcMaxChromaHpluv (lines) {\n\tlet r0 = distanceFromOrigin(lines.r0s, lines.r0i);\n\tlet r1 = distanceFromOrigin(lines.r1s, lines.r1i);\n\tlet g0 = distanceFromOrigin(lines.g0s, lines.g0i);\n\tlet g1 = distanceFromOrigin(lines.g1s, lines.g1i);\n\tlet b0 = distanceFromOrigin(lines.b0s, lines.b0i);\n\tlet b1 = distanceFromOrigin(lines.b1s, lines.b1i);\n\n\treturn Math.min(r0, r1, g0, g1, b0, b1);\n}\n\nexport default new ColorSpace({\n\tid: \"hpluv\",\n\tname: \"HPLuv\",\n\tcoords: {\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t},\n\t\ts: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Saturation\",\n\t\t},\n\t\tl: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Lightness\",\n\t\t},\n\t},\n\n\tbase: LCHuv,\n\tgamutSpace: \"self\",\n\n\t// Convert LCHuv to HPLuv\n\tfromBase (lch) {\n\t\tlet [l, c, h] = [skipNone(lch[0]), skipNone(lch[1]), skipNone(lch[2])];\n\t\tlet s;\n\n\t\tif (l > 99.9999999) {\n\t\t\ts = 0;\n\t\t\tl = 100;\n\t\t}\n\t\telse if (l < 0.00000001) {\n\t\t\ts = 0;\n\t\t\tl = 0;\n\t\t}\n\t\telse {\n\t\t\tlet lines = calculateBoundingLines(l);\n\t\t\tlet max = calcMaxChromaHpluv(lines);\n\t\t\ts = c / max * 100;\n\t\t}\n\t\treturn [h, s, l];\n\t},\n\n\t// Convert HPLuv to LCHuv\n\ttoBase (hsl) {\n\t\tlet [h, s, l] = [skipNone(hsl[0]), skipNone(hsl[1]), skipNone(hsl[2])];\n\t\tlet c;\n\n\t\tif (l > 99.9999999) {\n\t\t\tl = 100;\n\t\t\tc = 0;\n\t\t}\n\t\telse if (l < 0.00000001) {\n\t\t\tl = 0;\n\t\t\tc = 0;\n\t\t}\n\t\telse {\n\t\t\tlet lines = calculateBoundingLines(l);\n\t\t\tlet max = calcMaxChromaHpluv(lines, h);\n\t\t\tc = max / 100 * s;\n\t\t}\n\n\t\treturn [l, c, h];\n\t},\n\n\tformats: {\n\t\tcolor: {\n\t\t\tid: \"--hpluv\",\n\t\t\tcoords: [\"<number> | <angle>\", \"<percentage> | <number>\", \"<percentage> | <number>\"],\n\t\t},\n\t},\n});\n","import RGBColorSpace from \"../rgbspace.js\";\nimport REC2020Linear from \"./rec2020-linear.js\";\n\nconst Yw = 203;\t// absolute luminance of media white, cd/m²\nconst n = 2610 / (2 ** 14);\nconst ninv = (2 ** 14) / 2610;\nconst m = 2523 / (2 ** 5);\nconst minv = (2 ** 5) / 2523;\nconst c1 = 3424 / (2 ** 12);\nconst c2 = 2413 / (2 ** 7);\nconst c3 = 2392 / (2 ** 7);\n\nexport default new RGBColorSpace({\n\tid: \"rec2100pq\",\n\tcssId: \"rec2100-pq\",\n\tname: \"REC.2100-PQ\",\n\tbase: REC2020Linear,\n\ttoBase (RGB) {\n\t\t// given PQ encoded component in range [0, 1]\n\t\t// return media-white relative linear-light\n\t\treturn RGB.map(function (val) {\n\t\t\tlet x = ((Math.max(((val ** minv) - c1), 0) / (c2 - (c3 * (val ** minv)))) ** ninv);\n\t\t\treturn (x * 10000 / Yw); \t// luminance relative to diffuse white, [0, 70 or so].\n\t\t});\n\t},\n\tfromBase (RGB) {\n\t\t// given media-white relative linear-light\n\t\t// returnPQ encoded component in range [0, 1]\n\t\treturn RGB.map(function (val) {\n\t\t\tlet x = Math.max(val * Yw / 10000, 0); \t// absolute luminance of peak white is 10,000 cd/m².\n\t\t\tlet num = (c1 + (c2 * (x ** n)));\n\t\t\tlet denom = (1 + (c3 * (x ** n)));\n\n\t\t\treturn ((num / denom)  ** m);\n\t\t});\n\t},\n});\n","import RGBColorSpace from \"../rgbspace.js\";\nimport REC2020Linear from \"./rec2020-linear.js\";\n\n// FIXME see https://github.com/LeaVerou/color.js/issues/190\n\nconst a = 0.17883277;\nconst b = 0.28466892; // 1 - (4 * a)\nconst c = 0.55991073; // 0.5 - a * Math.log(4 *a)\n\nconst scale = 3.7743;\t// Place 18% grey at HLG 0.38, so media white at 0.75\n\nexport default new RGBColorSpace({\n\tid: \"rec2100hlg\",\n\tcssId: \"rec2100-hlg\",\n\tname: \"REC.2100-HLG\",\n\treferred: \"scene\",\n\n\tbase: REC2020Linear,\n\ttoBase (RGB) {\n\t\t// given HLG encoded component in range [0, 1]\n\t\t// return media-white relative linear-light\n\t\treturn RGB.map(function (val) {\n\t\t\t// first the HLG EOTF\n\t\t\t// ITU-R BT.2390-10 p.30 section\n\t\t\t// 6.3 The hybrid log-gamma electro-optical transfer function (EOTF)\n\t\t\t// Then scale by 3 so media white is 1.0\n\t\t\tif (val <= 0.5) {\n\t\t\t\treturn (val ** 2) / 3 * scale;\n\t\t\t}\n\t\t\treturn ((Math.exp((val - c) / a) + b) / 12) * scale;\n\t\t});\n\t},\n\tfromBase (RGB) {\n\t\t// given media-white relative linear-light\n\t\t// where diffuse white is 1.0,\n\t\t// return HLG encoded component in range [0, 1]\n\t\treturn RGB.map(function (val) {\n\t\t\t// first scale to put linear-light media white at 1/3\n\t\t\tval /= scale;\n\t\t\t// now the HLG OETF\n\t\t\t// ITU-R BT.2390-10 p.23\n\t\t\t// 6.1 The hybrid log-gamma opto-electronic transfer function (OETF)\n\t\t\tif (val <= 1 / 12) {\n\t\t\t\treturn Math.sqrt(3 * val);\n\t\t\t}\n\t\t\treturn a * Math.log(12 * val - b) + c;\n\t\t});\n\t},\n});\n","import hooks from \"./hooks.js\";\nimport {multiplyMatrices} from \"./util.js\";\nimport {WHITES} from \"./adapt.js\";\n\nexport const CATs = {};\n\nhooks.add(\"chromatic-adaptation-start\", env => {\n\tif (env.options.method) {\n\t\tenv.M = adapt(env.W1, env.W2, env.options.method);\n\t}\n});\n\nhooks.add(\"chromatic-adaptation-end\", env => {\n\tif (!env.M) {\n\t\tenv.M = adapt(env.W1, env.W2, env.options.method);\n\t}\n});\n\nexport function defineCAT ({id, toCone_M, fromCone_M}) {\n\t// Use id, toCone_M, fromCone_M like variables\n\tCATs[id] = arguments[0];\n}\n\nexport function adapt (W1, W2, id = \"Bradford\") {\n\t// adapt from a source whitepoint or illuminant W1\n\t// to a destination whitepoint or illuminant W2,\n\t// using the given chromatic adaptation transform (CAT)\n\t// debugger;\n\tlet method = CATs[id];\n\n\tlet [ρs, γs, βs] = multiplyMatrices(method.toCone_M, W1);\n\tlet [ρd, γd, βd] = multiplyMatrices(method.toCone_M, W2);\n\n\t// all practical illuminants have non-zero XYZ so no division by zero can occur below\n\tlet scale = [\n\t\t[ρd / ρs,  0,        0      ],\n\t\t[0,        γd / γs,  0      ],\n\t\t[0,        0,        βd / βs],\n\t];\n\t// console.log({scale});\n\n\tlet scaled_cone_M = multiplyMatrices(scale, method.toCone_M);\n\tlet adapt_M\t= multiplyMatrices(method.fromCone_M, scaled_cone_M);\n\t// console.log({scaled_cone_M, adapt_M});\n\treturn adapt_M;\n}\n\ndefineCAT({\n\tid: \"von Kries\",\n\ttoCone_M: [\n\t\t[  0.4002400,  0.7076000, -0.0808100 ],\n\t\t[ -0.2263000,  1.1653200,  0.0457000 ],\n\t\t[  0.0000000,  0.0000000,  0.9182200 ],\n\t],\n\tfromCone_M: [\n\t\t[ 1.8599363874558397, -1.1293816185800916,   0.21989740959619328     ],\n\t\t[ 0.3611914362417676,  0.6388124632850422,  -0.000006370596838649899 ],\n\t\t[ 0,                   0,                    1.0890636230968613      ],\n\t],\n});\n\ndefineCAT({\n\tid: \"Bradford\",\n\t// Convert an array of XYZ values in the range 0.0 - 1.0\n\t// to cone fundamentals\n\ttoCone_M: [\n\t\t[  0.8951000,  0.2664000, -0.1614000 ],\n\t\t[ -0.7502000,  1.7135000,  0.0367000 ],\n\t\t[  0.0389000, -0.0685000,  1.0296000 ],\n\t],\n\t// and back\n\tfromCone_M: [\n\t\t[  0.9869929054667121, -0.14705425642099013, 0.15996265166373122  ],\n\t\t[  0.4323052697233945,  0.5183602715367774,  0.049291228212855594 ],\n\t\t[ -0.00852866457517732, 0.04004282165408486, 0.96848669578755     ],\n\t],\n});\n\ndefineCAT({\n\tid: \"CAT02\",\n\t// with complete chromatic adaptation to W2, so D = 1.0\n\ttoCone_M: [\n\t\t[  0.7328000,  0.4296000, -0.1624000 ],\n\t\t[ -0.7036000,  1.6975000,  0.0061000 ],\n\t\t[  0.0030000,  0.0136000,  0.9834000 ],\n\t],\n\tfromCone_M: [\n\t\t[  1.0961238208355142,   -0.27886900021828726, 0.18274517938277307 ],\n\t\t[  0.4543690419753592,    0.4735331543074117,  0.07209780371722911 ],\n\t\t[ -0.009627608738429355, -0.00569803121611342, 1.0153256399545427  ],\n\t],\n});\n\ndefineCAT({\n\tid: \"CAT16\",\n\ttoCone_M: [\n\t\t[  0.401288,  0.650173, -0.051461 ],\n\t\t[ -0.250268,  1.204414,  0.045854 ],\n\t\t[ -0.002079,  0.048952,  0.953127 ],\n\t],\n\t// the extra precision is needed to avoid roundtripping errors\n\tfromCone_M: [\n\t\t[  1.862067855087233,   -1.0112546305316845,  0.14918677544445172  ],\n\t\t[  0.3875265432361372,   0.6214474419314753, -0.008973985167612521 ],\n\t\t[ -0.01584149884933386, -0.03412293802851557, 1.0499644368778496   ],\n\t],\n});\n\nObject.assign(WHITES, {\n\t// whitepoint values from ASTM E308-01 with 10nm spacing, 1931 2 degree observer\n\t// all normalized to Y (luminance) = 1.00000\n\t// Illuminant A is a tungsten electric light, giving a very warm, orange light.\n\tA:   [1.09850, 1.00000, 0.35585],\n\n\t// Illuminant C was an early approximation to daylight: illuminant A with a blue filter.\n\tC:   [0.98074, 1.000000, 1.18232],\n\n\t// The daylight series of illuminants simulate natural daylight.\n\t// The color temperature (in degrees Kelvin/100) ranges from\n\t// cool, overcast daylight (D50) to bright, direct sunlight (D65).\n\tD55: [0.95682, 1.00000, 0.92149],\n\tD75: [0.94972, 1.00000, 1.22638],\n\n\t// Equal-energy illuminant, used in two-stage CAT16\n\tE:   [1.00000, 1.00000, 1.00000],\n\n\t// The F series of illuminants represent fluorescent lights\n\tF2:  [0.99186, 1.00000, 0.67393],\n\tF7:  [0.95041, 1.00000, 1.08747],\n\tF11: [1.00962, 1.00000, 0.64350],\n});\n","import RGBColorSpace from \"../rgbspace.js\";\nimport {WHITES} from \"../adapt.js\";\nimport \"../CATs.js\"; // because of the funky whitepoint\n\n// The ACES whitepoint\n// see TB-2018-001 Derivation of the ACES White Point CIE Chromaticity Coordinates\n// also https://github.com/ampas/aces-dev/blob/master/documents/python/TB-2018-001/aces_wp.py\n// Similar to D60\nWHITES.ACES = [0.32168 / 0.33767, 1.00000, (1.00000 - 0.32168 - 0.33767) / 0.33767];\n\n// convert an array of linear-light ACEScc values to CIE XYZ\nconst toXYZ_M = [\n\t[  0.6624541811085053,   0.13400420645643313,  0.1561876870049078  ],\n\t[  0.27222871678091454,  0.6740817658111484,   0.05368951740793705 ],\n\t[ -0.005574649490394108, 0.004060733528982826, 1.0103391003129971  ],\n];\nconst fromXYZ_M = [\n\t[  1.6410233796943257,   -0.32480329418479,    -0.23642469523761225  ],\n\t[ -0.6636628587229829,    1.6153315916573379,   0.016756347685530137 ],\n\t[  0.011721894328375376, -0.008284441996237409, 0.9883948585390215   ],\n];\n\nexport default new RGBColorSpace({\n\tid: \"acescg\",\n\tcssId: \"--acescg\",\n\tname: \"ACEScg\",\n\n\t// ACEScg – A scene-referred, linear-light encoding of ACES Data\n\t// https://docs.acescentral.com/specifications/acescg/\n\t// uses the AP1 primaries, see section 4.3.1 Color primaries\n\tcoords: {\n\t\tr: {\n\t\t\trange: [0, 65504],\n\t\t\tname: \"Red\",\n\t\t},\n\t\tg: {\n\t\t\trange: [0, 65504],\n\t\t\tname: \"Green\",\n\t\t},\n\t\tb: {\n\t\t\trange: [0, 65504],\n\t\t\tname: \"Blue\",\n\t\t},\n\t},\n\n\treferred: \"scene\",\n\n\twhite: WHITES.ACES,\n\n\ttoXYZ_M,\n\tfromXYZ_M,\n});\n\n// export default Color;\n","import RGBColorSpace from \"../rgbspace.js\";\nimport \"../CATs.js\"; // because of the funky whitepoint\nimport ACEScg from \"./acescg.js\";\n\nconst ε = 2 ** -16;\n\n// the smallest value which, in the 32bit IEEE 754 float encoding,\n// decodes as a non-negative value\nconst ACES_min_nonzero = -0.35828683;\n\n// brightest encoded value, decodes to 65504\nconst ACES_cc_max = (Math.log2(65504) + 9.72) / 17.52; // 1.468\n\nexport default new RGBColorSpace({\n\tid: \"acescc\",\n\tcssId: \"--acescc\",\n\tname: \"ACEScc\",\n\t// see S-2014-003 ACEScc – A Logarithmic Encoding of ACES Data\n\t// https://docs.acescentral.com/specifications/acescc/\n\t// uses the AP1 primaries, see section 4.3.1 Color primaries\n\n\t// Appendix A: \"Very small ACES scene referred values below 7 1/4 stops\n\t// below 18% middle gray are encoded as negative ACEScc values.\n\t// These values should be preserved per the encoding in Section 4.4\n\t// so that all positive ACES values are maintained.\"\n\tcoords: {\n\t\tr: {\n\t\t\trange: [ACES_min_nonzero, ACES_cc_max],\n\t\t\tname: \"Red\",\n\t\t},\n\t\tg: {\n\t\t\trange: [ACES_min_nonzero, ACES_cc_max],\n\t\t\tname: \"Green\",\n\t\t},\n\t\tb: {\n\t\t\trange: [ACES_min_nonzero, ACES_cc_max],\n\t\t\tname: \"Blue\",\n\t\t},\n\t},\n\treferred: \"scene\",\n\n\tbase: ACEScg,\n\t// from section 4.4.2 Decoding Function\n\ttoBase (RGB) {\n\t\tconst low = (9.72 - 15) / 17.52; // -0.3014\n\n\t\treturn RGB.map(function (val) {\n\t\t\tif (val <= low) {\n\t\t\t\treturn (2 ** ((val * 17.52) - 9.72) - ε) * 2; // very low values, below -0.3014\n\t\t\t}\n\t\t\telse if (val < ACES_cc_max) {\n\t\t\t\treturn 2 ** ((val * 17.52) - 9.72);\n\t\t\t}\n\t\t\telse { // val >= ACES_cc_max\n\t\t\t\treturn 65504;\n\t\t\t}\n\t\t});\n\t},\n\n\t// Non-linear encoding function from S-2014-003, section 4.4.1 Encoding Function\n\tfromBase (RGB) {\n\t\treturn RGB.map(function (val) {\n\t\t\tif (val <= 0) {\n\t\t\t\treturn (Math.log2(ε) + 9.72) / 17.52; // -0.3584\n\t\t\t}\n\t\t\telse if (val < ε) {\n\t\t\t\treturn  (Math.log2(ε + val * 0.5) + 9.72) / 17.52;\n\t\t\t}\n\t\t\telse { // val >= ε\n\t\t\t\treturn  (Math.log2(val) + 9.72) / 17.52;\n\t\t\t}\n\t\t});\n\t},\n\t// encoded media white (rgb 1,1,1) => linear  [ 222.861, 222.861, 222.861 ]\n\t// encoded media black (rgb 0,0,0) => linear [ 0.0011857, 0.0011857, 0.0011857]\n});\n","import * as util from \"./util.js\";\nimport hooks from \"./hooks.js\";\nimport defaults from \"./defaults.js\";\nimport ColorSpace from \"./space.js\";\nimport {WHITES} from \"./adapt.js\";\nimport {\n\tgetColor,\n\tparse,\n\tto,\n\tserialize,\n\tinGamut,\n\ttoGamut,\n\tdistance,\n\tequals,\n\tget,\n\tgetAll,\n\tset,\n\tsetAll,\n\tdisplay,\n} from \"./index-fn.js\";\n\n\nimport \"./spaces/xyz-d50.js\";\nimport \"./spaces/srgb.js\";\n\n/**\n * Class that represents a color\n */\nexport default class Color {\n\t/**\n\t * Creates an instance of Color.\n\t * Signatures:\n\t * - `new Color(stringToParse)`\n\t * - `new Color(otherColor)`\n\t * - `new Color({space, coords, alpha})`\n\t * - `new Color(space, coords, alpha)`\n\t * - `new Color(spaceId, coords, alpha)`\n\t */\n\tconstructor (...args) {\n\t\tlet color;\n\n\t\tif (args.length === 1) {\n\t\t\tcolor = getColor(args[0]);\n\t\t}\n\n\t\tlet space, coords, alpha;\n\n\t\tif (color) {\n\t\t\tspace = color.space || color.spaceId;\n\t\t\tcoords = color.coords;\n\t\t\talpha = color.alpha;\n\t\t}\n\t\telse {\n\t\t\t// default signature new Color(ColorSpace, array [, alpha])\n\t\t\t[space, coords, alpha] = args;\n\t\t}\n\n\t\tObject.defineProperty(this, \"space\", {\n\t\t\tvalue: ColorSpace.get(space),\n\t\t\twritable: false,\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true, // see note in https://262.ecma-international.org/8.0/#sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver\n\t\t});\n\n\t\tthis.coords = coords ? coords.slice() : [0, 0, 0];\n\n\t\t// Clamp alpha to [0, 1]\n\t\tthis.alpha = alpha > 1 || alpha === undefined ? 1 : (alpha < 0 ? 0 : alpha);\n\n\t\t// Convert \"NaN\" to NaN\n\t\tfor (let i = 0; i < this.coords.length; i++) {\n\t\t\tif (this.coords[i] === \"NaN\") {\n\t\t\t\tthis.coords[i] = NaN;\n\t\t\t}\n\t\t}\n\n\t\t// Define getters and setters for each coordinate\n\t\tfor (let id in this.space.coords) {\n\t\t\tObject.defineProperty(this, id, {\n\t\t\t\tget: () => this.get(id),\n\t\t\t\tset: value => this.set(id, value),\n\t\t\t});\n\t\t}\n\t}\n\n\tget spaceId () {\n\t\treturn this.space.id;\n\t}\n\n\tclone () {\n\t\treturn new Color(this.space, this.coords, this.alpha);\n\t}\n\n\ttoJSON () {\n\t\treturn {\n\t\t\tspaceId: this.spaceId,\n\t\t\tcoords: this.coords,\n\t\t\talpha: this.alpha,\n\t\t};\n\t}\n\n\tdisplay (...args) {\n\t\tlet ret = display(this, ...args);\n\n\t\t// Convert color object to Color instance\n\t\tret.color = new Color(ret.color);\n\n\t\treturn ret;\n\t}\n\n\t/**\n\t * Get a color from the argument passed\n\t * Basically gets us the same result as new Color(color) but doesn't clone an existing color object\n\t */\n\tstatic get (color, ...args) {\n\t\tif (color instanceof Color) {\n\t\t\treturn color;\n\t\t}\n\n\t\treturn new Color(color, ...args);\n\t}\n\n\tstatic defineFunction (name, code, o = code) {\n\t\tlet {instance = true, returns} = o;\n\n\t\tlet func = function (...args) {\n\t\t\tlet ret = code(...args);\n\n\t\t\tif (returns === \"color\") {\n\t\t\t\tret = Color.get(ret);\n\t\t\t}\n\t\t\telse if (returns === \"function<color>\") {\n\t\t\t\tlet f = ret;\n\t\t\t\tret = function (...args) {\n\t\t\t\t\tlet ret = f(...args);\n\t\t\t\t\treturn Color.get(ret);\n\t\t\t\t};\n\t\t\t\t// Copy any function metadata\n\t\t\t\tObject.assign(ret, f);\n\t\t\t}\n\t\t\telse if (returns === \"array<color>\") {\n\t\t\t\tret = ret.map(c => Color.get(c));\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t};\n\n\t\tif (!(name in Color)) {\n\t\t\tColor[name] = func;\n\t\t}\n\n\t\tif (instance) {\n\t\t\tColor.prototype[name] = function (...args) {\n\t\t\t\treturn func(this, ...args);\n\t\t\t};\n\t\t}\n\t}\n\n\tstatic defineFunctions (o) {\n\t\tfor (let name in o) {\n\t\t\tColor.defineFunction(name, o[name], o[name]);\n\t\t}\n\t}\n\n\tstatic extend (exports) {\n\t\tif (exports.register) {\n\t\t\texports.register(Color);\n\t\t}\n\t\telse {\n\t\t\t// No register method, just add the module's functions\n\t\t\tfor (let name in exports) {\n\t\t\t\tColor.defineFunction(name, exports[name]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nColor.defineFunctions({\n\tget,\n\tgetAll,\n\tset,\n\tsetAll,\n\tto,\n\tequals,\n\tinGamut,\n\ttoGamut,\n\tdistance,\n\ttoString: serialize,\n});\n\nObject.assign(Color, {\n\tutil,\n\thooks,\n\tWHITES,\n\tSpace: ColorSpace,\n\tspaces: ColorSpace.registry,\n\tparse,\n\n\t// Global defaults one may want to configure\n\tdefaults,\n});\n","import ColorSpace from \"../space.js\";\nimport * as spaces from \"./index-fn.js\";\n\nexport * as spaces from \"./index-fn.js\";\n\nfor (let key of Object.keys(spaces)) {\n\tColorSpace.register(spaces[key]);\n}\n","/**\n * This plugin defines getters and setters for color[spaceId]\n * e.g. color.lch on *any* color gives us the lch coords\n */\nimport ColorSpace from \"./space.js\";\nimport Color from \"./color.js\";\nimport hooks from \"./hooks.js\";\n\n// Add space accessors to existing color spaces\nfor (let id in ColorSpace.registry) {\n\taddSpaceAccessors(id, ColorSpace.registry[id]);\n}\n\n// Add space accessors to color spaces not yet created\nhooks.add(\"colorspace-init-end\", space => {\n\taddSpaceAccessors(space.id, space);\n\tspace.aliases?.forEach(alias => {\n\t\taddSpaceAccessors(alias, space);\n\t});\n});\n\nfunction addSpaceAccessors (id, space) {\n\tlet propId = id.replace(/-/g, \"_\");\n\n\tObject.defineProperty(Color.prototype, propId, {\n\t\t// Convert coords to coords in another colorspace and return them\n\t\t// Source colorspace: this.spaceId\n\t\t// Target colorspace: id\n\t\tget () {\n\t\t\tlet ret = this.getAll(id);\n\n\t\t\tif (typeof Proxy === \"undefined\") {\n\t\t\t\t// If proxies are not supported, just return a static array\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Enable color.spaceId.coordName syntax\n\t\t\treturn new Proxy(ret, {\n\t\t\t\thas: (obj, property) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tColorSpace.resolveCoord([space, property]);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {}\n\n\t\t\t\t\treturn Reflect.has(obj, property);\n\t\t\t\t},\n\t\t\t\tget: (obj, property, receiver) => {\n\t\t\t\t\tif (property && typeof property !== \"symbol\" && !(property in obj)) {\n\t\t\t\t\t\tlet {index} = ColorSpace.resolveCoord([space, property]);\n\n\t\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\t\treturn obj[index];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Reflect.get(obj, property, receiver);\n\t\t\t\t},\n\t\t\t\tset: (obj, property, value, receiver) => {\n\t\t\t\t\tif (property && typeof property !== \"symbol\" && !(property in obj) || property >= 0) {\n\t\t\t\t\t\tlet {index} = ColorSpace.resolveCoord([space, property]);\n\n\t\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\t\tobj[index] = value;\n\n\t\t\t\t\t\t\t// Update color.coords\n\t\t\t\t\t\t\tthis.setAll(id, obj);\n\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Reflect.set(obj, property, value, receiver);\n\t\t\t\t},\n\t\t\t});\n\t\t},\n\t\t// Convert coords in another colorspace to internal coords and set them\n\t\t// Target colorspace: this.spaceId\n\t\t// Source colorspace: id\n\t\tset (coords) {\n\t\t\tthis.setAll(id, coords);\n\t\t},\n\t\tconfigurable: true,\n\t\tenumerable: true,\n\t});\n}\n","// Import all modules of Color.js\nimport Color from \"./color.js\";\n\n// Import all color spaces\nimport \"./spaces/index.js\";\n\n// Import all DeltaE methods\nimport deltaE from \"./deltaE.js\";\nimport deltaEMethods from \"./deltaE/index.js\";\n\nColor.extend(deltaEMethods);\nColor.extend({deltaE});\nObject.assign(Color, {deltaEMethods});\n\n// Import optional modules\nimport * as variations from \"./variations.js\";\nColor.extend(variations);\n\nimport contrast from \"./contrast.js\";\nColor.extend({contrast});\n\nimport * as chromaticity from \"./chromaticity.js\";\nColor.extend(chromaticity);\n\nimport * as luminance from \"./luminance.js\";\nColor.extend(luminance);\n\nimport * as interpolation from \"./interpolation.js\";\nColor.extend(interpolation);\n\nimport * as contrastMethods from \"./contrast/index.js\";\nColor.extend(contrastMethods);\n\nimport \"./CATs.js\";\nimport \"./space-accessors.js\";\n\n// Re-export everything\nexport default Color;\n","import type { PoseData } from \"./index\";\nimport type { Landmark, NormalizedLandmark } from \"../index\";\n\nconst posePoints: PoseLandmarks[] = [ \"nose\", \"left_eye_inner\", \"left_eye\", \"left_eye_outer\", \"right_eye_inner\", \"right_eye\", \"right_eye_outer\", \"left_ear\", \"right_ear\", \"mouth_left\", \"mouth_right\", \"left_shoulder\", \"right_shoulder\", \"left_elbow\", \"right_elbow\", \"left_wrist\", \"right_wrist\", \"left_pinky\", \"right_pinky\", \"left_index\", \"right_index\", \"left_thumb\", \"right_thumb\", \"left_hip\", \"right_hip\", \"left_knee\", \"right_knee\", \"left_ankle\", \"right_ankle\", \"left_heel\", \"right_heel\", \"left_foot_index\", \"right_foot_index\" ];\n\nexport type PoseLandmarks = \"nose\" | \"left_eye_inner\" | \"left_eye\" | \"left_eye_outer\" | \"right_eye_inner\" | \"right_eye\" | \"right_eye_outer\" | \"left_ear\" | \"right_ear\" | \"mouth_left\" | \"mouth_right\" | \"left_shoulder\" | \"right_shoulder\" | \"left_elbow\" | \"right_elbow\" | \"left_wrist\" | \"right_wrist\" | \"left_pinky\" | \"right_pinky\" | \"left_index\" | \"right_index\" | \"left_thumb\" | \"right_thumb\" | \"left_hip\" | \"right_hip\" | \"left_knee\" | \"right_knee\" | \"left_ankle\" | \"right_ankle\" | \"left_heel\" | \"right_heel\" | \"left_foot_index\" | \"right_foot_index\"\n\n/**\n * Returns landmark index by name, or _undefined_ if not found\n * @param name \n * @returns \n */\nexport const getLandmarkIndexByName = (name: PoseLandmarks | string): number | undefined => {\n  for (let i = 0; i < posePoints.length; i++) {\n    if (posePoints[ i ] === name) return i;\n  }\n}\n\n/**\n * Returns landmark name by index, throws if 'index' out of range.\n * @param index \n * @returns \n */\nexport const getLandmarkNameByIndex = (index: number): PoseLandmarks => {\n  if (typeof index !== `number`) throw new Error(`Expected numeric index. Got: ${ typeof index }`);\n  if (index < 0) throw new Error(`Index should be at least 0`);\n  if (index >= posePoints.length) throw new Error(`Index is higher than expected (${ index })`);\n  return posePoints[ index ];\n}\n\nexport const getLandmark = (pose: PoseData, indexOrName: number | PoseLandmarks): NormalizedLandmark | undefined => {\n  if (typeof indexOrName === `number`) {\n    return pose.landmarks[ indexOrName ];\n  } else {\n    const index = getLandmarkIndexByName(indexOrName);\n    if (!index) return;\n    return pose.landmarks[ index ];\n  }\n}\n\nexport const getWorldLandmark = (pose: PoseData, indexOrName: number | PoseLandmarks): Landmark | undefined => {\n  if (typeof indexOrName === `number`) {\n    return pose.world[ indexOrName ];\n  } else {\n    const index = getLandmarkIndexByName(indexOrName);\n    if (!index) return;\n    return pose.world[ index ];\n  }\n}","import { Lines, type Line, Points } from 'ixfx/geometry.js';\nimport { getLandmark, type PoseLandmarks } from './landmarks.js';\nimport type { PoseData } from './index.js';\n\n/**\n * Sorts raw `poses` by horziontal.\n * Leftmost pose will be first.\n */\nexport const horizontalSort = (poses: PoseData[]) => {\n  const withCentroids = poses.map(p => ({\n    ...p,\n    centroid: centroid(p)\n  }));\n  withCentroids.sort((a, b) => a.centroid.x - b.centroid.x);\n  return withCentroids;\n};\n\n/**\n * Return centroid of Pose based on landmarks.\n * \n */\nexport const centroid = (pose: PoseData) => Points.centroid(...pose.landmarks);\n\n/**\n * Return centroid of pose based on world landmarks\n */\nexport const centroidWorld = (pose: PoseData) => Points.centroid(...pose.world);\n\n/**\n * Returns a line between two named/indexed landmarks.\n * If either of the two points are not found, _undefined_ is returned.\n * @param pose Pose data \n * @param a Landmark A\n * @param b Landmark B\n */\nexport const lineBetween = (pose: PoseData, a: PoseLandmarks | number, b: PoseLandmarks | number): Line | undefined => {\n  if (pose === undefined) throw new TypeError(`Param 'pose' is undefined. Expected PoseData`);\n  if (a === undefined) throw new TypeError(`Param 'a' is undefined, expected landmark name or index.`);\n  if (b === undefined) throw new TypeError(`Param 'b' is undefined, expected landmark name or index.`);\n\n  const ptA = getLandmark(pose, a);\n  const ptB = getLandmark(pose, b);\n  if (ptA === undefined) return;\n  if (ptB === undefined) return;\n  return Object.freeze({\n    a: ptA,\n    b: ptB\n  });\n};\n\n/**\n * Returns the rough center of a pose, based on\n * the chest coordinates\n */\nexport const roughCenter = (pose: PoseData) => {\n  if (pose === undefined) throw new Error(`Param 'pose' is undefined. Expected PoseData`);\n  const a = lineBetween(pose, `left_shoulder`, `right_hip`);\n  const b = lineBetween(pose, `right_shoulder`, `left_hip`);\n  if (a === undefined) return;\n  if (b === undefined) return;\n\n  // Get halfway of each line\n  const halfA = Lines.interpolate(0.5, a);\n  const halfB = Lines.interpolate(0.5, b);\n\n  // Add them up\n  const sum = Points.sum(halfA, halfB);\n\n  // Divide to get avg\n  return Points.divide(sum, 2, 2);\n};\n","import type { IDictionary } from './IMappish.js';\nexport type GetOrGenerate<K, V, Z> = (key: K, args?: Z) => Promise<V>;\n\n/**\n * @inheritDoc getOrGenerate\n * @param map\n * @param fn\n * @returns\n */\n//eslint-disable-next-line functional/prefer-readonly-type\nexport const getOrGenerateSync =\n  <K, V, Z>(map: IDictionary<K, V>, fn: (key: K, args?: Z) => V) =>\n    (key: K, args?: Z): V => {\n      //eslint-disable-next-line functional/no-let\n      let value = map.get(key);\n      if (value !== undefined) return value;\n      value = fn(key, args);\n      map.set(key, value);\n      return value;\n    };\n\n/**\n * Returns a function that fetches a value from a map, or generates and sets it if not present.\n * Undefined is never returned, because if `fn` yields that, an error is thrown.\n *\n * See {@link getOrGenerateSync} for a synchronous version.\n *\n * ```\n * const m = getOrGenerate(new Map(), (key) => {\n *  return key.toUppercase();\n * });\n *\n * // Not contained in map, so it will run the uppercase function,\n * // setting the value to the key 'hello'.\n * const v = await m(`hello`);  // Yields 'HELLO'\n * const v1 = await m(`hello`); // Value exists, so it is returned ('HELLO')\n * ```\n *\n */\n//eslint-disable-next-line functional/prefer-readonly-type\nexport const getOrGenerate =\n  <K, V, Z>(\n    map: IDictionary<K, V>,\n    fn: (key: K, args?: Z) => Promise<V> | V\n  ): GetOrGenerate<K, V, Z> =>\n    async (key: K, args?: Z): Promise<V> => {\n      //eslint-disable-next-line functional/no-let\n      let value = map.get(key);\n      if (value !== undefined) return value; //Promise.resolve(value);\n      value = await fn(key, args);\n      if (value === undefined) throw new Error(`fn returned undefined`);\n      map.set(key, value);\n      return value;\n    };","import { type Timestamped, type TrackedValueOpts } from './TrackedValue.js';\n\n/**\n * Base tracker class\n */\nexport abstract class TrackerBase<V, SeenResultType> {\n  /**\n   * @ignore\n   */\n  seenCount: number;\n\n  /**\n   * @ignore\n   */\n  protected storeIntermediate: boolean;\n\n  /**\n   * @ignore\n   */\n  protected resetAfterSamples: number;\n\n  /**\n   * @ignore\n   */\n  protected sampleLimit: number;\n\n  public readonly id: string;\n\n  protected debug: boolean;\n\n  constructor(opts: TrackedValueOpts = {}) {\n    this.id = opts.id ?? `tracker`;\n    this.debug = opts.debug ?? false;\n    this.sampleLimit = opts.sampleLimit ?? -1;\n    this.resetAfterSamples = opts.resetAfterSamples ?? -1;\n\n    this.storeIntermediate =\n      opts.storeIntermediate ??\n      (this.sampleLimit > -1 || this.resetAfterSamples > -1);\n    this.seenCount = 0;\n\n    if (this.debug) {\n      console.log(`TrackerBase: sampleLimit: ${ this.sampleLimit } resetAfter: ${ this.resetAfterSamples } store: ${ this.storeIntermediate }`);\n    }\n  }\n\n  /**\n   * Reset tracker\n   */\n  reset() {\n    this.seenCount = 0;\n    this.onReset();\n  }\n\n  /**\n   * Calculate results\n   *  \n   * @param p \n   * @returns \n   */\n  seen(...p: Array<V>): SeenResultType {\n    if (this.resetAfterSamples > 0 && this.seenCount > this.resetAfterSamples) {\n      this.reset();\n    } else if (this.sampleLimit > 0 && this.seenCount > this.sampleLimit * 2) {\n      this.seenCount = this.trimStore(this.sampleLimit);\n      this.onTrimmed();\n    }\n\n    this.seenCount += p.length;\n    const t = this.filterData(p);\n    return this.computeResults(t);\n  }\n\n  /**\n   * @ignore\n   * @param p\n   */\n  abstract filterData(p: Array<V>): Array<Timestamped>;\n\n  abstract get last(): V | undefined;\n\n  /**\n   * Returns the initial value, or undefined\n   */\n  abstract get initial(): V | undefined;\n\n  /**\n   * Returns the elapsed milliseconds since the initial value\n   */\n  abstract get elapsed(): number;\n\n  /**\n   * @ignore\n   */\n  //eslint-disable-next-line @typescript-eslint/no-empty-function\n  abstract computeResults(_p: Array<Timestamped>): SeenResultType;\n\n  /**\n   * @ignore\n   */\n  abstract onReset(): void;\n\n  abstract onTrimmed(): void;\n  abstract trimStore(limit: number): number;\n}\n","import { type GetOrGenerate, getOrGenerate } from '../data/maps/GetOrGenerate.js';\nimport { TrackerBase } from './TrackerBase.js';\n\nexport type Timestamped = {\n  readonly at: number\n}\nexport type TimestampedObject<V> = V & Timestamped;\n\n/**\n * Options\n */\nexport type TrackedValueOpts = {\n  readonly id?: string;\n\n  /**\n   * If true, intermediate points are stored. False by default\n   */\n  readonly storeIntermediate?: boolean;\n  /**\n   * If above zero, tracker will reset after this many samples\n   */\n  readonly resetAfterSamples?: number;\n\n  /**\n   * If above zero, there will be a limit to intermediate values kept.\n   *\n   * When the seen values is twice `sampleLimit`, the stored values will be trimmed down\n   * to `sampleLimit`. We only do this when the values are double the size so that\n   * the collections do not need to be trimmed repeatedly whilst we are at the limit.\n   *\n   * Automatically implies storeIntermediate\n   */\n  readonly sampleLimit?: number;\n\n  /**\n   * If true\n   */\n  readonly debug?: boolean\n};\n\n/**\n * Keeps track of keyed values of type `V` (eg Point). It stores occurences in type `T`, which\n * must extend from `TrackerBase<V>`, eg `PointTracker`.\n *\n * The `creator` function passed in to the constructor is responsible for instantiating\n * the appropriate `TrackerBase` sub-class.\n *\n * @example Sub-class\n * ```js\n * export class TrackedPointMap extends TrackedValueMap<Points.Point> {\n *  constructor(opts:TrackOpts = {}) {\n *   super((key, start) => {\n *    if (start === undefined) throw new Error(`Requires start point`);\n *    const p = new PointTracker(key, opts);\n *    p.seen(start);\n *    return p;\n *   });\n *  }\n * }\n * ```\n *\n */\nexport class TrackedValueMap<V, T extends TrackerBase<V, TResult>, TResult> {\n  store: Map<string, T>;\n  gog: GetOrGenerate<string, T, V>;\n\n  constructor(creator: (key: string, start: V | undefined) => T) {\n    this.store = new Map();\n    this.gog = getOrGenerate<string, T, V>(this.store, creator);\n  }\n\n  /**\n   * Number of named values being tracked\n   */\n  get size() {\n    return this.store.size;\n  }\n\n  /**\n   * Returns _true_ if `id` is stored\n   * @param id\n   * @returns\n   */\n  has(id: string) {\n    return this.store.has(id);\n  }\n\n  /**\n   * For a given id, note that we have seen one or more values.\n   * @param id Id\n   * @param values Values(s)\n   * @returns Information about start to last value\n   */\n  //eslint-disable-next-line @typescript-eslint/no-explicit-any\n  //eslint-disable-next-line functional/prefer-immutable-types\n  public async seen(id: string, ...values: Array<V>): Promise<TResult> {\n    const trackedValue = await this.getTrackedValue(id, ...values);\n\n    // Pass it over to the TrackedValue\n    const result = trackedValue.seen(...values);\n\n    return result;\n  }\n\n  /**\n   * Creates or returns a TrackedValue instance for `id`.\n   * @param id\n   * @param values\n   * @returns\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  protected async getTrackedValue(id: string, ...values: Array<V>) {\n    if (id === null) throw new Error(`id parameter cannot be null`);\n    if (id === undefined) throw new Error(`id parameter cannot be undefined`);\n\n    // Create or recall TrackedValue by id\n    const trackedValue = await this.gog(id, values[ 0 ]);\n    return trackedValue;\n  }\n\n  /**\n   * Remove a tracked value by id.\n   * Use {@link reset} to clear them all.\n   * @param id\n   */\n  delete(id: string) {\n    this.store.delete(id);\n  }\n\n  /**\n   * Remove all tracked values.\n   * Use {@link delete} to remove a single value by id.\n   */\n  reset() {\n    this.store = new Map();\n  }\n\n  /**\n   * Enumerate ids\n   */\n  *ids() {\n    yield* this.store.keys();\n  }\n\n  /**\n   * Enumerate tracked values\n   */\n  *tracked() {\n    yield* this.store.values();\n  }\n\n  /**\n   * Iterates TrackedValues ordered with oldest first\n   * @returns\n   */\n  *trackedByAge() {\n    const tp = [ ...this.store.values() ];\n    tp.sort((a, b) => {\n      const aa = a.elapsed;\n      const bb = b.elapsed;\n      if (aa === bb) return 0;\n      if (aa > bb) return -1;\n      return 1;\n    });\n\n    for (const t of tp) {\n      yield t;\n    }\n  }\n\n  /**\n   * Iterates underlying values, ordered by age (oldest first)\n   * First the named values are sorted by their `elapsed` value, and then\n   * we return the last value for that group.\n   */\n  *valuesByAge() {\n    for (const tb of this.trackedByAge()) {\n      yield tb.last;\n    }\n  }\n\n  /**\n   * Enumerate last received values\n   *\n   * @example Calculate centroid of latest-received values\n   * ```js\n   * const pointers = pointTracker();\n   * const c = Points.centroid(...Array.from(pointers.lastPoints()));\n   * ```\n   */\n  *last() {\n    for (const p of this.store.values()) {\n      yield p.last;\n    }\n  }\n\n  /**\n   * Enumerate starting values\n   */\n  *initialValues() {\n    for (const p of this.store.values()) {\n      yield p.initial;\n    }\n  }\n\n  /**\n   * Returns a tracked value by id, or undefined if not found\n   * @param id\n   * @returns\n   */\n  get(id: string): TrackerBase<V, TResult> | undefined {\n    return this.store.get(id);\n  }\n}\n","//import { repeat } from '../flow/index.js';\n\nimport type { TrackedValueOpts } from './TrackedValue.js';\nimport { TrackerBase } from './TrackerBase.js';\n\nexport type TimestampedPrimitive<V extends number | string> = {\n  at: number\n  value: V\n}\n\nexport abstract class PrimitiveTracker<\n  V extends number | string,\n  TResult\n> extends TrackerBase<V, TResult> {\n\n  //computeResults(_p: Timestamped[]): TResult;\n\n  values: Array<V>;\n  timestamps: Array<number>;\n  //data: Array<TimestampedPrimitive<V>>;\n\n  constructor(opts?: TrackedValueOpts) {\n    super(opts);\n    //this.data = [];\n    this.values = [];\n    this.timestamps = [];\n  }\n\n  /**\n   * Reduces size of value store to `limit`. Returns\n   * number of remaining items\n   * @param limit\n   */\n  trimStore(limit: number): number {\n    if (limit >= this.values.length) return this.values.length;\n    //this.data = this.data.slice(-limit);\n    this.values = this.values.slice(-limit);\n    this.timestamps = this.timestamps.slice(-limit);\n    return this.values.length;\n  }\n\n  onTrimmed() {\n    // no-op\n  }\n\n  get last(): V | undefined {\n    return this.values.at(-1);\n  }\n\n  get initial(): V | undefined {\n    return this.values.at(0);\n  }\n\n  /**\n   * Returns number of recorded values (this can include the initial value)\n   */\n  get size() {\n    return this.values.length;\n  }\n\n  /**\n   * Returns the elapsed time, in milliseconds since the instance was created\n   */\n  get elapsed(): number {\n    if (this.values.length < 0) throw new Error(`No values seen yet`);\n    return Date.now() - this.timestamps[ 0 ];\n  }\n\n  onReset() {\n    this.values = [];\n    this.timestamps = [];\n  }\n\n  /**\n   * Tracks a value\n   */\n  filterData(rawValues: Array<V>): Array<TimestampedPrimitive<V>> {\n    const lastValue = rawValues.at(-1);\n    const last: TimestampedPrimitive<V> = { value: lastValue as unknown as V, at: performance.now() };\n\n    const values: Array<TimestampedPrimitive<V>> = rawValues.map(value => ({\n      at: performance.now(),\n      value: value\n    }));\n\n    //const now = Date.now();\n    if (this.storeIntermediate) {\n      this.values.push(...rawValues);\n      this.timestamps.push(...values.map(v => v.at));\n    } else switch (this.values.length) {\n      case 0: {\n        // Add as initial value\n        this.values.push(last.value);\n        this.timestamps.push(last.at);\n        break;\n      }\n      case 2: {\n        // Replace last value\n        this.values[ 1 ] = last.value;\n        this.timestamps[ 1 ] = last.at;\n        break;\n      }\n      case 1: {\n        // Add last value\n        this.values.push(last.value);\n        this.timestamps.push(last.at);\n        break;\n      }\n      // No default\n    }\n\n    return values;\n  }\n}\n","import { PrimitiveTracker, type TimestampedPrimitive } from './PrimitiveTracker.js'\nimport {\n  type TrackedValueOpts as TrackOpts,\n} from './TrackedValue.js';\nimport { minFast, maxFast, totalFast } from '../numbers/NumericArrays.js';\n\nexport type NumberTrackerResults = {\n  readonly total: number\n  readonly min: number\n  readonly max: number\n  readonly avg: number\n};\n\nexport class NumberTracker extends PrimitiveTracker<number, NumberTrackerResults> {\n  total = 0;\n  min = Number.MAX_SAFE_INTEGER;\n  max = Number.MIN_SAFE_INTEGER;\n\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(opts?: TrackOpts) {\n    super(opts);\n    /** no-op */\n  }\n\n  get avg() {\n    return this.total / this.seenCount;\n  }\n\n  /**\n   * Difference between last value and initial.\n   * Eg. if last value was 10 and initial value was 5, 5 is returned (10 - 5)\n   * If either of those is missing, undefined is returned\n   */\n  difference(): number | undefined {\n    if (this.last === undefined) return;\n    if (this.initial === undefined) return;\n    return this.last - this.initial;\n  }\n\n  /**\n   * Relative difference between last value and initial.\n   * Eg if last value was 10 and initial value was 5, 2 is returned (200%)\n   */\n  relativeDifference(): number | undefined {\n    if (this.last === undefined) return;\n    if (this.initial === undefined) return;\n    return this.last / this.initial;\n  }\n\n  onReset() {\n    this.min = Number.MAX_SAFE_INTEGER;\n    this.max = Number.MIN_SAFE_INTEGER;\n    this.total = 0;\n    super.onReset();\n  }\n\n  onTrimmed() {\n    this.min = minFast(this.values);\n    this.max = maxFast(this.values);\n    this.total = totalFast(this.values);\n  }\n\n  computeResults(values: Array<TimestampedPrimitive<number>>): NumberTrackerResults {\n    if (values.some((v) => Number.isNaN(v))) throw new Error(`Cannot add NaN`);\n    const numbers = values.map(value => value.value);\n\n    this.total = numbers.reduce((accumulator, v) => accumulator + v, this.total);\n    this.min = Math.min(...numbers, this.min);\n    this.max = Math.max(...numbers, this.max);\n    const r: NumberTrackerResults = {\n      max: this.max,\n      min: this.min,\n      total: this.total,\n      avg: this.avg\n    }\n    return r;\n  }\n\n  getMinMaxAvg() {\n    return {\n      min: this.min,\n      max: this.max,\n      avg: this.avg,\n    };\n  }\n}\n\n/**\n * Keeps track of the total, min, max and avg in a stream of values. By default values\n * are not stored.\n *\n * Usage:\n *\n * ```js\n * import { number } from 'https://unpkg.com/ixfx/dist/trackers.js';\n *\n * const t = number();\n * t.seen(10);\n *\n * t.avg / t.min/ t.max\n * t.initial; // initial value\n * t.size;    // number of seen values\n * t.elapsed; // milliseconds since intialisation\n * t.last;    // last value\n * ```\n *\n * To get `{ avg, min, max, total }`\n * ```\n * t.getMinMax()\n * ```\n *\n * Use `t.reset()` to clear everything.\n *\n * Trackers can automatically reset after a given number of samples\n * ```\n * // reset after 100 samples\n * const t = number({ resetAfterSamples: 100 });\n * ```\n *\n * To store values, use the `storeIntermediate` option:\n *\n * ```js\n * const t = number({ storeIntermediate: true });\n * ```\n *\n * Difference between last value and initial value:\n * ```js\n * t.relativeDifference();\n * ```\n *\n * Get raw data (if it is being stored):\n * ```js\n * t.values; // array of numbers\n * t.timestampes; // array of millisecond times, indexes correspond to t.values\n * ```\n */\nexport const number = (opts: TrackOpts = {}) => new NumberTracker(opts);\n","import type { TimestampedObject, TrackedValueOpts } from './TrackedValue.js';\nimport { TrackerBase } from './TrackerBase.js';\n\n/**\n * A tracked value of type `V`.\n */\nexport abstract class ObjectTracker<V extends object, SeenResultType> extends TrackerBase<V, SeenResultType> {\n  //abstract onSeen(_p: Array<V>): SeenResultType;\n\n  values: Array<TimestampedObject<V>>;\n\n  constructor(opts: TrackedValueOpts = {}) {\n    super(opts);\n    this.values = [];\n  }\n\n  onTrimmed() {\n    // no-op\n  }\n\n  /**\n   * Reduces size of value store to `limit`. \n   * Returns number of remaining items\n   * @param limit\n   */\n  trimStore(limit: number): number {\n    if (limit >= this.values.length) return this.values.length;\n    // Index 0 will be the oldest\n    this.values = this.values.slice(-limit);\n    return this.values.length;\n  }\n\n  /**\n   * Allows sub-classes to be notified when a reset happens\n   * @ignore\n   */\n  onReset() {\n    this.values = [];\n  }\n\n  /**\n   * Tracks a value\n   * @ignore\n   */\n  filterData(p: Array<V> | Array<TimestampedObject<V>>): Array<TimestampedObject<V>> {\n    // Make sure values have a timestamp\n    const ts = p.map((v) =>\n      `at` in v\n        ? v\n        : {\n          ...v,\n          at: Date.now(),\n        }\n    );\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const last = ts.at(-1)!;\n\n    if (this.storeIntermediate) this.values.push(...ts);\n    else switch (this.values.length) {\n      case 0: {\n        // Add as initial value\n        this.values.push(last);\n        break;\n      }\n      case 1: {\n        // Add last value\n        this.values.push(last);\n        break;\n      }\n      case 2: {\n        // Replace last value\n        this.values[ 1 ] = last;\n        break;\n      }\n    }\n    return ts;\n  }\n\n  /**\n   * Last seen value. If no values have been added, it will return the initial value\n   */\n  get last() {\n    if (this.values.length === 1) return this.values[ 0 ];\n    //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.values.at(-1)!;\n  }\n\n  /**\n   * Returns the initial value\n   */\n  get initial() {\n    return this.values.at(0);\n  }\n\n  /**\n   * Returns number of recorded values (includes the initial value in the count)\n   */\n  get size() {\n    return this.values.length;\n  }\n\n  /**\n   * Returns the elapsed time, in milliseconds since the initial value\n   */\n  get elapsed(): number {\n    return Date.now() - this.values[ 0 ].at;\n  }\n\n}\n","import * as Points from '../geometry/point/index.js';\nimport {\n  TrackedValueMap,\n  type TrackedValueOpts as TrackOpts,\n  type TimestampedObject,\n} from './TrackedValue.js';\nimport { ObjectTracker } from './ObjectTracker.js';\nimport { length as LineLength } from '../geometry/line/Length.js';\nimport { Vectors } from '../geometry/index.js';\nimport { Empty as LinesEmpty } from '../geometry/line/index.js';\nimport type { Coord as PolarCoord } from '../geometry/Polar.js';\nimport type { Line, PolyLine } from '../geometry/line/LineType.js';\nimport type { Point } from '../geometry/point/PointType.js';\nimport type { PointRelation } from '../geometry/point/PointRelationTypes.js';\nimport { joinPointsToLines } from '../geometry/line/JoinPointsToLines.js';\nimport type { PointTrack, PointTrackerResults } from './Types.js';\n\n/**\n * Point tracker. Create via `Trackers.point()`.\n *\n */\nexport class PointTracker extends ObjectTracker<Point, PointTrackerResults> {\n  /**\n   * Function that yields the relation from initial point\n   */\n  initialRelation: PointRelation | undefined;\n\n  /**\n   * Last result\n   */\n  lastResult: PointTrackerResults | undefined;\n\n  constructor(opts: TrackOpts = {}) {\n    super(opts);\n  }\n\n  onTrimmed(): void {\n    // Force new relation calculations\n    this.initialRelation = undefined;\n  }\n\n  /**\n   * Returns the last x coord\n   */\n  get x() {\n    return this.last.x;\n  }\n\n  /**\n   * Returns the last y coord\n   */\n  get y() {\n    return this.last.y;\n  }\n\n  /**\n   * @ignore\n   */\n  onReset(): void {\n    super.onReset();\n    this.lastResult = undefined;\n    this.initialRelation = undefined;\n  }\n\n  seenEvent(p: PointerEvent): PointTrackerResults {\n    if (`getCoalescedEvents` in p) {\n      const events = p.getCoalescedEvents();\n      const asPoints = events.map(event => ({ x: event.clientX, y: event.clientY }));\n      return this.seen(...asPoints);\n    } else {\n      // @ts-expect-error\n      return this.seen({ x: p.clientX, y: p.clientY });\n    }\n  }\n\n  /**\n   * Tracks a point, returning data on its relation to the\n   * initial point and the last received point.\n   * \n   * Use {@link seenEvent} to track a raw `PointerEvent`.\n   * \n   * @param _p Point\n   */\n  computeResults(\n    _p: Array<TimestampedObject<Point>>\n  ): PointTrackerResults {\n    const currentLast = this.last;\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const previousLast = this.values.at(-2);\n\n    if (this.initialRelation === undefined && this.initial) {\n      // Don't yet have an initial relation function\n      this.initialRelation = Points.relation(this.initial);\n    } else if (this.initialRelation === undefined) {\n      // Don't have an initial relation, but also don't have an initial point :()\n      throw new Error(`Bug: No initialRelation, and this.inital is undefined?`);\n    }\n\n    // Make a new relator based on previous point\n    const lastRelation = previousLast === undefined ? Points.relation(currentLast) : Points.relation(previousLast);\n\n    // Compute relation from initial point to latest\n    const initialRel: PointTrack = this.initialRelation(currentLast);\n\n    const speed = previousLast === undefined ? 0 : LineLength(previousLast, currentLast) / (currentLast.at - previousLast.at);\n\n    // Compute relation from current point to the previous\n    const lastRel: PointTrack = {\n      ...lastRelation(currentLast),\n      speed,\n    };\n\n    const r: PointTrackerResults = {\n      fromInitial: initialRel,\n      fromLast: lastRel,\n      values: [ ...this.values ],\n    };\n    this.lastResult = r;\n    return r;\n  }\n\n  /**\n   * Returns a polyline representation of stored points.\n   * Returns an empty array if points were not saved, or there's only one.\n   */\n  get line(): PolyLine {\n    if (this.values.length === 1) return [];\n    return joinPointsToLines(...this.values);\n  }\n\n  /**\n   * Returns a vector of the initial/last points of the tracker.\n   * Returns as a polar coordinate\n   */\n  get vectorPolar(): PolarCoord {\n    return Vectors.fromLinePolar(this.lineStartEnd);\n  }\n\n  /**\n   * Returns a vector of the initial/last points of the tracker.\n   * Returns as a Cartesian coordinate\n   */\n  get vectorCartesian(): Point {\n    return Vectors.fromLineCartesian(this.lineStartEnd);\n  }\n\n  /**\n   * Returns a line from initial point to last point.\n   *\n   * If there are less than two points, Lines.Empty is returned\n   */\n  get lineStartEnd(): Line {\n    const initial = this.initial;\n    if (this.values.length < 2 || !initial) return LinesEmpty;\n    return {\n      a: initial,\n      b: this.last,\n    };\n  }\n\n  /**\n   * Returns distance from latest point to initial point.\n   * If there are less than two points, zero is returned.\n   *\n   * This is the direct distance from initial to last,\n   * not the accumulated length.\n   * @returns Distance\n   */\n  distanceFromStart(): number {\n    const initial = this.initial;\n    return this.values.length >= 2 && initial !== undefined ? Points.distance(initial, this.last) : 0;\n  }\n\n  /**\n   * Difference between last point and the initial point, calculated\n   * as a simple subtraction of x & y.\n   *\n   * `Points.Placeholder` is returned if there's only one point so far.\n   */\n  difference(): Point {\n    const initial = this.initial;\n    return this.values.length >= 2 && initial !== undefined ? Points.subtract(this.last, initial) : Points.Placeholder;\n  }\n\n  /**\n   * Returns angle (in radians) from latest point to the initial point\n   * If there are less than two points, undefined is return.\n   * @returns Angle in radians\n   */\n  angleFromStart(): number | undefined {\n    const initial = this.initial;\n    if (initial !== undefined && this.values.length > 2) {\n      return Points.angleRadian(initial, this.last);\n    }\n  }\n\n  /**\n   * Returns the total length of accumulated points.\n   * Returns 0 if points were not saved, or there's only one\n   */\n  get length(): number {\n    if (this.values.length === 1) return 0;\n    const l = this.line;\n    return LineLength(l);\n  }\n}\n\n/**\n * A {@link TrackedValueMap} for points. Uses {@link PointTracker} to\n * track added values.\n */\nexport class TrackedPointMap extends TrackedValueMap<\n  Point,\n  PointTracker,\n  PointTrackerResults\n> {\n  constructor(opts: TrackOpts = {}) {\n    super((key, start) => {\n      if (start === undefined) throw new Error(`Requires start point`);\n      const p = new PointTracker({\n        ...opts,\n        id: key,\n      });\n      p.seen(start);\n      return p;\n    });\n  }\n\n  /**\n   * Track a PointerEvent\n   * @param event\n   */\n  seenEvent(event: PointerEvent): Promise<Array<PointTrackerResults>> {\n    if (`getCoalescedEvents` in event) {\n      const events = event.getCoalescedEvents();\n      const seens = events.map(subEvent => super.seen(subEvent.pointerId.toString(), subEvent));\n      return Promise.all(seens);\n    } else {\n      // eslint-disable-next-line unicorn/no-single-promise-in-promise-methods\n      return Promise.all([ super.seen((event as PointerEvent).pointerId.toString(), event) ]);\n    }\n  }\n}\n\n/**\n * Track several named points over time, eg a TensorFlow body pose point.\n * Call `seen()` to track a point. Mutable. If you want to compare\n * a single coordinate with a reference coordinate, {@link point} may be a better choice.\n *\n * See also:\n * * {@link Geometry.Points.relation}: Compute relation info between two points\n * * {@link Trackers.point}: Track relation between points over time\n * * [ixfx Guide to Point Tracker](https://ixfx.fun/geometry/tracking/)\n * \n * Basic usage\n * ```js\n * import { points } from 'https://unpkg.com/ixfx/dist/trackers.js';\n *\n * const pt = points();\n *\n * // Track a point under a given id\n * document.addEventListener(`pointermove`, e => {\n *  const info = await pt.seen(e.pointerId, { x: e.x, y: e.y });\n *  // Yields some info on relation of the point to initial value\n * });\n * ```\n *\n * Do something with last values for all points\n * ```js\n * const c = Points.centroid(...Array.from(pt.last()));\n * ```\n *\n * More functions...\n * ```js\n * pt.size;       // How many named points are being tracked\n * pt.delete(id); // Delete named point\n * pt.reset();    // Clear data\n * ```\n *\n * Accessing by id:\n *\n * ```js\n * pt.get(id);  // Get named point (or _undefined_)\n * pt.has(id);  // Returns true if id exists\n * ```\n *\n * Iterating over data\n *\n * ```js\n * pt.trackedByAge(); // Iterates over tracked points, sorted by age (oldest first)\n * pt.tracked(); // Tracked values\n * pt.ids();     // Iterator over ids\n *\n * // Last received value for each named point\n * pt.last();\n *\n * pt.initialValues(); // Iterator over initial values for each point\n * ```\n *\n * You can work with 'most recently updated' points:\n *\n * ```js\n * // Iterates over points, sorted by age (oldest first)\n * pt.valuesByAge();\n * ```\n *\n * Options:\n * * `id`: Id of this tracker. Optional\n * * `sampleLimit`: How many samples to store\n * * `storeIntermediate`: If _true_, all points are stored internally\n * * `resetAfterSamples`: If set above 0, it will automatically reset after the given number of samples have been seen\n * @param options\n * @returns\n */\nexport const points = (options: TrackOpts = {}) =>\n  new TrackedPointMap(options);\n\n/**\n * A tracked point. Create via {@link Trackers.point}. Mutable. Useful for monitoring how\n * it changes over time. Eg. when a pointerdown event happens, to record the start position and then\n * track the pointer as it moves until pointerup.\n *\n * See also\n * * [Playground](https://clinth.github.io/ixfx-play/data/point-tracker/index.html)\n * * {@link points}: Track several points, useful for multi-touch.\n * * [ixfx Guide to Point Tracker](https://ixfx.fun/geometry/tracking/)\n * \n * ```js\n * import { point } from 'https://unpkg.com/ixfx/dist/trackers.js';\n *\n * // Create a tracker on a pointerdown\n * const t = point();\n *\n * // ...and later, tell it when a point is seen (eg. pointermove)\n * const nfo = t.seen({x: evt.x, y:evt.y});\n * // nfo gives us some details on the relation between the seen point, the start, and points inbetween\n * // nfo.angle, nfo.centroid, nfo.speed etc.\n * ```\n *\n * Compute based on last seen point\n * ```js\n * t.angleFromStart();\n * t.distanceFromStart();\n * t.x / t.y\n * t.length; // Total length of accumulated points\n * t.elapsed; // Total duration since start\n * t.lastResult; // The PointSeenInfo for last seen point\n * ```\n *\n * Housekeeping\n * ```js\n * t.reset(); // Reset tracker\n * ```\n *\n * By default, the tracker only keeps track of the initial point and\n * does not store intermediate 'seen' points. To use the tracker as a buffer,\n * set `storeIntermediate` option to _true_.\n *\n * ```js\n * // Keep only the last 10 points\n * const t = point({\n *  sampleLimit: 10\n * });\n *\n * // Store all 'seen' points\n * const t = point({\n *  storeIntermediate: true\n * });\n *\n * // In this case, the whole tracker is automatically\n * // reset after 10 samples\n * const t = point({\n *  resetAfterSamples: 10\n * })\n * ```\n *\n * When using a buffer limited by `sampleLimit`, the 'initial' point will be the oldest in the\n * buffer, not actually the very first point seen.\n */\nexport const point = (opts: TrackOpts = {}) => new PointTracker(opts);\n","import { toStringDefault, type ToString } from \"../util/index.js\";\n\nexport type TrackUnique<T> = (value: T) => boolean\n\n/**\n * Tracks unique values. Returns _true_ if value is unique.\n * Alternatively: {@link uniqueInstances}\n * \n * ```js\n * const t = unique();\n * t(`hello`); // true\n * t(`hello`); // false\n * ```\n * \n * Uses JSON.stringify to compare anything which is not a string.\n * \n * Provide a custom function to convert to string to track uniqueness\n * for more complicated objects.\n * \n * ```js\n * const t = unique(p => p.name);\n * t({ name:`John`, level:2 }); // true\n * \n * // Since we're judging uniques by name only\n * t({ name:`John`, level:3 }); // false\n * ```\n * \n * Return function throws an error if `value` is null or undefined.\n * @returns \n */\nexport const unique = <T>(toString: ToString<T> = toStringDefault): TrackUnique<T> => {\n  const set = new Set<string>();\n\n  return (value: T) => {\n    if (value === null) throw new TypeError(`Param 'value' cannot be null`);\n    if (value === undefined) throw new TypeError(`Param 'value' cannot be undefined`);\n\n    const asString = (typeof value === `string`) ? value : toString(value);\n    if (set.has(asString)) return false;\n    set.add(asString);\n    return true;\n  }\n}\n\n/**\n * Tracks unique object instances. Returns _true_ if value is unique.\n * Alternatively: {@link unique} to track by value.\n */\nexport const uniqueInstances = <T>(): TrackUnique<T> => {\n\n  const set = new Set<T>();\n  return (value: T) => {\n    if (value === null) throw new TypeError(`Param 'value' cannot be null`);\n    if (value === undefined) throw new TypeError(`Param 'value' cannot be undefined`);\n\n    if (set.has(value)) return false;\n    set.add(value);\n    return true;\n  }\n}","export * from './FrequencyMutable.js';\nexport * from './IntervalTracker.js';\nexport * from './NumberTracker.js';\nexport * from './ObjectTracker.js';\nexport * from './PointTracker.js';\nexport * from './PrimitiveTracker.js';\nexport * from './TrackedValue.js';\nexport * from './TrackerBase.js';\nexport * from './TrackUnique.js';\nexport type * from './Types.js';","/// ✔ Unit tested!\n\nimport { type ToString } from '../util/index.js';\nimport { SimpleEventEmitter } from '../Events.js';\nimport * as KeyValues from '../util/KeyValue.js';\nimport type { KeyValue } from '../PrimitiveTypes.js';\n\nexport type FrequencyEventMap = {\n  readonly change: { context: any };\n};\n\nexport class FrequencyTracker<V> extends SimpleEventEmitter<FrequencyEventMap> {\n  readonly #store: Map<string, number>;\n  readonly #keyString: ToString<V>;\n\n  /**\n   * Constructor\n   * @param keyString Function to key items. Uses JSON.stringify by default\n   */\n  constructor(keyString?: ToString<V> | undefined) {\n    super();\n    this.#store = new Map();\n\n    if (keyString === undefined) {\n      keyString = (a) => {\n        if (a === undefined) throw new Error(`Cannot create key for undefined`);\n        return typeof a === `string` ? a : JSON.stringify(a);\n      };\n    }\n    this.#keyString = keyString;\n  }\n\n  /**\n   * Clear data. Fires `change` event\n   */\n  clear() {\n    this.#store.clear();\n    this.fireEvent(`change`, { context: this });\n  }\n\n  /**\n   * @returns Iterator over keys (ie. groups)\n   */\n  keys(): IterableIterator<string> {\n    return this.#store.keys();\n  }\n\n  /**\n   * @returns Iterator over frequency counts\n   */\n  values(): IterableIterator<number> {\n    return this.#store.values();\n  }\n\n  /**\n   * @returns Copy of entries as an array of `[key, count]`\n   */\n  toArray(): Array<[ key: string, count: number ]> {\n    return [ ...this.#store.entries() ];\n  }\n\n  /**\n   * Returns a string with keys and counts, useful for debugging.\n   * @returns\n   */\n  debugString(): string {\n    //eslint-disable-next-line functional/no-let\n    let t = ``;\n    for (const [ key, count ] of this.#store.entries()) {\n      t += `${ key }: ${ count }, `;\n    }\n    if (t.endsWith(`, `)) return t.slice(0, Math.max(0, t.length - 2));\n    return t;\n  }\n\n  /**\n   *\n   * @param value Value to count\n   * @returns Frequency of value, or _undefined_ if it does not exist\n   */\n  frequencyOf(value: V | string): number | undefined {\n    if (typeof value === `string`) return this.#store.get(value);\n\n    const key = this.#keyString(value);\n    return this.#store.get(key);\n  }\n\n  /**\n   *\n   * @param value Value to count\n   * @returns Relative frequency of `value`, or _undefined_ if it does not exist\n   */\n  relativeFrequencyOf(value: V | string): number | undefined {\n    //eslint-disable-next-line functional/no-let\n    let freq: number | undefined;\n    if (typeof value === `string`) freq = this.#store.get(value);\n    else {\n      const key = this.#keyString(value);\n      freq = this.#store.get(key);\n    }\n    if (freq === undefined) return;\n\n    const mma = this.minMaxAvg();\n    return freq / mma.total;\n  }\n\n  /**\n   * @returns Copy of entries as an array\n   */\n  entries(): Array<KeyValue> {\n    return [ ...this.#store.entries() ];\n  }\n\n  /**\n   *\n   * @returns Returns `{min,max,avg,total}`\n   */\n  minMaxAvg() {\n    return KeyValues.minMaxAvg(this.entries());\n  }\n\n  /**\n   *\n   * @param sortStyle Sorting style (default: _value_, ie. count)\n   * @returns Sorted array of [key,frequency]\n   */\n  entriesSorted(\n    sortStyle: KeyValues.SortSyles = `value`\n  ): ReadonlyArray<KeyValue> {\n    const s = KeyValues.getSorter(sortStyle);\n    return s(this.entries());\n  }\n\n  /**\n   *\n   * @param values Values to add. Fires _change_ event after adding item(s)\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  add(...values: Array<V>) {\n    if (values === undefined) throw new Error(`value parameter is undefined`);\n\n    const keys = values.map(v => this.#keyString(v));\n\n    //const key = this.#keyString(value);\n    for (const key of keys) {\n      const score = this.#store.get(key) ?? 0;\n      this.#store.set(key, score + 1);\n    }\n    this.fireEvent(`change`, { context: this });\n  }\n}\n\n/**\n * Frequency keeps track of how many times a particular value is seen, but\n * unlike a Map it does not store the data. By default compares\n * items by value (via JSON.stringify).\n *\n * Create with {@link Trackers.frequency}.\n *\n * Fires `change` event when items are added or it is cleared.\n *\n * Overview\n * ```\n * const fh = Trackers.frequency();\n * fh.add(value); // adds a value\n * fh.clear();    // clears all data\n * fh.keys() / .values() // returns an iterator for keys and values\n * fh.toArray();  //  returns an array of data in the shape [[key,freq],[key,freq]...]\n * ```\n *\n * Usage\n * ```\n * const fh = Trackers.frequency();\n * fh.add(`apples`); // Count an occurence of `apples`\n * fh.add(`oranges)`;\n * fh.add(`apples`);\n *\n * const fhData = fh.toArray(); // Expect result [[`apples`, 2], [`oranges`, 1]]\n * fhData.forEach((d) => {\n *  const [key,freq] = d;\n *  console.log(`Key '${key}' occurred ${freq} time(s).`);\n * })\n * ```\n *\n * Custom key string\n * ```\n * const fh = Trackers.frequency( person => person.name);\n * // All people with name `Samantha` will be counted in same group\n * fh.add({name:`Samantha`, city:`Brisbane`});\n * ```\n * @typeParam V - Type of items\n */\nexport const frequency = <V>(keyString?: ToString<V> | undefined) =>\n  new FrequencyTracker<V>(keyString);\n","import { NumberTracker } from './NumberTracker.js';\nimport { type TrackedValueOpts as TrackOpts } from './TrackedValue.js';\n\n/**\n * A `Tracker` that tracks interval between calls to `mark()`\n */\nexport class IntervalTracker extends NumberTracker {\n  lastMark = 0;\n\n  mark() {\n    if (this.lastMark > 0) {\n      this.seen(performance.now() - this.lastMark);\n    }\n    this.lastMark = performance.now();\n  }\n}\n\n/**\n * Returns a new {@link IntervalTracker} instance. IntervalTracker\n * records the interval between each call to `mark`.\n *\n * ```js\n * import { interval } from 'https://unpkg.com/ixfx/dist/trackers.js';\n *\n * const t = interval();\n *\n * // Call `mark` to record an interval\n * t.mark();\n * ...\n * t.mark();\n *\n * // Get average time in milliseconds between calls to `mark`\n * t.avg;\n *\n * // Longest and shortest times are available too...\n * t.min / t.max\n * ```\n *\n * Interval tracker can automatically reset after a given number of samples:\n *\n * ```\n * // Reset after 100 samples\n * const t = interval({ resetAfterSamples: 100} );\n * ```\n * @param options Options for tracker\n * @returns New interval tracker\n */\nexport const interval = (options?: TrackOpts) => new IntervalTracker(options);\n","import { PointTracker, TrackedPointMap, points as pointsTracker, type TrackedValueOpts } from 'ixfx/trackers.js';\nimport { Points, Rects, type Point, type RectPositioned } from 'ixfx/geometry.js';\nimport type { PoseData } from './index.js';\nimport { getLandmarkNameByIndex, type PoseLandmarks } from './landmarks.js';\nimport { centroid } from './geometry.js';\n\nexport type { TrackedValueOpts }\n/**\n * PoseTracker keeps track of a landmarks for a single pose. \n * This is useful for tracking the movement of a pose or its landmarks over time.\n * It does this by making a PointTracker for each keypoint of a pose.\n * \n * @example\n * ```js\n * // Create a tracker (fromId is the id of sender, poseId is the id of the pose)\n * const pt = new PoseTracker(fromId, poseId, options);\n * // ...and whenever there is data, call .seen()\n * pt.seen(pose);\n * ```\n * \n * When creating, the most useful tuning options are `sampleLimit` which governs\n * how many of the most recent samples to keep, and `storeIntermediate` (true/false)\n * to store intermediate data.\n * \n * ## Accessing keypoints\n *  You can get the raw keypoint data from the pose\n * ```js\n * // Get a single point\n * const nosePoint = pose.keypointValue(`nose`); // { x, y, score, name }\n * // Get all points\n * for (const kp of poses.getRawValues()) {\n * // { x, y, score, name }\n * }\n * ```\n * But the real power comes from getting the [PointTracker](https://api.ixfx.fun/classes/Trackers.PointTracker) for a keypoint, since it keeps track of not just the last data, but a whole trail of historical data for a given keypoint.\n * ```js\n * const noseTracker = pose.keypoint(`nose`); // PointTracker\n * ```\n * Once we have the PointTracker, there are a _lot_ of things to access:\n * \n */\nexport class PoseTracker {\n  #fromId;\n  #poseId;\n  #guid;\n  #seen = 0;\n  #box: RectPositioned | undefined;\n  #data: PoseData | undefined;\n  points: TrackedPointMap;\n  #hue: number;\n\n  /**\n   * Creates a PoseTracker\n   * \n   * Defaults:\n   * * sampleLimit: 10\n   * * storeIntermediate: false\n   * @param fromId Data source for pose (ie device)\n   * @param poseId Id of pose from TFjs\n   * @param options \n   */\n  constructor(fromId: string, poseId: string, options: TrackedValueOpts = {}) {\n    this.#poseId = poseId;\n    this.#fromId = fromId;\n    this.#guid = fromId + `-` + poseId;\n    this.#hue = Math.random() * 360;\n    const opts: TrackedValueOpts = {\n      id: poseId,\n      debug: options.debug ?? false,\n      sampleLimit: 10,\n      storeIntermediate: false\n    }\n    this.points = pointsTracker(opts);\n  }\n\n  /**\n   * Reset stored data for the tracker\n   */\n  reset() {\n    this.points.reset();\n  }\n\n  /**\n   * Returns a [PointTracker](https://api.ixfx.fun/classes/Trackers.PointTracker) for a given landmark\n   * by name or index.\n   * \n   * ```js\n   * // Eg. get tracker for the 'nose' landmark\n   * const nose = pose.landmark(`nose`);\n   * \n   * // Get the angle of nose movement since the start\n   * const a = nose.angleFromStart();\n   * \n   * // Get the distance of nose since start\n   * const d = nose.distanceFromStart();\n   * ```\n   * @param nameOrIndex \n   * @returns \n   */\n  landmark(nameOrIndex: PoseLandmarks | number) {\n    if (nameOrIndex === undefined) throw new TypeError(`Param 'nameOrIndex' is undefined. Expected landmark name or numerical index`);\n    if (typeof nameOrIndex === `number`) {\n      return this.points.get(getLandmarkNameByIndex(nameOrIndex));\n    } else {\n      return this.points.get(nameOrIndex);\n    }\n  }\n\n  /**\n   * Returns the last position for a given landmark.\n   * ```js\n   * const pos = pose.landmarkValue(`nose`); // { x, y }\n   * ```\n   * \n   * Throws an error if `nameOrIndex` does not exist.\n   * @param nameOrIndex\n   * @returns \n   */\n  landmarkValue(nameOrIndex: PoseLandmarks | number) {\n    if (nameOrIndex === undefined) throw new TypeError(`Param 'nameOrIndex' is undefined. Expected landmark name or numerical index`);\n    const name = typeof nameOrIndex === `string` ? nameOrIndex : getLandmarkNameByIndex(nameOrIndex);\n    const t = this.points.get(name);\n    if (t === undefined) throw new Error(`Point '${ name }' is not tracked`);\n    const pt = t.last;\n    if (pt === undefined) throw new Error(`No data for point '${ name }'`);\n    return pt;\n  }\n\n  /**\n   * Update this pose with new information\n   * @param pose \n   */\n  async seen(pose: PoseData) {\n    this.#seen = Date.now();\n    this.#data = pose;\n\n    for (let i = 0; i < pose.landmarks.length; i++) {\n      const lm = pose.landmarks[ i ];\n      const name = getLandmarkNameByIndex(i);\n      await this.points.seen(name, lm);\n    }\n  }\n\n  /**\n   * Returns all the [PointTrackers](https://api.ixfx.fun/classes/Trackers.PointTracker) (ie. landmark) for this pose.\n   * \n   * ```js\n   * for (const pt of pose.getPointTrackers()) {\n   *  // Do something with 'pt' (which tracks one individual landmark)\n   * }\n   * ```\n   */\n  *getPointTrackers() {\n    yield* this.points.store.values();\n  }\n\n  /**\n   * Returns the raw landmarks\n   * \n   * ```js\n   * for (const kp of pose.getRawValues()) {\n   *  // { x, y, z?, score, name }\n   * }\n   * ```\n   * @returns {Point>}\n   */\n  *getRawValues() {\n    for (const v of this.points.store.values()) {\n      yield v.last;\n    }\n  }\n\n  /**\n   * Returns the centroid of all the pose points\n   * ```js\n   * pose.centroid; // { x, y }\n   * ```\n   * \n   * Returns {0.5,0.5} is data is missing\n   */\n  get centroid() {\n    if (!this.#data) return { x: 0.5, y: 0.5 };\n    return centroid(this.#data);\n  }\n\n  /**\n   * Returns height of bounding box\n   */\n  get height() {\n    return this.box.height;\n  }\n\n  /**\n   * Return width of bounding box\n   */\n  get width() {\n    return this.box.width;\n  }\n\n\n  /**\n   * Gets the bounding box of the pose, computed by 'landmarks'.\n   * ```js\n   * pose.box; // { x, y, width, height }\n   * ````\n   * \n   * Returns an empty rectangle if there's no data\n   */\n  get box() {\n    if (this.#box) return this.#box;\n    if (!this.#data) return Rects.EmptyPositioned;\n    this.#box = Points.bbox(...this.#data.landmarks);\n    return this.#box;\n  }\n\n  /**\n   * Returns the id of the sender\n   */\n  get peerId() {\n    return this.#fromId;\n  }\n\n  /**\n   * Returns the middle of the pose bounding box\n   * ```js\n   * pose.middle; // { x, y }\n   * ```\n   * @returns \n   */\n  get middle() {\n    const box = this.box;\n    if (box) {\n      return {\n        x: box.x + box.width / 2,\n        y: box.y + box.height / 2\n      };\n    }\n    return { x: 0, y: 0 };\n  }\n\n  /**\n   * Returns the randomly-assigned hue (0..360)\n   */\n  get hue() {\n    return this.#hue;\n  }\n\n  /**\n   * Returns a CSS colour: hsl() based on\n   * the randomly-assigned hue\n   */\n  get hsl() {\n    return `hsl(${ this.#hue }, 70%, 50%)`;\n  }\n\n  /**\n   * Returns the globally unique id of this pose\n   * (fromId-poseId)\n   */\n  get guid() {\n    return this.#guid;\n  }\n\n  /**\n   * Returns the original pose id from TFjs\n   * Warning: this may not be unique if there are multiple senders\n   */\n  get poseId() {\n    return this.#poseId;\n  }\n  /**\n   * Returns the id of the sender of this pose\n   */\n  get fromId() {\n    return this.#fromId;\n  }\n\n\n  /**\n   * Returns how long since pose was updated\n   */\n  get elapsed() {\n    return Date.now() - this.#seen;\n  }\n\n  /**\n   * Returns the last pose data in raw format\n   */\n  get last() {\n    return this.#data;\n  }\n}","import type { TrackedValueOpts } from \"ixfx/trackers.js\";\nimport type { PoseData } from \"./index.js\";\nimport { SimpleEventEmitter } from \"ixfx/events.js\";\nimport { PoseTracker } from \"./pose-tracker.js\";\nimport { getLandmarkIndexByName, type PoseLandmarks } from \"./landmarks.js\";\n\nexport type PosesTrackerOptions = TrackedValueOpts & {\n  maxAgeMs: number\n}\n\n/**\n * Tracks several poses (ie. bodies)\n * \n * Events:\n * - expired: Tracked pose has not been seen for a while\n * - added: A new pose id\n */\nexport class PosesTracker extends EventTarget {\n  /** \n   * PoseTrackers, keyed by 'sender-poseid'\n   **/\n  #data = new Map<string, PoseTracker>();\n  #options: PosesTrackerOptions;\n\n  /**\n   * Constructor\n   * @param {Partial<PosesTrackerOptions>} options \n   */\n  constructor(options = {}) {\n    super();\n    this.#options = {\n      maxAgeMs: 10_000,\n      resetAfterSamples: 0,\n      sampleLimit: 100,\n      storeIntermediate: false,\n      ...options\n    };\n    setInterval(() => {\n      // Delete expired poses\n      const expired = [ ...this.#data.entries() ].filter(entry => entry[ 1 ].elapsed > this.#options.maxAgeMs);\n      for (const entry of expired) {\n        this.#data.delete(entry[ 0 ]);\n\n        //this.fireEvent(`expired`, { pose: entry[ 1 ] });\n        this.dispatchEvent(new CustomEvent(`expired`, { detail: entry[ 1 ] }));\n      }\n    }, 1000);\n  }\n\n  /**\n   * Enumerates each of the PoseTrackers, sorted by age.\n   * The most recent pose will be at position 0.\n   * (ie. one for each body).\n   * Use getRawPosesByAge() to enumerate raw pose data\n   */\n  *getByAge() {\n    const trackers = [ ...this.#data.values() ];\n    trackers.sort((a, b) => a.elapsed - b.elapsed);\n    yield* trackers.values();\n  }\n\n  /**\n   * Enumerates PoseTrackers, sorting by the horizontal position.\n   * Leftmost pose will be at position 0.\n   */\n  *getByHorizontal() {\n    const trackers = [ ...this.#data.values() ];\n    trackers.sort((a, b) => a.middle.x - b.middle.x);\n    yield* trackers;\n  }\n\n  /**\n   * Enumerate all PoseTracker instances\n   */\n  *get() {\n    const trackers = [ ...this.#data.values() ];\n    yield* trackers.values();\n  }\n\n  /**\n   * Enumerate the last set of raw pose data for\n   * each of the PoseTrackers.\n   */\n  *getRawPosesByAge() {\n    for (const tracker of this.getByAge()) {\n      yield tracker.last;\n    }\n  }\n\n  *getRawPoses(): Generator<PoseData> {\n    const values = [ ...this.#data.values() ];\n    for (const tracker of values) {\n      const last = tracker.last;\n      if (!last) continue;\n      yield last;\n    }\n\n  }\n\n  /**\n   * Get a raw landmark by name across all poses\n   * \n   * @example Get the 'nose' landmark for all bodies\n   * ````js\n   * for (const n of poses.getRawLandmarks(`nose`)) {\n   *  // Yields: { x, y, z?, score, name }\n   * }\n   * ```\n   * \n   * @param nameOrIndex Name or index of landmark to get data for\n   */\n  *getRawLandmarks(nameOrIndex: string | number) {\n    if (typeof nameOrIndex === `undefined`) throw new TypeError(`Param 'nameOrIndex' is undefined. Expected landmark name or numerical index`);\n    const index = typeof nameOrIndex === `number` ? nameOrIndex : getLandmarkIndexByName(nameOrIndex);\n    if (index === undefined) throw new Error(`Landmark unknown: '${ name }'`);\n    for (const pose of this.getRawPoses()) {\n      const kp = pose.landmarks[ index ];\n      if (kp !== undefined) yield kp;\n    }\n  }\n\n  /**\n   * Enumerates all [PointTrackers](https://api.ixfx.fun/classes/Trackers.PointTracker) for a given landmark id.\n   * \n   * eg. to get the PointTracker for 'nose' across all poses currently seen:\n   * \n   * ```js\n   * for (const pt of poses.getPointTrackers(`nose`)) {\n   *  // do something with tracker...\n   * }\n   * ```\n   * \n   * Throws an error if `nameOrIndex` is not found.\n   * \n   * @param nameOrIndex Name or index of landmark to get tracker for\n   */\n  *getPointTrackers(nameOrIndex: PoseLandmarks | number) {\n    if (typeof nameOrIndex === `undefined`) throw new TypeError(`Param 'nameOrIndex' is undefined. Expected landmark name or numerical index`);\n    const index = typeof nameOrIndex === `number` ? nameOrIndex : getLandmarkIndexByName(nameOrIndex);\n    if (index === undefined) throw new Error(`Landmark unknown: '${ name }'`);\n    for (const tracker of this.get()) {\n      yield tracker.landmark(nameOrIndex);\n\n    }\n  }\n\n  /**\n   * Returns all [PointTrackers](https://api.ixfx.fun/classes/Trackers.PointTracker) from a particular sender\n   * \n   * ```js\n   * for (const pt of poses.getFromSender(`mobile`)) {\n   *  // Do something with tracker...\n   * }\n   * ```\n   * \n   * @param senderId Id of sender\n   */\n  *getFromSender(senderId: string) {\n    const values = [ ...this.#data.values() ];\n    for (const tracker of values) {\n      if (tracker.fromId === senderId) yield tracker;\n    }\n  }\n\n\n  /**\n   * Enumerate the set of unique sender ids\n   * ```js\n   * for (const sender of poses.getSenderIds()) {\n   *  // Do something with sender (string)\n   * }\n   * ```\n   */\n  *getSenderIds() {\n    const set = new Set();\n    const values = [ ...this.#data.values() ];\n    for (const entry of values) {\n      set.add(entry.fromId);\n    }\n    yield* set.values();\n  }\n\n  /**\n   * Returns the PoseTracker for this pose id.\n   * \n   * ```js\n   * const pose = poses.getByPoseId(`123`);\n   * pose.middle; // { x, y }\n   * ```\n   * \n   * Warning: Pose ids are not unique if there are multiple data sources.\n   * Prefer using guids.\n   * \n   * @param id Id of pose\n   */\n  getByPoseId(id: string) {\n    for (const entry of this.#data.values()) {\n      if (entry.poseId === id) return entry;\n    }\n  }\n\n  /**\n   * Returns the last raw pose data for this pose id.\n   * \n   * ```js\n   * const pose = poses.getRawPoseByPoseId(`123`);\n   * pose.landmark; // array of landmarks { x, y, z?, score, name }\n   * pose.score; // score of this pose\n   * pose.box;  // bounding box\n   * ```\n   * \n   * Warning: Pose ids are not unique if there are multiple data sources.\n   * Prefer using guids.\n   * \n   * @param id Id of pose\n   */\n  getRawPoseByPoseId(id: string) {\n    for (const entry of this.#data.values()) {\n      if (entry.poseId === id) return entry.last;\n    }\n  }\n\n  /**\n   * Enumerate the set of globally-unique ids of poses\n   */\n  *getGuids() {\n    for (const t of this.#data.values()) {\n      yield t.guid;\n    }\n  }\n\n  /**\n   * Get the PoseTracker for unique id (based on sender and pose)\n   * ```js\n   * const pt = poses.getByGuid(`123-123`);\n   * pt.middle; // { x, y }\n   * ```\n   * \n   * Alternatively: {@link getRawPoseByGuid} to get raw data\n   * @param id Combined id of sender-poseid\n   */\n  getByGuid(id: string) {\n    return this.#data.get(id);\n  }\n\n  /**\n   * Returns the raw pose data for a unique id\n   * ```js\n   * const pose = poses.getRawPoseByGuide(`123-123`);\n   * pose.landmark; // array of { x, y, z?, score, name }\n   * pose.score;     // score of pose\n   * ```\n   * \n   * Alternatively: {@link getByGuid} to get a tracker for pose\n   * @param id Combined sender-pose\n   * @returns \n   */\n  getRawPoseByGuid(id: string) {\n    return this.#data.get(id)?.last;\n  }\n\n  /**\n   * Track a pose.\n   * Fires `added` event if it is a new pose.\n   * Returns the globally-unique id for this pose\n   * @param pose New pose data\n   * @param from Sender id\n   */\n  seen(from: string, pose: PoseData) {\n    if (from === undefined) throw new Error(`Param 'from' is undefined`);\n    if (pose === undefined) throw new Error(`Param 'pose' is undefined`);\n\n    // Construct globally-unique id for this pose\n    const id = (pose.poseid ?? 0).toString();\n    const nsId = from + `-` + id;\n\n    // Does it exist already?\n    let tp = this.#data.get(nsId);\n\n    // Nope, make a new PoseTracker\n    if (tp === undefined) {\n      tp = new PoseTracker(from, id, this.#options);\n      this.#data.set(nsId, tp);\n      tp.seen(pose);\n      //this.fireEvent(`added`, { pose: tp });\n      this.dispatchEvent(new CustomEvent(`added`, { detail: tp }));\n    } else {\n      // Got it, update with latest pose\n      tp.seen(pose);\n    }\n    return nsId;\n  }\n\n  /**\n   * Return number of tracked poses\n   */\n  get size() {\n    return this.#data.size;\n  }\n\n  /**\n   * Clear all data\n   */\n  clear() {\n    this.#data.clear();\n  }\n\n}\n","export type * from '../../types-mp.js';\nexport type * from '../../types.js';"],"mappings":"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","names":["centroid","range","p","isNaN","name","a","b","a","b","p","d","steps","length","t","p","m","interval","a","b","__defProp","__export","name","__defProp","__export","a","isEqual","m","resolve","name","type","__export","t","c","set","d","name","a","b","min","max","min","max","length","a","__export","between","length","c","m","name","total","min","max","d","range","__export","t","__export","minMaxAvg","a","b","__export","fromPoints","points","p","guard","name","b","a","length","sum","d","d2","distance","Empty","Placeholder","angleRadian","apply","bbox","divide","isEmpty","isEqual","isPlaceholder","multiply","normaliseByRect","rotate","subtract","toString","withinRange","c","getPointParameter","point","n","line","t","min","dotProduct","max","clamp","clampMagnitude","fromNumbers","interpolate","invert","isNaN","normalise","quantiseEvery","round","wrap","guardPositioned","isPositioned","centroid","distanceFromExterior","pipeline","height","nearest","random","center","isIntersecting","randomPoint","offset","from","arrow","multiplyScalar","toPath","piPi","area","toArray","cells","steps","cardinal","g","grid","visitor","rows","abs","t2","m","bbox2","intersections","reduce","m1","m2","v1","q","a2","phi","c1","c2","cos","sin","acos","sqrt","pi","last","p2","ls","le","segments","tlen","alen","cubic","cubic2","quadratic","relativePosition","toSvgString","lengths","corners","epsilon","slope","Direction","scaler","opacity","scale","distanceCenter","fromDegrees","toSvg","toSvgFull","toCartesian","EmptyCartesian","pow","edges","fromFlatArray","intersectsPoint","toFlatArray","fromCenter","perimeter","circumcircle","incircle","fromA","fromB","fromC","medians","angles","__export","scale","toString","m","p","c","n","interpolate","from","to","coordGrammar","type","range","clamp","min","max","d","name","adapt","util.mapRange","util.parseFunction","util.last","ε","white","coords","options","epsilon","XYZ_D65","ε3","κ","xyz_d50","angles","Lab","a","b","constrainAngle","π","d2r","XYZtoLMS_M","LMStoXYZ_M","OKLab","oklab","distance","c1","c2","Yw","ninv","c3","Jzazbz","jzczhz","m1","tau","deg2rad","t","viewingConditions","cam16","last","hct","util.isString","util.isNone","clipped","deltaE","util.clamp","inGamut","checkInGamut","util.serializeNumber","toXYZ_M","fromXYZ_M","abs","register","Color","contrast","contrastAlgorithms","sum","steps","angles.adjust","g","hwb","oklch","Luv","slope","lch","args","ret","opacity","name","p","centroid","a","b","sum","p","t","a","b","last","p","last","asPoints","length","point","toString","set","__export","point","a","t","name","t","centroid","a","b","last","set","t","from"]}